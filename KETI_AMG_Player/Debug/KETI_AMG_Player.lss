
KETI_AMG_Player.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0001aa5c  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8001cc00  8001cc00  0001d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000541a8  8001ce00  8001ce00  0001d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         000005a8  00000008  80070fa8  00071408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000049c8  000005b0  000005b0  00000000  2**2
                  ALLOC
  8 .heap         0000a088  00004f78  00004f78  00000000  2**0
                  ALLOC
  9 .comment      00000030  00000000  00000000  000719b0  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00002e40  00000000  00000000  000719e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000081b2  00000000  00000000  00074820  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00065ba0  00000000  00000000  0007c9d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000df24  00000000  00000000  000e2572  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00049a0c  00000000  00000000  000f0496  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00008f04  00000000  00000000  00139ea4  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000f29a  00000000  00000000  00142da8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    00023dcb  00000000  00000000  00152042  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 0439cb1a  00000000  00000000  00175e0d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00005f68  00000000  00000000  04512928  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	8a b0       	ld.uh	r0,r5[0x6]

80000008 <_trampoline>:
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:
80002008:	fe cf 95 58 	sub	pc,pc,-27304

Disassembly of section .text:

8000200c <et024006_CopyBitsToScreen>:
8000200c:	d4 31       	pushm	r0-r7,lr
8000200e:	20 6d       	sub	sp,24
static void et024006_CopyBitsToScreen(
  void *bitmap,
  uint32_t count,
  et024006_color_t foreground_color,
  et024006_color_t background_color )
{
80002010:	50 1c       	stdsp	sp[0x4],r12
80002012:	50 2a       	stdsp	sp[0x8],r10
80002014:	50 39       	stdsp	sp[0xc],r9
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
80002016:	18 98       	mov	r8,r12
  uint8_t bit_mask;
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80002018:	58 7b       	cp.w	r11,7
8000201a:	e0 88 00 5c 	brls	800020d2 <et024006_CopyBitsToScreen+0xc6>
void et024006_leave_idle(void)
{
  et024006_AdjustGamma();
}

static void et024006_CopyBitsToScreen(
8000201e:	20 8b       	sub	r11,8
80002020:	16 99       	mov	r9,r11
80002022:	a3 99       	lsr	r9,0x3
80002024:	50 4b       	stdsp	sp[0x10],r11
80002026:	2f f8       	sub	r8,-1
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
  uint8_t bit_mask;
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x01))?foreground_color:background_color;
80002028:	14 9b       	mov	r11,r10
void et024006_leave_idle(void)
{
  et024006_AdjustGamma();
}

static void et024006_CopyBitsToScreen(
8000202a:	12 08       	add	r8,r9
8000202c:	50 59       	stdsp	sp[0x14],r9
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
  uint8_t bit_mask;
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x01))?foreground_color:background_color;
8000202e:	40 3a       	lddsp	r10,sp[0xc]
void et024006_leave_idle(void)
{
  et024006_AdjustGamma();
}

static void et024006_CopyBitsToScreen(
80002030:	50 08       	stdsp	sp[0x0],r8
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
  uint8_t bit_mask;
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x01))?foreground_color:background_color;
80002032:	5c 8b       	casts.h	r11
80002034:	5c 8a       	casts.h	r10
80002036:	fc 19 c0 40 	movh	r9,0xc040
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x04))?foreground_color:background_color;
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x08))?foreground_color:background_color;
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x10))?foreground_color:background_color;
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x20))?foreground_color:background_color;
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x40))?foreground_color:background_color;
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x80))?foreground_color:background_color;
8000203a:	30 01       	mov	r1,0
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
  uint8_t bit_mask;
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x01))?foreground_color:background_color;
8000203c:	19 88       	ld.ub	r8,r12[0x0]
8000203e:	e5 d8 c0 01 	bfextu	r2,r8,0x0,0x1
80002042:	f6 0e 17 10 	movne	lr,r11
80002046:	f4 0e 17 00 	moveq	lr,r10
8000204a:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x02))?foreground_color:background_color;
8000204c:	10 93       	mov	r3,r8
8000204e:	e2 13 00 02 	andl	r3,0x2,COH
80002052:	f6 0e 17 10 	movne	lr,r11
80002056:	f4 0e 17 00 	moveq	lr,r10
8000205a:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x04))?foreground_color:background_color;
8000205c:	10 94       	mov	r4,r8
8000205e:	e2 14 00 04 	andl	r4,0x4,COH
80002062:	f6 0e 17 10 	movne	lr,r11
80002066:	f4 0e 17 00 	moveq	lr,r10
8000206a:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x08))?foreground_color:background_color;
8000206c:	10 95       	mov	r5,r8
8000206e:	e2 15 00 08 	andl	r5,0x8,COH
80002072:	f6 0e 17 10 	movne	lr,r11
80002076:	f4 0e 17 00 	moveq	lr,r10
8000207a:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x10))?foreground_color:background_color;
8000207c:	10 96       	mov	r6,r8
8000207e:	e2 16 00 10 	andl	r6,0x10,COH
80002082:	f6 0e 17 10 	movne	lr,r11
80002086:	f4 0e 17 00 	moveq	lr,r10
8000208a:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x20))?foreground_color:background_color;
8000208c:	10 97       	mov	r7,r8
8000208e:	e2 17 00 20 	andl	r7,0x20,COH
80002092:	f6 0e 17 10 	movne	lr,r11
80002096:	f4 0e 17 00 	moveq	lr,r10
8000209a:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x40))?foreground_color:background_color;
8000209c:	10 9e       	mov	lr,r8
8000209e:	e2 1e 00 40 	andl	lr,0x40,COH
800020a2:	f6 00 17 10 	movne	r0,r11
800020a6:	f4 00 17 00 	moveq	r0,r10
800020aa:	b2 00       	st.h	r9[0x0],r0
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x80))?foreground_color:background_color;
800020ac:	f0 01 18 00 	cp.b	r1,r8
800020b0:	f6 00 17 90 	movgt	r0,r11
800020b4:	f4 00 17 a0 	movle	r0,r10
800020b8:	b2 00       	st.h	r9[0x0],r0
    u8_bitmap++;
800020ba:	2f fc       	sub	r12,-1
  et024006_color_t background_color )
{
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
  uint8_t bit_mask;
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
800020bc:	40 08       	lddsp	r8,sp[0x0]
800020be:	10 3c       	cp.w	r12,r8
800020c0:	cb e1       	brne	8000203c <et024006_CopyBitsToScreen+0x30>
800020c2:	40 19       	lddsp	r9,sp[0x4]
800020c4:	40 58       	lddsp	r8,sp[0x14]
800020c6:	2f f8       	sub	r8,-1
800020c8:	f2 08 00 08 	add	r8,r9,r8
800020cc:	40 49       	lddsp	r9,sp[0x10]
800020ce:	f7 d9 c0 03 	bfextu	r11,r9,0x0,0x3
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x80))?foreground_color:background_color;
    u8_bitmap++;
    count -= 8;
  }
  bit_mask = 1;
  while (count)
800020d2:	58 0b       	cp.w	r11,0
800020d4:	c1 80       	breq	80002104 <et024006_CopyBitsToScreen+0xf8>
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, bit_mask))?foreground_color:background_color;
800020d6:	40 26       	lddsp	r6,sp[0x8]
800020d8:	40 37       	lddsp	r7,sp[0xc]
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x80))?foreground_color:background_color;
    u8_bitmap++;
    count -= 8;
  }
  bit_mask = 1;
  while (count)
800020da:	11 85       	ld.ub	r5,r8[0x0]
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, bit_mask))?foreground_color:background_color;
800020dc:	5c 86       	casts.h	r6
800020de:	5c 87       	casts.h	r7
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x80))?foreground_color:background_color;
    u8_bitmap++;
    count -= 8;
  }
  bit_mask = 1;
  while (count)
800020e0:	30 19       	mov	r9,1
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, bit_mask))?foreground_color:background_color;
800020e2:	30 0a       	mov	r10,0
800020e4:	fc 1e c0 40 	movh	lr,0xc040
800020e8:	c0 38       	rjmp	800020ee <et024006_CopyBitsToScreen+0xe2>
    bit_mask <<= 1;
800020ea:	a1 79       	lsl	r9,0x1
800020ec:	5c 59       	castu.b	r9
    count -= 8;
  }
  bit_mask = 1;
  while (count)
  {
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, bit_mask))?foreground_color:background_color;
800020ee:	f3 e5 00 08 	and	r8,r9,r5
800020f2:	f4 08 18 00 	cp.b	r8,r10
800020f6:	ec 0c 17 10 	movne	r12,r6
800020fa:	ee 0c 17 00 	moveq	r12,r7
800020fe:	bc 0c       	st.h	lr[0x0],r12
    bit_mask <<= 1;
    count--;
80002100:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, 0x80))?foreground_color:background_color;
    u8_bitmap++;
    count -= 8;
  }
  bit_mask = 1;
  while (count)
80002102:	cf 41       	brne	800020ea <et024006_CopyBitsToScreen+0xde>
    *ET024006_PARAM_ADDR = (Tst_bits(*u8_bitmap, bit_mask))?foreground_color:background_color;
    bit_mask <<= 1;
    count--;
  }
#endif
}
80002104:	2f ad       	sub	sp,-24
80002106:	d8 32       	popm	r0-r7,pc

80002108 <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
static void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
80002108:	eb cd 40 80 	pushm	r7,lr
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000210c:	fc 18 c0 00 	movh	r8,0xc000
80002110:	30 2e       	mov	lr,2
80002112:	b0 0e       	st.h	r8[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002114:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
80002118:	fc 1e c0 40 	movh	lr,0xc040
8000211c:	bc 07       	st.h	lr[0x0],r7
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000211e:	30 37       	mov	r7,3
80002120:	b0 07       	st.h	r8[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002122:	bc 0c       	st.h	lr[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002124:	30 4c       	mov	r12,4
80002126:	b0 0c       	st.h	r8[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002128:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
8000212c:	bc 0c       	st.h	lr[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000212e:	30 5c       	mov	r12,5
80002130:	b0 0c       	st.h	r8[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002132:	bc 0a       	st.h	lr[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002134:	30 6a       	mov	r10,6
80002136:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002138:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
8000213c:	bc 0a       	st.h	lr[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000213e:	30 7a       	mov	r10,7
80002140:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002142:	bc 0b       	st.h	lr[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002144:	30 8a       	mov	r10,8
80002146:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002148:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
8000214c:	bc 0a       	st.h	lr[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000214e:	30 9a       	mov	r10,9
80002150:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002152:	bc 09       	st.h	lr[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80002154:	e3 cd 80 80 	ldm	sp++,r7,pc

80002158 <et024006_PutBitmap>:
  uint16_t y,
  uint16_t width,
  uint16_t height,
  et024006_color_t foreground_color,
  et024006_color_t background_color )
{
80002158:	d4 31       	pushm	r0-r7,lr
8000215a:	16 97       	mov	r7,r11
8000215c:	fa c4 ff dc 	sub	r4,sp,-36
80002160:	18 90       	mov	r0,r12
80002162:	10 93       	mov	r3,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits(x, y, x2, y2);
80002164:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
80002168:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
  uint16_t y,
  uint16_t width,
  uint16_t height,
  et024006_color_t foreground_color,
  et024006_color_t background_color )
{
8000216c:	68 06       	ld.w	r6,r4[0x0]
8000216e:	68 22       	ld.w	r2,r4[0x8]
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits(x, y, x2, y2);
80002170:	20 19       	sub	r9,1
80002172:	20 1a       	sub	r10,1
80002174:	0c 09       	add	r9,r6
80002176:	10 0a       	add	r10,r8
80002178:	5c 79       	castu.h	r9
8000217a:	5c 7a       	castu.h	r10
  uint16_t y,
  uint16_t width,
  uint16_t height,
  et024006_color_t foreground_color,
  et024006_color_t background_color )
{
8000217c:	68 11       	ld.w	r1,r4[0x4]
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits(x, y, x2, y2);
8000217e:	cc 5f       	rcall	80002108 <et024006_SetLimits>
80002180:	fc 18 c0 00 	movh	r8,0xc000
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002184:	32 29       	mov	r9,34
80002186:	b0 09       	st.h	r8[0x0],r9
80002188:	0e 98       	mov	r8,r7

  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if (ET024006_BITMAP_WIDTH(map_width) == map_width)
8000218a:	00 97       	mov	r7,r0
  uint16_t width,
  uint16_t height,
  et024006_color_t foreground_color,
  et024006_color_t background_color )
{
  uint8_t *u8_bitmap = (uint8_t *) bitmap;
8000218c:	5c 78       	castu.h	r8

  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if (ET024006_BITMAP_WIDTH(map_width) == map_width)
8000218e:	f0 05 16 03 	lsr	r5,r8,0x3
80002192:	2f 95       	sub	r5,-7
80002194:	e0 15 ff f8 	andl	r5,0xfff8
80002198:	10 35       	cp.w	r5,r8
8000219a:	c1 30       	breq	800021c0 <et024006_PutBitmap+0x68>
8000219c:	58 06       	cp.w	r6,0
  }
  else
  {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0)
8000219e:	c1 c0       	breq	800021d6 <et024006_PutBitmap+0x7e>
800021a0:	e9 d3 c0 10 	bfextu	r4,r3,0x0,0x10
  // In case of no horizontal pixmap clipping, easier handling is possible.
  if (ET024006_BITMAP_WIDTH(map_width) == map_width)
  {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
    et024006_CopyBitsToScreen(u8_bitmap, count, foreground_color, background_color);
800021a4:	e7 d2 c0 10 	bfextu	r3,r2,0x0,0x10
800021a8:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
800021ac:	0e 9c       	mov	r12,r7
  {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0)
    {
      et024006_CopyBitsToScreen(u8_bitmap, width, foreground_color, background_color);
800021ae:	06 99       	mov	r9,r3
800021b0:	0a 07       	add	r7,r5
      u8_bitmap += ET024006_BITMAP_WIDTH(map_width);
800021b2:	04 9a       	mov	r10,r2
  {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0)
    {
      et024006_CopyBitsToScreen(u8_bitmap, width, foreground_color, background_color);
800021b4:	08 9b       	mov	r11,r4
800021b6:	20 16       	sub	r6,1
      u8_bitmap += ET024006_BITMAP_WIDTH(map_width);
      --lines_left;
800021b8:	c2 af       	rcall	8000200c <et024006_CopyBitsToScreen>
  {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0)
    {
      et024006_CopyBitsToScreen(u8_bitmap, width, foreground_color, background_color);
800021ba:	5c 86       	casts.h	r6
800021bc:	cf 81       	brne	800021ac <et024006_PutBitmap+0x54>
      u8_bitmap += ET024006_BITMAP_WIDTH(map_width);
      --lines_left;
800021be:	d8 32       	popm	r0-r7,pc
  }
  else
  {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0)
800021c0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
  // In case of no horizontal pixmap clipping, easier handling is possible.
  if (ET024006_BITMAP_WIDTH(map_width) == map_width)
  {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
    et024006_CopyBitsToScreen(u8_bitmap, count, foreground_color, background_color);
800021c4:	5c 73       	castu.h	r3
800021c6:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
800021ca:	a7 3b       	mul	r11,r3
800021cc:	f5 d1 c0 10 	bfextu	r10,r1,0x0,0x10
800021d0:	00 9c       	mov	r12,r0
800021d2:	c1 df       	rcall	8000200c <et024006_CopyBitsToScreen>
800021d4:	d8 32       	popm	r0-r7,pc
800021d6:	d8 32       	popm	r0-r7,pc

800021d8 <et024006_PrintString>:
800021d8:	d4 31       	pushm	r0-r7,lr
800021da:	21 1d       	sub	sp,68
800021dc:	50 9b       	stdsp	sp[0x24],r11
800021de:	50 59       	stdsp	sp[0x14],r9
800021e0:	18 90       	mov	r0,r12
800021e2:	10 94       	mov	r4,r8
800021e4:	41 a3       	lddsp	r3,sp[0x68]
800021e6:	19 82       	ld.ub	r2,r12[0x0]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
800021e8:	58 02       	cp.w	r2,0
800021ea:	c6 a0       	breq	800022be <et024006_PrintString+0xe6>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800021ec:	16 98       	mov	r8,r11
800021ee:	11 37       	ld.ub	r7,r8++
  data++;
  yfont = *data;  // get font y length
  data++;
  font_size = *data;  // get data bytes per font
800021f0:	11 9c       	ld.ub	r12,r8[0x1]
800021f2:	50 7c       	stdsp	sp[0x1c],r12
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
  data++;
  yfont = *data;  // get font y length
800021f4:	11 88       	ld.ub	r8,r8[0x0]
800021f6:	50 e8       	stdsp	sp[0x38],r8
  data++;
  font_size = *data;  // get data bytes per font

  // If transparent mode
  if(bcolor == -1)
800021f8:	5b f3       	cp.w	r3,-1
800021fa:	c6 40       	breq	800022c2 <et024006_PrintString+0xea>
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800021fc:	2f f0       	sub	r0,-1
800021fe:	5c 8a       	casts.h	r10
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80002200:	00 98       	mov	r8,r0
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
80002202:	50 ba       	stdsp	sp[0x2c],r10
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80002204:	04 90       	mov	r0,r2
80002206:	5c 83       	casts.h	r3
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
80002208:	14 91       	mov	r1,r10
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000220a:	30 05       	mov	r5,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000220c:	fc 16 c0 40 	movh	r6,0xc040
80002210:	40 e2       	lddsp	r2,sp[0x38]
80002212:	c0 78       	rjmp	80002220 <et024006_PrintString+0x48>
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
        x += xfont;
80002214:	0e 01       	add	r1,r7
80002216:	5c 81       	casts.h	r1
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
80002218:	11 30       	ld.ub	r0,r8++
8000221a:	58 00       	cp.w	r0,0
8000221c:	c5 10       	breq	800022be <et024006_PrintString+0xe6>
8000221e:	5c 81       	casts.h	r1
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80002220:	30 a9       	mov	r9,10
80002222:	f2 00 18 00 	cp.b	r0,r9
80002226:	c4 40       	breq	800022ae <et024006_PrintString+0xd6>
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
80002228:	30 99       	mov	r9,9
8000222a:	f2 00 18 00 	cp.b	r0,r9
8000222e:	cf 30       	breq	80002214 <et024006_PrintString+0x3c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
80002230:	40 5a       	lddsp	r10,sp[0x14]
80002232:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
80002236:	40 5b       	lddsp	r11,sp[0x14]
80002238:	50 08       	stdsp	sp[0x0],r8
8000223a:	0e 01       	add	r1,r7
8000223c:	e4 c9 00 01 	sub	r9,r2,1
80002240:	5c 81       	casts.h	r1
80002242:	14 09       	add	r9,r10
80002244:	5c 7b       	castu.h	r11
80002246:	5c 79       	castu.h	r9
80002248:	e2 ca 00 01 	sub	r10,r1,1
8000224c:	5c 7a       	castu.h	r10
8000224e:	c5 df       	rcall	80002108 <et024006_SetLimits>
80002250:	32 2a       	mov	r10,34
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002252:	fc 19 c0 00 	movh	r9,0xc000
80002256:	b2 0a       	st.h	r9[0x0],r10
80002258:	40 08       	lddsp	r8,sp[0x0]

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
8000225a:	58 02       	cp.w	r2,0
8000225c:	cd e0       	breq	80002218 <et024006_PrintString+0x40>
8000225e:	40 79       	lddsp	r9,sp[0x1c]
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
80002260:	22 00       	sub	r0,32
80002262:	40 9c       	lddsp	r12,sp[0x24]
80002264:	b3 30       	mul	r0,r9
80002266:	30 0e       	mov	lr,0
80002268:	12 00       	add	r0,r9
8000226a:	f8 00 00 00 	add	r0,r12,r0
8000226e:	58 07       	cp.w	r7,0
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80002270:	c1 70       	breq	8000229e <et024006_PrintString+0xc6>
80002272:	01 8c       	ld.ub	r12,r0[0x0]
80002274:	e0 6a 00 80 	mov	r10,128
80002278:	30 09       	mov	r9,0
8000227a:	c0 28       	rjmp	8000227e <et024006_PrintString+0xa6>
8000227c:	a1 9a       	lsr	r10,0x1
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
8000227e:	f5 ec 00 0b 	and	r11,r10,r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80002282:	ea 0b 18 00 	cp.b	r11,r5
          {
            *ET024006_PARAM_ADDR = fcolor;
80002286:	e8 0b 17 10 	movne	r11,r4
8000228a:	ed fb 1c 00 	st.hne	r6[0x0],r11
8000228e:	ed f3 0c 00 	st.heq	r6[0x0],r3
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80002292:	2f f9       	sub	r9,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80002294:	5c 89       	casts.h	r9
80002296:	f2 07 19 00 	cp.h	r7,r9
8000229a:	fe 9b ff f1 	brhi	8000227c <et024006_PrintString+0xa4>
8000229e:	2f fe       	sub	lr,-1

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800022a0:	5c 8e       	casts.h	lr
800022a2:	fc 02 19 00 	cp.h	r2,lr
800022a6:	fe 98 ff b9 	brls	80002218 <et024006_PrintString+0x40>
800022aa:	2f f0       	sub	r0,-1
          }
          mask >>= 1;
        }

        // Next row data
        data++;
800022ac:	ce 1b       	rjmp	8000226e <et024006_PrintString+0x96>
800022ae:	40 59       	lddsp	r9,sp[0x14]
  {
    do
    {
      if(*lcd_string =='\n') {
        x = saved_x;
        y += yfont;
800022b0:	04 09       	add	r9,r2
800022b2:	5c 89       	casts.h	r9
800022b4:	50 59       	stdsp	sp[0x14],r9
800022b6:	40 b1       	lddsp	r1,sp[0x2c]
800022b8:	11 30       	ld.ub	r0,r8++
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800022ba:	58 00       	cp.w	r0,0
800022bc:	cb 11       	brne	8000221e <et024006_PrintString+0x46>
800022be:	2e fd       	sub	sp,-68
  }
}
800022c0:	d8 32       	popm	r0-r7,pc
800022c2:	5c 8a       	casts.h	r10
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800022c4:	30 0b       	mov	r11,0

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800022c6:	50 ba       	stdsp	sp[0x2c],r10
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800022c8:	16 9c       	mov	r12,r11

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800022ca:	e0 69 00 ef 	mov	r9,239
800022ce:	e0 6a 01 3f 	mov	r10,319
800022d2:	c1 bf       	rcall	80002108 <et024006_SetLimits>
800022d4:	40 7b       	lddsp	r11,sp[0x1c]
800022d6:	50 d0       	stdsp	sp[0x34],r0
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800022d8:	f6 0b 00 18 	add	r8,r11,r11<<0x1
800022dc:	a5 78       	lsl	r8,0x5
800022de:	00 99       	mov	r9,r0
800022e0:	40 9a       	lddsp	r10,sp[0x24]

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800022e2:	40 bc       	lddsp	r12,sp[0x2c]
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800022e4:	10 0a       	add	r10,r8
800022e6:	51 0a       	stdsp	sp[0x40],r10
800022e8:	13 38       	ld.ub	r8,r9++
800022ea:	50 cc       	stdsp	sp[0x30],r12

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800022ec:	50 d9       	stdsp	sp[0x34],r9
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800022ee:	50 f7       	stdsp	sp[0x3c],r7

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800022f0:	50 24       	stdsp	sp[0x8],r4
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800022f2:	30 0e       	mov	lr,0
800022f4:	fc 1a c0 00 	movh	r10,0xc000
800022f8:	30 a9       	mov	r9,10
800022fa:	f2 08 18 00 	cp.b	r8,r9
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
800022fe:	c7 00       	breq	800023de <et024006_PrintString+0x206>
80002300:	30 99       	mov	r9,9
80002302:	f2 08 18 00 	cp.b	r8,r9
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
80002306:	c7 c0       	breq	800023fe <et024006_PrintString+0x226>
80002308:	f0 cb 00 20 	sub	r11,r8,32
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
8000230c:	35 f9       	mov	r9,95
8000230e:	f2 0b 18 00 	cp.b	r11,r9
80002312:	e0 88 00 6e 	brls	800023ee <et024006_PrintString+0x216>
80002316:	41 0b       	lddsp	r11,sp[0x40]
80002318:	50 4b       	stdsp	sp[0x10],r11
8000231a:	40 58       	lddsp	r8,sp[0x14]
8000231c:	40 eb       	lddsp	r11,sp[0x38]
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000231e:	5c 78       	castu.h	r8
80002320:	f0 0b 00 0b 	add	r11,r8,r11
80002324:	50 6b       	stdsp	sp[0x18],r11
80002326:	16 38       	cp.w	r8,r11
80002328:	c4 c4       	brge	800023c0 <et024006_PrintString+0x1e8>
8000232a:	40 cb       	lddsp	r11,sp[0x30]
8000232c:	5c 8b       	casts.h	r11
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000232e:	40 c9       	lddsp	r9,sp[0x30]
80002330:	40 58       	lddsp	r8,sp[0x14]
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80002332:	5c 79       	castu.h	r9
80002334:	5c 88       	casts.h	r8
80002336:	12 95       	mov	r5,r9
80002338:	40 fc       	lddsp	r12,sp[0x3c]
8000233a:	50 ab       	stdsp	sp[0x28],r11
8000233c:	50 89       	stdsp	sp[0x20],r9
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000233e:	50 38       	stdsp	sp[0xc],r8
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80002340:	18 05       	add	r5,r12
80002342:	fc 1b c0 40 	movh	r11,0xc040
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002346:	40 8c       	lddsp	r12,sp[0x20]
80002348:	18 35       	cp.w	r5,r12
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
8000234a:	e0 8a 00 2f 	brle	800023a8 <et024006_PrintString+0x1d0>
8000234e:	40 49       	lddsp	r9,sp[0x10]
80002350:	40 38       	lddsp	r8,sp[0xc]
80002352:	13 84       	ld.ub	r4,r9[0x0]
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002354:	e1 d8 c1 08 	bfextu	r0,r8,0x8,0x8
80002358:	40 3c       	lddsp	r12,sp[0xc]
8000235a:	40 a8       	lddsp	r8,sp[0x28]
8000235c:	5c 5c       	castu.b	r12
8000235e:	e0 69 00 80 	mov	r9,128
80002362:	30 31       	mov	r1,3
80002364:	30 62       	mov	r2,6
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002366:	30 73       	mov	r3,7
80002368:	50 1c       	stdsp	sp[0x4],r12
8000236a:	ed d8 c1 08 	bfextu	r6,r8,0x8,0x8
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000236e:	ef d8 c0 08 	bfextu	r7,r8,0x0,0x8
80002372:	f3 e4 00 0c 	and	r12,r9,r4
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80002376:	2f f8       	sub	r8,-1
80002378:	5c 88       	casts.h	r8
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
8000237a:	fc 0c 18 00 	cp.b	r12,lr
        {
          if (*data & mask) // if pixel data then put dot
8000237e:	c0 f0       	breq	8000239c <et024006_PrintString+0x1c4>
80002380:	30 2c       	mov	r12,2
80002382:	b4 0c       	st.h	r10[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002384:	b6 06       	st.h	r11[0x0],r6
80002386:	b4 01       	st.h	r10[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002388:	b6 07       	st.h	r11[0x0],r7
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000238a:	b4 02       	st.h	r10[0x0],r2
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000238c:	b6 00       	st.h	r11[0x0],r0
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000238e:	b4 03       	st.h	r10[0x0],r3
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002390:	40 1c       	lddsp	r12,sp[0x4]
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002392:	b6 0c       	st.h	r11[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002394:	32 2c       	mov	r12,34
80002396:	b4 0c       	st.h	r10[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002398:	40 2c       	lddsp	r12,sp[0x8]
8000239a:	b6 0c       	st.h	r11[0x0],r12
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000239c:	a1 99       	lsr	r9,0x1
8000239e:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800023a2:	18 35       	cp.w	r5,r12
800023a4:	fe 99 ff e3 	brgt	8000236a <et024006_PrintString+0x192>
800023a8:	40 38       	lddsp	r8,sp[0xc]
800023aa:	2f f8       	sub	r8,-1
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800023ac:	5c 88       	casts.h	r8
800023ae:	50 38       	stdsp	sp[0xc],r8
800023b0:	40 69       	lddsp	r9,sp[0x18]
800023b2:	5c 78       	castu.h	r8
800023b4:	12 38       	cp.w	r8,r9
800023b6:	c0 54       	brge	800023c0 <et024006_PrintString+0x1e8>
800023b8:	40 48       	lddsp	r8,sp[0x10]
800023ba:	2f f8       	sub	r8,-1
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800023bc:	50 48       	stdsp	sp[0x10],r8
800023be:	cc 4b       	rjmp	80002346 <et024006_PrintString+0x16e>
800023c0:	40 c8       	lddsp	r8,sp[0x30]
800023c2:	40 fb       	lddsp	r11,sp[0x3c]
      }
      // move to next character start pixel
      x += xfont;
800023c4:	16 08       	add	r8,r11
800023c6:	5c 88       	casts.h	r8
800023c8:	50 c8       	stdsp	sp[0x30],r8
800023ca:	40 d9       	lddsp	r9,sp[0x34]
800023cc:	13 38       	ld.ub	r8,r9++
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800023ce:	50 d9       	stdsp	sp[0x34],r9
800023d0:	58 08       	cp.w	r8,0
800023d2:	fe 90 ff 76 	breq	800022be <et024006_PrintString+0xe6>
800023d6:	30 a9       	mov	r9,10
800023d8:	f2 08 18 00 	cp.b	r8,r9
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
800023dc:	c9 21       	brne	80002300 <et024006_PrintString+0x128>
800023de:	40 58       	lddsp	r8,sp[0x14]
800023e0:	40 eb       	lddsp	r11,sp[0x38]
        x = saved_x;
        y += yfont;
800023e2:	40 b9       	lddsp	r9,sp[0x2c]
800023e4:	16 08       	add	r8,r11
800023e6:	50 c9       	stdsp	sp[0x30],r9
800023e8:	5c 88       	casts.h	r8
800023ea:	50 58       	stdsp	sp[0x14],r8
800023ec:	ce fb       	rjmp	800023ca <et024006_PrintString+0x1f2>
800023ee:	40 79       	lddsp	r9,sp[0x1c]
        lcd_string++;  // next character in string
        continue;
800023f0:	22 08       	sub	r8,32
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
800023f2:	40 9c       	lddsp	r12,sp[0x24]
800023f4:	b3 38       	mul	r8,r9
800023f6:	12 08       	add	r8,r9
800023f8:	10 0c       	add	r12,r8
800023fa:	50 4c       	stdsp	sp[0x10],r12
800023fc:	c8 fb       	rjmp	8000231a <et024006_PrintString+0x142>
800023fe:	40 c8       	lddsp	r8,sp[0x30]
80002400:	40 fc       	lddsp	r12,sp[0x3c]
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
        x += xfont;
80002402:	18 08       	add	r8,r12
80002404:	5c 88       	casts.h	r8
80002406:	50 c8       	stdsp	sp[0x30],r8
80002408:	ce 1b       	rjmp	800023ca <et024006_PrintString+0x1f2>
8000240a:	d7 03       	nop

8000240c <et024006_DrawFilledRect>:
        lcd_string++;  // next character in string
        continue;
8000240c:	eb cd 40 e0 	pushm	r5-r7,lr
80002410:	14 97       	mov	r7,r10
80002412:	12 96       	mov	r6,r9
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80002414:	18 9a       	mov	r10,r12
80002416:	16 99       	mov	r9,r11
80002418:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
8000241a:	5c 7b       	castu.h	r11
8000241c:	5c 7c       	castu.h	r12
8000241e:	20 19       	sub	r9,1
80002420:	20 1a       	sub	r10,1
80002422:	0c 09       	add	r9,r6
80002424:	0e 0a       	add	r10,r7
80002426:	5c 79       	castu.h	r9
80002428:	5c 7a       	castu.h	r10
8000242a:	c6 fe       	rcall	80002108 <et024006_SetLimits>
8000242c:	32 29       	mov	r9,34
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000242e:	fc 18 c0 00 	movh	r8,0xc000
80002432:	b0 09       	st.h	r8[0x0],r9
80002434:	5c 76       	castu.h	r6
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
  uint32_t count = (uint32_t) width * height;
80002436:	5c 77       	castu.h	r7
80002438:	ec 07 02 47 	mul	r7,r6,r7
8000243c:	58 77       	cp.w	r7,7
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000243e:	e0 88 00 13 	brls	80002464 <et024006_DrawFilledRect+0x58>
80002442:	0e 99       	mov	r9,r7
80002444:	fc 18 c0 40 	movh	r8,0xc040
    *ET024006_PARAM_ADDR = color;
80002448:	b0 05       	st.h	r8[0x0],r5
8000244a:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
8000244c:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
8000244e:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
80002450:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
80002452:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
80002454:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
80002456:	b0 05       	st.h	r8[0x0],r5
    *ET024006_PARAM_ADDR = color;
80002458:	20 89       	sub	r9,8
    count-=8;
8000245a:	58 79       	cp.w	r9,7
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000245c:	fe 9b ff f6 	brhi	80002448 <et024006_DrawFilledRect+0x3c>
80002460:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
    }
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
80002464:	58 07       	cp.w	r7,0
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002466:	c0 60       	breq	80002472 <et024006_DrawFilledRect+0x66>
80002468:	fc 18 c0 40 	movh	r8,0xc040
    *ET024006_PARAM_ADDR = color;
8000246c:	b0 05       	st.h	r8[0x0],r5
8000246e:	20 17       	sub	r7,1
    --count;
80002470:	cf e1       	brne	8000246c <et024006_DrawFilledRect+0x60>
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002472:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002476:	d7 03       	nop

80002478 <et024006_PutPixmap>:
80002478:	eb cd 40 fc 	pushm	r2-r7,lr
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
8000247c:	18 92       	mov	r2,r12
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits( x, y, x2, y2 );
8000247e:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80002482:	20 18       	sub	r8,1
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
80002484:	fa c4 ff e4 	sub	r4,sp,-28
80002488:	14 96       	mov	r6,r10
8000248a:	68 27       	ld.w	r7,r4[0x8]
8000248c:	16 95       	mov	r5,r11
8000248e:	12 93       	mov	r3,r9
80002490:	68 09       	ld.w	r9,r4[0x0]
80002492:	68 14       	ld.w	r4,r4[0x4]
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits( x, y, x2, y2 );
80002494:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
80002498:	f0 04 00 0a 	add	r10,r8,r4
8000249c:	20 19       	sub	r9,1
8000249e:	5c 7a       	castu.h	r10
800024a0:	0e 09       	add	r9,r7
800024a2:	5c 79       	castu.h	r9
800024a4:	c3 2e       	rcall	80002108 <et024006_SetLimits>
800024a6:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10

  // Offset into pixmap.
  pixmap += map_x;
800024aa:	e4 08 00 12 	add	r2,r2,r8<<0x1
800024ae:	58 03       	cp.w	r3,0
  if (map_y > 0) {
800024b0:	c0 70       	breq	800024be <et024006_PutPixmap+0x46>
800024b2:	5c 73       	castu.h	r3
    pixmap += (uint32_t) map_y * map_width;
800024b4:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024b8:	a1 78       	lsl	r8,0x1
800024ba:	f0 03 03 42 	mac	r2,r8,r3
800024be:	32 29       	mov	r9,34
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024c0:	fc 18 c0 00 	movh	r8,0xc000
800024c4:	b0 09       	st.h	r8[0x0],r9
800024c6:	e8 05 19 00 	cp.h	r5,r4
  }
  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
800024ca:	5f 0a       	sreq	r10
800024cc:	30 08       	mov	r8,0
800024ce:	f0 06 19 00 	cp.h	r6,r8
800024d2:	5f 09       	sreq	r9
800024d4:	f5 e9 00 09 	and	r9,r10,r9
800024d8:	f0 09 18 00 	cp.b	r9,r8
800024dc:	c4 01       	brne	8000255c <et024006_PutPixmap+0xe4>
800024de:	58 07       	cp.w	r7,0
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
800024e0:	c7 20       	breq	800025c4 <et024006_PutPixmap+0x14c>
800024e2:	ed d5 c0 10 	bfextu	r6,r5,0x0,0x10
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
800024e6:	5c 74       	castu.h	r4
800024e8:	a1 76       	lsl	r6,0x1
800024ea:	e8 c5 00 08 	sub	r5,r4,8
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
800024ee:	5c 87       	casts.h	r7
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
800024f0:	ea 0c 16 03 	lsr	r12,r5,0x3
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
800024f4:	fc 19 c0 40 	movh	r9,0xc040
  Assert( count > 0 );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
  {
    *ET024006_PARAM_ADDR = *pixels++;
800024f8:	ea 0c 01 35 	sub	r5,r5,r12<<0x3
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
800024fc:	58 74       	cp.w	r4,7
{
  Assert( pixels != NULL );
  Assert( count > 0 );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
800024fe:	e0 88 00 2c 	brls	80002556 <et024006_PutPixmap+0xde>
80002502:	08 9a       	mov	r10,r4
80002504:	04 98       	mov	r8,r2
80002506:	90 0b       	ld.sh	r11,r8[0x0]
  {
    *ET024006_PARAM_ADDR = *pixels++;
80002508:	b2 0b       	st.h	r9[0x0],r11
8000250a:	90 1b       	ld.sh	r11,r8[0x2]
    *ET024006_PARAM_ADDR = *pixels++;
8000250c:	b2 0b       	st.h	r9[0x0],r11
8000250e:	90 2b       	ld.sh	r11,r8[0x4]
    *ET024006_PARAM_ADDR = *pixels++;
80002510:	b2 0b       	st.h	r9[0x0],r11
80002512:	90 3b       	ld.sh	r11,r8[0x6]
    *ET024006_PARAM_ADDR = *pixels++;
80002514:	b2 0b       	st.h	r9[0x0],r11
80002516:	90 4b       	ld.sh	r11,r8[0x8]
    *ET024006_PARAM_ADDR = *pixels++;
80002518:	b2 0b       	st.h	r9[0x0],r11
8000251a:	90 5b       	ld.sh	r11,r8[0xa]
    *ET024006_PARAM_ADDR = *pixels++;
8000251c:	b2 0b       	st.h	r9[0x0],r11
8000251e:	90 6b       	ld.sh	r11,r8[0xc]
    *ET024006_PARAM_ADDR = *pixels++;
80002520:	b2 0b       	st.h	r9[0x0],r11
80002522:	90 7b       	ld.sh	r11,r8[0xe]
    *ET024006_PARAM_ADDR = *pixels++;
80002524:	b2 0b       	st.h	r9[0x0],r11
80002526:	2f 08       	sub	r8,-16
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80002528:	20 8a       	sub	r10,8
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
8000252a:	58 7a       	cp.w	r10,7
{
  Assert( pixels != NULL );
  Assert( count > 0 );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
8000252c:	fe 9b ff ed 	brhi	80002506 <et024006_PutPixmap+0x8e>
80002530:	f8 ca ff ff 	sub	r10,r12,-1
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80002534:	0a 98       	mov	r8,r5
80002536:	a5 6a       	lsl	r10,0x4
80002538:	e4 0a 00 0a 	add	r10,r2,r10
8000253c:	c0 48       	rjmp	80002544 <et024006_PutPixmap+0xcc>
8000253e:	15 1b       	ld.sh	r11,r10++
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
  {
    *ET024006_PARAM_ADDR = *pixels;
80002540:	20 18       	sub	r8,1
    pixels++;
    count--;
80002542:	b2 0b       	st.h	r9[0x0],r11
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
  {
    *ET024006_PARAM_ADDR = *pixels;
80002544:	58 08       	cp.w	r8,0
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80002546:	cf c1       	brne	8000253e <et024006_PutPixmap+0xc6>
80002548:	20 17       	sub	r7,1
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
      --lines_left;
8000254a:	5c 87       	casts.h	r7
8000254c:	c3 a0       	breq	800025c0 <et024006_PutPixmap+0x148>
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
8000254e:	0c 02       	add	r2,r6
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
80002550:	58 74       	cp.w	r4,7
{
  Assert( pixels != NULL );
  Assert( count > 0 );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80002552:	fe 9b ff d8 	brhi	80002502 <et024006_PutPixmap+0x8a>
80002556:	08 98       	mov	r8,r4
80002558:	04 9a       	mov	r10,r2
8000255a:	cf 5b       	rjmp	80002544 <et024006_PutPixmap+0xcc>
8000255c:	0e 9a       	mov	r10,r7
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
8000255e:	5c 74       	castu.h	r4
80002560:	5c 7a       	castu.h	r10
80002562:	a9 3a       	mul	r10,r4
80002564:	58 7a       	cp.w	r10,7
{
  Assert( pixels != NULL );
  Assert( count > 0 );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80002566:	e0 88 00 23 	brls	800025ac <et024006_PutPixmap+0x134>
8000256a:	14 9b       	mov	r11,r10
8000256c:	04 98       	mov	r8,r2
8000256e:	fc 19 c0 40 	movh	r9,0xc040
  {
    *ET024006_PARAM_ADDR = *pixels++;
80002572:	90 0c       	ld.sh	r12,r8[0x0]
80002574:	b2 0c       	st.h	r9[0x0],r12
80002576:	90 1c       	ld.sh	r12,r8[0x2]
    *ET024006_PARAM_ADDR = *pixels++;
80002578:	b2 0c       	st.h	r9[0x0],r12
8000257a:	90 2c       	ld.sh	r12,r8[0x4]
    *ET024006_PARAM_ADDR = *pixels++;
8000257c:	b2 0c       	st.h	r9[0x0],r12
8000257e:	90 3c       	ld.sh	r12,r8[0x6]
    *ET024006_PARAM_ADDR = *pixels++;
80002580:	b2 0c       	st.h	r9[0x0],r12
80002582:	90 4c       	ld.sh	r12,r8[0x8]
    *ET024006_PARAM_ADDR = *pixels++;
80002584:	b2 0c       	st.h	r9[0x0],r12
80002586:	90 5c       	ld.sh	r12,r8[0xa]
    *ET024006_PARAM_ADDR = *pixels++;
80002588:	b2 0c       	st.h	r9[0x0],r12
8000258a:	90 6c       	ld.sh	r12,r8[0xc]
    *ET024006_PARAM_ADDR = *pixels++;
8000258c:	b2 0c       	st.h	r9[0x0],r12
8000258e:	90 7c       	ld.sh	r12,r8[0xe]
    *ET024006_PARAM_ADDR = *pixels++;
80002590:	b2 0c       	st.h	r9[0x0],r12
80002592:	2f 08       	sub	r8,-16
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80002594:	20 8b       	sub	r11,8
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
80002596:	58 7b       	cp.w	r11,7
{
  Assert( pixels != NULL );
  Assert( count > 0 );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80002598:	fe 9b ff ed 	brhi	80002572 <et024006_PutPixmap+0xfa>
8000259c:	f4 c8 00 08 	sub	r8,r10,8
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
800025a0:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800025a4:	a3 98       	lsr	r8,0x3
800025a6:	2f f8       	sub	r8,-1
800025a8:	a5 68       	lsl	r8,0x4
800025aa:	10 02       	add	r2,r8
800025ac:	58 0a       	cp.w	r10,0
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
800025ae:	c0 90       	breq	800025c0 <et024006_PutPixmap+0x148>
800025b0:	fc 19 c0 40 	movh	r9,0xc040
  {
    *ET024006_PARAM_ADDR = *pixels;
800025b4:	05 18       	ld.sh	r8,r2++
800025b6:	b2 08       	st.h	r9[0x0],r8
800025b8:	20 1a       	sub	r10,1
    pixels++;
    count--;
800025ba:	cf d1       	brne	800025b4 <et024006_PutPixmap+0x13c>
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
800025bc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800025c0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800025c4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

800025c8 <et024006_Init>:
800025c8:	d4 31       	pushm	r0-r7,lr
800025ca:	fe f7 04 86 	ld.w	r7,pc[1158]
800025ce:	8f 1b       	st.w	r7[0x4],r11
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
  tft_data.cpu_hz = cpu_hz;
800025d0:	8f 0c       	st.w	r7[0x0],r12

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
800025d2:	16 9c       	mov	r12,r11
800025d4:	e0 a0 03 44 	rcall	80002c5c <smc_init>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
800025d8:	37 3c       	mov	r12,115
800025da:	e0 a0 30 57 	rcall	80008688 <gpio_enable_gpio_pin>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
800025de:	30 3b       	mov	r11,3
800025e0:	37 cc       	mov	r12,124
800025e2:	e0 a0 2f f1 	rcall	800085c4 <gpio_enable_module_pin>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800025e6:	37 0c       	mov	r12,112
800025e8:	e0 a0 30 66 	rcall	800086b4 <gpio_set_gpio_pin>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
800025ec:	37 0c       	mov	r12,112
800025ee:	e0 a0 30 70 	rcall	800086ce <gpio_clr_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800025f2:	ee 78 42 40 	mov	r8,1000000
800025f6:	33 2a       	mov	r10,50
800025f8:	30 09       	mov	r9,0
800025fa:	6e 05       	ld.w	r5,r7[0x0]
800025fc:	30 0b       	mov	r11,0
800025fe:	ea 0a 06 44 	mulu.d	r4,r5,r10
80002602:	ee 7a 42 3f 	mov	r10,999999
80002606:	e8 0a 00 0a 	add	r10,r4,r10
8000260a:	ea 0b 00 4b 	adc	r11,r5,r11
8000260e:	e0 a0 a0 bf 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002612:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002616:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000261a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000261e:	14 38       	cp.w	r8,r10
80002620:	e0 88 02 12 	brls	80002a44 <et024006_Init+0x47c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002624:	12 38       	cp.w	r8,r9
80002626:	fe 98 ff fa 	brls	8000261a <et024006_Init+0x52>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000262a:	12 3a       	cp.w	r10,r9
8000262c:	cf 72       	brcc	8000261a <et024006_Init+0x52>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
8000262e:	37 0c       	mov	r12,112
80002630:	e0 a0 30 42 	rcall	800086b4 <gpio_set_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002634:	e0 68 03 e8 	mov	r8,1000
80002638:	30 5a       	mov	r10,5
8000263a:	30 09       	mov	r9,0
8000263c:	6e 05       	ld.w	r5,r7[0x0]
8000263e:	30 0b       	mov	r11,0
80002640:	ea 0a 06 44 	mulu.d	r4,r5,r10
80002644:	e0 6a 03 e7 	mov	r10,999
80002648:	e8 0a 00 0a 	add	r10,r4,r10
8000264c:	ea 0b 00 4b 	adc	r11,r5,r11
80002650:	e0 a0 a0 9e 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002654:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002658:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000265c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002660:	14 38       	cp.w	r8,r10
80002662:	e0 88 00 0c 	brls	8000267a <et024006_Init+0xb2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002666:	12 38       	cp.w	r8,r9
80002668:	e0 88 00 04 	brls	80002670 <et024006_Init+0xa8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000266c:	12 3a       	cp.w	r10,r9
8000266e:	c0 93       	brcs	80002680 <et024006_Init+0xb8>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002670:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002674:	14 38       	cp.w	r8,r10
80002676:	fe 9b ff f8 	brhi	80002666 <et024006_Init+0x9e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000267a:	12 38       	cp.w	r8,r9
8000267c:	fe 98 ff f8 	brls	8000266c <et024006_Init+0xa4>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002680:	fc 19 c0 00 	movh	r9,0xc000
80002684:	34 6a       	mov	r10,70
80002686:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002688:	fc 18 c0 40 	movh	r8,0xc040
8000268c:	e0 6b 00 94 	mov	r11,148
80002690:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002692:	34 7b       	mov	r11,71
80002694:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002696:	34 11       	mov	r1,65
80002698:	b0 01       	st.h	r8[0x0],r1
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000269a:	34 8b       	mov	r11,72
8000269c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000269e:	30 0c       	mov	r12,0
800026a0:	b0 0c       	st.h	r8[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026a2:	34 92       	mov	r2,73
800026a4:	b2 02       	st.h	r9[0x0],r2
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026a6:	33 3b       	mov	r11,51
800026a8:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026aa:	34 ab       	mov	r11,74
800026ac:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026ae:	32 53       	mov	r3,37
800026b0:	b0 03       	st.h	r8[0x0],r3
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026b2:	34 bb       	mov	r11,75
800026b4:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026b6:	34 5e       	mov	lr,69
800026b8:	b0 0e       	st.h	r8[0x0],lr
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026ba:	34 cb       	mov	r11,76
800026bc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026be:	34 46       	mov	r6,68
800026c0:	b0 06       	st.h	r8[0x0],r6
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026c2:	34 db       	mov	r11,77
800026c4:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026c6:	37 7b       	mov	r11,119
800026c8:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026ca:	34 eb       	mov	r11,78
800026cc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026ce:	31 25       	mov	r5,18
800026d0:	b0 05       	st.h	r8[0x0],r5
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026d2:	34 fb       	mov	r11,79
800026d4:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026d6:	e0 6b 00 cc 	mov	r11,204
800026da:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026dc:	35 0b       	mov	r11,80
800026de:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026e0:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026e2:	35 1a       	mov	r10,81
800026e4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026e6:	e0 6a 00 82 	mov	r10,130
800026ea:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026ec:	30 1a       	mov	r10,1
800026ee:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026f0:	30 6b       	mov	r11,6
800026f2:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026f4:	33 ab       	mov	r11,58
800026f6:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026f8:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800026fa:	33 bb       	mov	r11,59
800026fc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800026fe:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002700:	33 ca       	mov	r10,60
80002702:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002704:	e0 6a 00 f0 	mov	r10,240
80002708:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000270a:	33 db       	mov	r11,61
8000270c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000270e:	b0 0c       	st.h	r8[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002710:	33 eb       	mov	r11,62
80002712:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002714:	33 8b       	mov	r11,56
80002716:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002718:	34 04       	mov	r4,64
8000271a:	b2 04       	st.h	r9[0x0],r4
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000271c:	30 f0       	mov	r0,15
8000271e:	b0 00       	st.h	r8[0x0],r0
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002720:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002722:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002724:	32 7a       	mov	r10,39
80002726:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002728:	30 2a       	mov	r10,2
8000272a:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000272c:	32 81       	mov	r1,40
8000272e:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002730:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002732:	32 91       	mov	r1,41
80002734:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002736:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002738:	32 a1       	mov	r1,42
8000273a:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000273c:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000273e:	32 c1       	mov	r1,44
80002740:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002742:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002744:	32 d1       	mov	r1,45
80002746:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002748:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000274a:	31 9a       	mov	r10,25
8000274c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000274e:	b0 02       	st.h	r8[0x0],r2
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002750:	e0 6a 00 93 	mov	r10,147
80002754:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002756:	30 8a       	mov	r10,8
80002758:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000275a:	31 6a       	mov	r10,22
8000275c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000275e:	36 8a       	mov	r10,104
80002760:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002762:	32 3a       	mov	r10,35
80002764:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002766:	e0 6a 00 95 	mov	r10,149
8000276a:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000276c:	32 42       	mov	r2,36
8000276e:	b2 02       	st.h	r9[0x0],r2
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002770:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002772:	b2 03       	st.h	r9[0x0],r3
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002774:	e0 6a 00 ff 	mov	r10,255
80002778:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000277a:	e0 6a 00 90 	mov	r10,144
8000277e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002780:	37 fa       	mov	r10,127
80002782:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002784:	33 5a       	mov	r10,53
80002786:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002788:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000278a:	33 6a       	mov	r10,54
8000278c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000278e:	37 8a       	mov	r10,120
80002790:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002792:	31 da       	mov	r10,29
80002794:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002796:	30 7a       	mov	r10,7
80002798:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000279a:	31 ea       	mov	r10,30
8000279c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000279e:	b0 0c       	st.h	r8[0x0],r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027a0:	31 fa       	mov	r10,31
800027a2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027a4:	30 4a       	mov	r10,4
800027a6:	b0 0a       	st.h	r8[0x0],r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027a8:	32 0a       	mov	r10,32
800027aa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027ac:	b0 04       	st.h	r8[0x0],r4
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027ae:	b2 06       	st.h	r9[0x0],r6
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027b0:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027b2:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027b4:	b0 05       	st.h	r8[0x0],r5
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800027b6:	30 a8       	mov	r8,10
800027b8:	6e 0b       	ld.w	r11,r7[0x0]
800027ba:	f6 08 06 4a 	mulu.d	r10,r11,r8
800027be:	e0 68 03 e7 	mov	r8,999
800027c2:	30 09       	mov	r9,0
800027c4:	10 0a       	add	r10,r8
800027c6:	f6 09 00 4b 	adc	r11,r11,r9
800027ca:	e0 68 03 e8 	mov	r8,1000
800027ce:	30 09       	mov	r9,0
800027d0:	e0 a0 9f de 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027d4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800027d8:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800027dc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800027e0:	14 38       	cp.w	r8,r10
800027e2:	e0 88 00 0c 	brls	800027fa <et024006_Init+0x232>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800027e6:	12 38       	cp.w	r8,r9
800027e8:	e0 88 00 04 	brls	800027f0 <et024006_Init+0x228>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800027ec:	12 3a       	cp.w	r10,r9
800027ee:	c0 93       	brcs	80002800 <et024006_Init+0x238>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800027f0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800027f4:	14 38       	cp.w	r8,r10
800027f6:	fe 9b ff f8 	brhi	800027e6 <et024006_Init+0x21e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800027fa:	12 38       	cp.w	r8,r9
800027fc:	fe 98 ff f8 	brls	800027ec <et024006_Init+0x224>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002800:	fc 18 c0 00 	movh	r8,0xc000
80002804:	31 c9       	mov	r9,28
80002806:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002808:	fc 18 c0 40 	movh	r8,0xc040
8000280c:	30 49       	mov	r9,4
8000280e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002810:	31 48       	mov	r8,20
80002812:	6e 0b       	ld.w	r11,r7[0x0]
80002814:	f6 08 06 4a 	mulu.d	r10,r11,r8
80002818:	e0 68 03 e7 	mov	r8,999
8000281c:	30 09       	mov	r9,0
8000281e:	10 0a       	add	r10,r8
80002820:	f6 09 00 4b 	adc	r11,r11,r9
80002824:	e0 68 03 e8 	mov	r8,1000
80002828:	30 09       	mov	r9,0
8000282a:	e0 a0 9f b1 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000282e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002832:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002836:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000283a:	14 38       	cp.w	r8,r10
8000283c:	e0 88 00 0c 	brls	80002854 <et024006_Init+0x28c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002840:	12 38       	cp.w	r8,r9
80002842:	e0 88 00 04 	brls	8000284a <et024006_Init+0x282>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002846:	12 3a       	cp.w	r10,r9
80002848:	c0 93       	brcs	8000285a <et024006_Init+0x292>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000284a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000284e:	14 38       	cp.w	r8,r10
80002850:	fe 9b ff f8 	brhi	80002840 <et024006_Init+0x278>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002854:	12 38       	cp.w	r8,r9
80002856:	fe 98 ff f8 	brls	80002846 <et024006_Init+0x27e>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000285a:	fc 18 c0 00 	movh	r8,0xc000
8000285e:	34 39       	mov	r9,67
80002860:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002862:	fc 18 c0 40 	movh	r8,0xc040
80002866:	e0 69 00 80 	mov	r9,128
8000286a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000286c:	30 58       	mov	r8,5
8000286e:	6e 0b       	ld.w	r11,r7[0x0]
80002870:	f6 08 06 4a 	mulu.d	r10,r11,r8
80002874:	e0 68 03 e7 	mov	r8,999
80002878:	30 09       	mov	r9,0
8000287a:	10 0a       	add	r10,r8
8000287c:	f6 09 00 4b 	adc	r11,r11,r9
80002880:	e0 68 03 e8 	mov	r8,1000
80002884:	30 09       	mov	r9,0
80002886:	e0 a0 9f 83 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000288a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000288e:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002892:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002896:	14 38       	cp.w	r8,r10
80002898:	e0 88 00 0c 	brls	800028b0 <et024006_Init+0x2e8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000289c:	12 38       	cp.w	r8,r9
8000289e:	e0 88 00 04 	brls	800028a6 <et024006_Init+0x2de>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028a2:	12 3a       	cp.w	r10,r9
800028a4:	c0 93       	brcs	800028b6 <et024006_Init+0x2ee>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800028a6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800028aa:	14 38       	cp.w	r8,r10
800028ac:	fe 9b ff f8 	brhi	8000289c <et024006_Init+0x2d4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028b0:	12 38       	cp.w	r8,r9
800028b2:	fe 98 ff f8 	brls	800028a2 <et024006_Init+0x2da>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028b6:	fc 18 c0 00 	movh	r8,0xc000
800028ba:	31 b9       	mov	r9,27
800028bc:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800028be:	fc 18 c0 40 	movh	r8,0xc040
800028c2:	30 89       	mov	r9,8
800028c4:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028c6:	32 88       	mov	r8,40
800028c8:	6e 0b       	ld.w	r11,r7[0x0]
800028ca:	f6 08 06 4a 	mulu.d	r10,r11,r8
800028ce:	e0 68 03 e7 	mov	r8,999
800028d2:	30 09       	mov	r9,0
800028d4:	10 0a       	add	r10,r8
800028d6:	f6 09 00 4b 	adc	r11,r11,r9
800028da:	e0 68 03 e8 	mov	r8,1000
800028de:	30 09       	mov	r9,0
800028e0:	e0 a0 9f 56 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800028e4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800028e8:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800028ec:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800028f0:	14 38       	cp.w	r8,r10
800028f2:	e0 88 00 0c 	brls	8000290a <et024006_Init+0x342>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800028f6:	12 38       	cp.w	r8,r9
800028f8:	e0 88 00 04 	brls	80002900 <et024006_Init+0x338>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028fc:	12 3a       	cp.w	r10,r9
800028fe:	c0 93       	brcs	80002910 <et024006_Init+0x348>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002900:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002904:	14 38       	cp.w	r8,r10
80002906:	fe 9b ff f8 	brhi	800028f6 <et024006_Init+0x32e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000290a:	12 38       	cp.w	r8,r9
8000290c:	fe 98 ff f8 	brls	800028fc <et024006_Init+0x334>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002910:	fc 18 c0 00 	movh	r8,0xc000
80002914:	31 b9       	mov	r9,27
80002916:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002918:	fc 18 c0 40 	movh	r8,0xc040
8000291c:	31 09       	mov	r9,16
8000291e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002920:	32 88       	mov	r8,40
80002922:	6e 0b       	ld.w	r11,r7[0x0]
80002924:	f6 08 06 4a 	mulu.d	r10,r11,r8
80002928:	e0 68 03 e7 	mov	r8,999
8000292c:	30 09       	mov	r9,0
8000292e:	10 0a       	add	r10,r8
80002930:	f6 09 00 4b 	adc	r11,r11,r9
80002934:	e0 68 03 e8 	mov	r8,1000
80002938:	30 09       	mov	r9,0
8000293a:	e0 a0 9f 29 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000293e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002942:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002946:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000294a:	14 38       	cp.w	r8,r10
8000294c:	e0 88 00 0c 	brls	80002964 <et024006_Init+0x39c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002950:	12 38       	cp.w	r8,r9
80002952:	e0 88 00 04 	brls	8000295a <et024006_Init+0x392>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002956:	12 3a       	cp.w	r10,r9
80002958:	c0 93       	brcs	8000296a <et024006_Init+0x3a2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000295a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000295e:	14 38       	cp.w	r8,r10
80002960:	fe 9b ff f8 	brhi	80002950 <et024006_Init+0x388>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002964:	12 38       	cp.w	r8,r9
80002966:	fe 98 ff f8 	brls	80002956 <et024006_Init+0x38e>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000296a:	fc 18 c0 00 	movh	r8,0xc000
8000296e:	32 69       	mov	r9,38
80002970:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002972:	fc 18 c0 40 	movh	r8,0xc040
80002976:	30 49       	mov	r9,4
80002978:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000297a:	32 88       	mov	r8,40
8000297c:	6e 0b       	ld.w	r11,r7[0x0]
8000297e:	f6 08 06 4a 	mulu.d	r10,r11,r8
80002982:	e0 68 03 e7 	mov	r8,999
80002986:	30 09       	mov	r9,0
80002988:	10 0a       	add	r10,r8
8000298a:	f6 09 00 4b 	adc	r11,r11,r9
8000298e:	e0 68 03 e8 	mov	r8,1000
80002992:	30 09       	mov	r9,0
80002994:	e0 a0 9e fc 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002998:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000299c:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800029a0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029a4:	14 38       	cp.w	r8,r10
800029a6:	e0 88 00 0c 	brls	800029be <et024006_Init+0x3f6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029aa:	12 38       	cp.w	r8,r9
800029ac:	e0 88 00 04 	brls	800029b4 <et024006_Init+0x3ec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800029b0:	12 3a       	cp.w	r10,r9
800029b2:	c0 93       	brcs	800029c4 <et024006_Init+0x3fc>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800029b4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029b8:	14 38       	cp.w	r8,r10
800029ba:	fe 9b ff f8 	brhi	800029aa <et024006_Init+0x3e2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800029be:	12 38       	cp.w	r8,r9
800029c0:	fe 98 ff f8 	brls	800029b0 <et024006_Init+0x3e8>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029c4:	fc 19 c0 00 	movh	r9,0xc000
800029c8:	32 6a       	mov	r10,38
800029ca:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029cc:	fc 18 c0 40 	movh	r8,0xc040
800029d0:	32 4b       	mov	r11,36
800029d2:	b0 0b       	st.h	r8[0x0],r11
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029d4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029d6:	32 c9       	mov	r9,44
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800029d8:	6e 0b       	ld.w	r11,r7[0x0]
800029da:	b0 09       	st.h	r8[0x0],r9
800029dc:	32 88       	mov	r8,40
800029de:	f6 08 06 4a 	mulu.d	r10,r11,r8
800029e2:	e0 68 03 e7 	mov	r8,999
800029e6:	30 09       	mov	r9,0
800029e8:	10 0a       	add	r10,r8
800029ea:	f6 09 00 4b 	adc	r11,r11,r9
800029ee:	e0 68 03 e8 	mov	r8,1000
800029f2:	30 09       	mov	r9,0
800029f4:	e0 a0 9e cc 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800029f8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800029fc:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a00:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a04:	14 38       	cp.w	r8,r10
80002a06:	e0 88 00 0c 	brls	80002a1e <et024006_Init+0x456>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a0a:	12 38       	cp.w	r8,r9
80002a0c:	e0 88 00 04 	brls	80002a14 <et024006_Init+0x44c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a10:	12 3a       	cp.w	r10,r9
80002a12:	c0 93       	brcs	80002a24 <et024006_Init+0x45c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a14:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a18:	14 38       	cp.w	r8,r10
80002a1a:	fe 9b ff f8 	brhi	80002a0a <et024006_Init+0x442>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a1e:	12 38       	cp.w	r8,r9
80002a20:	fe 98 ff f8 	brls	80002a10 <et024006_Init+0x448>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a24:	fc 1a c0 00 	movh	r10,0xc000
80002a28:	32 68       	mov	r8,38
80002a2a:	b4 08       	st.h	r10[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a2c:	33 c9       	mov	r9,60
80002a2e:	fc 18 c0 40 	movh	r8,0xc040
80002a32:	b0 09       	st.h	r8[0x0],r9
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a34:	37 0b       	mov	r11,112
80002a36:	b4 0b       	st.h	r10[0x0],r11
  return *ET024006_PARAM_ADDR;
80002a38:	90 09       	ld.sh	r9,r8[0x0]
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002a3a:	b4 0b       	st.h	r10[0x0],r11
__attribute__((__always_inline__))
#endif
static __inline__ uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  return *ET024006_PARAM_ADDR;
80002a3c:	5c 59       	castu.b	r9
__attribute__((__always_inline__))
#endif
static __inline__ void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002a3e:	a3 b9       	sbr	r9,0x3
80002a40:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80002a42:	d8 32       	popm	r0-r7,pc
80002a44:	12 38       	cp.w	r8,r9
80002a46:	fe 9b fd f4 	brhi	8000262e <et024006_Init+0x66>
80002a4a:	fe 9f fd f0 	bral	8000262a <et024006_Init+0x62>
80002a4e:	d7 03       	nop
80002a50:	00 00       	add	r0,r0
80002a52:	05 b0       	ld.ub	r0,r2[0x3]

80002a54 <at42qt1060_register_int>:

/** \brief Register a normal pin interrupt for the touch event.
 *
 */
void at42qt1060_register_int(void (*touch_detect_callback)(void))
{
80002a54:	d4 01       	pushm	lr
	at42qt1060.touch_detect_callback = touch_detect_callback;
80002a56:	48 88       	lddpc	r8,80002a74 <at42qt1060_register_int+0x20>

	// register Register at42qt1060_detect_int_handler interrupt on level 0
	//irqflags_t flags = cpu_irq_save();
	// mod by netbugger
	INTC_register_interrupt(touch_detect_callback, AVR32_GPIO_IRQ_0 + AT42QT1060_DETECT_PIN/8, AVR32_INTC_INTLEV_INT0);
80002a58:	30 0a       	mov	r10,0
/** \brief Register a normal pin interrupt for the touch event.
 *
 */
void at42qt1060_register_int(void (*touch_detect_callback)(void))
{
	at42qt1060.touch_detect_callback = touch_detect_callback;
80002a5a:	91 0c       	st.w	r8[0x0],r12

	// register Register at42qt1060_detect_int_handler interrupt on level 0
	//irqflags_t flags = cpu_irq_save();
	// mod by netbugger
	INTC_register_interrupt(touch_detect_callback, AVR32_GPIO_IRQ_0 + AT42QT1060_DETECT_PIN/8, AVR32_INTC_INTLEV_INT0);
80002a5c:	e0 6b 02 48 	mov	r11,584
80002a60:	e0 a0 2e 8e 	rcall	8000877c <INTC_register_interrupt>
	//irq_register_handler(at42qt1060_detect_int_handler, AVR32_GPIO_IRQ_0 + AT42QT1060_DETECT_PIN/8, 0);

	// For now we only react on falling edge
	// Actually this is a level interrupt (low active)
	gpio_enable_pin_interrupt(AT42QT1060_DETECT_PIN, GPIO_FALLING_EDGE);
80002a64:	30 2b       	mov	r11,2
80002a66:	34 7c       	mov	r12,71
80002a68:	e0 a0 2e 4d 	rcall	80008702 <gpio_enable_pin_interrupt>
	gpio_clear_pin_interrupt_flag(AT42QT1060_DETECT_PIN);
80002a6c:	34 7c       	mov	r12,71
80002a6e:	e0 a0 2e 7b 	rcall	80008764 <gpio_clear_pin_interrupt_flag>

	//cpu_irq_restore(flags);

	return;
}
80002a72:	d8 02       	popm	pc
80002a74:	00 00       	add	r0,r0
80002a76:	05 b8       	ld.ub	r8,r2[0x3]

80002a78 <at42qt1060_write_reg>:
80002a78:	eb cd 40 80 	pushm	r7,lr
80002a7c:	20 6d       	sub	sp,24
80002a7e:	31 28       	mov	r8,18
80002a80:	50 08       	stdsp	sp[0x0],r8
80002a82:	30 08       	mov	r8,0

	pack[0] = reg_index;
	pack[1] = data;

	twi_package.chip = AT42QT1060_TWI_ADDRESS;
	twi_package.addr_length = 0;
80002a84:	ba f8       	st.b	sp[0x7],r8
	twi_package.buffer = &pack;
80002a86:	fa c8 ff ec 	sub	r8,sp,-20
void at42qt1060_write_reg(uint8_t reg_index, uint8_t data)
{
	uint8_t pack[2];
	twi_package_t twi_package;

	pack[0] = reg_index;
80002a8a:	fb 6c 00 14 	st.b	sp[20],r12
	pack[1] = data;

	twi_package.chip = AT42QT1060_TWI_ADDRESS;
	twi_package.addr_length = 0;
	twi_package.buffer = &pack;
80002a8e:	50 28       	stdsp	sp[0x8],r8
{
	uint8_t pack[2];
	twi_package_t twi_package;

	pack[0] = reg_index;
	pack[1] = data;
80002a90:	fb 6b 00 15 	st.b	sp[21],r11

	twi_package.chip = AT42QT1060_TWI_ADDRESS;
	twi_package.addr_length = 0;
	twi_package.buffer = &pack;
	twi_package.length = sizeof(pack);
80002a94:	30 28       	mov	r8,2
80002a96:	1a 97       	mov	r7,sp
80002a98:	50 38       	stdsp	sp[0xc],r8
 * \return STATUS_OK   if all bytes were written, error code otherwise
 */
static inline status_code_t twi_master_write (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
	return (twim_write_packet (twim, package));
80002a9a:	1a 9b       	mov	r11,sp
80002a9c:	fe 7c 38 00 	mov	r12,-51200
80002aa0:	e0 a0 03 62 	rcall	80003164 <twim_write_packet>

	while(twi_master_write(AT42QT1060_TWI, &twi_package)!=TWI_SUCCESS);
80002aa4:	cf b1       	brne	80002a9a <at42qt1060_write_reg+0x22>

	return;
}
80002aa6:	2f ad       	sub	sp,-24
80002aa8:	e3 cd 80 80 	ldm	sp++,r7,pc

80002aac <at42qt1060_read_reg>:
80002aac:	eb cd 40 80 	pushm	r7,lr
 *
 * \param reg_index Register address.
 * \returns Register content.
 */
uint8_t at42qt1060_read_reg(uint8_t reg_index)
{
80002ab0:	20 7d       	sub	sp,28
	uint8_t data;
	twi_package_t twi_package;

	twi_package.chip = AT42QT1060_TWI_ADDRESS;
80002ab2:	31 28       	mov	r8,18
80002ab4:	50 18       	stdsp	sp[0x4],r8
	twi_package.addr_length = 0;
80002ab6:	30 08       	mov	r8,0
 *
 * \param reg_index Register address.
 * \returns Register content.
 */
uint8_t at42qt1060_read_reg(uint8_t reg_index)
{
80002ab8:	ba 8c       	st.b	sp[0x0],r12
	uint8_t data;
	twi_package_t twi_package;

	twi_package.chip = AT42QT1060_TWI_ADDRESS;
	twi_package.addr_length = 0;
80002aba:	fb 68 00 0b 	st.b	sp[11],r8
	twi_package.buffer = &reg_index;
80002abe:	50 3d       	stdsp	sp[0xc],sp
	twi_package.length = 1;
80002ac0:	30 18       	mov	r8,1
80002ac2:	fa c7 ff fc 	sub	r7,sp,-4
80002ac6:	50 48       	stdsp	sp[0x10],r8
80002ac8:	0e 9b       	mov	r11,r7
80002aca:	fe 7c 38 00 	mov	r12,-51200
80002ace:	e0 a0 03 4b 	rcall	80003164 <twim_write_packet>
	while(twi_master_write(AT42QT1060_TWI, &twi_package)!=TWI_SUCCESS);
80002ad2:	cf b1       	brne	80002ac8 <at42qt1060_read_reg+0x1c>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002ad4:	49 c8       	lddpc	r8,80002b44 <at42qt1060_read_reg+0x98>
80002ad6:	70 0b       	ld.w	r11,r8[0x0]
80002ad8:	31 48       	mov	r8,20
80002ada:	f6 08 06 4a 	mulu.d	r10,r11,r8
80002ade:	ee 78 42 3f 	mov	r8,999999
80002ae2:	30 09       	mov	r9,0
80002ae4:	10 0a       	add	r10,r8
80002ae6:	f6 09 00 4b 	adc	r11,r11,r9
80002aea:	ee 78 42 40 	mov	r8,1000000
80002aee:	30 09       	mov	r9,0
80002af0:	e0 a0 9e 4e 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002af4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002af8:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002afc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b00:	14 38       	cp.w	r8,r10
80002b02:	e0 88 00 1c 	brls	80002b3a <at42qt1060_read_reg+0x8e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b06:	12 38       	cp.w	r8,r9
80002b08:	fe 98 ff fa 	brls	80002afc <at42qt1060_read_reg+0x50>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b0c:	12 3a       	cp.w	r10,r9
80002b0e:	cf 72       	brcc	80002afc <at42qt1060_read_reg+0x50>
	* since some delay here (code or real delay) adds about 500us
	* between the write and the next read cycle.
	*/
	cpu_delay_us(20, cpu_hz);

	twi_package.chip = AT42QT1060_TWI_ADDRESS;
80002b10:	31 28       	mov	r8,18
80002b12:	50 18       	stdsp	sp[0x4],r8
	twi_package.addr_length = 0;
80002b14:	30 08       	mov	r8,0
80002b16:	fb 68 00 0b 	st.b	sp[11],r8
	twi_package.buffer = &data;
80002b1a:	fa c8 ff e5 	sub	r8,sp,-27
80002b1e:	50 38       	stdsp	sp[0xc],r8
	twi_package.length = 1;
80002b20:	30 18       	mov	r8,1
80002b22:	50 48       	stdsp	sp[0x10],r8
 * \return STATUS_OK   If all bytes were read, error code otherwise
 */
static inline status_code_t twi_master_read (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
	return (twim_read_packet (twim, package));
80002b24:	0e 9b       	mov	r11,r7
80002b26:	fe 7c 38 00 	mov	r12,-51200
80002b2a:	e0 a0 03 8d 	rcall	80003244 <twim_read_packet>
	while(twi_master_read(AT42QT1060_TWI, &twi_package)!=TWI_SUCCESS);
80002b2e:	cf b1       	brne	80002b24 <at42qt1060_read_reg+0x78>

	return data;
}
80002b30:	fb 3c 00 1b 	ld.ub	r12,sp[27]
80002b34:	2f 9d       	sub	sp,-28
80002b36:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b3a:	12 38       	cp.w	r8,r9
80002b3c:	fe 9b ff ea 	brhi	80002b10 <at42qt1060_read_reg+0x64>
80002b40:	ce 6b       	rjmp	80002b0c <at42qt1060_read_reg+0x60>
80002b42:	d7 03       	nop
80002b44:	00 00       	add	r0,r0
80002b46:	05 bc       	ld.ub	r12,r2[0x3]

80002b48 <at42qt1060_get_detect_status>:
80002b48:	eb cd 40 80 	pushm	r7,lr
80002b4c:	30 4c       	mov	r12,4
80002b4e:	ca ff       	rcall	80002aac <at42qt1060_read_reg>
80002b50:	18 97       	mov	r7,r12
80002b52:	30 5c       	mov	r12,5
uint8_t at42qt1060_get_detect_status(void)
{
	uint8_t status;
	/* We need to read both status registers to reset the CHG line */
	status = at42qt1060_read_reg(AT42QT1060_DETECTION_STATUS);
	at42qt1060_read_reg(AT42QT1060_INPUT_PORT_STATUS);
80002b54:	ca cf       	rcall	80002aac <at42qt1060_read_reg>
80002b56:	0e 9c       	mov	r12,r7
80002b58:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b5c <at42qt1060_init>:
	return status;
}
80002b5c:	d4 01       	pushm	lr
80002b5e:	20 1d       	sub	sp,4
80002b60:	49 68       	lddpc	r8,80002bb8 <at42qt1060_init+0x5c>
80002b62:	e0 6b 00 ff 	mov	r11,255
void at42qt1060_init(int32_t fcpu)
{
	volatile uint8_t tmp1, tmp2, tmp3;

	/* Store cpu frequency locally*/
	cpu_hz = fcpu;
80002b66:	91 0c       	st.w	r8[0x0],r12

	/* set I/O pins as outputs in order to not let them float
	 * This will trigger a change on the detect line although not
	 * documented in datasheet
	 */
  	at42qt1060_write_reg(AT42QT1060_IO_MASK, 0xFF);
80002b68:	31 7c       	mov	r12,23
80002b6a:	c8 7f       	rcall	80002a78 <at42qt1060_write_reg>
80002b6c:	33 fb       	mov	r11,63

	/* Set keys that will trigger a change on the detect line
	 */
	at42qt1060_write_reg(AT42QT1060_KEY_MASK, AT42QT1060_KEY_MASK_VALUE);
80002b6e:	31 8c       	mov	r12,24
80002b70:	c8 4f       	rcall	80002a78 <at42qt1060_write_reg>
80002b72:	30 3b       	mov	r11,3
80002b74:	31 ec       	mov	r12,30
  	at42qt1060_write_reg(AT42QT1060_DI, AT42QT1060_DETECT_INTEGRATOR_VALUE);
80002b76:	c8 1f       	rcall	80002a78 <at42qt1060_write_reg>
80002b78:	30 fb       	mov	r11,15
80002b7a:	31 0c       	mov	r12,16
80002b7c:	c7 ef       	rcall	80002a78 <at42qt1060_write_reg>
	// Set detect thresholds
	at42qt1060_write_reg(AT42QT1060_KEY_0_NTHR, AT42QT1060_KEY_0_NTHR_VALUE);
80002b7e:	30 fb       	mov	r11,15
80002b80:	31 1c       	mov	r12,17
80002b82:	c7 bf       	rcall	80002a78 <at42qt1060_write_reg>
80002b84:	30 fb       	mov	r11,15
	at42qt1060_write_reg(AT42QT1060_KEY_1_NTHR, AT42QT1060_KEY_1_NTHR_VALUE);
80002b86:	31 2c       	mov	r12,18
80002b88:	c7 8f       	rcall	80002a78 <at42qt1060_write_reg>
80002b8a:	30 fb       	mov	r11,15
80002b8c:	31 3c       	mov	r12,19
	at42qt1060_write_reg(AT42QT1060_KEY_2_NTHR, AT42QT1060_KEY_2_NTHR_VALUE);
80002b8e:	c7 5f       	rcall	80002a78 <at42qt1060_write_reg>
80002b90:	30 fb       	mov	r11,15
80002b92:	31 4c       	mov	r12,20
80002b94:	c7 2f       	rcall	80002a78 <at42qt1060_write_reg>
	at42qt1060_write_reg(AT42QT1060_KEY_3_NTHR, AT42QT1060_KEY_3_NTHR_VALUE);
80002b96:	30 ab       	mov	r11,10
80002b98:	31 5c       	mov	r12,21
80002b9a:	c6 ff       	rcall	80002a78 <at42qt1060_write_reg>
80002b9c:	31 7c       	mov	r12,23
	at42qt1060_write_reg(AT42QT1060_KEY_4_NTHR, AT42QT1060_KEY_4_NTHR_VALUE);
80002b9e:	c8 7f       	rcall	80002aac <at42qt1060_read_reg>
80002ba0:	ba bc       	st.b	sp[0x3],r12
80002ba2:	31 8c       	mov	r12,24
80002ba4:	c8 4f       	rcall	80002aac <at42qt1060_read_reg>
	at42qt1060_write_reg(AT42QT1060_KEY_5_NTHR, AT42QT1060_KEY_5_NTHR_VALUE);
80002ba6:	ba ac       	st.b	sp[0x2],r12
80002ba8:	31 6c       	mov	r12,22
80002baa:	c8 1f       	rcall	80002aac <at42qt1060_read_reg>
80002bac:	ba 9c       	st.b	sp[0x1],r12
	tmp1 = at42qt1060_read_reg(AT42QT1060_IO_MASK);
80002bae:	cc df       	rcall	80002b48 <at42qt1060_get_detect_status>
80002bb0:	ba bc       	st.b	sp[0x3],r12
80002bb2:	2f fd       	sub	sp,-4
80002bb4:	d8 02       	popm	pc
	tmp2 = at42qt1060_read_reg(AT42QT1060_KEY_MASK);
80002bb6:	d7 03       	nop
80002bb8:	00 00       	add	r0,r0
80002bba:	05 bc       	ld.ub	r12,r2[0x3]

80002bbc <canif_clear_all_mob>:
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
		uint8_t nb_mob)
{
80002bbc:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
80002bc0:	58 0b       	cp.w	r11,0
80002bc2:	c2 00       	breq	80002c02 <canif_clear_all_mob+0x46>

#include "compiler.h"
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
80002bc4:	f6 ce 00 01 	sub	lr,r11,1
80002bc8:	a7 6c       	lsl	r12,0x6
80002bca:	5c 5e       	castu.b	lr
80002bcc:	30 08       	mov	r8,0
80002bce:	2f fe       	sub	lr,-1
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
		CANIF_clr_mob(ch,mob_number)
80002bd0:	2f fc       	sub	r12,-1

#include "compiler.h"
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
80002bd2:	a5 6e       	lsl	lr,0x4
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
		CANIF_clr_mob(ch,mob_number)
80002bd4:	fc 79 1c 00 	mov	r9,-189440
80002bd8:	10 9a       	mov	r10,r8
80002bda:	30 06       	mov	r6,0
80002bdc:	30 07       	mov	r7,0
80002bde:	f2 0c 03 3b 	ld.w	r11,r9[r12<<0x3]
80002be2:	f0 0b 09 0a 	st.w	r8[r11],r10
80002be6:	f2 0c 03 3b 	ld.w	r11,r9[r12<<0x3]
80002bea:	f0 0b 00 0b 	add	r11,r8,r11
80002bee:	97 1a       	st.w	r11[0x4],r10
80002bf0:	f2 0c 03 3b 	ld.w	r11,r9[r12<<0x3]
80002bf4:	f0 0b 00 0b 	add	r11,r8,r11
80002bf8:	f6 e7 00 08 	st.d	r11[8],r6
80002bfc:	2f 08       	sub	r8,-16
void canif_clear_all_mob(uint8_t ch,
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
80002bfe:	1c 38       	cp.w	r8,lr
80002c00:	ce f1       	brne	80002bde <canif_clear_all_mob+0x22>
80002c02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80002c06 <canif_fixed_baudrate>:
	return MOB_NOT_COMPLETED;
}

uint8_t canif_fixed_baudrate(uint8_t ch)
{
  CANIF_conf_bt(ch);
80002c06:	f8 08 15 09 	lsl	r8,r12,0x9
80002c0a:	e2 28 e3 f4 	sub	r8,189428
80002c0e:	70 09       	ld.w	r9,r8[0x0]
80002c10:	e4 19 ff e7 	andh	r9,0xffe7
80002c14:	91 09       	st.w	r8[0x0],r9
80002c16:	70 09       	ld.w	r9,r8[0x0]
80002c18:	b3 b9       	sbr	r9,0x13
80002c1a:	91 09       	st.w	r8[0x0],r9
80002c1c:	70 09       	ld.w	r9,r8[0x0]
80002c1e:	e4 19 ff f8 	andh	r9,0xfff8
80002c22:	91 09       	st.w	r8[0x0],r9
80002c24:	70 09       	ld.w	r9,r8[0x0]
80002c26:	b1 b9       	sbr	r9,0x11
80002c28:	91 09       	st.w	r8[0x0],r9
80002c2a:	70 09       	ld.w	r9,r8[0x0]
80002c2c:	e0 19 ff c0 	andl	r9,0xffc0
80002c30:	91 09       	st.w	r8[0x0],r9
80002c32:	70 09       	ld.w	r9,r8[0x0]
80002c34:	e8 19 00 03 	orl	r9,0x3
80002c38:	91 09       	st.w	r8[0x0],r9
80002c3a:	70 09       	ld.w	r9,r8[0x0]
80002c3c:	e0 19 c7 ff 	andl	r9,0xc7ff
80002c40:	91 09       	st.w	r8[0x0],r9
80002c42:	70 09       	ld.w	r9,r8[0x0]
80002c44:	ab b9       	sbr	r9,0xb
80002c46:	91 09       	st.w	r8[0x0],r9
80002c48:	70 09       	ld.w	r9,r8[0x0]
80002c4a:	e0 19 f8 ff 	andl	r9,0xf8ff
80002c4e:	91 09       	st.w	r8[0x0],r9
  return 1;
}
80002c50:	30 1c       	mov	r12,1
	return MOB_NOT_COMPLETED;
}

uint8_t canif_fixed_baudrate(uint8_t ch)
{
  CANIF_conf_bt(ch);
80002c52:	70 09       	ld.w	r9,r8[0x0]
80002c54:	a9 a9       	sbr	r9,0x8
80002c56:	91 09       	st.w	r8[0x0],r9
  return 1;
}
80002c58:	5e fc       	retal	r12
80002c5a:	d7 03       	nop

80002c5c <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80002c5c:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002c60:	ee 78 42 3f 	mov	r8,999999
80002c64:	f8 08 00 07 	add	r7,r12,r8
80002c68:	e0 68 de 83 	mov	r8,56963
80002c6c:	ea 18 43 1b 	orh	r8,0x431b
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80002c70:	e0 69 4d d3 	mov	r9,19923
80002c74:	ea 19 10 62 	orh	r9,0x1062
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002c78:	ee 08 06 46 	mulu.d	r6,r7,r8
80002c7c:	0e 98       	mov	r8,r7
80002c7e:	b3 88       	lsr	r8,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80002c80:	f0 08 00 25 	add	r5,r8,r8<<0x2
80002c84:	a3 65       	lsl	r5,0x2
80002c86:	ea c5 fc 19 	sub	r5,r5,-999
80002c8a:	ea 09 06 44 	mulu.d	r4,r5,r9
80002c8e:	f0 07 15 04 	lsl	r7,r8,0x4
80002c92:	ea 0c 16 06 	lsr	r12,r5,0x6
80002c96:	ee 08 01 05 	sub	r5,r7,r8
80002c9a:	a1 75       	lsl	r5,0x1
80002c9c:	ea c5 fc 19 	sub	r5,r5,-999
80002ca0:	ea 09 06 44 	mulu.d	r4,r5,r9
80002ca4:	f0 03 10 5a 	mul	r3,r8,90
80002ca8:	ea 06 16 06 	lsr	r6,r5,0x6
80002cac:	e6 c3 fc 19 	sub	r3,r3,-999
80002cb0:	f9 e6 11 0b 	or	r11,r12,r6<<0x10
80002cb4:	e6 09 06 42 	mulu.d	r2,r3,r9
80002cb8:	ee 08 01 05 	sub	r5,r7,r8
80002cbc:	a5 65       	lsl	r5,0x4
80002cbe:	ea c5 fc 19 	sub	r5,r5,-999
80002cc2:	ea 09 06 44 	mulu.d	r4,r5,r9
80002cc6:	fe 6a 28 00 	mov	r10,-120832
80002cca:	ea 0e 16 06 	lsr	lr,r5,0x6
80002cce:	95 0b       	st.w	r10[0x0],r11
80002cd0:	ee 08 01 05 	sub	r5,r7,r8
80002cd4:	e6 07 16 06 	lsr	r7,r3,0x6
80002cd8:	a3 65       	lsl	r5,0x2
80002cda:	e0 63 00 d2 	mov	r3,210
80002cde:	ea c5 fc 19 	sub	r5,r5,-999
80002ce2:	f0 03 02 43 	mul	r3,r8,r3
80002ce6:	ea 09 06 44 	mulu.d	r4,r5,r9
80002cea:	e6 c3 fc 19 	sub	r3,r3,-999
80002cee:	a7 85       	lsr	r5,0x6
80002cf0:	e6 09 06 42 	mulu.d	r2,r3,r9
80002cf4:	ea 0c 00 0c 	add	r12,r5,r12
80002cf8:	e6 0b 16 06 	lsr	r11,r3,0x6
80002cfc:	0e 3c       	cp.w	r12,r7
80002cfe:	f8 07 17 20 	movhs	r7,r12
80002d02:	eb eb 11 05 	or	r5,r5,r11<<0x10
80002d06:	0c 0b       	add	r11,r6
80002d08:	eb e7 10 85 	or	r5,r5,r7<<0x8
80002d0c:	1c 3b       	cp.w	r11,lr
80002d0e:	f6 0e 17 20 	movhs	lr,r11
80002d12:	eb ee 11 85 	or	r5,r5,lr<<0x18
80002d16:	95 15       	st.w	r10[0x4],r5
80002d18:	f0 05 10 64 	mul	r5,r8,100
80002d1c:	ea c5 fc 19 	sub	r5,r5,-999
80002d20:	ea 09 06 44 	mulu.d	r4,r5,r9
80002d24:	ea 06 16 06 	lsr	r6,r5,0x6
80002d28:	0c 3c       	cp.w	r12,r6
80002d2a:	ec 0c 17 30 	movlo	r12,r6
80002d2e:	0e 3c       	cp.w	r12,r7
80002d30:	ee 0c 17 30 	movlo	r12,r7
80002d34:	e0 67 01 0e 	mov	r7,270
80002d38:	af 38       	mul	r8,r7
80002d3a:	f0 c8 fc 19 	sub	r8,r8,-999
80002d3e:	f0 09 06 48 	mulu.d	r8,r8,r9
80002d42:	e0 68 10 03 	mov	r8,4099
80002d46:	a7 89       	lsr	r9,0x6
80002d48:	12 3b       	cp.w	r11,r9
80002d4a:	f2 0b 17 30 	movlo	r11,r9
80002d4e:	1c 3b       	cp.w	r11,lr
80002d50:	fc 0b 17 30 	movlo	r11,lr
80002d54:	f9 eb 11 0b 	or	r11,r12,r11<<0x10
80002d58:	95 2b       	st.w	r10[0x8],r11
80002d5a:	95 38       	st.w	r10[0xc],r8
80002d5c:	30 19       	mov	r9,1
80002d5e:	48 58       	lddpc	r8,80002d70 <smc_init+0x114>
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

	gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80002d60:	31 4b       	mov	r11,20
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80002d62:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

	gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80002d64:	48 4c       	lddpc	r12,80002d74 <smc_init+0x118>
80002d66:	e0 a0 2c 7d 	rcall	80008660 <gpio_enable_module>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80002d6a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002d6e:	d7 03       	nop
80002d70:	00 00       	add	r0,r0
80002d72:	05 c0       	ld.ub	r0,r2[0x4]
80002d74:	80 01       	ld.sh	r1,r0[0x0]
80002d76:	d7 18       	*unknown*

80002d78 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
80002d78:	d4 01       	pushm	lr
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80002d7a:	76 09       	ld.w	r9,r11[0x0]
80002d7c:	58 29       	cp.w	r9,2
80002d7e:	e0 8b 00 4b 	brhi	80002e14 <tc_init_waveform+0x9c>
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80002d82:	76 18       	ld.w	r8,r11[0x4]
80002d84:	10 9e       	mov	lr,r8
80002d86:	e6 1e c0 00 	andh	lr,0xc000,COH
80002d8a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80002d8e:	af ba       	sbr	r10,0xf
80002d90:	1c 4a       	or	r10,lr
80002d92:	10 9e       	mov	lr,r8
80002d94:	e6 1e 30 00 	andh	lr,0x3000,COH
80002d98:	1c 4a       	or	r10,lr
80002d9a:	10 9e       	mov	lr,r8
80002d9c:	e6 1e 0c 00 	andh	lr,0xc00,COH
80002da0:	1c 4a       	or	r10,lr
80002da2:	10 9e       	mov	lr,r8
80002da4:	e6 1e 03 00 	andh	lr,0x300,COH
80002da8:	1c 4a       	or	r10,lr
80002daa:	10 9e       	mov	lr,r8
80002dac:	e6 1e 00 c0 	andh	lr,0xc0,COH
80002db0:	1c 4a       	or	r10,lr
80002db2:	10 9e       	mov	lr,r8
80002db4:	e6 1e 00 30 	andh	lr,0x30,COH
80002db8:	1c 4a       	or	r10,lr
80002dba:	10 9e       	mov	lr,r8
80002dbc:	e6 1e 00 0c 	andh	lr,0xc,COH
80002dc0:	1c 4a       	or	r10,lr
80002dc2:	10 9e       	mov	lr,r8
80002dc4:	e6 1e 00 03 	andh	lr,0x3,COH
80002dc8:	1c 4a       	or	r10,lr
80002dca:	10 9e       	mov	lr,r8
80002dcc:	e2 1e 60 00 	andl	lr,0x6000,COH
80002dd0:	1c 4a       	or	r10,lr
80002dd2:	10 9e       	mov	lr,r8
80002dd4:	e2 1e 10 00 	andl	lr,0x1000,COH
80002dd8:	1c 4a       	or	r10,lr
80002dda:	10 9e       	mov	lr,r8
80002ddc:	e2 1e 0c 00 	andl	lr,0xc00,COH
80002de0:	1c 4a       	or	r10,lr
80002de2:	10 9e       	mov	lr,r8
80002de4:	e2 1e 03 00 	andl	lr,0x300,COH
80002de8:	1c 4a       	or	r10,lr
80002dea:	10 9e       	mov	lr,r8
80002dec:	e2 1e 00 80 	andl	lr,0x80,COH
80002df0:	10 9b       	mov	r11,r8
80002df2:	1c 4a       	or	r10,lr
80002df4:	e2 1b 00 08 	andl	r11,0x8,COH
80002df8:	10 9e       	mov	lr,r8
80002dfa:	a5 69       	lsl	r9,0x4
80002dfc:	e2 1e 00 40 	andl	lr,0x40,COH
80002e00:	2f f9       	sub	r9,-1
80002e02:	1c 4a       	or	r10,lr
80002e04:	e2 18 00 30 	andl	r8,0x30,COH
80002e08:	f5 e8 10 08 	or	r8,r10,r8
80002e0c:	16 48       	or	r8,r11
80002e0e:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80002e12:	d8 0a       	popm	pc,r12=0


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80002e14:	dc 0a       	popm	pc,r12=-1

80002e16 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e16:	58 2b       	cp.w	r11,2
80002e18:	e0 8b 00 07 	brhi	80002e26 <tc_start+0x10>
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80002e1c:	a7 6b       	lsl	r11,0x6
80002e1e:	16 0c       	add	r12,r11
80002e20:	30 58       	mov	r8,5
80002e22:	99 08       	st.w	r12[0x0],r8
80002e24:	5e fd       	retal	0


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e26:	5e fe       	retal	-1

80002e28 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e28:	58 2b       	cp.w	r11,2
80002e2a:	e0 8b 00 07 	brhi	80002e38 <tc_read_sr+0x10>
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80002e2e:	a7 6b       	lsl	r11,0x6
80002e30:	2e 0b       	sub	r11,-32
80002e32:	16 0c       	add	r12,r11
80002e34:	78 0c       	ld.w	r12,r12[0x0]
}
80002e36:	5e fc       	retal	r12


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e38:	5e fe       	retal	-1

80002e3a <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e3a:	58 2b       	cp.w	r11,2
80002e3c:	e0 8b 00 1a 	brhi	80002e70 <tc_write_rc+0x36>
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80002e40:	f6 08 15 04 	lsl	r8,r11,0x4
80002e44:	2f f8       	sub	r8,-1
80002e46:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80002e4a:	ed b8 00 0f 	bld	r8,0xf
80002e4e:	c0 e1       	brne	80002e6a <tc_write_rc+0x30>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80002e50:	a7 6b       	lsl	r11,0x6
80002e52:	f8 0b 00 0b 	add	r11,r12,r11
80002e56:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
80002e5a:	2e 4b       	sub	r11,-28
80002e5c:	76 08       	ld.w	r8,r11[0x0]
80002e5e:	e0 18 00 00 	andl	r8,0x0
80002e62:	f9 e8 10 08 	or	r8,r12,r8
80002e66:	97 08       	st.w	r11[0x0],r8

  return value;
}
80002e68:	5e fc       	retal	r12
80002e6a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
80002e6e:	5e fc       	retal	r12


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e70:	5e fe       	retal	-1

80002e72 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80002e72:	eb cd 40 80 	pushm	r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002e76:	e1 be 00 00 	mfsr	lr,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e7a:	58 2b       	cp.w	r11,2
80002e7c:	e0 8b 00 5f 	brhi	80002f3a <tc_configure_interrupts+0xc8>
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80002e80:	74 08       	ld.w	r8,r10[0x0]
80002e82:	10 99       	mov	r9,r8
80002e84:	e2 19 00 02 	andl	r9,0x2,COH
80002e88:	e2 18 00 fd 	andl	r8,0xfd,COH
80002e8c:	12 48       	or	r8,r9
80002e8e:	f6 09 15 06 	lsl	r9,r11,0x6
80002e92:	f8 09 00 07 	add	r7,r12,r9
80002e96:	2d c7       	sub	r7,-36
80002e98:	8f 08       	st.w	r7[0x0],r8
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80002e9a:	ee 1e 00 01 	eorh	lr,0x1
80002e9e:	fd de c2 01 	bfextu	lr,lr,0x10,0x1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002ea2:	c4 e1       	brne	80002f3e <tc_configure_interrupts+0xcc>
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002ea4:	a7 6b       	lsl	r11,0x6
80002ea6:	2e 0b       	sub	r11,-32
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002ea8:	74 08       	ld.w	r8,r10[0x0]
80002eaa:	f8 09 00 0a 	add	r10,r12,r9
80002eae:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002eb2:	16 0c       	add	r12,r11
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002eb4:	e0 6b 00 80 	mov	r11,128
80002eb8:	58 07       	cp.w	r7,0
80002eba:	f9 bb 01 00 	movne	r11,0
80002ebe:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80002ec2:	ec 19 00 01 	eorl	r9,0x1
80002ec6:	f7 e9 10 09 	or	r9,r11,r9
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80002eca:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80002ece:	f9 bb 00 40 	moveq	r11,64
80002ed2:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002ed6:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80002ed8:	f7 d8 c0 a1 	bfextu	r11,r8,0x5,0x1
80002edc:	f9 bb 00 20 	moveq	r11,32
80002ee0:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002ee4:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80002ee6:	f7 d8 c0 81 	bfextu	r11,r8,0x4,0x1
80002eea:	f9 bb 00 10 	moveq	r11,16
80002eee:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002ef2:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80002ef4:	f7 d8 c0 61 	bfextu	r11,r8,0x3,0x1
80002ef8:	f9 bb 00 08 	moveq	r11,8
80002efc:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002f00:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80002f02:	f7 d8 c0 41 	bfextu	r11,r8,0x2,0x1
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002f06:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80002f0a:	58 0b       	cp.w	r11,0
80002f0c:	f9 bb 00 04 	moveq	r11,4
80002f10:	f9 bb 01 00 	movne	r11,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002f14:	58 08       	cp.w	r8,0
80002f16:	f9 b8 00 02 	moveq	r8,2
80002f1a:	f9 b8 01 00 	movne	r8,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002f1e:	16 49       	or	r9,r11
80002f20:	f3 e8 10 08 	or	r8,r9,r8
80002f24:	2d 8a       	sub	r10,-40
80002f26:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002f28:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002f2a:	58 0e       	cp.w	lr,0
80002f2c:	c0 41       	brne	80002f34 <tc_configure_interrupts+0xc2>
80002f2e:	1c 9c       	mov	r12,lr
80002f30:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f34:	d5 03       	csrf	0x10
80002f36:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
  bool global_interrupt_enabled = Is_global_interrupt_enabled();

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002f3a:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002f3e:	d3 03       	ssrf	0x10
80002f40:	cb 2b       	rjmp	80002ea4 <tc_configure_interrupts+0x32>
80002f42:	d7 03       	nop

80002f44 <twim_master_interrupt_handler>:
 * \brief TWI interrupt handler.
 */
ISR(twim_master_interrupt_handler,CONF_TWIM_IRQ_GROUP,CONF_TWIM_IRQ_LEVEL)
{
	// get masked status register value
	uint32_t status = twim_inst->sr & twim_it_mask;
80002f44:	4a b8       	lddpc	r8,80002ff0 <twim_master_interrupt_handler+0xac>
80002f46:	4a ca       	lddpc	r10,80002ff4 <twim_master_interrupt_handler+0xb0>
80002f48:	70 08       	ld.w	r8,r8[0x0]
80002f4a:	70 79       	ld.w	r9,r8[0x1c]
80002f4c:	74 0a       	ld.w	r10,r10[0x0]
80002f4e:	f5 e9 00 09 	and	r9,r10,r9
	// this is a NACK
	if (status & AVR32_TWIM_SR_STD_MASK) {
80002f52:	12 9a       	mov	r10,r9
80002f54:	e2 1a 07 00 	andl	r10,0x700,COH
80002f58:	c1 40       	breq	80002f80 <twim_master_interrupt_handler+0x3c>
		//if we get a nak, clear the valid bit in cmdr,
		//otherwise the command will be resent.
		transfer_status =(status & AVR32_TWIM_IER_NAK_MASK) ?
80002f5a:	4a 8a       	lddpc	r10,80002ff8 <twim_master_interrupt_handler+0xb4>
80002f5c:	e2 19 03 00 	andl	r9,0x300,COH
80002f60:	f9 b9 01 fc 	movne	r9,-4
80002f64:	f9 b9 00 fe 	moveq	r9,-2
80002f68:	95 09       	st.w	r10[0x0],r9
							TWI_RECEIVE_NACK : TWI_ARBITRATION_LOST;
		twim_inst->CMDR.valid = 0;
80002f6a:	30 09       	mov	r9,0
80002f6c:	70 3a       	ld.w	r10,r8[0xc]
80002f6e:	f5 d9 d1 e1 	bfins	r10,r9,0xf,0x1
80002f72:	91 3a       	st.w	r8[0xc],r10
		twim_inst->scr = ~0UL;
80002f74:	3f fa       	mov	r10,-1
80002f76:	91 ba       	st.w	r8[0x2c],r10
		twim_inst->idr = ~0UL;
80002f78:	91 9a       	st.w	r8[0x24],r10
		twim_next = false;
80002f7a:	4a 18       	lddpc	r8,80002ffc <twim_master_interrupt_handler+0xb8>
80002f7c:	b0 89       	st.b	r8[0x0],r9
80002f7e:	d6 03       	rete
	}
	// this is a RXRDY
	else if (status & AVR32_TWIM_SR_RXRDY_MASK) {
80002f80:	ed b9 00 00 	bld	r9,0x0
80002f84:	c1 21       	brne	80002fa8 <twim_master_interrupt_handler+0x64>
		// get data from Receive Holding Register
		*twim_rx_data = twim_inst->rhr;
80002f86:	70 5b       	ld.w	r11,r8[0x14]
80002f88:	49 ea       	lddpc	r10,80003000 <twim_master_interrupt_handler+0xbc>
80002f8a:	74 09       	ld.w	r9,r10[0x0]
80002f8c:	12 cb       	st.b	r9++,r11
		// decrease received bytes number
		twim_rx_nb_bytes--;
		twim_rx_data++;
80002f8e:	95 09       	st.w	r10[0x0],r9
	// this is a RXRDY
	else if (status & AVR32_TWIM_SR_RXRDY_MASK) {
		// get data from Receive Holding Register
		*twim_rx_data = twim_inst->rhr;
		// decrease received bytes number
		twim_rx_nb_bytes--;
80002f90:	49 d9       	lddpc	r9,80003004 <twim_master_interrupt_handler+0xc0>
80002f92:	72 0a       	ld.w	r10,r9[0x0]
80002f94:	20 1a       	sub	r10,1
80002f96:	93 0a       	st.w	r9[0x0],r10
		twim_rx_data++;
		
		// receive complete
		if (twim_rx_nb_bytes == 0) {
80002f98:	72 09       	ld.w	r9,r9[0x0]
80002f9a:	58 09       	cp.w	r9,0
80002f9c:	c2 31       	brne	80002fe2 <twim_master_interrupt_handler+0x9e>
			// finish the receive operation
			twim_inst->idr = AVR32_TWIM_IDR_RXRDY_MASK;
80002f9e:	30 1a       	mov	r10,1
80002fa0:	91 9a       	st.w	r8[0x24],r10
			// set busy to false
			twim_next = false;
80002fa2:	49 78       	lddpc	r8,80002ffc <twim_master_interrupt_handler+0xb8>
80002fa4:	b0 89       	st.b	r8[0x0],r9
80002fa6:	d6 03       	rete
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWIM_SR_TXRDY_MASK) {
80002fa8:	ed b9 00 01 	bld	r9,0x1
80002fac:	c1 b1       	brne	80002fe2 <twim_master_interrupt_handler+0x9e>
		// no more bytes to transmit
		if (twim_tx_nb_bytes == 0) {
80002fae:	49 79       	lddpc	r9,80003008 <twim_master_interrupt_handler+0xc4>
80002fb0:	72 0a       	ld.w	r10,r9[0x0]
80002fb2:	58 0a       	cp.w	r10,0
80002fb4:	c1 80       	breq	80002fe4 <twim_master_interrupt_handler+0xa0>
			twim_inst->idr = AVR32_TWIM_IDR_TXRDY_MASK;
			// set busy to false
			twim_next = false;
		} else {
			// put the byte in the Transmit Holding Register
			twim_inst->thr = *twim_tx_data++;
80002fb6:	49 6b       	lddpc	r11,8000300c <twim_master_interrupt_handler+0xc8>
80002fb8:	76 0a       	ld.w	r10,r11[0x0]
80002fba:	15 3c       	ld.ub	r12,r10++
80002fbc:	91 6c       	st.w	r8[0x18],r12
80002fbe:	97 0a       	st.w	r11[0x0],r10
			// decrease transmitted bytes number
			twim_tx_nb_bytes--;
80002fc0:	72 08       	ld.w	r8,r9[0x0]
80002fc2:	20 18       	sub	r8,1
80002fc4:	93 08       	st.w	r9[0x0],r8
			if (twim_tx_nb_bytes == 0) {
80002fc6:	72 08       	ld.w	r8,r9[0x0]
80002fc8:	58 08       	cp.w	r8,0
80002fca:	c0 c1       	brne	80002fe2 <twim_master_interrupt_handler+0x9e>
				// Check for next transfer
				if(twim_next) {
80002fcc:	48 ca       	lddpc	r10,80002ffc <twim_master_interrupt_handler+0xb8>
80002fce:	15 8c       	ld.ub	r12,r10[0x0]
80002fd0:	58 0c       	cp.w	r12,0
80002fd2:	c0 80       	breq	80002fe2 <twim_master_interrupt_handler+0x9e>
					twim_next = false;
80002fd4:	b4 88       	st.b	r10[0x0],r8
					twim_tx_nb_bytes = twim_package->length;
80002fd6:	48 f8       	lddpc	r8,80003010 <twim_master_interrupt_handler+0xcc>
80002fd8:	70 08       	ld.w	r8,r8[0x0]
80002fda:	70 3a       	ld.w	r10,r8[0xc]
80002fdc:	93 0a       	st.w	r9[0x0],r10
					twim_tx_data = twim_package->buffer;
80002fde:	70 28       	ld.w	r8,r8[0x8]
80002fe0:	97 08       	st.w	r11[0x0],r8
80002fe2:	d6 03       	rete
	// this is a TXRDY
	else if (status & AVR32_TWIM_SR_TXRDY_MASK) {
		// no more bytes to transmit
		if (twim_tx_nb_bytes == 0) {
			// finish the receive operation
			twim_inst->idr = AVR32_TWIM_IDR_TXRDY_MASK;
80002fe4:	30 29       	mov	r9,2
80002fe6:	91 99       	st.w	r8[0x24],r9
			// set busy to false
			twim_next = false;
80002fe8:	48 58       	lddpc	r8,80002ffc <twim_master_interrupt_handler+0xb8>
80002fea:	b0 8a       	st.b	r8[0x0],r10
80002fec:	d6 03       	rete
80002fee:	d7 03       	nop
80002ff0:	00 00       	add	r0,r0
80002ff2:	05 c8       	ld.ub	r8,r2[0x4]
80002ff4:	00 00       	add	r0,r0
80002ff6:	05 dc       	ld.ub	r12,r2[0x5]
80002ff8:	00 00       	add	r0,r0
80002ffa:	05 d4       	ld.ub	r4,r2[0x5]
80002ffc:	00 00       	add	r0,r0
80002ffe:	05 e0       	ld.ub	r0,r2[0x6]
80003000:	00 00       	add	r0,r0
80003002:	05 cc       	ld.ub	r12,r2[0x4]
80003004:	00 00       	add	r0,r0
80003006:	05 d0       	ld.ub	r0,r2[0x5]
80003008:	00 00       	add	r0,r0
8000300a:	05 e8       	ld.ub	r8,r2[0x6]
8000300c:	00 00       	add	r0,r0
8000300e:	05 d8       	ld.ub	r8,r2[0x5]
80003010:	00 00       	add	r0,r0
80003012:	05 e4       	ld.ub	r4,r2[0x6]

80003014 <twim_set_speed>:
 * \retval STATUS_OK        Transaction is successful
 * \retval ERR_INVALID_ARG  Invalid arg resulting in wrong CWGR Exponential
 */
status_code_t twim_set_speed (volatile avr32_twim_t *twim, uint32_t speed,
		uint32_t pba_hz)
{
80003014:	eb cd 40 80 	pushm	r7,lr
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
80003018:	f4 0b 0d 0a 	divu	r10,r10,r11
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
8000301c:	30 09       	mov	r9,0
status_code_t twim_set_speed (volatile avr32_twim_t *twim, uint32_t speed,
		uint32_t pba_hz)
{
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
8000301e:	f4 08 16 01 	lsr	r8,r10,0x1
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
80003022:	e0 48 00 ff 	cp.w	r8,255
80003026:	f9 ba 0b 01 	movhi	r10,1
8000302a:	f9 ba 08 00 	movls	r10,0
8000302e:	f2 0a 18 00 	cp.b	r10,r9
80003032:	c2 d0       	breq	8000308c <twim_set_speed+0x78>
80003034:	30 09       	mov	r9,0
80003036:	30 77       	mov	r7,7
80003038:	12 9e       	mov	lr,r9
		// increase clock divider
		cwgr_exp++;
8000303a:	2f f9       	sub	r9,-1
		// divide f_prescaled value
		f_prescaled /= 2;
8000303c:	a1 98       	lsr	r8,0x1
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
		// increase clock divider
		cwgr_exp++;
8000303e:	5c 59       	castu.b	r9
{
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
80003040:	e0 48 00 ff 	cp.w	r8,255
80003044:	f9 ba 0b 01 	movhi	r10,1
80003048:	f9 ba 08 00 	movls	r10,0
8000304c:	f2 07 18 00 	cp.b	r7,r9
80003050:	f9 bb 02 01 	movhs	r11,1
80003054:	f9 bb 03 00 	movlo	r11,0
80003058:	f7 ea 00 0a 	and	r10,r11,r10
8000305c:	fc 0a 18 00 	cp.b	r10,lr
80003060:	ce d1       	brne	8000303a <twim_set_speed+0x26>
		// increase clock divider
		cwgr_exp++;
		// divide f_prescaled value
		f_prescaled /= 2;
	}
	if (cwgr_exp > 0x7) {
80003062:	30 7a       	mov	r10,7
80003064:	f4 09 18 00 	cp.b	r9,r10
80003068:	e0 8b 00 0f 	brhi	80003086 <twim_set_speed+0x72>
8000306c:	bd 69       	lsl	r9,0x1c
		return ERR_INVALID_ARG;
	}
	// set clock waveform generator register
	twim->cwgr = ((f_prescaled/2) << AVR32_TWIM_CWGR_LOW_OFFSET)
			| ((f_prescaled - f_prescaled/2) << AVR32_TWIM_CWGR_HIGH_OFFSET)
8000306e:	f0 0a 16 01 	lsr	r10,r8,0x1
	}
	if (cwgr_exp > 0x7) {
		return ERR_INVALID_ARG;
	}
	// set clock waveform generator register
	twim->cwgr = ((f_prescaled/2) << AVR32_TWIM_CWGR_LOW_OFFSET)
80003072:	f0 0a 01 0b 	sub	r11,r8,r10
80003076:	f5 e8 11 08 	or	r8,r10,r8<<0x10
8000307a:	12 48       	or	r8,r9
8000307c:	f1 eb 10 88 	or	r8,r8,r11<<0x8
80003080:	99 18       	st.w	r12[0x4],r8
80003082:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		// increase clock divider
		cwgr_exp++;
		// divide f_prescaled value
		f_prescaled /= 2;
	}
	if (cwgr_exp > 0x7) {
80003086:	3f 8c       	mov	r12,-8
80003088:	e3 cd 80 80 	ldm	sp++,r7,pc
{
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
8000308c:	30 09       	mov	r9,0
8000308e:	cf 0b       	rjmp	8000306e <twim_set_speed+0x5a>

80003090 <twim_write>:
 * \retval STATUS_OK      If all bytes were send successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_write (volatile avr32_twim_t *twim, uint8_t const *buffer,
		uint32_t nbytes, uint32_t saddr, bool tenbit)
{
80003090:	eb cd 40 c0 	pushm	r6-r7,lr
	// Reset the TWIM module to clear the THR register
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80003094:	30 1e       	mov	lr,1
80003096:	99 0e       	st.w	r12[0x0],lr
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80003098:	e0 6e 00 80 	mov	lr,128
8000309c:	99 0e       	st.w	r12[0x0],lr
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
8000309e:	30 2e       	mov	lr,2
800030a0:	99 0e       	st.w	r12[0x0],lr
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
800030a2:	4a 5e       	lddpc	lr,80003134 <twim_write+0xa4>
800030a4:	9d 0c       	st.w	lr[0x0],r12
 *
 * \param twim         Base address of the TWIM (i.e. &AVR32_TWI).
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
800030a6:	e1 b7 00 00 	mfsr	r7,0x0
	if (global_interrupt_enabled) {
800030aa:	ed b7 00 10 	bld	r7,0x10
800030ae:	c3 a1       	brne	80003122 <twim_write+0x92>
		cpu_irq_disable ();
	}
	// Clear the interrupt flags
	twim->idr = ~0UL;
800030b0:	3f f7       	mov	r7,-1
800030b2:	99 97       	st.w	r12[0x24],r7
	// Clear the status flags
	twim->scr = ~0UL;
800030b4:	99 b7       	st.w	r12[0x2c],r7
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
	// get a pointer to applicative data
	twim_tx_data = buffer;
	// set the number of bytes to transmit
	twim_tx_nb_bytes = nbytes;
800030b6:	4a 17       	lddpc	r7,80003138 <twim_write+0xa8>
800030b8:	8f 0a       	st.w	r7[0x0],r10
	// Set next transfer to false
	twim_next = false;
800030ba:	4a 17       	lddpc	r7,8000313c <twim_write+0xac>
800030bc:	30 06       	mov	r6,0
800030be:	ae 86       	st.b	r7[0x0],r6
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
	// get a pointer to applicative data
	twim_tx_data = buffer;
800030c0:	4a 07       	lddpc	r7,80003140 <twim_write+0xb0>
	// Set next transfer to false
	twim_next = false;
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
800030c2:	b1 6a       	lsl	r10,0x10
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
	// get a pointer to applicative data
	twim_tx_data = buffer;
800030c4:	8f 0b       	st.w	r7[0x0],r11
	// Set next transfer to false
	twim_next = false;
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
800030c6:	e8 1a e0 00 	orl	r10,0xe000
	// set the number of bytes to transmit
	twim_tx_nb_bytes = nbytes;
	// Set next transfer to false
	twim_next = false;
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
800030ca:	49 fb       	lddpc	r11,80003144 <twim_write+0xb4>
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
800030cc:	f5 e9 10 1a 	or	r10,r10,r9<<0x1
	// set the number of bytes to transmit
	twim_tx_nb_bytes = nbytes;
	// Set next transfer to false
	twim_next = false;
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
800030d0:	30 07       	mov	r7,0
800030d2:	97 07       	st.w	r11[0x0],r7
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
800030d4:	f5 e8 10 b8 	or	r8,r10,r8<<0xb
800030d8:	7c 0a       	ld.w	r10,lr[0x0]
800030da:	95 38       	st.w	r10[0xc],r8
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| ((tenbit ? 1 : 0) << AVR32_TWIM_CMDR_TENBIT_OFFSET)
			| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
	// mask NACK and TXRDY interrupts
	twim_it_mask = AVR32_TWIM_IER_NAK_MASK | AVR32_TWIM_IER_TXRDY_MASK;
800030dc:	e0 69 03 02 	mov	r9,770
800030e0:	49 a8       	lddpc	r8,80003148 <twim_write+0xb8>
800030e2:	91 09       	st.w	r8[0x0],r9
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
800030e4:	70 08       	ld.w	r8,r8[0x0]
800030e6:	95 88       	st.w	r10[0x20],r8
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
800030e8:	30 18       	mov	r8,1
800030ea:	95 08       	st.w	r10[0x0],r8
	// Enable all interrupts
	cpu_irq_enable ();
800030ec:	d5 03       	csrf	0x10
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800030ee:	76 08       	ld.w	r8,r11[0x0]
800030f0:	58 08       	cp.w	r8,0
800030f2:	c1 11       	brne	80003114 <twim_write+0x84>
/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
	uint32_t status = twim_inst->sr;
800030f4:	49 08       	lddpc	r8,80003134 <twim_write+0xa4>
800030f6:	70 08       	ld.w	r8,r8[0x0]
800030f8:	70 78       	ld.w	r8,r8[0x1c]
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
800030fa:	ed b8 00 04 	bld	r8,0x4
800030fe:	c0 b0       	breq	80003114 <twim_write+0x84>
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
80003100:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
80003104:	76 08       	ld.w	r8,r11[0x0]
80003106:	58 08       	cp.w	r8,0
80003108:	c0 61       	brne	80003114 <twim_write+0x84>
/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
	uint32_t status = twim_inst->sr;
8000310a:	7c 08       	ld.w	r8,lr[0x0]
8000310c:	70 78       	ld.w	r8,r8[0x1c]
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
8000310e:	ed b8 00 04 	bld	r8,0x4
80003112:	cf 71       	brne	80003100 <twim_write+0x70>
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80003114:	30 28       	mov	r8,2
80003116:	99 08       	st.w	r12[0x0],r8
#endif
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80003118:	76 08       	ld.w	r8,r11[0x0]
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
8000311a:	5b c8       	cp.w	r8,-4
8000311c:	c0 51       	brne	80003126 <twim_write+0x96>
8000311e:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
	if (global_interrupt_enabled) {
		cpu_irq_disable ();
80003122:	d3 03       	ssrf	0x10
80003124:	cc 6b       	rjmp	800030b0 <twim_write+0x20>
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80003126:	48 88       	lddpc	r8,80003144 <twim_write+0xb4>
80003128:	70 08       	ld.w	r8,r8[0x0]
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
8000312a:	5b e8       	cp.w	r8,-2
8000312c:	cf 90       	breq	8000311e <twim_write+0x8e>
8000312e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003132:	d7 03       	nop
80003134:	00 00       	add	r0,r0
80003136:	05 c8       	ld.ub	r8,r2[0x4]
80003138:	00 00       	add	r0,r0
8000313a:	05 e8       	ld.ub	r8,r2[0x6]
8000313c:	00 00       	add	r0,r0
8000313e:	05 e0       	ld.ub	r0,r2[0x6]
80003140:	00 00       	add	r0,r0
80003142:	05 d8       	ld.ub	r8,r2[0x5]
80003144:	00 00       	add	r0,r0
80003146:	05 d4       	ld.ub	r4,r2[0x5]
80003148:	00 00       	add	r0,r0
8000314a:	05 dc       	ld.ub	r12,r2[0x5]

8000314c <twim_probe>:
 * \param chip_addr       Address of the chip which is searched for
 * \retval STATUS_OK      Slave Found
 * \retval ERR_IO_ERROR   ANAK received or Bus Arbitration lost
 */
status_code_t twim_probe (volatile avr32_twim_t *twim, uint32_t chip_addr)
{
8000314c:	d4 01       	pushm	lr
8000314e:	20 1d       	sub	sp,4
	uint8_t data[1] = { 0 };
80003150:	30 08       	mov	r8,0
	return (twim_write (twim,data,0,chip_addr,0));
80003152:	16 99       	mov	r9,r11
 * \retval STATUS_OK      Slave Found
 * \retval ERR_IO_ERROR   ANAK received or Bus Arbitration lost
 */
status_code_t twim_probe (volatile avr32_twim_t *twim, uint32_t chip_addr)
{
	uint8_t data[1] = { 0 };
80003154:	ba 88       	st.b	sp[0x0],r8
	return (twim_write (twim,data,0,chip_addr,0));
80003156:	1a 9b       	mov	r11,sp
80003158:	30 08       	mov	r8,0
8000315a:	10 9a       	mov	r10,r8
8000315c:	c9 af       	rcall	80003090 <twim_write>
8000315e:	2f fd       	sub	sp,-4
}
80003160:	d8 02       	popm	pc
80003162:	d7 03       	nop

80003164 <twim_write_packet>:
80003164:	eb cd 40 e0 	pushm	r5-r7,lr
 */
status_code_t twim_write_packet (volatile avr32_twim_t *twim,
		const twim_package_t *package)
{
	// Reset the TWIM module to clear the THR register
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80003168:	30 18       	mov	r8,1
8000316a:	99 08       	st.w	r12[0x0],r8
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
8000316c:	e0 68 00 80 	mov	r8,128
80003170:	99 08       	st.w	r12[0x0],r8
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80003172:	30 28       	mov	r8,2
80003174:	99 08       	st.w	r12[0x0],r8
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
80003176:	4a d9       	lddpc	r9,80003228 <twim_write_packet+0xc4>
80003178:	93 0c       	st.w	r9[0x0],r12
 *
 * \param twim         Base address of the TWIM (i.e. &AVR32_TWI).
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
8000317a:	e1 b8 00 00 	mfsr	r8,0x0
	if (global_interrupt_enabled) {
8000317e:	ed b8 00 10 	bld	r8,0x10
80003182:	c4 b1       	brne	80003218 <twim_write_packet+0xb4>
		cpu_irq_disable ();
	}
	// Clear the interrupt flags
	twim->idr = ~0UL;
80003184:	3f f8       	mov	r8,-1
80003186:	99 98       	st.w	r12[0x24],r8
	// Clear the status flags
	twim->scr = ~0UL;
80003188:	99 b8       	st.w	r12[0x2c],r8
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
8000318a:	4a 9a       	lddpc	r10,8000322c <twim_write_packet+0xc8>
8000318c:	30 08       	mov	r8,0
8000318e:	95 08       	st.w	r10[0x0],r8
	// mask NACK and TXRDY interrupts
	twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_TXRDY_MASK;
80003190:	e0 67 07 02 	mov	r7,1794
80003194:	4a 7e       	lddpc	lr,80003230 <twim_write_packet+0xcc>
80003196:	9d 07       	st.w	lr[0x0],r7
	// Set next transfer to false
	twim_next = false;
80003198:	4a 77       	lddpc	r7,80003234 <twim_write_packet+0xd0>
8000319a:	ae 88       	st.b	r7[0x0],r8
	//check if internal address access is performed
	if (package->addr_length) {
8000319c:	17 f8       	ld.ub	r8,r11[0x7]
8000319e:	58 08       	cp.w	r8,0
800031a0:	c3 50       	breq	8000320a <twim_write_packet+0xa6>
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
800031a2:	4a 66       	lddpc	r6,80003238 <twim_write_packet+0xd4>
800031a4:	8d 08       	st.w	r6[0x0],r8
	// Set next transfer to false
	twim_next = false;
	//check if internal address access is performed
	if (package->addr_length) {
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
800031a6:	4a 66       	lddpc	r6,8000323c <twim_write_packet+0xd8>
800031a8:	f6 c5 ff fc 	sub	r5,r11,-4
800031ac:	8d 05       	st.w	r6[0x0],r5
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
		// set next transfer to true
		twim_next = true;
800031ae:	30 16       	mov	r6,1
800031b0:	ae 86       	st.b	r7[0x0],r6
		// Set the number of bytes & address for next transfer
		twim_package = package;
800031b2:	4a 47       	lddpc	r7,80003240 <twim_write_packet+0xdc>
800031b4:	8f 0b       	st.w	r7[0x0],r11
800031b6:	76 37       	ld.w	r7,r11[0xc]
	twim_tx_data = package->buffer;
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
800031b8:	f0 07 00 07 	add	r7,r8,r7
800031bc:	76 08       	ld.w	r8,r11[0x0]
800031be:	a1 78       	lsl	r8,0x1
800031c0:	e8 18 e0 00 	orl	r8,0xe000
800031c4:	f1 e7 11 08 	or	r8,r8,r7<<0x10
800031c8:	99 38       	st.w	r12[0xc],r8
			| (AVR32_TWIM_CMDR_VALID_MASK)
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
800031ca:	7c 0b       	ld.w	r11,lr[0x0]
800031cc:	72 08       	ld.w	r8,r9[0x0]
800031ce:	91 8b       	st.w	r8[0x20],r11
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
800031d0:	30 1b       	mov	r11,1
800031d2:	91 0b       	st.w	r8[0x0],r11
	// Enable all interrupts
	cpu_irq_enable ();
800031d4:	d5 03       	csrf	0x10
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800031d6:	74 08       	ld.w	r8,r10[0x0]
800031d8:	58 08       	cp.w	r8,0
800031da:	c1 11       	brne	800031fc <twim_write_packet+0x98>
/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
	uint32_t status = twim_inst->sr;
800031dc:	49 38       	lddpc	r8,80003228 <twim_write_packet+0xc4>
800031de:	70 08       	ld.w	r8,r8[0x0]
800031e0:	70 78       	ld.w	r8,r8[0x1c]
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
800031e2:	ed b8 00 04 	bld	r8,0x4
800031e6:	c0 b0       	breq	800031fc <twim_write_packet+0x98>
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
800031e8:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800031ec:	74 08       	ld.w	r8,r10[0x0]
800031ee:	58 08       	cp.w	r8,0
800031f0:	c0 61       	brne	800031fc <twim_write_packet+0x98>
/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
	uint32_t status = twim_inst->sr;
800031f2:	72 08       	ld.w	r8,r9[0x0]
800031f4:	70 78       	ld.w	r8,r8[0x1c]
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
800031f6:	ed b8 00 04 	bld	r8,0x4
800031fa:	cf 71       	brne	800031e8 <twim_write_packet+0x84>
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
800031fc:	30 28       	mov	r8,2
800031fe:	99 08       	st.w	r12[0x0],r8
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80003200:	74 08       	ld.w	r8,r10[0x0]
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
80003202:	5b c8       	cp.w	r8,-4
80003204:	c0 c1       	brne	8000321c <twim_write_packet+0xb8>
80003206:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
		twim_next = true;
		// Set the number of bytes & address for next transfer
		twim_package = package;
	} else {
	// get a pointer to applicative data
	twim_tx_data = package->buffer;
8000320a:	76 26       	ld.w	r6,r11[0x8]
8000320c:	48 c7       	lddpc	r7,8000323c <twim_write_packet+0xd8>
8000320e:	8f 06       	st.w	r7[0x0],r6
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
80003210:	48 a6       	lddpc	r6,80003238 <twim_write_packet+0xd4>
80003212:	76 37       	ld.w	r7,r11[0xc]
80003214:	8d 07       	st.w	r6[0x0],r7
80003216:	cd 1b       	rjmp	800031b8 <twim_write_packet+0x54>
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
	if (global_interrupt_enabled) {
		cpu_irq_disable ();
80003218:	d3 03       	ssrf	0x10
8000321a:	cb 5b       	rjmp	80003184 <twim_write_packet+0x20>
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
8000321c:	48 48       	lddpc	r8,8000322c <twim_write_packet+0xc8>
8000321e:	70 08       	ld.w	r8,r8[0x0]
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
80003220:	5b e8       	cp.w	r8,-2
80003222:	cf 20       	breq	80003206 <twim_write_packet+0xa2>
80003224:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003228:	00 00       	add	r0,r0
8000322a:	05 c8       	ld.ub	r8,r2[0x4]
8000322c:	00 00       	add	r0,r0
8000322e:	05 d4       	ld.ub	r4,r2[0x5]
80003230:	00 00       	add	r0,r0
80003232:	05 dc       	ld.ub	r12,r2[0x5]
80003234:	00 00       	add	r0,r0
80003236:	05 e0       	ld.ub	r0,r2[0x6]
80003238:	00 00       	add	r0,r0
8000323a:	05 e8       	ld.ub	r8,r2[0x6]
8000323c:	00 00       	add	r0,r0
8000323e:	05 d8       	ld.ub	r8,r2[0x5]
80003240:	00 00       	add	r0,r0
80003242:	05 e4       	ld.ub	r4,r2[0x6]

80003244 <twim_read_packet>:
 *                        (see \ref twim_package_t)
 * \retval STATUS_OK      If all bytes were read successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_read_packet (volatile avr32_twim_t *twim, const twim_package_t *package)
{
80003244:	eb cd 40 c0 	pushm	r6-r7,lr
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80003248:	30 28       	mov	r8,2
8000324a:	99 08       	st.w	r12[0x0],r8
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
8000324c:	4b 79       	lddpc	r9,80003328 <twim_read_packet+0xe4>
8000324e:	93 0c       	st.w	r9[0x0],r12
 *
 * \param twim         Base address of the TWIM (i.e. &AVR32_TWI).
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
80003250:	e1 b8 00 00 	mfsr	r8,0x0
	if (global_interrupt_enabled) {
80003254:	ed b8 00 10 	bld	r8,0x10
80003258:	c5 f1       	brne	80003316 <twim_read_packet+0xd2>
		cpu_irq_disable ();
	}
	// Clear the interrupt flags
	twim->idr = ~0UL;
8000325a:	3f f8       	mov	r8,-1
8000325c:	99 98       	st.w	r12[0x24],r8
	// Clear the status flags
	twim->scr = ~0UL;
8000325e:	99 b8       	st.w	r12[0x2c],r8
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
	// get a pointer to applicative data
	twim_rx_data = package->buffer;
80003260:	4b 38       	lddpc	r8,8000332c <twim_read_packet+0xe8>
80003262:	76 2a       	ld.w	r10,r11[0x8]
80003264:	91 0a       	st.w	r8[0x0],r10
	// get a copy of nb bytes to read
	twim_rx_nb_bytes = package->length;
80003266:	4b 38       	lddpc	r8,80003330 <twim_read_packet+0xec>
80003268:	76 37       	ld.w	r7,r11[0xc]
8000326a:	91 07       	st.w	r8[0x0],r7
	// Set next write transfer to false
	twim_next = false;
8000326c:	4b 2a       	lddpc	r10,80003334 <twim_read_packet+0xf0>
8000326e:	30 08       	mov	r8,0
80003270:	b4 88       	st.b	r10[0x0],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80003272:	30 0e       	mov	lr,0
80003274:	4b 1a       	lddpc	r10,80003338 <twim_read_packet+0xf4>
80003276:	95 0e       	st.w	r10[0x0],lr
	//check if internal address access is performed
	if (package->addr_length) {
80003278:	17 f6       	ld.ub	r6,r11[0x7]
8000327a:	f0 06 18 00 	cp.b	r6,r8
8000327e:	c3 d0       	breq	800032f8 <twim_read_packet+0xb4>
		// Reset the TWIM module to clear the THR register
		twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
80003280:	30 1e       	mov	lr,1
80003282:	72 08       	ld.w	r8,r9[0x0]
80003284:	91 0e       	st.w	r8[0x0],lr
		twim_inst->cr = AVR32_TWIM_CR_SWRST_MASK;
80003286:	e0 6e 00 80 	mov	lr,128
8000328a:	91 0e       	st.w	r8[0x0],lr
		twim_inst->cr = AVR32_TWIM_CR_MDIS_MASK;
8000328c:	30 2e       	mov	lr,2
8000328e:	91 0e       	st.w	r8[0x0],lr
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
80003290:	4a be       	lddpc	lr,8000333c <twim_read_packet+0xf8>
80003292:	f6 c7 ff fc 	sub	r7,r11,-4
80003296:	9d 07       	st.w	lr[0x0],r7
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
80003298:	4a ae       	lddpc	lr,80003340 <twim_read_packet+0xfc>
8000329a:	17 f6       	ld.ub	r6,r11[0x7]
8000329c:	9d 06       	st.w	lr[0x0],r6
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
8000329e:	e0 67 07 03 	mov	r7,1795
800032a2:	4a 9e       	lddpc	lr,80003344 <twim_read_packet+0x100>
800032a4:	9d 07       	st.w	lr[0x0],r7
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
800032a6:	76 07       	ld.w	r7,r11[0x0]
800032a8:	a1 77       	lsl	r7,0x1
800032aa:	e8 17 a0 00 	orl	r7,0xa000
800032ae:	ef e6 11 07 	or	r7,r7,r6<<0x10
800032b2:	91 37       	st.w	r8[0xc],r7
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
800032b4:	76 37       	ld.w	r7,r11[0xc]
800032b6:	76 0b       	ld.w	r11,r11[0x0]
800032b8:	b1 67       	lsl	r7,0x10
800032ba:	ef eb 10 1b 	or	r11,r7,r11<<0x1
800032be:	e8 1b e0 01 	orl	r11,0xe001
800032c2:	91 4b       	st.w	r8[0x10],r11
				| (AVR32_TWIM_CMDR_START_MASK)
				| (AVR32_TWIM_CMDR_STOP_MASK)
				| (AVR32_TWIM_CMDR_READ_MASK);
	}
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
800032c4:	7c 0b       	ld.w	r11,lr[0x0]
800032c6:	91 8b       	st.w	r8[0x20],r11
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
800032c8:	30 18       	mov	r8,1
800032ca:	99 08       	st.w	r12[0x0],r8
	// Enable all interrupts
	cpu_irq_enable ();
800032cc:	d5 03       	csrf	0x10
	// get data
	while (!(transfer_status) && !(twim_status ())) {
800032ce:	74 08       	ld.w	r8,r10[0x0]
800032d0:	58 08       	cp.w	r8,0
800032d2:	c0 61       	brne	800032de <twim_read_packet+0x9a>
/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
	uint32_t status = twim_inst->sr;
800032d4:	72 08       	ld.w	r8,r9[0x0]
800032d6:	70 78       	ld.w	r8,r8[0x1c]
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
800032d8:	ed b8 00 04 	bld	r8,0x4
800032dc:	c0 81       	brne	800032ec <twim_read_packet+0xa8>
	// get data
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
800032de:	30 28       	mov	r8,2
800032e0:	99 08       	st.w	r12[0x0],r8
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
800032e2:	74 08       	ld.w	r8,r10[0x0]
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
800032e4:	5b c8       	cp.w	r8,-4
800032e6:	c1 a1       	brne	8000331a <twim_read_packet+0xd6>
800032e8:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// get data
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
800032ec:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// get data
	while (!(transfer_status) && !(twim_status ())) {
800032f0:	74 08       	ld.w	r8,r10[0x0]
800032f2:	58 08       	cp.w	r8,0
800032f4:	cf 00       	breq	800032d4 <twim_read_packet+0x90>
800032f6:	cf 4b       	rjmp	800032de <twim_read_packet+0x9a>
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (AVR32_TWIM_CMDR_STOP_MASK)
				| (AVR32_TWIM_CMDR_READ_MASK);
	} else {
		twim_tx_nb_bytes = 0;
800032f8:	49 28       	lddpc	r8,80003340 <twim_read_packet+0xfc>
800032fa:	91 0e       	st.w	r8[0x0],lr
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
800032fc:	e0 68 07 01 	mov	r8,1793
80003300:	49 1e       	lddpc	lr,80003344 <twim_read_packet+0x100>
80003302:	9d 08       	st.w	lr[0x0],r8
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80003304:	76 08       	ld.w	r8,r11[0x0]
80003306:	b1 67       	lsl	r7,0x10
80003308:	ef e8 10 17 	or	r7,r7,r8<<0x1
8000330c:	72 08       	ld.w	r8,r9[0x0]
8000330e:	e8 17 e0 01 	orl	r7,0xe001
80003312:	91 37       	st.w	r8[0xc],r7
80003314:	cd 8b       	rjmp	800032c4 <twim_read_packet+0x80>
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
	if (global_interrupt_enabled) {
		cpu_irq_disable ();
80003316:	d3 03       	ssrf	0x10
80003318:	ca 1b       	rjmp	8000325a <twim_read_packet+0x16>
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
8000331a:	48 88       	lddpc	r8,80003338 <twim_read_packet+0xf4>
8000331c:	70 08       	ld.w	r8,r8[0x0]
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
8000331e:	5b e8       	cp.w	r8,-2
80003320:	ce 40       	breq	800032e8 <twim_read_packet+0xa4>
80003322:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003326:	d7 03       	nop
80003328:	00 00       	add	r0,r0
8000332a:	05 c8       	ld.ub	r8,r2[0x4]
8000332c:	00 00       	add	r0,r0
8000332e:	05 cc       	ld.ub	r12,r2[0x4]
80003330:	00 00       	add	r0,r0
80003332:	05 d0       	ld.ub	r0,r2[0x5]
80003334:	00 00       	add	r0,r0
80003336:	05 e0       	ld.ub	r0,r2[0x6]
80003338:	00 00       	add	r0,r0
8000333a:	05 d4       	ld.ub	r4,r2[0x5]
8000333c:	00 00       	add	r0,r0
8000333e:	05 d8       	ld.ub	r8,r2[0x5]
80003340:	00 00       	add	r0,r0
80003342:	05 e8       	ld.ub	r8,r2[0x6]
80003344:	00 00       	add	r0,r0
80003346:	05 dc       	ld.ub	r12,r2[0x5]

80003348 <twim_master_init>:
 * \retval ERR_INVALID_ARG  Invalid arg resulting in wrong CWGR Exponential
 * \retval ERR_IO_ERROR     NACK is received or Bus Arbitration lost
 */
status_code_t twim_master_init (volatile avr32_twim_t *twim,
		const twim_options_t *opt)
{
80003348:	d4 21       	pushm	r4-r7,lr
8000334a:	18 97       	mov	r7,r12
8000334c:	16 96       	mov	r6,r11
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
8000334e:	e1 b8 00 00 	mfsr	r8,0x0
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80003352:	4a 55       	lddpc	r5,800033e4 <twim_master_init+0x9c>
80003354:	30 09       	mov	r9,0
80003356:	8b 09       	st.w	r5[0x0],r9
	// Disable TWI interrupts
	if (global_interrupt_enabled) {
80003358:	ed b8 00 10 	bld	r8,0x10
8000335c:	c2 b1       	brne	800033b2 <twim_master_init+0x6a>
		cpu_irq_disable ();
	}
	twim->idr = ~0UL;
8000335e:	3f f8       	mov	r8,-1
80003360:	99 98       	st.w	r12[0x24],r8
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80003362:	30 18       	mov	r8,1
80003364:	99 08       	st.w	r12[0x0],r8
	// Reset TWI
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80003366:	e0 68 00 80 	mov	r8,128
8000336a:	99 08       	st.w	r12[0x0],r8
	if (global_interrupt_enabled) {
		cpu_irq_enable ();
	}
	// Clear SR
	twim->scr = ~0UL;
8000336c:	3f f8       	mov	r8,-1
8000336e:	8f b8       	st.w	r7[0x2c],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003370:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
80003374:	d3 03       	ssrf	0x10

	// register Register twim_master_interrupt_handler interrupt on level CONF_TWIM_IRQ_LEVEL
	irqflags_t flags = cpu_irq_save();
	irq_register_handler(twim_master_interrupt_handler,
80003376:	30 1a       	mov	r10,1
80003378:	e0 6b 03 20 	mov	r11,800
8000337c:	fe cc 04 38 	sub	r12,pc,1080
80003380:	e0 a0 29 fe 	rcall	8000877c <INTC_register_interrupt>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003384:	e6 14 00 01 	andh	r4,0x1,COH
			CONF_TWIM_IRQ_LINE, CONF_TWIM_IRQ_LEVEL);
	cpu_irq_restore(flags);

	if (opt->smbus) {
80003388:	c1 f0       	breq	800033c6 <twim_master_init+0x7e>
8000338a:	30 08       	mov	r8,0
8000338c:	ed 39 00 0c 	ld.ub	r9,r6[12]
		// Enable SMBUS Transfer
		twim->cr = AVR32_TWIM_CR_SMEN_MASK;
80003390:	f0 09 18 00 	cp.b	r9,r8
80003394:	f9 b8 01 10 	movne	r8,16
80003398:	ef f8 1a 00 	st.wne	r7[0x0],r8
		twim->smbtr = (uint32_t) -1;
8000339c:	f9 b8 01 ff 	movne	r8,-1
800033a0:	ef f8 1a 02 	st.wne	r7[0x8],r8
	}
	// Select the speed
	if (twim_set_speed (twim, opt->speed, opt->pba_hz) ==
800033a4:	0e 9c       	mov	r12,r7
800033a6:	6c 0a       	ld.w	r10,r6[0x0]
800033a8:	6c 1b       	ld.w	r11,r6[0x4]
800033aa:	c3 5e       	rcall	80003014 <twim_set_speed>
800033ac:	5b 8c       	cp.w	r12,-8
800033ae:	c0 e1       	brne	800033ca <twim_master_init+0x82>
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
	}
	return STATUS_OK;
}
800033b0:	d8 22       	popm	r4-r7,pc
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
	// Disable TWI interrupts
	if (global_interrupt_enabled) {
		cpu_irq_disable ();
800033b2:	d3 03       	ssrf	0x10
	}
	twim->idr = ~0UL;
800033b4:	3f f8       	mov	r8,-1
800033b6:	99 98       	st.w	r12[0x24],r8
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
800033b8:	30 18       	mov	r8,1
800033ba:	99 08       	st.w	r12[0x0],r8
	// Reset TWI
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
800033bc:	e0 68 00 80 	mov	r8,128
800033c0:	99 08       	st.w	r12[0x0],r8
	if (global_interrupt_enabled) {
		cpu_irq_enable ();
800033c2:	d5 03       	csrf	0x10
800033c4:	cd 4b       	rjmp	8000336c <twim_master_init+0x24>
      cpu_irq_enable();
800033c6:	d5 03       	csrf	0x10
800033c8:	ce 1b       	rjmp	8000338a <twim_master_init+0x42>
	if (twim_set_speed (twim, opt->speed, opt->pba_hz) ==
			ERR_INVALID_ARG) {
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
800033ca:	6c 2b       	ld.w	r11,r6[0x8]
800033cc:	0e 9c       	mov	r12,r7
800033ce:	cb fe       	rcall	8000314c <twim_probe>
800033d0:	6a 08       	ld.w	r8,r5[0x0]
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
800033d2:	5b c8       	cp.w	r8,-4
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
800033d4:	c0 31       	brne	800033da <twim_master_init+0x92>
800033d6:	3f fc       	mov	r12,-1
800033d8:	ce cb       	rjmp	800033b0 <twim_master_init+0x68>
800033da:	48 38       	lddpc	r8,800033e4 <twim_master_init+0x9c>
			|| transfer_status == TWI_ARBITRATION_LOST) {
800033dc:	70 08       	ld.w	r8,r8[0x0]
800033de:	5b e8       	cp.w	r8,-2
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
800033e0:	cf b0       	breq	800033d6 <twim_master_init+0x8e>
800033e2:	d8 2a       	popm	r4-r7,pc,r12=0
800033e4:	00 00       	add	r0,r0
800033e6:	05 d4       	ld.ub	r4,r2[0x5]

800033e8 <can0_int_tx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_tx_handler(void)
{
800033e8:	d4 01       	pushm	lr
	U8 handle;
	
	handle = CANIF_mob_get_mob_txok(0);
800033ea:	fc 78 1c 00 	mov	r8,-189440
800033ee:	70 cc       	ld.w	r12,r8[0x30]
	if (handle != 0x20)
800033f0:	32 09       	mov	r9,32
#endif
static void can0_int_tx_handler(void)
{
	U8 handle;
	
	handle = CANIF_mob_get_mob_txok(0);
800033f2:	f9 dc c2 06 	bfextu	r12,r12,0x10,0x6
	if (handle != 0x20)
800033f6:	f2 0c 18 00 	cp.b	r12,r9
800033fa:	c1 30       	breq	80003420 <can0_int_tx_handler+0x38>
	{
		CANIF_mob_clear_txok_status(0,handle);
800033fc:	30 19       	mov	r9,1
800033fe:	f2 0c 09 49 	lsl	r9,r9,r12
80003402:	f1 49 00 54 	st.w	r8[84],r9
		CANIF_mob_clear_status(0,handle); //   and reset MOb status
80003406:	f8 0c 00 18 	add	r8,r12,r12<<0x1
8000340a:	30 f9       	mov	r9,15
8000340c:	a3 68       	lsl	r8,0x2
8000340e:	e2 28 e3 a0 	sub	r8,189344
80003412:	91 09       	st.w	r8[0x0],r9
	}
	can_lib_params.can_msg_callback_channel0(handle,CAN_STATUS_COMPLETED);
80003414:	48 48       	lddpc	r8,80003424 <can0_int_tx_handler+0x3c>
80003416:	30 0b       	mov	r11,0
80003418:	70 08       	ld.w	r8,r8[0x0]
8000341a:	5d 18       	icall	r8
}
8000341c:	d4 02       	popm	lr
8000341e:	d6 03       	rete
static void can0_int_tx_handler(void)
{
	U8 handle;
	
	handle = CANIF_mob_get_mob_txok(0);
	if (handle != 0x20)
80003420:	32 0c       	mov	r12,32
80003422:	cf 9b       	rjmp	80003414 <can0_int_tx_handler+0x2c>
80003424:	00 00       	add	r0,r0
80003426:	05 f4       	ld.ub	r4,r2[0x7]

80003428 <can0_int_rx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_rx_handler(void)
{
80003428:	d4 01       	pushm	lr
	U8 handle;
	handle = CANIF_mob_get_mob_rxok(0) ;
8000342a:	fc 78 1c 00 	mov	r8,-189440
8000342e:	70 cc       	ld.w	r12,r8[0x30]
	if (handle != 0x20)
80003430:	32 09       	mov	r9,32
__interrupt
#endif
static void can0_int_rx_handler(void)
{
	U8 handle;
	handle = CANIF_mob_get_mob_rxok(0) ;
80003432:	f9 dc c1 06 	bfextu	r12,r12,0x8,0x6
	if (handle != 0x20)
80003436:	f2 0c 18 00 	cp.b	r12,r9
8000343a:	c1 30       	breq	80003460 <can0_int_rx_handler+0x38>
	{
		CANIF_mob_clear_rxok_status(0,handle);
8000343c:	30 19       	mov	r9,1
8000343e:	f2 0c 09 49 	lsl	r9,r9,r12
80003442:	f1 49 00 4c 	st.w	r8[76],r9
		CANIF_mob_clear_status(0,handle); //   and reset MOb status
80003446:	f8 0c 00 18 	add	r8,r12,r12<<0x1
8000344a:	30 f9       	mov	r9,15
8000344c:	a3 68       	lsl	r8,0x2
8000344e:	e2 28 e3 a0 	sub	r8,189344
80003452:	91 09       	st.w	r8[0x0],r9
	}
	can_lib_params.can_msg_callback_channel0(handle,CAN_STATUS_COMPLETED);
80003454:	48 48       	lddpc	r8,80003464 <can0_int_rx_handler+0x3c>
80003456:	30 0b       	mov	r11,0
80003458:	70 08       	ld.w	r8,r8[0x0]
8000345a:	5d 18       	icall	r8
}
8000345c:	d4 02       	popm	lr
8000345e:	d6 03       	rete
#endif
static void can0_int_rx_handler(void)
{
	U8 handle;
	handle = CANIF_mob_get_mob_rxok(0) ;
	if (handle != 0x20)
80003460:	32 0c       	mov	r12,32
80003462:	cf 9b       	rjmp	80003454 <can0_int_rx_handler+0x2c>
80003464:	00 00       	add	r0,r0
80003466:	05 f4       	ld.ub	r4,r2[0x7]

80003468 <can0_int_busoff_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_busoff_handler(void)
{
80003468:	d4 01       	pushm	lr
	CANIF_clr_interrupt_status(0);
8000346a:	fc 79 1c 00 	mov	r9,-189440
8000346e:	72 ba       	ld.w	r10,r9[0x2c]
	can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_BUSOFF);
80003470:	48 58       	lddpc	r8,80003484 <can0_int_busoff_handler+0x1c>
80003472:	30 4b       	mov	r11,4
80003474:	70 08       	ld.w	r8,r8[0x0]
80003476:	e0 6c 00 ff 	mov	r12,255
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_busoff_handler(void)
{
	CANIF_clr_interrupt_status(0);
8000347a:	93 aa       	st.w	r9[0x28],r10
	can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_BUSOFF);
8000347c:	5d 18       	icall	r8
}
8000347e:	d4 02       	popm	lr
80003480:	d6 03       	rete
80003482:	d7 03       	nop
80003484:	00 00       	add	r0,r0
80003486:	05 f4       	ld.ub	r4,r2[0x7]

80003488 <can0_int_cerr_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_cerr_handler(void)
{
80003488:	d4 01       	pushm	lr
	CANIF_clr_interrupt_status(0);
8000348a:	fc 79 1c 00 	mov	r9,-189440
8000348e:	72 ba       	ld.w	r10,r9[0x2c]
	can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_ERROR);
80003490:	48 58       	lddpc	r8,800034a4 <can0_int_cerr_handler+0x1c>
80003492:	30 2b       	mov	r11,2
80003494:	70 08       	ld.w	r8,r8[0x0]
80003496:	e0 6c 00 ff 	mov	r12,255
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_cerr_handler(void)
{
	CANIF_clr_interrupt_status(0);
8000349a:	93 aa       	st.w	r9[0x28],r10
	can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_ERROR);
8000349c:	5d 18       	icall	r8
}
8000349e:	d4 02       	popm	lr
800034a0:	d6 03       	rete
800034a2:	d7 03       	nop
800034a4:	00 00       	add	r0,r0
800034a6:	05 f4       	ld.ub	r4,r2[0x7]

800034a8 <can0_int_wakeup_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_wakeup_handler(void)
{
800034a8:	d4 01       	pushm	lr
	CANIF_clr_interrupt_status(0);
800034aa:	fc 79 1c 00 	mov	r9,-189440
800034ae:	72 ba       	ld.w	r10,r9[0x2c]
	can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_WAKEUP);
800034b0:	48 58       	lddpc	r8,800034c4 <can0_int_wakeup_handler+0x1c>
800034b2:	30 3b       	mov	r11,3
800034b4:	70 08       	ld.w	r8,r8[0x0]
800034b6:	e0 6c 00 ff 	mov	r12,255
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_wakeup_handler(void)
{
	CANIF_clr_interrupt_status(0);
800034ba:	93 aa       	st.w	r9[0x28],r10
	can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_WAKEUP);
800034bc:	5d 18       	icall	r8
}
800034be:	d4 02       	popm	lr
800034c0:	d6 03       	rete
800034c2:	d7 03       	nop
800034c4:	00 00       	add	r0,r0
800034c6:	05 f4       	ld.ub	r4,r2[0x7]

800034c8 <can1_int_tx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_tx_handler(void)
{
800034c8:	d4 01       	pushm	lr
	U8 handle;
	handle = CANIF_mob_get_mob_txok(1) ;
800034ca:	fc 78 1c 00 	mov	r8,-189440
800034ce:	f0 fc 02 30 	ld.w	r12,r8[560]
	if (handle != 0x20)
800034d2:	32 09       	mov	r9,32
__interrupt
#endif
static void can1_int_tx_handler(void)
{
	U8 handle;
	handle = CANIF_mob_get_mob_txok(1) ;
800034d4:	f9 dc c2 06 	bfextu	r12,r12,0x10,0x6
	if (handle != 0x20)
800034d8:	f2 0c 18 00 	cp.b	r12,r9
800034dc:	c1 30       	breq	80003502 <can1_int_tx_handler+0x3a>
	{
		CANIF_mob_clear_txok_status(1,handle);
800034de:	30 19       	mov	r9,1
800034e0:	f2 0c 09 49 	lsl	r9,r9,r12
800034e4:	f1 49 02 54 	st.w	r8[596],r9
		CANIF_mob_clear_status(1,handle); //   and reset MOb status
800034e8:	f8 0c 00 18 	add	r8,r12,r12<<0x1
800034ec:	30 f9       	mov	r9,15
800034ee:	a3 68       	lsl	r8,0x2
800034f0:	e2 28 e1 a0 	sub	r8,188832
800034f4:	91 09       	st.w	r8[0x0],r9
	}
	can_lib_params.can_msg_callback_channel1(handle,CAN_STATUS_COMPLETED);
800034f6:	48 58       	lddpc	r8,80003508 <can1_int_tx_handler+0x40>
800034f8:	30 0b       	mov	r11,0
800034fa:	70 18       	ld.w	r8,r8[0x4]
800034fc:	5d 18       	icall	r8
}
800034fe:	d4 02       	popm	lr
80003500:	d6 03       	rete
#endif
static void can1_int_tx_handler(void)
{
	U8 handle;
	handle = CANIF_mob_get_mob_txok(1) ;
	if (handle != 0x20)
80003502:	32 0c       	mov	r12,32
80003504:	cf 9b       	rjmp	800034f6 <can1_int_tx_handler+0x2e>
80003506:	d7 03       	nop
80003508:	00 00       	add	r0,r0
8000350a:	05 f4       	ld.ub	r4,r2[0x7]

8000350c <can1_int_rx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_rx_handler(void)
{
8000350c:	d4 01       	pushm	lr
	U8 handle;
	handle = CANIF_mob_get_mob_rxok(1) ;
8000350e:	fc 78 1c 00 	mov	r8,-189440
80003512:	f0 fc 02 30 	ld.w	r12,r8[560]
	if (handle != 0x20)
80003516:	32 09       	mov	r9,32
__interrupt
#endif
static void can1_int_rx_handler(void)
{
	U8 handle;
	handle = CANIF_mob_get_mob_rxok(1) ;
80003518:	f9 dc c1 06 	bfextu	r12,r12,0x8,0x6
	if (handle != 0x20)
8000351c:	f2 0c 18 00 	cp.b	r12,r9
80003520:	c1 30       	breq	80003546 <can1_int_rx_handler+0x3a>
	{
		CANIF_mob_clear_rxok_status(1,handle);
80003522:	30 19       	mov	r9,1
80003524:	f2 0c 09 49 	lsl	r9,r9,r12
80003528:	f1 49 02 4c 	st.w	r8[588],r9
		CANIF_mob_clear_status(1,handle); //   and reset MOb status
8000352c:	f8 0c 00 18 	add	r8,r12,r12<<0x1
80003530:	30 f9       	mov	r9,15
80003532:	a3 68       	lsl	r8,0x2
80003534:	e2 28 e1 a0 	sub	r8,188832
80003538:	91 09       	st.w	r8[0x0],r9
	}
	can_lib_params.can_msg_callback_channel1(handle,CAN_STATUS_COMPLETED);
8000353a:	48 58       	lddpc	r8,8000354c <can1_int_rx_handler+0x40>
8000353c:	30 0b       	mov	r11,0
8000353e:	70 18       	ld.w	r8,r8[0x4]
80003540:	5d 18       	icall	r8
}
80003542:	d4 02       	popm	lr
80003544:	d6 03       	rete
#endif
static void can1_int_rx_handler(void)
{
	U8 handle;
	handle = CANIF_mob_get_mob_rxok(1) ;
	if (handle != 0x20)
80003546:	32 0c       	mov	r12,32
80003548:	cf 9b       	rjmp	8000353a <can1_int_rx_handler+0x2e>
8000354a:	d7 03       	nop
8000354c:	00 00       	add	r0,r0
8000354e:	05 f4       	ld.ub	r4,r2[0x7]

80003550 <can1_int_busoff_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_busoff_handler(void)
{
80003550:	d4 01       	pushm	lr
	CANIF_clr_interrupt_status(1);
80003552:	fc 79 1c 00 	mov	r9,-189440
80003556:	f2 fa 02 2c 	ld.w	r10,r9[556]
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_BUSOFF);
8000355a:	48 68       	lddpc	r8,80003570 <can1_int_busoff_handler+0x20>
8000355c:	30 4b       	mov	r11,4
8000355e:	70 18       	ld.w	r8,r8[0x4]
80003560:	e0 6c 00 ff 	mov	r12,255
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_busoff_handler(void)
{
	CANIF_clr_interrupt_status(1);
80003564:	f3 4a 02 28 	st.w	r9[552],r10
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_BUSOFF);
80003568:	5d 18       	icall	r8
}
8000356a:	d4 02       	popm	lr
8000356c:	d6 03       	rete
8000356e:	d7 03       	nop
80003570:	00 00       	add	r0,r0
80003572:	05 f4       	ld.ub	r4,r2[0x7]

80003574 <can1_int_cerr_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_cerr_handler(void)
{
80003574:	d4 01       	pushm	lr
	CANIF_clr_interrupt_status(1);
80003576:	fc 79 1c 00 	mov	r9,-189440
8000357a:	f2 fa 02 2c 	ld.w	r10,r9[556]
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_ERROR);
8000357e:	48 68       	lddpc	r8,80003594 <can1_int_cerr_handler+0x20>
80003580:	30 2b       	mov	r11,2
80003582:	70 18       	ld.w	r8,r8[0x4]
80003584:	e0 6c 00 ff 	mov	r12,255
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_cerr_handler(void)
{
	CANIF_clr_interrupt_status(1);
80003588:	f3 4a 02 28 	st.w	r9[552],r10
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_ERROR);
8000358c:	5d 18       	icall	r8
}
8000358e:	d4 02       	popm	lr
80003590:	d6 03       	rete
80003592:	d7 03       	nop
80003594:	00 00       	add	r0,r0
80003596:	05 f4       	ld.ub	r4,r2[0x7]

80003598 <can1_int_wakeup_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_wakeup_handler(void)
{
80003598:	d4 01       	pushm	lr
	CANIF_clr_interrupt_status(1);
8000359a:	fc 79 1c 00 	mov	r9,-189440
8000359e:	f2 fa 02 2c 	ld.w	r10,r9[556]
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
800035a2:	48 68       	lddpc	r8,800035b8 <can1_int_wakeup_handler+0x20>
800035a4:	30 3b       	mov	r11,3
800035a6:	70 18       	ld.w	r8,r8[0x4]
800035a8:	e0 6c 00 ff 	mov	r12,255
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_wakeup_handler(void)
{
	CANIF_clr_interrupt_status(1);
800035ac:	f3 4a 02 28 	st.w	r9[552],r10
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
800035b0:	5d 18       	icall	r8
}
800035b2:	d4 02       	popm	lr
800035b4:	d6 03       	rete
800035b6:	d7 03       	nop
800035b8:	00 00       	add	r0,r0
800035ba:	05 f4       	ld.ub	r4,r2[0x7]

800035bc <can_mob_alloc>:
}


U8 can_mob_alloc(U8 ch)
{
	if ((ch > 1))
800035bc:	30 18       	mov	r8,1
800035be:	f0 0c 18 00 	cp.b	r12,r8
800035c2:	e0 88 00 05 	brls	800035cc <can_mob_alloc+0x10>
		}
		return CAN_CMD_REFUSED;
	}
	else{
		int i;
		for (i=0;i<NB_MOB_CHANNEL;i++)
800035c6:	e0 6c 00 ff 	mov	r12,255
				return i;
			}
		}
		return CAN_CMD_REFUSED;
	}
}
800035ca:	5e fc       	retal	r12
U8 can_mob_alloc(U8 ch)
{
	if ((ch > 1))
	return  CAN_CMD_REFUSED;

	if(ch==0)
800035cc:	58 0c       	cp.w	r12,0
800035ce:	c2 51       	brne	80003618 <can_mob_alloc+0x5c>
800035d0:	4a 6a       	lddpc	r10,80003668 <can_mob_alloc+0xac>
800035d2:	74 09       	ld.w	r9,r10[0x0]
800035d4:	c0 48       	rjmp	800035dc <can_mob_alloc+0x20>
	{
		int i;
		for (i=0;i<NB_MOB_CHANNEL;i++)
800035d6:	2f fc       	sub	r12,-1
800035d8:	59 0c       	cp.w	r12,16
800035da:	cf 60       	breq	800035c6 <can_mob_alloc+0xa>
		{
			if (!((can_mob_alloc_vector0>>i)&0x01))
800035dc:	f2 0c 0a 48 	lsr	r8,r9,r12
800035e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800035e4:	cf 91       	brne	800035d6 <can_mob_alloc+0x1a>
			{
				can_mob_alloc_vector0|=(1<<i);
800035e6:	30 1b       	mov	r11,1
800035e8:	f6 0c 09 4b 	lsl	r11,r11,r12
800035ec:	f7 e9 10 09 	or	r9,r11,r9
800035f0:	95 09       	st.w	r10[0x0],r9
				CANIF_clr_mob(0,i);
800035f2:	f8 09 15 04 	lsl	r9,r12,0x4
800035f6:	fc 7a 1c 00 	mov	r10,-189440
800035fa:	74 2b       	ld.w	r11,r10[0x8]
800035fc:	f2 0b 09 08 	st.w	r9[r11],r8
80003600:	74 2b       	ld.w	r11,r10[0x8]
80003602:	f2 0b 00 0b 	add	r11,r9,r11
80003606:	97 18       	st.w	r11[0x4],r8
				return i;
80003608:	5c 5c       	castu.b	r12
		for (i=0;i<NB_MOB_CHANNEL;i++)
		{
			if (!((can_mob_alloc_vector0>>i)&0x01))
			{
				can_mob_alloc_vector0|=(1<<i);
				CANIF_clr_mob(0,i);
8000360a:	74 28       	ld.w	r8,r10[0x8]
8000360c:	30 0b       	mov	r11,0
8000360e:	10 09       	add	r9,r8
80003610:	30 0a       	mov	r10,0
80003612:	f2 eb 00 08 	st.d	r9[8],r10
				return i;
80003616:	5e fc       	retal	r12
	return  CAN_CMD_REFUSED;

	if(ch==0)
	{
		int i;
		for (i=0;i<NB_MOB_CHANNEL;i++)
80003618:	49 5a       	lddpc	r10,8000366c <can_mob_alloc+0xb0>
8000361a:	30 0c       	mov	r12,0
8000361c:	74 09       	ld.w	r9,r10[0x0]
8000361e:	c0 48       	rjmp	80003626 <can_mob_alloc+0x6a>
		}
		return CAN_CMD_REFUSED;
	}
	else{
		int i;
		for (i=0;i<NB_MOB_CHANNEL;i++)
80003620:	2f fc       	sub	r12,-1
80003622:	59 0c       	cp.w	r12,16
80003624:	cd 10       	breq	800035c6 <can_mob_alloc+0xa>
		{
			if (!((can_mob_alloc_vector1>>i)&0x01))
80003626:	f2 0c 0a 48 	lsr	r8,r9,r12
8000362a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000362e:	cf 91       	brne	80003620 <can_mob_alloc+0x64>
			{
				can_mob_alloc_vector1|=(1<<i);
80003630:	30 1b       	mov	r11,1
80003632:	f6 0c 09 4b 	lsl	r11,r11,r12
80003636:	f7 e9 10 09 	or	r9,r11,r9
8000363a:	95 09       	st.w	r10[0x0],r9
				CANIF_clr_mob(1,i);
8000363c:	f8 09 15 04 	lsl	r9,r12,0x4
80003640:	fc 7a 1c 00 	mov	r10,-189440
80003644:	f4 fb 02 08 	ld.w	r11,r10[520]
80003648:	f2 0b 09 08 	st.w	r9[r11],r8
8000364c:	f4 fb 02 08 	ld.w	r11,r10[520]
80003650:	f2 0b 00 0b 	add	r11,r9,r11
80003654:	97 18       	st.w	r11[0x4],r8
				return i;
80003656:	5c 5c       	castu.b	r12
		for (i=0;i<NB_MOB_CHANNEL;i++)
		{
			if (!((can_mob_alloc_vector1>>i)&0x01))
			{
				can_mob_alloc_vector1|=(1<<i);
				CANIF_clr_mob(1,i);
80003658:	f4 f8 02 08 	ld.w	r8,r10[520]
8000365c:	30 0b       	mov	r11,0
8000365e:	10 09       	add	r9,r8
80003660:	30 0a       	mov	r10,0
80003662:	f2 eb 00 08 	st.d	r9[8],r10
				return i;
80003666:	5e fc       	retal	r12
80003668:	00 00       	add	r0,r0
8000366a:	05 ec       	ld.ub	r12,r2[0x6]
8000366c:	00 00       	add	r0,r0
8000366e:	05 f0       	ld.ub	r0,r2[0x7]

80003670 <can_mob_free>:
	}
}

U8 can_mob_free(U8 ch, U8 handle)
{
	if ((ch > 1)||
80003670:	30 f9       	mov	r9,15
80003672:	f6 09 18 00 	cp.b	r9,r11
80003676:	f9 b9 03 01 	movlo	r9,1
8000367a:	f9 b9 02 00 	movhs	r9,0
8000367e:	30 18       	mov	r8,1
80003680:	f8 08 18 00 	cp.b	r8,r12
80003684:	f9 b8 02 00 	movhs	r8,0
80003688:	f3 e8 10 08 	or	r8,r9,r8
8000368c:	30 09       	mov	r9,0
8000368e:	f2 08 18 00 	cp.b	r8,r9
80003692:	c1 91       	brne	800036c4 <can_mob_free+0x54>
	(handle > (NB_MOB_CHANNEL-1)))
	return  CAN_CMD_REFUSED;
	switch(ch)
80003694:	30 18       	mov	r8,1
80003696:	f0 0c 18 00 	cp.b	r12,r8
8000369a:	c0 b0       	breq	800036b0 <can_mob_free+0x40>
	{
		case 0:
		can_mob_alloc_vector0 &=  (~(1<<handle));
8000369c:	30 19       	mov	r9,1
8000369e:	48 c8       	lddpc	r8,800036cc <can_mob_free+0x5c>
800036a0:	f2 0b 09 4b 	lsl	r11,r9,r11
800036a4:	30 0c       	mov	r12,0
800036a6:	70 09       	ld.w	r9,r8[0x0]
800036a8:	5c db       	com	r11
800036aa:	12 6b       	and	r11,r9
800036ac:	91 0b       	st.w	r8[0x0],r11
		break;
800036ae:	5e fc       	retal	r12
		case 1:
		can_mob_alloc_vector1 &=  (~(1<<handle));
800036b0:	30 19       	mov	r9,1
800036b2:	48 88       	lddpc	r8,800036d0 <can_mob_free+0x60>
800036b4:	f2 0b 09 4b 	lsl	r11,r9,r11
800036b8:	30 0c       	mov	r12,0
800036ba:	70 09       	ld.w	r9,r8[0x0]
800036bc:	5c db       	com	r11
800036be:	12 6b       	and	r11,r9
800036c0:	91 0b       	st.w	r8[0x0],r11
		break;
	}
	return CAN_CMD_ACCEPTED;
}
800036c2:	5e fc       	retal	r12
	}
}

U8 can_mob_free(U8 ch, U8 handle)
{
	if ((ch > 1)||
800036c4:	e0 6c 00 ff 	mov	r12,255
800036c8:	5e fc       	retal	r12
800036ca:	d7 03       	nop
800036cc:	00 00       	add	r0,r0
800036ce:	05 ec       	ld.ub	r12,r2[0x6]
800036d0:	00 00       	add	r0,r0
800036d2:	05 f0       	ld.ub	r0,r2[0x7]

800036d4 <can_tx>:
U8 can_tx( U8 ch,
U8 handle,
U8 dlc,
U8 req_type,
const can_msg_t *can_msg)
{
800036d4:	eb cd 40 f8 	pushm	r3-r7,lr
	if ((ch > 1) ||
800036d8:	30 f7       	mov	r7,15
800036da:	f6 07 18 00 	cp.b	r7,r11
800036de:	f9 b7 03 01 	movlo	r7,1
800036e2:	f9 b7 02 00 	movhs	r7,0
800036e6:	30 1e       	mov	lr,1
800036e8:	0e 96       	mov	r6,r7
800036ea:	f8 0e 18 00 	cp.b	lr,r12
800036ee:	f9 be 02 00 	movhs	lr,0
800036f2:	30 07       	mov	r7,0
800036f4:	ed ee 10 0e 	or	lr,r6,lr
800036f8:	ee 0e 18 00 	cp.b	lr,r7
800036fc:	c4 b1       	brne	80003792 <can_tx+0xbe>
800036fe:	30 8e       	mov	lr,8
80003700:	fc 0a 18 00 	cp.b	r10,lr
80003704:	e0 8b 00 47 	brhi	80003792 <can_tx+0xbe>
	(handle > (NB_MOB_CHANNEL-1)) ||
	(dlc > 8))
	return  CAN_CMD_REFUSED;

	if (can_msg->ide_bit){
80003708:	70 0e       	ld.w	lr,r8[0x0]
8000370a:	ed be 00 1d 	bld	lr,0x1d
8000370e:	c0 21       	brne	80003712 <can_tx+0x3e>
		CANIF_set_ext_id(ch,
80003710:	bd be       	sbr	lr,0x1d
		CANIF_set_ext_idmask(ch,
		handle,
		can_msg->id_mask);
	}
	else {
		CANIF_set_std_id(ch,
80003712:	fc 75 1c 00 	mov	r5,-189440
80003716:	f8 06 15 06 	lsl	r6,r12,0x6
8000371a:	ec c4 ff ff 	sub	r4,r6,-1
8000371e:	f6 07 15 04 	lsl	r7,r11,0x4
80003722:	ea 04 03 33 	ld.w	r3,r5[r4<<0x3]
80003726:	ee 03 09 0e 	st.w	r7[r3],lr
		handle,
		can_msg->id);
		CANIF_set_std_idmask(ch,
8000372a:	ea 04 03 3e 	ld.w	lr,r5[r4<<0x3]
8000372e:	70 15       	ld.w	r5,r8[0x4]
80003730:	ee 0e 00 0e 	add	lr,r7,lr
		handle,
		can_msg->id_mask);
	}
	CANIF_mob_set_dlc(ch,handle,dlc);
80003734:	f6 0b 00 14 	add	r4,r11,r11<<0x1
	}
	else {
		CANIF_set_std_id(ch,
		handle,
		can_msg->id);
		CANIF_set_std_idmask(ch,
80003738:	9d 15       	st.w	lr[0x4],r5
		handle,
		can_msg->id_mask);
	}
	CANIF_mob_set_dlc(ch,handle,dlc);
8000373a:	ec c5 ff ff 	sub	r5,r6,-1
8000373e:	ea 0e 15 03 	lsl	lr,r5,0x3
80003742:	2a ce       	sub	lr,-84
80003744:	fc 04 00 2e 	add	lr,lr,r4<<0x2
80003748:	e2 2e e4 00 	sub	lr,189440
8000374c:	7c 04       	ld.w	r4,lr[0x0]
8000374e:	e9 ea 10 0a 	or	r10,r4,r10
80003752:	9d 0a       	st.w	lr[0x0],r10
	if (req_type == CAN_REMOTE_FRAME){
80003754:	30 1a       	mov	r10,1
80003756:	f4 09 18 00 	cp.b	r9,r10
8000375a:	c2 00       	breq	8000379a <can_tx+0xc6>
		CANIF_set_rtr(ch,handle);
		CANIF_set_rtrmask(ch,handle);
		CANIF_mob_set_automode(ch,handle);
	}
	CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
8000375c:	f0 e8 00 08 	ld.d	r8,r8[8]
80003760:	2f f6       	sub	r6,-1
80003762:	fc 7a 1c 00 	mov	r10,-189440
80003766:	f4 06 03 3a 	ld.w	r10,r10[r6<<0x3]
8000376a:	14 07       	add	r7,r10
8000376c:	ee e9 00 08 	st.d	r7[8],r8
	CANIF_config_tx(ch,handle);
80003770:	7c 08       	ld.w	r8,lr[0x0]
80003772:	a5 a8       	sbr	r8,0x4
80003774:	9d 08       	st.w	lr[0x0],r8
	CANIF_mob_enable(ch,handle);
80003776:	30 18       	mov	r8,1
80003778:	f0 0b 09 4b 	lsl	r11,r8,r11
8000377c:	f8 08 15 09 	lsl	r8,r12,0x9
	#ifdef CAN_LIB_UNDER_INTERRUPT
	CANIF_mob_enable_interrupt(ch,handle);
80003780:	a9 7c       	lsl	r12,0x9
		CANIF_set_rtrmask(ch,handle);
		CANIF_mob_set_automode(ch,handle);
	}
	CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
	CANIF_config_tx(ch,handle);
	CANIF_mob_enable(ch,handle);
80003782:	e2 28 e3 cc 	sub	r8,189388
	#ifdef CAN_LIB_UNDER_INTERRUPT
	CANIF_mob_enable_interrupt(ch,handle);
80003786:	e2 2c e3 c0 	sub	r12,189376
		CANIF_set_rtrmask(ch,handle);
		CANIF_mob_set_automode(ch,handle);
	}
	CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
	CANIF_config_tx(ch,handle);
	CANIF_mob_enable(ch,handle);
8000378a:	91 0b       	st.w	r8[0x0],r11
	#ifdef CAN_LIB_UNDER_INTERRUPT
	CANIF_mob_enable_interrupt(ch,handle);
8000378c:	99 0b       	st.w	r12[0x0],r11
8000378e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
	#endif
	return CAN_CMD_ACCEPTED;
80003792:	e0 6c 00 ff 	mov	r12,255
}
80003796:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
		handle,
		can_msg->id_mask);
	}
	CANIF_mob_set_dlc(ch,handle,dlc);
	if (req_type == CAN_REMOTE_FRAME){
		CANIF_set_rtr(ch,handle);
8000379a:	fc 79 1c 00 	mov	r9,-189440
8000379e:	30 14       	mov	r4,1
800037a0:	f2 05 03 3a 	ld.w	r10,r9[r5<<0x3]
800037a4:	ee 0a 03 03 	ld.w	r3,r7[r10]
800037a8:	e7 d4 d3 c1 	bfins	r3,r4,0x1e,0x1
800037ac:	ee 0a 09 03 	st.w	r7[r10],r3
		CANIF_set_rtrmask(ch,handle);
800037b0:	f2 05 03 39 	ld.w	r9,r9[r5<<0x3]
800037b4:	ee 09 00 09 	add	r9,r7,r9
800037b8:	72 1a       	ld.w	r10,r9[0x4]
800037ba:	f5 d4 d3 c1 	bfins	r10,r4,0x1e,0x1
800037be:	93 1a       	st.w	r9[0x4],r10
		CANIF_mob_set_automode(ch,handle);
800037c0:	7c 09       	ld.w	r9,lr[0x0]
800037c2:	a5 b9       	sbr	r9,0x5
800037c4:	9d 09       	st.w	lr[0x0],r9
800037c6:	cc bb       	rjmp	8000375c <can_tx+0x88>

800037c8 <can_rx>:

U8 can_rx( U8 ch,
U8 handle,
U8 req_type,
const can_msg_t *can_msg)
{
800037c8:	d4 21       	pushm	r4-r7,lr
	if ((ch > 1) ||
800037ca:	30 fe       	mov	lr,15
800037cc:	f6 0e 18 00 	cp.b	lr,r11
800037d0:	f9 be 03 01 	movlo	lr,1
800037d4:	f9 be 02 00 	movhs	lr,0
800037d8:	30 18       	mov	r8,1
800037da:	f8 08 18 00 	cp.b	r8,r12
800037de:	f9 b8 02 00 	movhs	r8,0
800037e2:	fd e8 10 08 	or	r8,lr,r8
800037e6:	30 0e       	mov	lr,0
800037e8:	fc 08 18 00 	cp.b	r8,lr
800037ec:	c3 41       	brne	80003854 <can_rx+0x8c>
	(handle > (NB_MOB_CHANNEL-1)))
	return  CAN_CMD_REFUSED;
	if (can_msg->ide_bit){
800037ee:	72 07       	ld.w	r7,r9[0x0]
800037f0:	ed b7 00 1d 	bld	r7,0x1d
800037f4:	c0 21       	brne	800037f8 <can_rx+0x30>
		CANIF_set_ext_id(ch,
800037f6:	bd b7       	sbr	r7,0x1d
		CANIF_set_ext_idmask(ch,
		handle,
		can_msg->id_mask);
	}
	else {
		CANIF_set_std_id(ch,
800037f8:	fc 76 1c 00 	mov	r6,-189440
800037fc:	f6 0e 15 04 	lsl	lr,r11,0x4
80003800:	f8 08 15 06 	lsl	r8,r12,0x6
80003804:	f0 c5 ff ff 	sub	r5,r8,-1
80003808:	ec 05 03 34 	ld.w	r4,r6[r5<<0x3]
8000380c:	fc 04 09 07 	st.w	lr[r4],r7
		handle,
		can_msg->id);
		CANIF_set_std_idmask(ch,
80003810:	ec 05 03 37 	ld.w	r7,r6[r5<<0x3]
80003814:	72 16       	ld.w	r6,r9[0x4]
80003816:	fc 07 00 07 	add	r7,lr,r7
8000381a:	8f 16       	st.w	r7[0x4],r6
		handle,
		can_msg->id_mask);
	}
	if (req_type == CAN_REMOTE_FRAME){
8000381c:	30 17       	mov	r7,1
8000381e:	ee 0a 18 00 	cp.b	r10,r7
80003822:	c1 c0       	breq	8000385a <can_rx+0x92>
80003824:	a3 78       	lsl	r8,0x3
80003826:	f6 0b 00 19 	add	r9,r11,r11<<0x1
8000382a:	2a 48       	sub	r8,-92
8000382c:	f0 09 00 28 	add	r8,r8,r9<<0x2
80003830:	e2 28 e4 00 	sub	r8,189440
		CANIF_set_rtr(ch,handle);
		CANIF_set_rtrmask(ch,handle);
		CANIF_mob_set_automode(ch,handle);
		CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
	}
	CANIF_config_rx(ch,handle);
80003834:	70 09       	ld.w	r9,r8[0x0]
80003836:	a5 c9       	cbr	r9,0x4
80003838:	91 09       	st.w	r8[0x0],r9
	CANIF_mob_enable(ch,handle);
8000383a:	30 18       	mov	r8,1
8000383c:	f0 0b 09 4b 	lsl	r11,r8,r11
80003840:	f8 08 15 09 	lsl	r8,r12,0x9
	#ifdef CAN_LIB_UNDER_INTERRUPT
	CANIF_mob_enable_interrupt(ch,handle);
80003844:	a9 7c       	lsl	r12,0x9
		CANIF_set_rtrmask(ch,handle);
		CANIF_mob_set_automode(ch,handle);
		CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
	}
	CANIF_config_rx(ch,handle);
	CANIF_mob_enable(ch,handle);
80003846:	e2 28 e3 cc 	sub	r8,189388
	#ifdef CAN_LIB_UNDER_INTERRUPT
	CANIF_mob_enable_interrupt(ch,handle);
8000384a:	e2 2c e3 c0 	sub	r12,189376
		CANIF_set_rtrmask(ch,handle);
		CANIF_mob_set_automode(ch,handle);
		CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
	}
	CANIF_config_rx(ch,handle);
	CANIF_mob_enable(ch,handle);
8000384e:	91 0b       	st.w	r8[0x0],r11
	#ifdef CAN_LIB_UNDER_INTERRUPT
	CANIF_mob_enable_interrupt(ch,handle);
80003850:	99 0b       	st.w	r12[0x0],r11
80003852:	d8 2a       	popm	r4-r7,pc,r12=0
U8 can_rx( U8 ch,
U8 handle,
U8 req_type,
const can_msg_t *can_msg)
{
	if ((ch > 1) ||
80003854:	e0 6c 00 ff 	mov	r12,255
80003858:	d8 22       	popm	r4-r7,pc
		CANIF_set_std_idmask(ch,
		handle,
		can_msg->id_mask);
	}
	if (req_type == CAN_REMOTE_FRAME){
		CANIF_set_rtr(ch,handle);
8000385a:	f0 c7 ff ff 	sub	r7,r8,-1
8000385e:	fc 7a 1c 00 	mov	r10,-189440
80003862:	30 15       	mov	r5,1
80003864:	f4 07 03 38 	ld.w	r8,r10[r7<<0x3]
80003868:	fc 08 03 06 	ld.w	r6,lr[r8]
8000386c:	ed d5 d3 c1 	bfins	r6,r5,0x1e,0x1
80003870:	fc 08 09 06 	st.w	lr[r8],r6
		CANIF_set_rtrmask(ch,handle);
80003874:	f4 07 03 38 	ld.w	r8,r10[r7<<0x3]
80003878:	fc 08 00 08 	add	r8,lr,r8
8000387c:	70 16       	ld.w	r6,r8[0x4]
8000387e:	ed d5 d3 c1 	bfins	r6,r5,0x1e,0x1
80003882:	91 16       	st.w	r8[0x4],r6
		CANIF_mob_set_automode(ch,handle);
80003884:	f6 0b 00 16 	add	r6,r11,r11<<0x1
80003888:	f8 08 15 09 	lsl	r8,r12,0x9
8000388c:	2a 48       	sub	r8,-92
8000388e:	f0 06 00 28 	add	r8,r8,r6<<0x2
80003892:	14 08       	add	r8,r10
80003894:	70 06       	ld.w	r6,r8[0x0]
80003896:	a5 b6       	sbr	r6,0x5
80003898:	91 06       	st.w	r8[0x0],r6
		CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
8000389a:	f4 07 03 3a 	ld.w	r10,r10[r7<<0x3]
8000389e:	f2 e6 00 08 	ld.d	r6,r9[8]
800038a2:	14 0e       	add	lr,r10
800038a4:	fc e7 00 08 	st.d	lr[8],r6
800038a8:	cc 6b       	rjmp	80003834 <can_rx+0x6c>

800038aa <can_get_mob_data>:
}

Union64 can_get_mob_data( U8 ch ,
U8 handle)
{
	return ((CANIF_mob_get_ptr_data(ch,handle)->data));
800038aa:	a5 6b       	lsl	r11,0x4
800038ac:	a7 6c       	lsl	r12,0x6
800038ae:	fc 78 1c 00 	mov	r8,-189440
800038b2:	2f fc       	sub	r12,-1
800038b4:	f0 0c 03 38 	ld.w	r8,r8[r12<<0x3]
800038b8:	10 0b       	add	r11,r8
}
800038ba:	76 3a       	ld.w	r10,r11[0xc]
800038bc:	76 2b       	ld.w	r11,r11[0x8]
800038be:	5e fc       	retal	r12

800038c0 <can_get_mob_dlc>:

U8 can_get_mob_dlc( U8 ch ,
U8 handle)
{
	return (CANIF_mob_get_dlc(ch,handle));
800038c0:	f6 0b 00 1b 	add	r11,r11,r11<<0x1
800038c4:	a9 7c       	lsl	r12,0x9
800038c6:	f8 0b 00 2c 	add	r12,r12,r11<<0x2
800038ca:	e2 2c e3 a4 	sub	r12,189348
800038ce:	78 0c       	ld.w	r12,r12[0x0]
}
800038d0:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
800038d4:	5e fc       	retal	r12

800038d6 <can_get_mob_id>:

U32 can_get_mob_id( U8 ch ,
U8 handle)
{
	return (CANIF_get_ext_id(ch,handle));
800038d6:	a7 6c       	lsl	r12,0x6
800038d8:	2f fc       	sub	r12,-1
800038da:	a5 6b       	lsl	r11,0x4
800038dc:	fc 78 1c 00 	mov	r8,-189440
800038e0:	f0 0c 03 38 	ld.w	r8,r8[r12<<0x3]
800038e4:	f6 08 03 0c 	ld.w	r12,r11[r8]
}
800038e8:	f9 dc c0 1d 	bfextu	r12,r12,0x0,0x1d
800038ec:	5e fc       	retal	r12
800038ee:	d7 03       	nop

800038f0 <can_enable_interrupt>:
	CANIF_clr_interrupt_status(1);
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
}

U8 can_enable_interrupt(U8 ch)
{
800038f0:	eb cd 40 80 	pushm	r7,lr
	if ((ch > 1))
800038f4:	30 18       	mov	r8,1
	CANIF_clr_interrupt_status(1);
	can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
}

U8 can_enable_interrupt(U8 ch)
{
800038f6:	18 97       	mov	r7,r12
	if ((ch > 1))
800038f8:	f0 0c 18 00 	cp.b	r12,r8
800038fc:	e0 88 00 06 	brls	80003908 <can_enable_interrupt+0x18>
80003900:	e0 6c 00 ff 	mov	r12,255
80003904:	e3 cd 80 80 	ldm	sp++,r7,pc
	return  CAN_CMD_REFUSED;

	if (ch==0)
80003908:	58 0c       	cp.w	r12,0
8000390a:	c2 d0       	breq	80003964 <can_enable_interrupt+0x74>
		INTC_register_interrupt(&can0_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_0, CAN0_INT_WAKE_UP_LEVEL);
		CANIF_enable_interrupt(ch);
	}
	else if (ch == 1)
	{
		INTC_register_interrupt(&can1_int_tx_handler, AVR32_CANIF_TXOK_IRQ_1, CAN1_INT_TX_LEVEL);
8000390c:	30 0a       	mov	r10,0
8000390e:	e0 6b 01 28 	mov	r11,296
80003912:	fe cc 04 4a 	sub	r12,pc,1098
80003916:	e0 a0 27 33 	rcall	8000877c <INTC_register_interrupt>
		INTC_register_interrupt(&can1_int_rx_handler, AVR32_CANIF_RXOK_IRQ_1, CAN1_INT_RX_LEVEL);
8000391a:	30 0a       	mov	r10,0
8000391c:	e0 6b 01 27 	mov	r11,295
80003920:	fe cc 04 14 	sub	r12,pc,1044
		INTC_register_interrupt(&can1_int_busoff_handler, AVR32_CANIF_BUS_OFF_IRQ_1, CAN1_INT_BOFF_LEVEL);
80003924:	e0 a0 27 2c 	rcall	8000877c <INTC_register_interrupt>
80003928:	30 0a       	mov	r10,0
8000392a:	e0 6b 01 25 	mov	r11,293
8000392e:	fe cc 03 de 	sub	r12,pc,990
		INTC_register_interrupt(&can1_int_cerr_handler, AVR32_CANIF_ERROR_IRQ_1, CAN1_INT_ERR_LEVEL);
80003932:	e0 a0 27 25 	rcall	8000877c <INTC_register_interrupt>
80003936:	30 0a       	mov	r10,0
80003938:	e0 6b 01 26 	mov	r11,294
		INTC_register_interrupt(&can1_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_1, CAN1_INT_WAKE_UP_LEVEL);
8000393c:	fe cc 03 c8 	sub	r12,pc,968
80003940:	e0 a0 27 1e 	rcall	8000877c <INTC_register_interrupt>
80003944:	30 0a       	mov	r10,0
80003946:	e0 6b 01 29 	mov	r11,297
		CANIF_enable_interrupt(ch);
8000394a:	fe cc 03 b2 	sub	r12,pc,946
8000394e:	e0 a0 27 17 	rcall	8000877c <INTC_register_interrupt>
80003952:	e0 69 01 c9 	mov	r9,457
	}

	return  CAN_CMD_ACCEPTED;
}
80003956:	fc 78 1c 00 	mov	r8,-189440
	if ((ch > 1))
	return  CAN_CMD_REFUSED;

	if (ch==0)
	{
		INTC_register_interrupt(&can0_int_tx_handler, AVR32_CANIF_TXOK_IRQ_0, CAN0_INT_TX_LEVEL);
8000395a:	30 0c       	mov	r12,0
8000395c:	f1 49 02 1c 	st.w	r8[540],r9
80003960:	e3 cd 80 80 	ldm	sp++,r7,pc
80003964:	e0 6b 01 23 	mov	r11,291
		INTC_register_interrupt(&can0_int_rx_handler, AVR32_CANIF_RXOK_IRQ_0, CAN0_INT_RX_LEVEL);
80003968:	fe cc 05 80 	sub	r12,pc,1408
8000396c:	0e 9a       	mov	r10,r7
8000396e:	e0 a0 27 07 	rcall	8000877c <INTC_register_interrupt>
		INTC_register_interrupt(&can0_int_busoff_handler, AVR32_CANIF_BUS_OFF_IRQ_0, CAN0_INT_BOFF_LEVEL);
80003972:	0e 9a       	mov	r10,r7
80003974:	e0 6b 01 22 	mov	r11,290
80003978:	fe cc 05 50 	sub	r12,pc,1360
8000397c:	e0 a0 27 00 	rcall	8000877c <INTC_register_interrupt>
		INTC_register_interrupt(&can0_int_cerr_handler, AVR32_CANIF_ERROR_IRQ_0, CAN0_INT_ERR_LEVEL);
80003980:	0e 9a       	mov	r10,r7
80003982:	e0 6b 01 20 	mov	r11,288
80003986:	fe cc 05 1e 	sub	r12,pc,1310
		INTC_register_interrupt(&can0_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_0, CAN0_INT_WAKE_UP_LEVEL);
8000398a:	e0 a0 26 f9 	rcall	8000877c <INTC_register_interrupt>
8000398e:	0e 9a       	mov	r10,r7
80003990:	e0 6b 01 21 	mov	r11,289
80003994:	fe cc 05 0c 	sub	r12,pc,1292
		CANIF_enable_interrupt(ch);
80003998:	e0 a0 26 f2 	rcall	8000877c <INTC_register_interrupt>
8000399c:	fe cc 04 f4 	sub	r12,pc,1268
800039a0:	0e 9a       	mov	r10,r7
800039a2:	e0 6b 01 24 	mov	r11,292
800039a6:	e0 a0 26 eb 	rcall	8000877c <INTC_register_interrupt>
800039aa:	e0 69 01 c9 	mov	r9,457
800039ae:	fc 78 1c 00 	mov	r8,-189440
800039b2:	0e 9c       	mov	r12,r7
800039b4:	91 79       	st.w	r8[0x1c],r9
800039b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800039ba:	d7 03       	nop

800039bc <can_init>:
800039bc:	d4 21       	pushm	r4-r7,lr
800039be:	20 2d       	sub	sp,8
800039c0:	30 18       	mov	r8,1
800039c2:	18 97       	mov	r7,r12
800039c4:	f0 0c 18 00 	cp.b	r12,r8
800039c8:	e0 88 00 06 	brls	800039d4 <can_init+0x18>
800039cc:	e0 6c 00 ff 	mov	r12,255
800039d0:	2f ed       	sub	sp,-8
800039d2:	d8 22       	popm	r4-r7,pc
{
	if ( ch > 1)
	return  CAN_CMD_REFUSED;

	// Initialize CAN channel
	CANIF_set_reset(ch);
800039d4:	ee 05 15 05 	lsl	r5,r7,0x5
800039d8:	ea 08 15 04 	lsl	r8,r5,0x4
800039dc:	e2 28 e3 f0 	sub	r8,189424
800039e0:	30 1c       	mov	r12,1
800039e2:	91 0c       	st.w	r8[0x0],r12
	while(CANIF_channel_enable_status(ch));
800039e4:	fc 78 1c 00 	mov	r8,-189440
800039e8:	ee 06 15 09 	lsl	r6,r7,0x9
800039ec:	ec 08 00 04 	add	r4,r6,r8
800039f0:	fc 78 1c 14 	mov	r8,-189420
800039f4:	ec 08 00 0c 	add	r12,r6,r8
800039f8:	78 08       	ld.w	r8,r12[0x0]
800039fa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800039fe:	cf d1       	brne	800039f8 <can_init+0x3c>
	CANIF_clr_reset(ch);
80003a00:	ea 0c 15 04 	lsl	r12,r5,0x4
80003a04:	e2 2c e3 f0 	sub	r12,189424
80003a08:	99 08       	st.w	r12[0x0],r8

	CANIF_set_ram_add(ch,(unsigned long) can_msg_ram_add);
80003a0a:	fc 78 1c 00 	mov	r8,-189440
80003a0e:	ee 0c 15 06 	lsl	r12,r7,0x6
80003a12:	2f fc       	sub	r12,-1
80003a14:	f0 0c 09 3b 	st.w	r8[r12<<0x3],r11
	if ((CANIF_bit_timing(ch))==0) return (0);
80003a18:	50 1a       	stdsp	sp[0x4],r10
80003a1a:	50 09       	stdsp	sp[0x0],r9
80003a1c:	0e 9c       	mov	r12,r7
80003a1e:	fe b0 f8 f4 	rcall	80002c06 <canif_fixed_baudrate>
80003a22:	40 1a       	lddsp	r10,sp[0x4]
80003a24:	40 09       	lddsp	r9,sp[0x0]
80003a26:	cd 50       	breq	800039d0 <can_init+0x14>
	switch(operating_mode)
80003a28:	30 18       	mov	r8,1
80003a2a:	f0 0a 18 00 	cp.b	r10,r8
80003a2e:	c2 80       	breq	80003a7e <can_init+0xc2>
80003a30:	c3 32       	brcc	80003a96 <can_init+0xda>
	{
		case CANIF_CHANNEL_MODE_NORMAL:
		CANIF_set_channel_mode(ch,0);
80003a32:	2f 44       	sub	r4,-12
80003a34:	68 08       	ld.w	r8,r4[0x0]
80003a36:	e4 18 fc ff 	andh	r8,0xfcff
80003a3a:	89 08       	st.w	r4[0x0],r8
80003a3c:	68 08       	ld.w	r8,r4[0x0]
80003a3e:	89 08       	st.w	r4[0x0],r8
		CANIF_clr_overrun_mode(ch);
80003a40:	68 08       	ld.w	r8,r4[0x0]
80003a42:	bb c8       	cbr	r8,0x1a
80003a44:	89 08       	st.w	r4[0x0],r8
		case CANIF_CHANNEL_MODE_LOOPBACK:
		CANIF_set_channel_mode(ch,2);
		CANIF_clr_overrun_mode(ch);
		break;
	}
	canif_clear_all_mob(ch,NB_MOB_CHANNEL);
80003a46:	50 09       	stdsp	sp[0x0],r9
80003a48:	31 0b       	mov	r11,16
80003a4a:	0e 9c       	mov	r12,r7
80003a4c:	fe b0 f8 b8 	rcall	80002bbc <canif_clear_all_mob>
	CANIF_enable(ch);
80003a50:	a5 65       	lsl	r5,0x4
	while(!CANIF_channel_enable_status(ch));
80003a52:	e2 26 e3 ec 	sub	r6,189420
		CANIF_set_channel_mode(ch,2);
		CANIF_clr_overrun_mode(ch);
		break;
	}
	canif_clear_all_mob(ch,NB_MOB_CHANNEL);
	CANIF_enable(ch);
80003a56:	e2 25 e3 f0 	sub	r5,189424
80003a5a:	6a 08       	ld.w	r8,r5[0x0]
80003a5c:	a1 b8       	sbr	r8,0x1
80003a5e:	8b 08       	st.w	r5[0x0],r8
80003a60:	40 09       	lddsp	r9,sp[0x0]
	while(!CANIF_channel_enable_status(ch));
80003a62:	6c 08       	ld.w	r8,r6[0x0]
80003a64:	ed b8 00 00 	bld	r8,0x0
80003a68:	cf d1       	brne	80003a62 <can_init+0xa6>

	#ifdef CAN_LIB_UNDER_INTERRUPT
	switch(ch)
80003a6a:	30 18       	mov	r8,1
80003a6c:	f0 07 18 00 	cp.b	r7,r8
80003a70:	c2 30       	breq	80003ab6 <can_init+0xfa>
	{
		case 0:
		can_lib_params.can_msg_callback_channel0     = can_msg_callback_channel;
80003a72:	49 38       	lddpc	r8,80003abc <can_init+0x100>
80003a74:	91 09       	st.w	r8[0x0],r9
		break;
		case 1:
		can_lib_params.can_msg_callback_channel1     = can_msg_callback_channel;
		break;
	}
	can_enable_interrupt(ch);
80003a76:	0e 9c       	mov	r12,r7
80003a78:	c3 cf       	rcall	800038f0 <can_enable_interrupt>
80003a7a:	2f ed       	sub	sp,-8
80003a7c:	d8 2a       	popm	r4-r7,pc,r12=0
80003a7e:	2f 44       	sub	r4,-12
		case CANIF_CHANNEL_MODE_NORMAL:
		CANIF_set_channel_mode(ch,0);
		CANIF_clr_overrun_mode(ch);
		break;
		case CANIF_CHANNEL_MODE_LISTENING:
		CANIF_set_channel_mode(ch,1);
80003a80:	68 08       	ld.w	r8,r4[0x0]
80003a82:	e4 18 fc ff 	andh	r8,0xfcff
80003a86:	89 08       	st.w	r4[0x0],r8
80003a88:	68 08       	ld.w	r8,r4[0x0]
80003a8a:	b9 a8       	sbr	r8,0x18
80003a8c:	89 08       	st.w	r4[0x0],r8
80003a8e:	68 08       	ld.w	r8,r4[0x0]
		CANIF_set_overrun_mode(ch);
80003a90:	bb a8       	sbr	r8,0x1a
80003a92:	89 08       	st.w	r4[0x0],r8
80003a94:	cd 9b       	rjmp	80003a46 <can_init+0x8a>
		break;
80003a96:	30 28       	mov	r8,2
	while(CANIF_channel_enable_status(ch));
	CANIF_clr_reset(ch);

	CANIF_set_ram_add(ch,(unsigned long) can_msg_ram_add);
	if ((CANIF_bit_timing(ch))==0) return (0);
	switch(operating_mode)
80003a98:	f0 0a 18 00 	cp.b	r10,r8
80003a9c:	cd 51       	brne	80003a46 <can_init+0x8a>
80003a9e:	2f 44       	sub	r4,-12
		case CANIF_CHANNEL_MODE_LISTENING:
		CANIF_set_channel_mode(ch,1);
		CANIF_set_overrun_mode(ch);
		break;
		case CANIF_CHANNEL_MODE_LOOPBACK:
		CANIF_set_channel_mode(ch,2);
80003aa0:	68 08       	ld.w	r8,r4[0x0]
80003aa2:	e4 18 fc ff 	andh	r8,0xfcff
80003aa6:	89 08       	st.w	r4[0x0],r8
80003aa8:	68 08       	ld.w	r8,r4[0x0]
80003aaa:	b9 b8       	sbr	r8,0x19
80003aac:	89 08       	st.w	r4[0x0],r8
80003aae:	68 08       	ld.w	r8,r4[0x0]
		CANIF_clr_overrun_mode(ch);
80003ab0:	bb c8       	cbr	r8,0x1a
80003ab2:	89 08       	st.w	r4[0x0],r8
80003ab4:	cc 9b       	rjmp	80003a46 <can_init+0x8a>
80003ab6:	48 28       	lddpc	r8,80003abc <can_init+0x100>
	{
		case 0:
		can_lib_params.can_msg_callback_channel0     = can_msg_callback_channel;
		break;
		case 1:
		can_lib_params.can_msg_callback_channel1     = can_msg_callback_channel;
80003ab8:	91 19       	st.w	r8[0x4],r9
80003aba:	cd eb       	rjmp	80003a76 <can_init+0xba>
80003abc:	00 00       	add	r0,r0
80003abe:	05 f4       	ld.ub	r4,r2[0x7]

80003ac0 <hex_upper_nibble>:
 *                  used with hex_lower_nibble to print a full hex byte.
 *  RETURNS:      nothing
 */
/*-------------------------------------------------------------------------------------------------------------------*/
TYPE_U8 hex_upper_nibble (TYPE_U8 val)
{
80003ac0:	48 38       	lddpc	r8,80003acc <hex_upper_nibble+0xc>
80003ac2:	f9 dc c0 88 	bfextu	r12,r12,0x4,0x8
      return(hex_table[(val & 0xf0)>>4]);
}
80003ac6:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80003aca:	5e fc       	retal	r12
80003acc:	80 06       	ld.sh	r6,r0[0x0]
80003ace:	87 c4       	st.w	r3[0x30],r4

80003ad0 <hex_lower_nibble>:
 *                  used with hex_upper_nibble to print a full hex byte.
 *  RETURNS:      nothing
 */
/*-------------------------------------------------------------------------------------------------------------------*/
TYPE_U8 hex_lower_nibble (TYPE_U8 val)
{
80003ad0:	48 38       	lddpc	r8,80003adc <hex_lower_nibble+0xc>
80003ad2:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
      return(hex_table[(val & 0x0f)]);
}
80003ad6:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80003ada:	5e fc       	retal	r12
80003adc:	80 06       	ld.sh	r6,r0[0x0]
80003ade:	87 c4       	st.w	r3[0x30],r4

80003ae0 <init_board_gpio>:




void init_board_gpio()
{
80003ae0:	eb cd 40 c0 	pushm	r6-r7,lr
80003ae4:	20 3d       	sub	sp,12
		GPIO_INIC_RESET,
		LED0_GPIO,
		LED1_GPIO,
		LED2_GPIO,
		LED3_GPIO
	};
80003ae6:	49 39       	lddpc	r9,80003b30 <init_board_gpio+0x50>
80003ae8:	f3 3a 00 09 	ld.ub	r10,r9[9]
80003aec:	1a 97       	mov	r7,sp
80003aee:	fb 6a 00 09 	st.b	sp[9],r10
}




void init_board_gpio()
80003af2:	fa c6 ff f6 	sub	r6,sp,-10
		GPIO_INIC_RESET,
		LED0_GPIO,
		LED1_GPIO,
		LED2_GPIO,
		LED3_GPIO
	};
80003af6:	f2 ea 00 00 	ld.d	r10,r9[0]
80003afa:	fa eb 00 00 	st.d	sp[0],r10
80003afe:	f3 39 00 08 	ld.ub	r9,r9[8]
80003b02:	fb 69 00 08 	st.b	sp[8],r9
	
	for(pin = 0; pin < sizeof(gpioList); pin++) {
		gpio_enable_gpio_pin(gpioList[pin]);
80003b06:	0f 3c       	ld.ub	r12,r7++
80003b08:	e0 a0 25 c0 	rcall	80008688 <gpio_enable_gpio_pin>
		LED1_GPIO,
		LED2_GPIO,
		LED3_GPIO
	};
	
	for(pin = 0; pin < sizeof(gpioList); pin++) {
80003b0c:	0c 37       	cp.w	r7,r6
80003b0e:	cf c1       	brne	80003b06 <init_board_gpio+0x26>
		gpio_enable_gpio_pin(gpioList[pin]);
	}
	
	/* LED INIT */
	gpio_set_gpio_pin(LED3_GPIO);
80003b10:	37 6c       	mov	r12,118
80003b12:	e0 a0 25 d1 	rcall	800086b4 <gpio_set_gpio_pin>
	gpio_set_gpio_pin(LED2_GPIO);
80003b16:	34 dc       	mov	r12,77
80003b18:	e0 a0 25 ce 	rcall	800086b4 <gpio_set_gpio_pin>
	gpio_set_gpio_pin(LED1_GPIO);
80003b1c:	37 7c       	mov	r12,119
80003b1e:	e0 a0 25 cb 	rcall	800086b4 <gpio_set_gpio_pin>
	gpio_set_gpio_pin(LED0_GPIO);
80003b22:	30 8c       	mov	r12,8
80003b24:	e0 a0 25 c8 	rcall	800086b4 <gpio_set_gpio_pin>
80003b28:	2f dd       	sub	sp,-12
80003b2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003b2e:	d7 03       	nop
80003b30:	80 06       	ld.sh	r6,r0[0x0]
80003b32:	87 b8       	st.w	r3[0x2c],r8

80003b34 <codec_activeI2c>:
80003b34:	d4 01       	pushm	lr
80003b36:	33 5c       	mov	r12,53
80003b38:	e0 a0 25 be 	rcall	800086b4 <gpio_set_gpio_pin>
	gpio_clr_gpio_pin(GPIO_CODEC_I2C_EN);
}
void codec_activeI2c(void)
{
	gpio_set_gpio_pin(GPIO_CODEC_I2C_RDY);
}
80003b3c:	d8 02       	popm	pc
80003b3e:	d7 03       	nop

80003b40 <inic_ReleaseReset>:
80003b40:	d4 01       	pushm	lr
80003b42:	36 5c       	mov	r12,101
	gpio_clr_gpio_pin(GPIO_INIC_RESET);
}

void inic_ReleaseReset(void)
{
	gpio_set_gpio_pin(GPIO_INIC_RESET);
80003b44:	e0 a0 25 b8 	rcall	800086b4 <gpio_set_gpio_pin>
}
80003b48:	d8 02       	popm	pc
80003b4a:	d7 03       	nop

80003b4c <codec_ReleaseReset>:
80003b4c:	d4 01       	pushm	lr
80003b4e:	33 0c       	mov	r12,48
	gpio_clr_gpio_pin(GPIO_CODEC_RESET);
}

void codec_ReleaseReset(void)
{
	gpio_set_gpio_pin(GPIO_CODEC_RESET);
80003b50:	e0 a0 25 b2 	rcall	800086b4 <gpio_set_gpio_pin>
}
80003b54:	d8 02       	popm	pc
80003b56:	d7 03       	nop

80003b58 <codec_EnableI2c>:
80003b58:	d4 01       	pushm	lr
80003b5a:	33 1c       	mov	r12,49
}


void codec_EnableI2c(void)
{
	gpio_clr_gpio_pin(GPIO_CODEC_I2C_EN);
80003b5c:	e0 a0 25 b9 	rcall	800086ce <gpio_clr_gpio_pin>
}
80003b60:	d8 02       	popm	pc
80003b62:	d7 03       	nop

80003b64 <inic_HoldReset>:
80003b64:	d4 01       	pushm	lr
80003b66:	36 5c       	mov	r12,101
	gpio_set_gpio_pin(GPIO_CODEC_RESET);
}

void inic_HoldReset(void)
{
	gpio_clr_gpio_pin(GPIO_INIC_RESET);
80003b68:	e0 a0 25 b3 	rcall	800086ce <gpio_clr_gpio_pin>
}
80003b6c:	d8 02       	popm	pc
80003b6e:	d7 03       	nop

80003b70 <codec_HoldReset>:
80003b70:	d4 01       	pushm	lr
80003b72:	33 0c       	mov	r12,48
const char hexDigits[16] = "0123456789ABCDEF";


void codec_HoldReset(void)
{
	gpio_clr_gpio_pin(GPIO_CODEC_RESET);
80003b74:	e0 a0 25 ad 	rcall	800086ce <gpio_clr_gpio_pin>
}
80003b78:	d8 02       	popm	pc
80003b7a:	d7 03       	nop

80003b7c <can_example_prepare_data_to_send>:
 *        - Fill the MOB with the correct DATA
 *        - Start the transmission
 */
/* modified by park to communicate via channel 1 */
void can_example_prepare_data_to_send(void)
{
80003b7c:	d4 01       	pushm	lr
	//static unsigned counter_ = 0;
	// Initialize channel 1
	can_init(0, ((U32)&mob_ram_ch1[0]), CANIF_CHANNEL_MODE_NORMAL, can_out_callback_channel1);
80003b7e:	30 0a       	mov	r10,0
80003b80:	fe c9 fa 98 	sub	r9,pc,-1384
80003b84:	48 cb       	lddpc	r11,80003bb4 <can_example_prepare_data_to_send+0x38>
80003b86:	14 9c       	mov	r12,r10
80003b88:	c1 af       	rcall	800039bc <can_init>
	// Allocate one mob for TX
	pCANMOB_message0[0].handle = can_mob_alloc(0);
80003b8a:	30 0c       	mov	r12,0
80003b8c:	fe b0 fd 18 	rcall	800035bc <can_mob_alloc>
80003b90:	48 a9       	lddpc	r9,80003bb8 <can_example_prepare_data_to_send+0x3c>
80003b92:	b2 8c       	st.b	r9[0x0],r12
80003b94:	18 9b       	mov	r11,r12

	// Check return if no mob are available
	if (pCANMOB_message0[0].handle==CAN_CMD_REFUSED) {
80003b96:	3f f8       	mov	r8,-1
80003b98:	f0 0c 18 00 	cp.b	r12,r8
80003b9c:	c0 21       	brne	80003ba0 <can_example_prepare_data_to_send+0x24>
80003b9e:	c0 08       	rjmp	80003b9e <can_example_prepare_data_to_send+0x22>
		while(true);
	}
		
	can_tx(0, pCANMOB_message0[0].handle, pCANMOB_message0[0].dlc, pCANMOB_message0[0].req_type, pCANMOB_message0[0].can_msg);
80003ba0:	f3 3a 00 08 	ld.ub	r10,r9[8]
80003ba4:	72 18       	ld.w	r8,r9[0x4]
80003ba6:	30 0c       	mov	r12,0
80003ba8:	f3 39 00 09 	ld.ub	r9,r9[9]
80003bac:	fe b0 fd 94 	rcall	800036d4 <can_tx>
}
80003bb0:	d8 02       	popm	pc
80003bb2:	d7 03       	nop
80003bb4:	00 00       	add	r0,r0
80003bb6:	3b 8c       	mov	r12,-72
80003bb8:	00 00       	add	r0,r0
80003bba:	00 18       	sub	r8,r0

80003bbc <process_ecu_comm>:
80003bbc:	eb cd 40 fc 	pushm	r2-r7,lr
80003bc0:	fa cd 00 88 	sub	sp,sp,136
80003bc4:	fa eb 00 00 	st.d	sp[0],r10
80003bc8:	e0 4c 06 fc 	cp.w	r12,1788
	unsigned char return_value = 0;
	unsigned char buffer_[64];
	unsigned char buffer_2 [64];
	FILE* fp;
	
	switch (can_id)		{
80003bcc:	e0 80 00 e1 	breq	80003d8e <process_ecu_comm+0x1d2>
80003bd0:	e0 8b 00 0b 	brhi	80003be6 <process_ecu_comm+0x2a>
80003bd4:	e0 4c 06 fa 	cp.w	r12,1786
80003bd8:	e0 80 00 de 	breq	80003d94 <process_ecu_comm+0x1d8>
80003bdc:	e0 6c 00 ff 	mov	r12,255
		break;
		
	}
	
	return return_value;
80003be0:	2d ed       	sub	sp,-136
80003be2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	unsigned char return_value = 0;
	unsigned char buffer_[64];
	unsigned char buffer_2 [64];
	FILE* fp;
	
	switch (can_id)		{
80003be6:	e0 4c 06 fe 	cp.w	r12,1790
80003bea:	c6 c0       	breq	80003cc2 <process_ecu_comm+0x106>
80003bec:	e0 4c 06 ff 	cp.w	r12,1791
80003bf0:	cf 61       	brne	80003bdc <process_ecu_comm+0x20>
		else
			return_value = 234;
		break;

	case 0x6FF:	/* binary-content data-2 */
		fp = fopen ("asdf","wb");
80003bf2:	fe fb 03 8a 	ld.w	r11,pc[906]
80003bf6:	fe fc 03 8a 	ld.w	r12,pc[906]
80003bfa:	e0 a0 98 d5 	rcall	80016da4 <fopen>
		fwrite(&input_data, 1, 16, fp);
80003bfe:	31 0a       	mov	r10,16
		else
			return_value = 234;
		break;

	case 0x6FF:	/* binary-content data-2 */
		fp = fopen ("asdf","wb");
80003c00:	18 97       	mov	r7,r12
		fwrite(&input_data, 1, 16, fp);
80003c02:	18 99       	mov	r9,r12
80003c04:	30 1b       	mov	r11,1
80003c06:	1a 9c       	mov	r12,sp
80003c08:	e0 a0 9c 2e 	rcall	80017464 <fwrite>
		fclose(fp);
80003c0c:	0e 9c       	mov	r12,r7
80003c0e:	e0 a0 97 4b 	rcall	80016aa4 <fclose>

		fp = fopen ("asdf", "rb");
80003c12:	fe fb 03 72 	ld.w	r11,pc[882]
80003c16:	fe fc 03 6a 	ld.w	r12,pc[874]
80003c1a:	e0 a0 98 c5 	rcall	80016da4 <fopen>
		fread (buffer_, 1, 16, fp);
80003c1e:	31 0a       	mov	r10,16
	case 0x6FF:	/* binary-content data-2 */
		fp = fopen ("asdf","wb");
		fwrite(&input_data, 1, 16, fp);
		fclose(fp);

		fp = fopen ("asdf", "rb");
80003c20:	18 97       	mov	r7,r12
		fread (buffer_, 1, 16, fp);
80003c22:	18 99       	mov	r9,r12
80003c24:	30 1b       	mov	r11,1
80003c26:	fa cc ff b8 	sub	r12,sp,-72
80003c2a:	e0 a0 99 1b 	rcall	80016e60 <fread>
		fclose (fp);
80003c2e:	0e 9c       	mov	r12,r7
80003c30:	e0 a0 97 3a 	rcall	80016aa4 <fclose>
		memset (buffer_2, 0x0, 64);
80003c34:	30 08       	mov	r8,0
80003c36:	30 09       	mov	r9,0
80003c38:	fa e9 00 40 	st.d	sp[64],r8
80003c3c:	fa e9 00 08 	st.d	sp[8],r8
80003c40:	fa e9 00 10 	st.d	sp[16],r8
80003c44:	fa e9 00 18 	st.d	sp[24],r8
80003c48:	fa e9 00 20 	st.d	sp[32],r8
80003c4c:	fa e9 00 28 	st.d	sp[40],r8
80003c50:	fa e9 00 30 	st.d	sp[48],r8
80003c54:	fa e9 00 38 	st.d	sp[56],r8
		//strncmp (buffer_2, buffer_, 2);
		//return_value = atoi (buffer_2);
		
		version_flag = 1;
80003c58:	30 18       	mov	r8,1
80003c5a:	fe f9 03 2e 	ld.w	r9,pc[814]
80003c5e:	b2 88       	st.b	r9[0x0],r8
		
		pCANMOB_message0[0].can_msg->id = 0xFFFF;
80003c60:	e0 6b ff ff 	mov	r11,65535
80003c64:	fe f9 03 28 	ld.w	r9,pc[808]
80003c68:	72 1a       	ld.w	r10,r9[0x4]
80003c6a:	95 0b       	st.w	r10[0x0],r11
		pCANMOB_message0[0].can_msg->data.u64 = 0x44ffffffffffffff;
80003c6c:	72 19       	ld.w	r9,r9[0x4]
80003c6e:	3f fa       	mov	r10,-1
80003c70:	e0 6b ff ff 	mov	r11,65535
80003c74:	ea 1b 44 ff 	orh	r11,0x44ff
80003c78:	f2 eb 00 08 	st.d	r9[8],r10
		//can_example_prepare_data_to_send2(DOWNGRADE);
		gFwState.fwVerStored = 1;
80003c7c:	fe f9 03 14 	ld.w	r9,pc[788]
80003c80:	b2 88       	st.b	r9[0x0],r8
			
		can_example_prepare_data_to_send();
80003c82:	c7 df       	rcall	80003b7c <can_example_prepare_data_to_send>
80003c84:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003c88:	e0 6a 24 00 	mov	r10,9216
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003c8c:	ea 1a 00 f4 	orh	r10,0xf4
80003c90:	f0 0a 00 0a 	add	r10,r8,r10
80003c94:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003c98:	14 38       	cp.w	r8,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003c9a:	e0 88 00 0d 	brls	80003cb4 <process_ecu_comm+0xf8>
80003c9e:	12 38       	cp.w	r8,r9
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003ca0:	fe 98 ff fa 	brls	80003c94 <process_ecu_comm+0xd8>
80003ca4:	12 3a       	cp.w	r10,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003ca6:	cf 72       	brcc	80003c94 <process_ecu_comm+0xd8>
80003ca8:	e0 a0 13 0a 	rcall	800062bc <gui_clear_view>
		
		//for (unsigned p = 0; p < 100000000; p ++);
		//sleep(1);
		delay_ms(1000);
		//gui_init(FCPU_HZ, FHSB_HZ, FPBB_HZ, FPBA_HZ);
		gui_clear_view();
80003cac:	30 ac       	mov	r12,10
80003cae:	2d ed       	sub	sp,-136
		break;
		
	}
	
	return return_value;
80003cb0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003cb4:	12 38       	cp.w	r8,r9
80003cb6:	fe 98 ff f7 	brls	80003ca4 <process_ecu_comm+0xe8>
80003cba:	e0 a0 13 01 	rcall	800062bc <gui_clear_view>
		
		//for (unsigned p = 0; p < 100000000; p ++);
		//sleep(1);
		delay_ms(1000);
		//gui_init(FCPU_HZ, FHSB_HZ, FPBB_HZ, FPBA_HZ);
		gui_clear_view();
80003cbe:	30 ac       	mov	r12,10
80003cc0:	cf 7b       	rjmp	80003cae <process_ecu_comm+0xf2>
80003cc2:	fe fb 02 ba 	ld.w	r11,pc[698]
		gui_clear_view();
		break;
		
	case 0x6FE:	/* binary-content data-1 */
		/* processing binary data-1 in this area */
		fp = fopen ("recv_file","wb");
80003cc6:	fe fc 02 ce 	ld.w	r12,pc[718]
80003cca:	e0 a0 98 6d 	rcall	80016da4 <fopen>
80003cce:	31 0a       	mov	r10,16
		fwrite(&input_data, 1, 16, fp);
80003cd0:	18 97       	mov	r7,r12
		gui_clear_view();
		break;
		
	case 0x6FE:	/* binary-content data-1 */
		/* processing binary data-1 in this area */
		fp = fopen ("recv_file","wb");
80003cd2:	18 99       	mov	r9,r12
		fwrite(&input_data, 1, 16, fp);
80003cd4:	30 1b       	mov	r11,1
80003cd6:	1a 9c       	mov	r12,sp
80003cd8:	e0 a0 9b c6 	rcall	80017464 <fwrite>
80003cdc:	0e 9c       	mov	r12,r7
		fclose(fp);
80003cde:	e0 a0 96 e3 	rcall	80016aa4 <fclose>
80003ce2:	fe fb 02 a2 	ld.w	r11,pc[674]

		fp = fopen ("recv_file", "rb");
80003ce6:	fe fc 02 ae 	ld.w	r12,pc[686]
80003cea:	e0 a0 98 5d 	rcall	80016da4 <fopen>
80003cee:	31 0a       	mov	r10,16
		fread (buffer_, 1, 16, fp);
80003cf0:	18 97       	mov	r7,r12
		/* processing binary data-1 in this area */
		fp = fopen ("recv_file","wb");
		fwrite(&input_data, 1, 16, fp);
		fclose(fp);

		fp = fopen ("recv_file", "rb");
80003cf2:	18 99       	mov	r9,r12
		fread (buffer_, 1, 16, fp);
80003cf4:	30 1b       	mov	r11,1
80003cf6:	fa cc ff b8 	sub	r12,sp,-72
80003cfa:	e0 a0 98 b3 	rcall	80016e60 <fread>
80003cfe:	0e 9c       	mov	r12,r7
		fclose (fp);
80003d00:	e0 a0 96 d2 	rcall	80016aa4 <fclose>
80003d04:	30 08       	mov	r8,0
		memset (buffer_2, 0x0, 64);
80003d06:	30 09       	mov	r9,0
80003d08:	fa e9 00 40 	st.d	sp[64],r8
80003d0c:	fa e9 00 08 	st.d	sp[8],r8
80003d10:	fa e9 00 10 	st.d	sp[16],r8
80003d14:	fa e9 00 18 	st.d	sp[24],r8
80003d18:	fa e9 00 20 	st.d	sp[32],r8
80003d1c:	fa e9 00 28 	st.d	sp[40],r8
80003d20:	fa e9 00 30 	st.d	sp[48],r8
80003d24:	fa e9 00 38 	st.d	sp[56],r8
80003d28:	30 28       	mov	r8,2
		//strncmp (buffer_2, buffer_, 2);
		//return_value = atoi (buffer_2);
		
		version_flag = 2;
80003d2a:	fe f9 02 5e 	ld.w	r9,pc[606]
80003d2e:	b2 88       	st.b	r9[0x0],r8
80003d30:	e0 6b ff ff 	mov	r11,65535
		

		pCANMOB_message0[0].can_msg->id = 0xFFFF;
80003d34:	fe f9 02 58 	ld.w	r9,pc[600]
80003d38:	72 1a       	ld.w	r10,r9[0x4]
80003d3a:	95 0b       	st.w	r10[0x0],r11
80003d3c:	72 19       	ld.w	r9,r9[0x4]
		pCANMOB_message0[0].can_msg->data.u64 = 0x55ffffffffffffff;
80003d3e:	3f fa       	mov	r10,-1
80003d40:	e0 6b ff ff 	mov	r11,65535
80003d44:	ea 1b 55 ff 	orh	r11,0x55ff
80003d48:	f2 eb 00 08 	st.d	r9[8],r10
80003d4c:	fe f9 02 44 	ld.w	r9,pc[580]
		//can_example_prepare_data_to_send2(UPDATE);
		gFwState.fwVerStored = 2;
80003d50:	b2 88       	st.b	r9[0x0],r8
80003d52:	c1 5f       	rcall	80003b7c <can_example_prepare_data_to_send>
		can_example_prepare_data_to_send();
80003d54:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003d58:	e0 6a 24 00 	mov	r10,9216
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003d5c:	ea 1a 00 f4 	orh	r10,0xf4
80003d60:	f0 0a 00 0a 	add	r10,r8,r10
80003d64:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003d68:	14 38       	cp.w	r8,r10
80003d6a:	e0 88 00 0b 	brls	80003d80 <process_ecu_comm+0x1c4>
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003d6e:	12 38       	cp.w	r8,r9
80003d70:	fe 98 ff fa 	brls	80003d64 <process_ecu_comm+0x1a8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003d74:	12 3a       	cp.w	r10,r9
80003d76:	cf 72       	brcc	80003d64 <process_ecu_comm+0x1a8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003d78:	e0 a0 12 a2 	rcall	800062bc <gui_clear_view>
		
		//for (unsigned p = 0; p < 100000000; p ++);
		//sleep(1);
		delay_ms(1000);
		//gui_init(FCPU_HZ, FHSB_HZ, FPBB_HZ, FPBA_HZ);
		gui_clear_view();
80003d7c:	30 ac       	mov	r12,10
80003d7e:	c9 8b       	rjmp	80003cae <process_ecu_comm+0xf2>
80003d80:	12 38       	cp.w	r8,r9
80003d82:	fe 98 ff f9 	brls	80003d74 <process_ecu_comm+0x1b8>
80003d86:	e0 a0 12 9b 	rcall	800062bc <gui_clear_view>
80003d8a:	30 ac       	mov	r12,10
80003d8c:	c9 1b       	rjmp	80003cae <process_ecu_comm+0xf2>
80003d8e:	e0 6c 00 ea 	mov	r12,234
	unsigned char return_value = 0;
	unsigned char buffer_[64];
	unsigned char buffer_2 [64];
	FILE* fp;
	
	switch (can_id)		{
80003d92:	c2 7b       	rjmp	80003be0 <process_ecu_comm+0x24>
80003d94:	fe 76 ff 00 	mov	r6,-256
		case 0x6FA:	/* request or order packet*/
			//temp_data >>
			if ((input_data & 0xFFFFFFFFFFFFFF00) == 0)	{
80003d98:	3f f7       	mov	r7,-1
80003d9a:	f5 e6 00 08 	and	r8,r10,r6
80003d9e:	f7 e7 00 09 	and	r9,r11,r7
80003da2:	58 08       	cp.w	r8,0
80003da4:	5c 29       	cpc	r9
80003da6:	c0 31       	brne	80003dac <process_ecu_comm+0x1f0>
80003da8:	4f 88       	lddpc	r8,80003f88 <process_ecu_comm+0x3cc>
80003daa:	b0 8a       	st.b	r8[0x0],r10
				version_flag = (input_data & 0x00000000000000FF);
80003dac:	fc 16 ff 00 	movh	r6,0xff00
				return_value = 0;
			}
			switch (input_data & 0xFF000000)	{ /* command */
80003db0:	30 07       	mov	r7,0
80003db2:	f5 e6 00 08 	and	r8,r10,r6
80003db6:	f7 e7 00 09 	and	r9,r11,r7
80003dba:	fc 14 10 00 	movh	r4,0x1000
80003dbe:	30 05       	mov	r5,0
80003dc0:	08 38       	cp.w	r8,r4
80003dc2:	ea 09 13 00 	cpc	r9,r5
80003dc6:	c2 90       	breq	80003e18 <process_ecu_comm+0x25c>
80003dc8:	e0 8b 00 0a 	brhi	80003ddc <process_ecu_comm+0x220>
80003dcc:	59 18       	cp.w	r8,17
80003dce:	5c 29       	cpc	r9
80003dd0:	c4 20       	breq	80003e54 <process_ecu_comm+0x298>
80003dd2:	59 28       	cp.w	r8,18
80003dd4:	5c 29       	cpc	r9
80003dd6:	c3 10       	breq	80003e38 <process_ecu_comm+0x27c>
80003dd8:	37 bc       	mov	r12,123
80003dda:	c0 3b       	rjmp	80003be0 <process_ecu_comm+0x24>
80003ddc:	fc 14 21 00 	movh	r4,0x2100
80003de0:	30 05       	mov	r5,0
80003de2:	08 38       	cp.w	r8,r4
80003de4:	ea 09 13 00 	cpc	r9,r5
80003de8:	c4 40       	breq	80003e70 <process_ecu_comm+0x2b4>
80003dea:	fc 16 22 00 	movh	r6,0x2200
80003dee:	30 07       	mov	r7,0
80003df0:	0c 38       	cp.w	r8,r6
80003df2:	ee 09 13 00 	cpc	r9,r7
80003df6:	cf 11       	brne	80003dd8 <process_ecu_comm+0x21c>
80003df8:	e0 66 ff 00 	mov	r6,65280
				}
				else
					return_value = 14;
				break;
			case 0x22000000: /*ECUM request state of SW update */
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
80003dfc:	ea 16 00 ff 	orh	r6,0xff
80003e00:	30 07       	mov	r7,0
80003e02:	f5 e6 00 08 	and	r8,r10,r6
80003e06:	f7 e7 00 09 	and	r9,r11,r7
80003e0a:	e0 48 ff 00 	cp.w	r8,65280
80003e0e:	5c 29       	cpc	r9
80003e10:	e0 80 00 8a 	breq	80003f24 <process_ecu_comm+0x368>
80003e14:	30 fc       	mov	r12,15
80003e16:	ce 5a       	rjmp	80003be0 <process_ecu_comm+0x24>
80003e18:	e0 66 ff 00 	mov	r6,65280
				version_flag = (input_data & 0x00000000000000FF);
				return_value = 0;
			}
			switch (input_data & 0xFF000000)	{ /* command */
				case 0x10000000: /* ECUM request to confirm connection */
					if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
80003e1c:	ea 16 00 ff 	orh	r6,0xff
80003e20:	30 07       	mov	r7,0
80003e22:	f5 e6 00 08 	and	r8,r10,r6
80003e26:	f7 e7 00 09 	and	r9,r11,r7
80003e2a:	e0 48 ff 00 	cp.w	r8,65280
80003e2e:	5c 29       	cpc	r9
80003e30:	e0 80 00 94 	breq	80003f58 <process_ecu_comm+0x39c>
80003e34:	30 bc       	mov	r12,11
80003e36:	cd 5a       	rjmp	80003be0 <process_ecu_comm+0x24>
80003e38:	e0 66 ff 00 	mov	r6,65280
					}
					else
						return_value = 12;
					break;
			case 0x12: /*ECUM notify to end TX of data */
				if (((input_data & 0xFFFF00) == 0) || ((input_data & 0xFFFF00) == 0XFF))	{
80003e3c:	ea 16 00 ff 	orh	r6,0xff
80003e40:	30 07       	mov	r7,0
80003e42:	f5 e6 00 08 	and	r8,r10,r6
80003e46:	f7 e7 00 09 	and	r9,r11,r7
80003e4a:	58 08       	cp.w	r8,0
80003e4c:	5c 29       	cpc	r9
80003e4e:	c2 00       	breq	80003e8e <process_ecu_comm+0x2d2>
80003e50:	30 dc       	mov	r12,13
80003e52:	cc 7a       	rjmp	80003be0 <process_ecu_comm+0x24>
80003e54:	e0 66 ff 00 	mov	r6,65280
					}
					else
						return_value = 11;
					break;
				case 0x11: /* ECUM notify to start TX of data */
					if ((input_data & 0xFFFF00) == 0)	{
80003e58:	ea 16 00 ff 	orh	r6,0xff
80003e5c:	30 07       	mov	r7,0
80003e5e:	f5 e6 00 08 	and	r8,r10,r6
80003e62:	f7 e7 00 09 	and	r9,r11,r7
80003e66:	58 08       	cp.w	r8,0
80003e68:	5c 29       	cpc	r9
80003e6a:	c2 30       	breq	80003eb0 <process_ecu_comm+0x2f4>
80003e6c:	30 cc       	mov	r12,12
80003e6e:	cb 9a       	rjmp	80003be0 <process_ecu_comm+0x24>
80003e70:	e0 64 ff 00 	mov	r4,65280
				}
				else
					return_value = 13;
				break;
			case 0x21000000: /*ECUM request information of SW version*/
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
80003e74:	ea 14 00 ff 	orh	r4,0xff
80003e78:	30 05       	mov	r5,0
80003e7a:	f5 e4 00 08 	and	r8,r10,r4
80003e7e:	f7 e5 00 09 	and	r9,r11,r5
80003e82:	e0 48 ff 00 	cp.w	r8,65280
80003e86:	5c 29       	cpc	r9
80003e88:	c2 60       	breq	80003ed4 <process_ecu_comm+0x318>
80003e8a:	30 ec       	mov	r12,14
80003e8c:	ca aa       	rjmp	80003be0 <process_ecu_comm+0x24>
80003e8e:	e0 6a 06 fb 	mov	r10,1787
						return_value = 12;
					break;
			case 0x12: /*ECUM notify to end TX of data */
				if (((input_data & 0xFFFF00) == 0) || ((input_data & 0xFFFF00) == 0XFF))	{
					/* normal(0) or irregulary(0xFF) end */
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003e92:	4b f8       	lddpc	r8,80003f8c <process_ecu_comm+0x3d0>
80003e94:	e0 6b 12 00 	mov	r11,4608
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF120010000000;
80003e98:	ea 1b 00 ff 	orh	r11,0xff
80003e9c:	70 19       	ld.w	r9,r8[0x4]
80003e9e:	93 0a       	st.w	r9[0x0],r10
						return_value = 12;
					break;
			case 0x12: /*ECUM notify to end TX of data */
				if (((input_data & 0xFFFF00) == 0) || ((input_data & 0xFFFF00) == 0XFF))	{
					/* normal(0) or irregulary(0xFF) end */
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003ea0:	fc 1a 10 00 	movh	r10,0x1000
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF120010000000;
80003ea4:	70 18       	ld.w	r8,r8[0x4]
80003ea6:	f0 eb 00 08 	st.d	r8[8],r10
80003eaa:	c6 9e       	rcall	80003b7c <can_example_prepare_data_to_send>
80003eac:	30 3c       	mov	r12,3
					can_example_prepare_data_to_send();
80003eae:	c9 9a       	rjmp	80003be0 <process_ecu_comm+0x24>
80003eb0:	e0 6a 06 fb 	mov	r10,1787
80003eb4:	4b 68       	lddpc	r8,80003f8c <process_ecu_comm+0x3d0>
					else
						return_value = 11;
					break;
				case 0x11: /* ECUM notify to start TX of data */
					if ((input_data & 0xFFFF00) == 0)	{
						pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003eb6:	e0 6b 11 00 	mov	r11,4352
80003eba:	ea 1b 00 ff 	orh	r11,0xff
						pCANMOB_message0[0].can_msg->data.u64 = 0x00FF110010000000;
80003ebe:	70 19       	ld.w	r9,r8[0x4]
80003ec0:	93 0a       	st.w	r9[0x0],r10
80003ec2:	fc 1a 10 00 	movh	r10,0x1000
					else
						return_value = 11;
					break;
				case 0x11: /* ECUM notify to start TX of data */
					if ((input_data & 0xFFFF00) == 0)	{
						pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003ec6:	70 18       	ld.w	r8,r8[0x4]
						pCANMOB_message0[0].can_msg->data.u64 = 0x00FF110010000000;
80003ec8:	f0 eb 00 08 	st.d	r8[8],r10
80003ecc:	c5 8e       	rcall	80003b7c <can_example_prepare_data_to_send>
80003ece:	30 2c       	mov	r12,2
80003ed0:	fe 9f fe 88 	bral	80003be0 <process_ecu_comm+0x24>
						can_example_prepare_data_to_send();
80003ed4:	4a e8       	lddpc	r8,80003f8c <process_ecu_comm+0x3d0>
80003ed6:	e0 6a 06 fb 	mov	r10,1787
80003eda:	70 19       	ld.w	r9,r8[0x4]
				else
					return_value = 13;
				break;
			case 0x21000000: /*ECUM request information of SW version*/
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003edc:	93 0a       	st.w	r9[0x0],r10
80003ede:	70 1b       	ld.w	r11,r8[0x4]
80003ee0:	4a a8       	lddpc	r8,80003f88 <process_ecu_comm+0x3cc>
80003ee2:	11 8a       	ld.ub	r10,r8[0x0]
80003ee4:	b9 6a       	lsl	r10,0x18
					//if (version_flag == 1)
					U64 temp_u64 = 0xFF000000;
					temp_u64 &= version_flag <<24;
					temp_u64 |= 0xFFFFFFFF00FFFFFF;
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF2100FF000000 & temp_u64;
80003ee6:	f4 09 14 1f 	asr	r9,r10,0x1f
			case 0x21000000: /*ECUM request information of SW version*/
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
					//if (version_flag == 1)
					U64 temp_u64 = 0xFF000000;
					temp_u64 &= version_flag <<24;
80003eea:	e0 68 ff ff 	mov	r8,65535
80003eee:	ea 18 00 ff 	orh	r8,0xff
					temp_u64 |= 0xFFFFFFFF00FFFFFF;
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF2100FF000000 & temp_u64;
80003ef2:	f3 e7 00 03 	and	r3,r9,r7
80003ef6:	3f f9       	mov	r9,-1
80003ef8:	f5 e6 00 02 	and	r2,r10,r6
			case 0x21000000: /*ECUM request information of SW version*/
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
					//if (version_flag == 1)
					U64 temp_u64 = 0xFF000000;
					temp_u64 &= version_flag <<24;
80003efc:	e0 67 21 00 	mov	r7,8448
80003f00:	ea 17 00 ff 	orh	r7,0xff
					temp_u64 |= 0xFFFFFFFF00FFFFFF;
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF2100FF000000 & temp_u64;
80003f04:	e5 e8 10 04 	or	r4,r2,r8
80003f08:	e7 e9 10 05 	or	r5,r3,r9
80003f0c:	fc 16 ff 00 	movh	r6,0xff00
80003f10:	eb e7 00 09 	and	r9,r5,r7
80003f14:	e9 e6 00 08 	and	r8,r4,r6
80003f18:	f6 e9 00 08 	st.d	r11[8],r8
80003f1c:	c3 0e       	rcall	80003b7c <can_example_prepare_data_to_send>
80003f1e:	30 4c       	mov	r12,4
80003f20:	fe 9f fe 60 	bral	80003be0 <process_ecu_comm+0x24>
					can_example_prepare_data_to_send();
80003f24:	fc 17 ff 00 	movh	r7,0xff00
80003f28:	49 88       	lddpc	r8,80003f88 <process_ecu_comm+0x3cc>
80003f2a:	f7 e7 00 09 	and	r9,r11,r7
				else
					return_value = 14;
				break;
			case 0x22000000: /*ECUM request state of SW update */
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					version_flag = (input_data & 0xFF00000000000000) >> 56;
80003f2e:	e0 6a 06 fb 	mov	r10,1787
80003f32:	b9 89       	lsr	r9,0x18
80003f34:	b0 89       	st.b	r8[0x0],r9
80003f36:	e0 6b 22 00 	mov	r11,8704
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003f3a:	ea 1b 00 ff 	orh	r11,0xff
				else
					return_value = 14;
				break;
			case 0x22000000: /*ECUM request state of SW update */
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					version_flag = (input_data & 0xFF00000000000000) >> 56;
80003f3e:	49 48       	lddpc	r8,80003f8c <process_ecu_comm+0x3d0>
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF220064000000;
80003f40:	70 19       	ld.w	r9,r8[0x4]
80003f42:	93 0a       	st.w	r9[0x0],r10
80003f44:	fc 1a 64 00 	movh	r10,0x6400
					return_value = 14;
				break;
			case 0x22000000: /*ECUM request state of SW update */
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					version_flag = (input_data & 0xFF00000000000000) >> 56;
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
80003f48:	70 18       	ld.w	r8,r8[0x4]
80003f4a:	f0 eb 00 08 	st.d	r8[8],r10
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF220064000000;
80003f4e:	c1 7e       	rcall	80003b7c <can_example_prepare_data_to_send>
80003f50:	30 06       	mov	r6,0
80003f52:	30 5c       	mov	r12,5
80003f54:	fe 9f fe 46 	bral	80003be0 <process_ecu_comm+0x24>
					can_example_prepare_data_to_send();
80003f58:	e0 6a 06 fb 	mov	r10,1787
				else
					return_value = 14;
				break;
			case 0x22000000: /*ECUM request state of SW update */
				if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
					version_flag = (input_data & 0xFF00000000000000) >> 56;
80003f5c:	48 c8       	lddpc	r8,80003f8c <process_ecu_comm+0x3d0>
					pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU replay */
					pCANMOB_message0[0].can_msg->data.u64 = 0x00FF220064000000;
					can_example_prepare_data_to_send();
80003f5e:	e0 6b 10 00 	mov	r11,4096
80003f62:	ea 1b 00 ff 	orh	r11,0xff
				return_value = 0;
			}
			switch (input_data & 0xFF000000)	{ /* command */
				case 0x10000000: /* ECUM request to confirm connection */
					if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
						pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU confirm the connection */
80003f66:	70 19       	ld.w	r9,r8[0x4]
80003f68:	93 0a       	st.w	r9[0x0],r10
						pCANMOB_message0[0].can_msg->data.u64 = 0x00FF100000000000;
80003f6a:	30 0a       	mov	r10,0
80003f6c:	70 18       	ld.w	r8,r8[0x4]
80003f6e:	f0 eb 00 08 	st.d	r8[8],r10
				return_value = 0;
			}
			switch (input_data & 0xFF000000)	{ /* command */
				case 0x10000000: /* ECUM request to confirm connection */
					if ((input_data & 0xFFFF00) == 0xFF00 /* temporal ECU ID*/)	{
						pCANMOB_message0[0].can_msg->id = 0x6FB;	/* ECU confirm the connection */
80003f72:	c0 5e       	rcall	80003b7c <can_example_prepare_data_to_send>
80003f74:	30 1c       	mov	r12,1
						pCANMOB_message0[0].can_msg->data.u64 = 0x00FF100000000000;
80003f76:	fe 9f fe 35 	bral	80003be0 <process_ecu_comm+0x24>
80003f7a:	d7 03       	nop
80003f7c:	80 06       	ld.sh	r6,r0[0x0]
						can_example_prepare_data_to_send();
80003f7e:	87 d4       	st.w	r3[0x34],r4
80003f80:	80 06       	ld.sh	r6,r0[0x0]
80003f82:	87 d8       	st.w	r3[0x34],r8
80003f84:	80 06       	ld.sh	r6,r0[0x0]
80003f86:	87 e0       	st.w	r3[0x38],r0
80003f88:	00 00       	add	r0,r0
80003f8a:	3c 90       	mov	r0,-55
80003f8c:	00 00       	add	r0,r0
80003f8e:	00 18       	sub	r8,r0
80003f90:	00 00       	add	r0,r0
80003f92:	4d 69       	lddpc	r9,800040e8 <can_out_callback_channel1>
80003f94:	80 06       	ld.sh	r6,r0[0x0]
80003f96:	87 e4       	st.w	r3[0x38],r4

80003f98 <can_example_prepare_data_to_receive>:
80003f98:	d4 01       	pushm	lr
80003f9a:	30 0a       	mov	r10,0
80003f9c:	fe c9 ff 04 	sub	r9,pc,-252
80003fa0:	48 9b       	lddpc	r11,80003fc4 <can_example_prepare_data_to_receive+0x2c>
80003fa2:	14 9c       	mov	r12,r10
80003fa4:	fe b0 fd 0c 	rcall	800039bc <can_init>
80003fa8:	30 0c       	mov	r12,0
80003faa:	fe b0 fb 09 	rcall	800035bc <can_mob_alloc>
80003fae:	48 78       	lddpc	r8,80003fc8 <can_example_prepare_data_to_receive+0x30>
80003fb0:	18 9b       	mov	r11,r12
80003fb2:	b0 8c       	st.b	r8[0x0],r12
80003fb4:	f1 3a 00 09 	ld.ub	r10,r8[9]
80003fb8:	70 19       	ld.w	r9,r8[0x4]
80003fba:	30 0c       	mov	r12,0
	can_init(0, ((U32)&mob_ram_ch0[0]), CANIF_CHANNEL_MODE_NORMAL, can_out_callback_channel0);

	// Allocate one mob for RX
	pCANMOB_message2[0].handle = can_mob_alloc(0);

	can_rx(0, pCANMOB_message2[0].handle, pCANMOB_message2[0].req_type, pCANMOB_message2[0].can_msg);
80003fbc:	fe b0 fc 06 	rcall	800037c8 <can_rx>
}
80003fc0:	d8 02       	popm	pc
80003fc2:	d7 03       	nop
80003fc4:	00 00       	add	r0,r0
80003fc6:	3c 94       	mov	r4,-55
80003fc8:	00 00       	add	r0,r0
80003fca:	00 90       	mov	r0,r0

80003fcc <can_task>:
80003fcc:	eb cd 40 80 	pushm	r7,lr
80003fd0:	4a 17       	lddpc	r7,80004054 <can_task+0x88>
80003fd2:	30 08       	mov	r8,0
80003fd4:	0f 89       	ld.ub	r9,r7[0x0]
80003fd6:	f0 09 18 00 	cp.b	r9,r8
void can_task(void)
{
	static bool rcvFlag = false;
	static unsigned tx_counter_ = 0;

	if (!rcvFlag)	{
80003fda:	c1 90       	breq	8000400c <can_task+0x40>
		can_example_prepare_data_to_receive();
		rcvFlag = true;
		printf ("can recv prepare\n");
	}		

	if (counter_ ==  55){
80003fdc:	49 f8       	lddpc	r8,80004058 <can_task+0x8c>
80003fde:	70 09       	ld.w	r9,r8[0x0]
80003fe0:	e0 49 00 37 	cp.w	r9,55
80003fe4:	c1 b0       	breq	8000401a <can_task+0x4e>
		pCANMOB_message0[0].can_msg->id = 0x6FC;
		pCANMOB_message0[0].can_msg->data.u64 = (0x1234FFFFFFFFFF01 + tx_counter_);
		can_example_prepare_data_to_send();						
	}

	if (message_received_on_channel0 == true) {
80003fe6:	49 e8       	lddpc	r8,8000405c <can_task+0x90>
80003fe8:	11 89       	ld.ub	r9,r8[0x0]
80003fea:	58 09       	cp.w	r9,0
80003fec:	c0 e0       	breq	80004008 <can_task+0x3c>
		message_received_on_channel0 = false;
80003fee:	30 09       	mov	r9,0
		rcvFlag = false;
		
		printf ("RECV from ECU mng via CAN\n");
80003ff0:	49 cc       	lddpc	r12,80004060 <can_task+0x94>
		pCANMOB_message0[0].can_msg->data.u64 = (0x1234FFFFFFFFFF01 + tx_counter_);
		can_example_prepare_data_to_send();						
	}

	if (message_received_on_channel0 == true) {
		message_received_on_channel0 = false;
80003ff2:	b0 89       	st.b	r8[0x0],r9
		rcvFlag = false;
80003ff4:	ae 89       	st.b	r7[0x0],r9
		
		printf ("RECV from ECU mng via CAN\n");
80003ff6:	e0 a0 9e 0d 	rcall	80017c10 <puts>
		 
		process_ecu_comm(pCANMOB_message2[0].can_msg->id, pCANMOB_message2[0].can_msg->data.u64);						
80003ffa:	49 b8       	lddpc	r8,80004064 <can_task+0x98>
80003ffc:	70 18       	ld.w	r8,r8[0x4]
80003ffe:	70 0c       	ld.w	r12,r8[0x0]
80004000:	f0 ea 00 08 	ld.d	r10,r8[8]
80004004:	fe b0 fd dc 	rcall	80003bbc <process_ecu_comm>
80004008:	e3 cd 80 80 	ldm	sp++,r7,pc
{
	static bool rcvFlag = false;
	static unsigned tx_counter_ = 0;

	if (!rcvFlag)	{
		can_example_prepare_data_to_receive();
8000400c:	cc 6f       	rcall	80003f98 <can_example_prepare_data_to_receive>
8000400e:	30 18       	mov	r8,1
		rcvFlag = true;
80004010:	49 6c       	lddpc	r12,80004068 <can_task+0x9c>
		printf ("can recv prepare\n");
80004012:	ae 88       	st.b	r7[0x0],r8
	static bool rcvFlag = false;
	static unsigned tx_counter_ = 0;

	if (!rcvFlag)	{
		can_example_prepare_data_to_receive();
		rcvFlag = true;
80004014:	e0 a0 9d fe 	rcall	80017c10 <puts>
		printf ("can recv prepare\n");
80004018:	ce 2b       	rjmp	80003fdc <can_task+0x10>
8000401a:	30 0a       	mov	r10,0
	}		

	if (counter_ ==  55){
		counter_ = 0;
8000401c:	91 0a       	st.w	r8[0x0],r10
8000401e:	49 48       	lddpc	r8,8000406c <can_task+0xa0>
		tx_counter_ ++;
80004020:	e0 6c 06 fc 	mov	r12,1788

		pCANMOB_message0[0].can_msg->id = 0x6FC;
80004024:	70 0b       	ld.w	r11,r8[0x0]
		printf ("can recv prepare\n");
	}		

	if (counter_ ==  55){
		counter_ = 0;
		tx_counter_ ++;
80004026:	2f fb       	sub	r11,-1
80004028:	91 0b       	st.w	r8[0x0],r11
8000402a:	49 28       	lddpc	r8,80004070 <can_task+0xa4>

		pCANMOB_message0[0].can_msg->id = 0x6FC;
8000402c:	70 19       	ld.w	r9,r8[0x4]
8000402e:	93 0c       	st.w	r9[0x0],r12
80004030:	14 99       	mov	r9,r10
		pCANMOB_message0[0].can_msg->data.u64 = (0x1234FFFFFFFFFF01 + tx_counter_);
80004032:	70 1c       	ld.w	r12,r8[0x4]
80004034:	fe 7a ff 01 	mov	r10,-255
80004038:	16 98       	mov	r8,r11
8000403a:	e0 6b ff ff 	mov	r11,65535
8000403e:	ea 1b 12 34 	orh	r11,0x1234
80004042:	14 08       	add	r8,r10
80004044:	f2 0b 00 49 	adc	r9,r9,r11
80004048:	f8 e9 00 08 	st.d	r12[8],r8
8000404c:	fe b0 fd 98 	rcall	80003b7c <can_example_prepare_data_to_send>
		can_example_prepare_data_to_send();						
80004050:	cc bb       	rjmp	80003fe6 <can_task+0x1a>
80004052:	d7 03       	nop
80004054:	00 00       	add	r0,r0
80004056:	06 15       	sub	r5,r3
80004058:	00 00       	add	r0,r0
8000405a:	3c 8c       	mov	r12,-56
8000405c:	00 00       	add	r0,r0
8000405e:	06 14       	sub	r4,r3
80004060:	80 06       	ld.sh	r6,r0[0x0]
80004062:	88 04       	ld.sh	r4,r4[0x0]
80004064:	00 00       	add	r0,r0
80004066:	00 90       	mov	r0,r0
80004068:	80 06       	ld.sh	r6,r0[0x0]
8000406a:	87 f0       	st.w	r3[0x3c],r0
8000406c:	00 00       	add	r0,r0
8000406e:	06 10       	sub	r0,r3
80004070:	00 00       	add	r0,r0
80004072:	00 18       	sub	r8,r0

80004074 <can_task_init>:
80004074:	d4 01       	pushm	lr
80004076:	30 09       	mov	r9,0
80004078:	30 3b       	mov	r11,3
8000407a:	12 9a       	mov	r10,r9
8000407c:	30 1c       	mov	r12,1
8000407e:	e0 a0 24 07 	rcall	8000888c <scif_gc_setup>
80004082:	30 1c       	mov	r12,1
	scif_gc_setup(AVR32_SCIF_GCLK_CANIF,
		SCIF_GCCTRL_OSC0,
		AVR32_SCIF_GC_NO_DIV_CLOCK,
		0);
	// Now enable the generic clock
	scif_gc_enable(AVR32_SCIF_GCLK_CANIF);
80004084:	e0 a0 24 4d 	rcall	8000891e <scif_gc_enable>
	static const gpio_map_t CAN_GPIO_MAP = {
		{AVR32_CANIF_RXLINE_0_0_PIN, AVR32_CANIF_RXLINE_0_0_FUNCTION},
		{AVR32_CANIF_TXLINE_0_0_PIN, AVR32_CANIF_TXLINE_0_0_FUNCTION}
	};
	// Assign GPIO to CAN.
	gpio_enable_module(CAN_GPIO_MAP,
80004088:	30 2b       	mov	r11,2
8000408a:	48 3c       	lddpc	r12,80004094 <can_task_init+0x20>
8000408c:	e0 a0 22 ea 	rcall	80008660 <gpio_enable_module>
		sizeof(CAN_GPIO_MAP) / sizeof(CAN_GPIO_MAP[0]));
	/*	can_example_prepare_data_to_send();
	*/	can_example_prepare_data_to_receive();
80004090:	c8 4f       	rcall	80003f98 <can_example_prepare_data_to_receive>
80004092:	d8 02       	popm	pc

}
80004094:	80 06       	ld.sh	r6,r0[0x0]
80004096:	88 20       	ld.sh	r0,r4[0x4]

80004098 <can_out_callback_channel0>:
80004098:	d4 21       	pushm	r4-r7,lr
8000409a:	18 97       	mov	r7,r12
8000409c:	16 95       	mov	r5,r11
8000409e:	37 6c       	mov	r12,118
800040a0:	e0 a0 23 24 	rcall	800086e8 <gpio_tgl_gpio_pin>
800040a4:	48 f6       	lddpc	r6,800040e0 <can_out_callback_channel0+0x48>
800040a6:	30 0c       	mov	r12,0
800040a8:	6c 14       	ld.w	r4,r6[0x4]
800040aa:	0e 9b       	mov	r11,r7
 */
void can_out_callback_channel0(U8 handle, U8 event)
{
	gpio_tgl_gpio_pin(LED3_GPIO);
	// Reception Only
	pCANMOB_message2[0].can_msg->data.u64 = can_get_mob_data(0,handle).u64;
800040ac:	fe b0 fb ff 	rcall	800038aa <can_get_mob_data>
	pCANMOB_message2[0].can_msg->id = can_get_mob_id(0,handle);
800040b0:	30 0c       	mov	r12,0
 */
void can_out_callback_channel0(U8 handle, U8 event)
{
	gpio_tgl_gpio_pin(LED3_GPIO);
	// Reception Only
	pCANMOB_message2[0].can_msg->data.u64 = can_get_mob_data(0,handle).u64;
800040b2:	e8 eb 00 08 	st.d	r4[8],r10
	pCANMOB_message2[0].can_msg->id = can_get_mob_id(0,handle);
800040b6:	0e 9b       	mov	r11,r7
800040b8:	6c 14       	ld.w	r4,r6[0x4]
800040ba:	fe b0 fc 0e 	rcall	800038d6 <can_get_mob_id>
	pCANMOB_message2[0].dlc = can_get_mob_dlc(0,handle);
800040be:	0e 9b       	mov	r11,r7
void can_out_callback_channel0(U8 handle, U8 event)
{
	gpio_tgl_gpio_pin(LED3_GPIO);
	// Reception Only
	pCANMOB_message2[0].can_msg->data.u64 = can_get_mob_data(0,handle).u64;
	pCANMOB_message2[0].can_msg->id = can_get_mob_id(0,handle);
800040c0:	89 0c       	st.w	r4[0x0],r12
	pCANMOB_message2[0].dlc = can_get_mob_dlc(0,handle);
800040c2:	30 0c       	mov	r12,0
800040c4:	fe b0 fb fe 	rcall	800038c0 <can_get_mob_dlc>
	pCANMOB_message2[0].status = event;
	can_mob_free(0,handle);
800040c8:	0e 9b       	mov	r11,r7
{
	gpio_tgl_gpio_pin(LED3_GPIO);
	// Reception Only
	pCANMOB_message2[0].can_msg->data.u64 = can_get_mob_data(0,handle).u64;
	pCANMOB_message2[0].can_msg->id = can_get_mob_id(0,handle);
	pCANMOB_message2[0].dlc = can_get_mob_dlc(0,handle);
800040ca:	ed 6c 00 08 	st.b	r6[8],r12
	pCANMOB_message2[0].status = event;
800040ce:	ed 65 00 0a 	st.b	r6[10],r5
	can_mob_free(0,handle);
800040d2:	30 0c       	mov	r12,0
800040d4:	fe b0 fa ce 	rcall	80003670 <can_mob_free>
	message_received_on_channel0 = true;
800040d8:	30 19       	mov	r9,1
800040da:	48 38       	lddpc	r8,800040e4 <can_out_callback_channel0+0x4c>
800040dc:	b0 89       	st.b	r8[0x0],r9
	
	//printf ("recv data via can0\n");
}
800040de:	d8 22       	popm	r4-r7,pc
800040e0:	00 00       	add	r0,r0
800040e2:	00 90       	mov	r0,r0
800040e4:	00 00       	add	r0,r0
800040e6:	06 14       	sub	r4,r3

800040e8 <can_out_callback_channel1>:
800040e8:	eb cd 40 80 	pushm	r7,lr
800040ec:	18 97       	mov	r7,r12
800040ee:	37 7c       	mov	r12,119
800040f0:	e0 a0 22 fc 	rcall	800086e8 <gpio_tgl_gpio_pin>
800040f4:	0e 9b       	mov	r11,r7
800040f6:	30 1c       	mov	r12,1
800040f8:	fe b0 fa bc 	rcall	80003670 <can_mob_free>
void can_out_callback_channel1(U8 handle, U8 event)
{
	gpio_tgl_gpio_pin(LED1_GPIO);
	// Transmission Only
	can_mob_free(1,handle);
	message_transmitted_on_channel1 = true;
800040fc:	30 19       	mov	r9,1
800040fe:	48 38       	lddpc	r8,80004108 <can_out_callback_channel1+0x20>
80004100:	b0 89       	st.b	r8[0x0],r9
}
80004102:	e3 cd 80 80 	ldm	sp++,r7,pc
80004106:	d7 03       	nop
80004108:	00 00       	add	r0,r0
8000410a:	06 0c       	add	r12,r3

8000410c <codec_RegisterWrite>:

	return result;
}

Type_Result codec_RegisterWrite(TYPE_U8 regAddr, TYPE_U8 regData)
{
8000410c:	d4 01       	pushm	lr
8000410e:	20 1d       	sub	sp,4
80004110:	ba 8b       	st.b	sp[0x0],r11
	Type_Result result;

	result = dac_write(&regData, 1, regAddr);
80004112:	f5 dc b0 08 	bfexts	r10,r12,0x0,0x8
80004116:	30 1b       	mov	r11,1
80004118:	1a 9c       	mov	r12,sp
8000411a:	e0 a0 14 03 	rcall	80006920 <dac_write>
8000411e:	30 08       	mov	r8,0
80004120:	f8 08 0d 4c 	min	r12,r12,r8
	{
		return ERR_NONE;
	}

	return result;
}
80004124:	5c 8c       	casts.h	r12
80004126:	2f fd       	sub	sp,-4
80004128:	d8 02       	popm	pc
8000412a:	d7 03       	nop

8000412c <CODEC_setAttenuation>:
8000412c:	eb cd 40 c0 	pushm	r6-r7,lr
 *                  an outside routine should map MOST volume values to Codec Attn values
 *  RETURNS:      >0 = success, <0 is one of the I2C errors
 */
/*-------------------------------------------------------------------------------------------------------------------*/
s16_t CODEC_setAttenuation(u8_t ch, u8_t value)
{
80004130:	16 96       	mov	r6,r11
   s16_t ret;
   u8_t regAddr;
   
   regAddr = (ch *2) + CODEC_DAC1_VOL;
80004132:	f8 c7 ff fc 	sub	r7,r12,-4

   LOG_NOR("Setting Volume ...\n");
80004136:	48 8c       	lddpc	r12,80004154 <CODEC_setAttenuation+0x28>
s16_t CODEC_setAttenuation(u8_t ch, u8_t value)
{
   s16_t ret;
   u8_t regAddr;
   
   regAddr = (ch *2) + CODEC_DAC1_VOL;
80004138:	a1 77       	lsl	r7,0x1
8000413a:	5c 57       	castu.b	r7

   LOG_NOR("Setting Volume ...\n");
8000413c:	e0 a0 9d 6a 	rcall	80017c10 <puts>
   ret = codec_RegisterWrite(regAddr, value);
80004140:	0c 9b       	mov	r11,r6
80004142:	0e 9c       	mov	r12,r7
80004144:	ce 4f       	rcall	8000410c <codec_RegisterWrite>
80004146:	0e 9c       	mov	r12,r7
   ret = codec_RegisterWrite((regAddr+1), value);
80004148:	0c 9b       	mov	r11,r6
8000414a:	2f fc       	sub	r12,-1
8000414c:	5c 5c       	castu.b	r12
8000414e:	cd ff       	rcall	8000410c <codec_RegisterWrite>
80004150:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   return ret;
} // SetAttenaution()
80004154:	80 06       	ld.sh	r6,r0[0x0]
80004156:	88 30       	ld.sh	r0,r4[0x6]

80004158 <CODEC_setVolume>:
80004158:	d4 01       	pushm	lr
8000415a:	58 0b       	cp.w	r11,0
8000415c:	c0 70       	breq	8000416a <CODEC_setVolume+0x12>
8000415e:	f6 0b 11 28 	rsub	r11,r11,40
80004162:	a1 7b       	lsl	r11,0x1
   //                 20       28 ( 40)  -20 dB
   //                 30       14 ( 20)  -10 dB
   //                 38       04 (  4)  - 2 dB
   //                 39       02 (  2)  - 1 dB
   //                 40       00 (  0)    0 dB
   if (0 == value)      // special case, 0 causes attn to be bigger than byte
80004164:	5c 5b       	castu.b	r11
   }
   else
   {
      attn = (40 - value)*2;     // change sense & make each step 1 dB
   }
   CODEC_setAttenuation(ch, attn);
80004166:	ce 3f       	rcall	8000412c <CODEC_setAttenuation>
80004168:	d8 02       	popm	pc
}
8000416a:	e0 6b 00 ff 	mov	r11,255
   //                 20       28 ( 40)  -20 dB
   //                 30       14 ( 20)  -10 dB
   //                 38       04 (  4)  - 2 dB
   //                 39       02 (  2)  - 1 dB
   //                 40       00 (  0)    0 dB
   if (0 == value)      // special case, 0 causes attn to be bigger than byte
8000416e:	cd ff       	rcall	8000412c <CODEC_setAttenuation>
   }
   else
   {
      attn = (40 - value)*2;     // change sense & make each step 1 dB
   }
   CODEC_setAttenuation(ch, attn);
80004170:	d8 02       	popm	pc
80004172:	d7 03       	nop

80004174 <CODEC_demute>:
}
80004174:	d4 01       	pushm	lr
80004176:	48 4c       	lddpc	r12,80004184 <CODEC_demute+0x10>
80004178:	e0 a0 9d 4c 	rcall	80017c10 <puts>
#ifdef DEV_USE_BUB85650
   return ERR_NONE;
#endif

   LOG_NOR("DeMuting Codec ... \n");
   result = codec_RegisterWrite(CODEC_DAC_MUTE, 0x00);
8000417c:	30 0b       	mov	r11,0
8000417e:	30 7c       	mov	r12,7
80004180:	cc 6f       	rcall	8000410c <codec_RegisterWrite>
80004182:	d8 02       	popm	pc
   return result;
} // DeMute()
80004184:	80 06       	ld.sh	r6,r0[0x0]
80004186:	88 44       	ld.sh	r4,r4[0x8]

80004188 <codec_RegisterRead>:
80004188:	d4 01       	pushm	lr
8000418a:	18 9a       	mov	r10,r12
8000418c:	16 9c       	mov	r12,r11
8000418e:	30 1b       	mov	r11,1
80004190:	e0 a0 14 0c 	rcall	800069a8 <dac_read>

Type_Result codec_RegisterRead(TYPE_U8 regAddr, TYPE_U8 * regData_ptr)
{
	Type_Result result;

	result = dac_read(regData_ptr, 1, regAddr);
80004194:	30 08       	mov	r8,0
80004196:	f8 08 0d 4c 	min	r12,r12,r8
	{
		return ERR_NONE;
	}

	return result;
}
8000419a:	5c 8c       	casts.h	r12
8000419c:	d8 02       	popm	pc
8000419e:	d7 03       	nop

800041a0 <CODEC_setDefaultValues>:
800041a0:	d4 31       	pushm	r0-r7,lr
800041a2:	20 1d       	sub	sp,4
	u8_t data_in;
	u8_t i;
	s16_t ret;

	// codec being held in reset till now, let it go
	codec_ReleaseReset();
800041a4:	fe b0 fc d4 	rcall	80003b4c <codec_ReleaseReset>
	LOG_NOR("Initializing CS42448 CODEC ... \n");
800041a8:	4a bc       	lddpc	r12,80004254 <CODEC_setDefaultValues+0xb4>
800041aa:	e0 a0 9d 33 	rcall	80017c10 <puts>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800041ae:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800041b2:	e0 79 38 80 	mov	r9,80000
800041b6:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800041ba:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800041be:	14 38       	cp.w	r8,r10
800041c0:	e0 88 00 38 	brls	80004230 <CODEC_setDefaultValues+0x90>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800041c4:	10 39       	cp.w	r9,r8
800041c6:	cf a2       	brcc	800041ba <CODEC_setDefaultValues+0x1a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800041c8:	14 39       	cp.w	r9,r10
800041ca:	fe 98 ff f8 	brls	800041ba <CODEC_setDefaultValues+0x1a>
800041ce:	4a 37       	lddpc	r7,80004258 <CODEC_setDefaultValues+0xb8>
800041d0:	4a 31       	lddpc	r1,8000425c <CODEC_setDefaultValues+0xbc>
 *  DESCRIPTION:  A "debug" version of initializing CODEC
 *                  Prints each register's initial and final value as it programs them
 *  RETURNS:      >0 = success, <0 is one of the I2C errors
 */
/*-------------------------------------------------------------------------------------------------------------------*/
s16_t CODEC_setDefaultValues(void)
800041d2:	ee c3 ff f4 	sub	r3,r7,-12
		data_out = cs42448_defaults[i * 2 + 1]; // Register value (byte)

		ret = codec_RegisterWrite(map, data_out);
		if (ERR_NONE == ret)
		{
			MyNode.CodecPresent = TRUE; // codec responded
800041d6:	30 10       	mov	r0,1
			delay_ms(1); // codec must have some time between commands
			codec_RegisterRead(map, &data_in);
800041d8:	fa c4 ff fd 	sub	r4,sp,-3
800041dc:	c1 48       	rjmp	80004204 <CODEC_setDefaultValues+0x64>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800041de:	12 38       	cp.w	r8,r9
800041e0:	e0 88 00 1f 	brls	8000421e <CODEC_setDefaultValues+0x7e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800041e4:	12 3a       	cp.w	r10,r9
800041e6:	c1 c2       	brcc	8000421e <CODEC_setDefaultValues+0x7e>
800041e8:	08 9b       	mov	r11,r4
800041ea:	0c 9c       	mov	r12,r6
800041ec:	cc ef       	rcall	80004188 <codec_RegisterRead>
800041ee:	1b b8       	ld.ub	r8,sp[0x3]
			LOG_NOR("CS42448 Register, Value written, Value read: %02X %02X %02X\n", map, data_out, data_in);
800041f0:	2f e7       	sub	r7,-2
800041f2:	1a d8       	st.w	--sp,r8
800041f4:	49 bc       	lddpc	r12,80004260 <CODEC_setDefaultValues+0xc0>
800041f6:	1a d5       	st.w	--sp,r5
800041f8:	1a d6       	st.w	--sp,r6
800041fa:	e0 a0 9c 75 	rcall	80017ae4 <printf>
800041fe:	2f dd       	sub	sp,-12
	// codec being held in reset till now, let it go
	codec_ReleaseReset();
	LOG_NOR("Initializing CS42448 CODEC ... \n");
	delay_ms(5);

	for (i = 0; i < CODEC_INIT_REGS; i++) // Setting register defaults of MAX9850
80004200:	06 37       	cp.w	r7,r3
80004202:	c1 a0       	breq	80004236 <CODEC_setDefaultValues+0x96>
80004204:	0f 95       	ld.ub	r5,r7[0x1]
	{

		map = (cs42448_defaults[i * 2 + 0]); // Register adr.
		data_out = cs42448_defaults[i * 2 + 1]; // Register value (byte)

		ret = codec_RegisterWrite(map, data_out);
80004206:	0f 86       	ld.ub	r6,r7[0x0]
80004208:	0a 9b       	mov	r11,r5
8000420a:	0c 9c       	mov	r12,r6
8000420c:	c8 0f       	rcall	8000410c <codec_RegisterWrite>
8000420e:	18 92       	mov	r2,r12
80004210:	c1 91       	brne	80004242 <CODEC_setDefaultValues+0xa2>
80004212:	e3 60 00 1a 	st.b	r1[26],r0
		if (ERR_NONE == ret)
		{
			MyNode.CodecPresent = TRUE; // codec responded
80004216:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000421a:	f0 ca c1 80 	sub	r10,r8,-16000
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000421e:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80004222:	14 38       	cp.w	r8,r10
80004224:	fe 9b ff dd 	brhi	800041de <CODEC_setDefaultValues+0x3e>
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80004228:	12 38       	cp.w	r8,r9
8000422a:	fe 9b ff df 	brhi	800041e8 <CODEC_setDefaultValues+0x48>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000422e:	cd bb       	rjmp	800041e4 <CODEC_setDefaultValues+0x44>
80004230:	10 39       	cp.w	r9,r8
80004232:	cc b2       	brcc	800041c8 <CODEC_setDefaultValues+0x28>
80004234:	cc db       	rjmp	800041ce <CODEC_setDefaultValues+0x2e>
80004236:	48 cc       	lddpc	r12,80004264 <CODEC_setDefaultValues+0xc4>
80004238:	e0 a0 9c ec 	rcall	80017c10 <puts>
		}
	}
	// if everything was OK, now enable DAC (take out of Shutdown)
	if (ERR_NONE == ret)
	{
		LOG_NOR("Initializing done - CODEC enabled now ... \n");
8000423c:	04 9c       	mov	r12,r2
8000423e:	2f fd       	sub	sp,-4
	}

	return (ret);
}
80004240:	d8 32       	popm	r0-r7,pc
80004242:	30 08       	mov	r8,0
80004244:	48 9c       	lddpc	r12,80004268 <CODEC_setDefaultValues+0xc8>
			MyNode.CodecPresent = TRUE; // codec responded
			delay_ms(1); // codec must have some time between commands
			codec_RegisterRead(map, &data_in);
			LOG_NOR("CS42448 Register, Value written, Value read: %02X %02X %02X\n", map, data_out, data_in);
		} else {
			MyNode.CodecPresent = FALSE; // can't talk to codec
80004246:	e3 68 00 1a 	st.b	r1[26],r8
8000424a:	e0 a0 9c e3 	rcall	80017c10 <puts>
			LOG_ERR("Error writing to Codec\n");
8000424e:	04 9c       	mov	r12,r2
80004250:	2f fd       	sub	sp,-4
	{
		LOG_NOR("Initializing done - CODEC enabled now ... \n");
	}

	return (ret);
}
80004252:	d8 32       	popm	r0-r7,pc
80004254:	80 06       	ld.sh	r6,r0[0x0]
80004256:	88 6c       	ld.sh	r12,r4[0xc]
80004258:	80 06       	ld.sh	r6,r0[0x0]
8000425a:	89 2c       	st.w	r4[0x8],r12
8000425c:	00 00       	add	r0,r0
8000425e:	40 06       	lddsp	r6,sp[0x0]
80004260:	80 06       	ld.sh	r6,r0[0x0]
80004262:	88 ec       	ld.uh	r12,r4[0xc]
80004264:	80 06       	ld.sh	r6,r0[0x0]
80004266:	88 c0       	ld.uh	r0,r4[0x8]
80004268:	80 06       	ld.sh	r6,r0[0x0]
8000426a:	88 a8       	ld.uh	r8,r4[0x4]

8000426c <controller_key_fct3>:
		&joystick_key_sensibility_timer);
}

// FCT3/ Up
bool controller_key_fct3(void)
{
8000426c:	48 38       	lddpc	r8,80004278 <controller_key_fct3+0xc>
8000426e:	11 8c       	ld.ub	r12,r8[0x0]
	if (touch_data.detect_status & (1 << 0)) {
		return true;
	}
	return false;
}
80004270:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80004274:	5e fc       	retal	r12
80004276:	d7 03       	nop
80004278:	00 00       	add	r0,r0
8000427a:	3f a4       	mov	r4,-6

8000427c <controller_key_fct4>:

// FCT4/ Down
bool controller_key_fct4(void)
{
8000427c:	48 38       	lddpc	r8,80004288 <controller_key_fct4+0xc>
8000427e:	11 8c       	ld.ub	r12,r8[0x0]
	if (touch_data.detect_status & (1 << 1)) {
		return true;
	}
	return false;
}
80004280:	f9 dc c0 21 	bfextu	r12,r12,0x1,0x1
80004284:	5e fc       	retal	r12
80004286:	d7 03       	nop
80004288:	00 00       	add	r0,r0
8000428a:	3f a4       	mov	r4,-6

8000428c <controller_key_fct1>:

// FCT1/ Right button
bool controller_key_fct1(void)
{
8000428c:	48 38       	lddpc	r8,80004298 <controller_key_fct1+0xc>
8000428e:	11 8c       	ld.ub	r12,r8[0x0]
	if (touch_data.detect_status & (1 << 2)) {
		return true;
	}
	return false;
}
80004290:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
80004294:	5e fc       	retal	r12
80004296:	d7 03       	nop
80004298:	00 00       	add	r0,r0
8000429a:	3f a4       	mov	r4,-6

8000429c <controller_key_fct2>:

// FCT2/ Left
bool controller_key_fct2(void)
{
8000429c:	48 38       	lddpc	r8,800042a8 <controller_key_fct2+0xc>
8000429e:	11 8c       	ld.ub	r12,r8[0x0]
	if (touch_data.detect_status & (1 << 3)) {
		return true;
	}
	return false;
}
800042a0:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
800042a4:	5e fc       	retal	r12
800042a6:	d7 03       	nop
800042a8:	00 00       	add	r0,r0
800042aa:	3f a4       	mov	r4,-6

800042ac <controller_key_fct5>:

// FCT5/ Middle
bool controller_key_fct5(void)
{
800042ac:	48 38       	lddpc	r8,800042b8 <controller_key_fct5+0xc>
800042ae:	11 8c       	ld.ub	r12,r8[0x0]
	if (touch_data.detect_status & (1 << 4)) {
		return true;
	}
	return false;
}
800042b0:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800042b4:	5e fc       	retal	r12
800042b6:	d7 03       	nop
800042b8:	00 00       	add	r0,r0
800042ba:	3f a4       	mov	r4,-6

800042bc <controller_init>:
		touch_detect = false;
	}
}

void controller_init(uint32_t fcpu_hz, uint32_t fhsb_hz, uint32_t fpbb_hz, uint32_t fpba_hz)
{
800042bc:	d4 01       	pushm	lr
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800042be:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800042c2:	e0 6a 27 00 	mov	r10,9984
800042c6:	ea 1a 00 38 	orh	r10,0x38
800042ca:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800042ce:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800042d2:	14 38       	cp.w	r8,r10
800042d4:	e0 88 00 16 	brls	80004300 <controller_init+0x44>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800042d8:	12 38       	cp.w	r8,r9
800042da:	fe 98 ff fa 	brls	800042ce <controller_init+0x12>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800042de:	12 3a       	cp.w	r10,r9
800042e0:	cf 72       	brcc	800042ce <controller_init+0x12>
	// wait until the device settles its CHG line
	delay_ms(230);
	at42qt1060_init(fcpu_hz);
800042e2:	fe b0 f4 3d 	rcall	80002b5c <at42qt1060_init>
	at42qt1060_register_int(&touch_detect_callback);
800042e6:	fe cc ff ae 	sub	r12,pc,-82
800042ea:	fe b0 f3 b5 	rcall	80002a54 <at42qt1060_register_int>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800042ee:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800042f2:	48 68       	lddpc	r8,80004308 <controller_init+0x4c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800042f4:	91 19       	st.w	r8[0x4],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800042f6:	91 09       	st.w	r8[0x0],r9
800042f8:	30 09       	mov	r9,0
800042fa:	f1 69 00 08 	st.b	r8[8],r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800042fe:	d8 02       	popm	pc
80004300:	12 38       	cp.w	r8,r9
80004302:	fe 9b ff f0 	brhi	800042e2 <controller_init+0x26>
80004306:	ce cb       	rjmp	800042de <controller_init+0x22>
80004308:	00 00       	add	r0,r0
8000430a:	3f 98       	mov	r8,-7

8000430c <controller_task>:
8000430c:	eb cd 40 80 	pushm	r7,lr
80004310:	48 87       	lddpc	r7,80004330 <controller_task+0x24>
80004312:	0f 88       	ld.ub	r8,r7[0x0]
80004314:	58 08       	cp.w	r8,0
80004316:	c0 b0       	breq	8000432c <controller_task+0x20>
void controller_task(void)
{
	// if a touch is detected we read the status
	if (touch_detect) {
		touch_data.detect_status =
			at42qt1060_read_reg(AT42QT1060_DETECTION_STATUS);
80004318:	30 4c       	mov	r12,4
8000431a:	fe b0 f3 c9 	rcall	80002aac <at42qt1060_read_reg>
struct at42qt1060_data touch_data;
void controller_task(void)
{
	// if a touch is detected we read the status
	if (touch_detect) {
		touch_data.detect_status =
8000431e:	48 68       	lddpc	r8,80004334 <controller_task+0x28>
80004320:	b0 8c       	st.b	r8[0x0],r12
			at42qt1060_read_reg(AT42QT1060_DETECTION_STATUS);
		// need to read input port status too to reset CHG line
		at42qt1060_read_reg(AT42QT1060_INPUT_PORT_STATUS);
80004322:	30 5c       	mov	r12,5
80004324:	fe b0 f3 c4 	rcall	80002aac <at42qt1060_read_reg>
		touch_detect = false;
80004328:	30 08       	mov	r8,0
8000432a:	ae 88       	st.b	r7[0x0],r8
8000432c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004330:	00 00       	add	r0,r0
80004332:	06 16       	sub	r6,r3
80004334:	00 00       	add	r0,r0
80004336:	3f a4       	mov	r4,-6

80004338 <touch_detect_callback>:
80004338:	d4 01       	pushm	lr
8000433a:	34 7c       	mov	r12,71
 */


__attribute__((__interrupt__))void touch_detect_callback(void)
{
	if(gpio_get_pin_interrupt_flag(AT42QT1060_DETECT_PIN)) {
8000433c:	e0 a0 22 08 	rcall	8000874c <gpio_get_pin_interrupt_flag>
80004340:	c0 70       	breq	8000434e <touch_detect_callback+0x16>
		gpio_clear_pin_interrupt_flag(AT42QT1060_DETECT_PIN);
80004342:	34 7c       	mov	r12,71
80004344:	e0 a0 22 10 	rcall	80008764 <gpio_clear_pin_interrupt_flag>
		touch_detect = true;
80004348:	30 19       	mov	r9,1
8000434a:	48 38       	lddpc	r8,80004354 <touch_detect_callback+0x1c>
8000434c:	b0 89       	st.b	r8[0x0],r9
	}
}
8000434e:	d4 02       	popm	lr
80004350:	d6 03       	rete
80004352:	d7 03       	nop
80004354:	00 00       	add	r0,r0
80004356:	06 16       	sub	r6,r3

80004358 <SCError_Timeout>:
	}
}


void SCError_Timeout(void)
{
80004358:	d4 01       	pushm	lr
    LOG_ERR("Timed out while trying to automatically disconnect /destroy sockets after SCError\n");
8000435a:	48 3c       	lddpc	r12,80004364 <SCError_Timeout+0xc>
8000435c:	e0 a0 9c 5a 	rcall	80017c10 <puts>
}
80004360:	d8 02       	popm	pc
80004362:	d7 03       	nop
80004364:	80 06       	ld.sh	r6,r0[0x0]
80004366:	89 38       	st.w	r4[0xc],r8

80004368 <InitPorts_Timeout>:
80004368:	d4 01       	pushm	lr
8000436a:	48 3c       	lddpc	r12,80004374 <InitPorts_Timeout+0xc>
	}
}

void InitPorts_Timeout (void)
{
    LOG_ERR("Timed out during Open Port process\n");
8000436c:	e0 a0 9c 52 	rcall	80017c10 <puts>
}
80004370:	d8 02       	popm	pc
80004372:	d7 03       	nop
80004374:	80 06       	ld.sh	r6,r0[0x0]
80004376:	89 8c       	st.w	r4[0x20],r12

80004378 <OpenSerialPort>:
80004378:	d4 01       	pushm	lr
8000437a:	20 2d       	sub	sp,8
uint8_t OpenSerialPort(void)
{
    TScmPortDesc PortDesc, *pPortDesc;
    uint8_t result;

    LOG_NOR("Opening Streaming Port...\n");
8000437c:	48 9c       	lddpc	r12,800043a0 <OpenSerialPort+0x28>
8000437e:	e0 a0 9c 49 	rcall	80017c10 <puts>

    pPortDesc = &PortDesc;
    pPortDesc->port_id = SCM_PORT_ID_STREAM; // Open Streaming Port
    pPortDesc->config.streaming.clock_drive_mode = SCM_PORT_CFG_STREAM_SCKFSY_INIC; // INIC is source of SCK and FSY
80004382:	30 08       	mov	r8,0
    pPortDesc->config.streaming.port_mode = SCM_PORT_CFG_STREAM_IN_OUT; // Full Streaming Mode
    pPortDesc->config.streaming.data_format = DELAY_64FS_16BIT; // Delayed bit 64Fs 16 bit I2S format
80004384:	ba e8       	st.b	sp[0x6],r8

    LOG_NOR("Opening Streaming Port...\n");

    pPortDesc = &PortDesc;
    pPortDesc->port_id = SCM_PORT_ID_STREAM; // Open Streaming Port
    pPortDesc->config.streaming.clock_drive_mode = SCM_PORT_CFG_STREAM_SCKFSY_INIC; // INIC is source of SCK and FSY
80004386:	ba c8       	st.b	sp[0x4],r8
    pPortDesc->config.streaming.port_mode = SCM_PORT_CFG_STREAM_IN_OUT; // Full Streaming Mode
80004388:	ba d8       	st.b	sp[0x5],r8
    uint8_t result;

    LOG_NOR("Opening Streaming Port...\n");

    pPortDesc = &PortDesc;
    pPortDesc->port_id = SCM_PORT_ID_STREAM; // Open Streaming Port
8000438a:	30 38       	mov	r8,3
    pPortDesc->config.streaming.clock_drive_mode = SCM_PORT_CFG_STREAM_SCKFSY_INIC; // INIC is source of SCK and FSY
    pPortDesc->config.streaming.port_mode = SCM_PORT_CFG_STREAM_IN_OUT; // Full Streaming Mode
    pPortDesc->config.streaming.data_format = DELAY_64FS_16BIT; // Delayed bit 64Fs 16 bit I2S format
    result = ScmOpenPort(pPortDesc, OpenSerialPort_CB);
8000438c:	fe cb ff 44 	sub	r11,pc,-188
80004390:	ba b8       	st.b	sp[0x3],r8
80004392:	fa cc ff fd 	sub	r12,sp,-3
80004396:	e0 a0 74 ad 	rcall	80012cf0 <ScmOpenPort>
    return (result);

}
8000439a:	2f ed       	sub	sp,-8
8000439c:	d8 02       	popm	pc
8000439e:	d7 03       	nop
800043a0:	80 06       	ld.sh	r6,r0[0x0]
800043a2:	89 b0       	st.w	r4[0x2c],r0

800043a4 <connection_manager>:
800043a4:	eb cd 40 80 	pushm	r7,lr
800043a8:	49 97       	lddpc	r7,8000440c <connection_manager+0x68>
800043aa:	6e 08       	ld.w	r8,r7[0x0]
 *  RETURNS:		nothing
 *
 */
void connection_manager(void)
{
	switch (connection_state)
800043ac:	58 08       	cp.w	r8,0
800043ae:	c0 91       	brne	800043c0 <connection_manager+0x1c>
	{
		case CON_IDLE:
		{
			if (TIMER_EXPIRED == TemperatureTimer.flag) // see if temperature timer has expired
800043b0:	49 88       	lddpc	r8,80004410 <connection_manager+0x6c>
800043b2:	30 29       	mov	r9,2
800043b4:	11 9a       	ld.ub	r10,r8[0x1]
800043b6:	f2 0a 18 00 	cp.b	r10,r9
800043ba:	c1 a0       	breq	800043ee <connection_manager+0x4a>
800043bc:	e3 cd 80 80 	ldm	sp++,r7,pc
 *  RETURNS:		nothing
 *
 */
void connection_manager(void)
{
	switch (connection_state)
800043c0:	58 18       	cp.w	r8,1
800043c2:	cf d1       	brne	800043bc <connection_manager+0x18>
			break; // just waiting for someone to request a SCM action
		}

		case SCM_PENDING:
		{
			if (TIMER_EXPIRED == ScmCmdTimer.flag) // check if command timer has expired
800043c4:	49 4c       	lddpc	r12,80004414 <connection_manager+0x70>
800043c6:	30 28       	mov	r8,2
800043c8:	19 99       	ld.ub	r9,r12[0x1]
800043ca:	f0 09 18 00 	cp.b	r9,r8
800043ce:	cf 71       	brne	800043bc <connection_manager+0x18>
			{
				StopTimer(&ScmCmdTimer); // kill the timer
800043d0:	e0 a0 14 d2 	rcall	80006d74 <StopTimer>
				LOG_ERR("Error: Pending Socket Connection Manager operation has timed out - retry...\n");
800043d4:	49 1c       	lddpc	r12,80004418 <connection_manager+0x74>
800043d6:	e0 a0 9c 1d 	rcall	80017c10 <puts>
				ScmCmd.apiLocked = FALSE; // open up for new commands
800043da:	49 18       	lddpc	r8,8000441c <connection_manager+0x78>
800043dc:	30 09       	mov	r9,0
800043de:	b0 89       	st.b	r8[0x0],r9
				RED_LED_ON(); // turn on error light
				if(NULL != ScmCmd.ScmTimeout_fptr)
800043e0:	70 18       	ld.w	r8,r8[0x4]
800043e2:	58 08       	cp.w	r8,0
800043e4:	c0 f0       	breq	80004402 <connection_manager+0x5e>
				{
					ScmCmd.ScmTimeout_fptr();  // call the timeout callback
800043e6:	5d 18       	icall	r8
				}
				else
				{
					LOG_ERR("Tried to call SCM Timeout function, but pointer was null\n");
				}
				connection_state = CON_IDLE; // done - not waiting on anything now
800043e8:	30 08       	mov	r8,0
800043ea:	8f 08       	st.w	r7[0x0],r8
800043ec:	ce 8b       	rjmp	800043bc <connection_manager+0x18>
	{
		case CON_IDLE:
		{
			if (TIMER_EXPIRED == TemperatureTimer.flag) // see if temperature timer has expired
			{
				TemperatureTimer.flag = TIMER_RUNNING; // if so, reset flag (periodic timer)
800043ee:	30 19       	mov	r9,1
			//	{
			//		TmrNewTime(TemperatureTimer.handle, FAST_TEMP_POLLING_TIME/TIMER_TICK);
			//	}
			//	else
			//	{
					TmrNewTime(TemperatureTimer.handle, TEMP_POLLING_TIME/TIMER_TICK);
800043f0:	11 8c       	ld.ub	r12,r8[0x0]
800043f2:	e0 6b 17 70 	mov	r11,6000
	{
		case CON_IDLE:
		{
			if (TIMER_EXPIRED == TemperatureTimer.flag) // see if temperature timer has expired
			{
				TemperatureTimer.flag = TIMER_RUNNING; // if so, reset flag (periodic timer)
800043f6:	b0 99       	st.b	r8[0x1],r9
			//	{
			//		TmrNewTime(TemperatureTimer.handle, FAST_TEMP_POLLING_TIME/TIMER_TICK);
			//	}
			//	else
			//	{
					TmrNewTime(TemperatureTimer.handle, TEMP_POLLING_TIME/TIMER_TICK);
800043f8:	e0 a0 14 52 	rcall	80006c9c <TmrNewTime>
			//	}
				Amp_UpdateTemp(); // call FBlock Amp function to do the work
800043fc:	cc cd       	rcall	80004794 <Amp_UpdateTemp>
800043fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80004402:	48 8c       	lddpc	r12,80004420 <connection_manager+0x7c>
				{
					ScmCmd.ScmTimeout_fptr();  // call the timeout callback
				}
				else
				{
					LOG_ERR("Tried to call SCM Timeout function, but pointer was null\n");
80004404:	e0 a0 9c 06 	rcall	80017c10 <puts>
80004408:	cf 0b       	rjmp	800043e8 <connection_manager+0x44>
8000440a:	d7 03       	nop
8000440c:	00 00       	add	r0,r0
8000440e:	40 30       	lddsp	r0,sp[0xc]
80004410:	00 00       	add	r0,r0
80004412:	40 24       	lddsp	r4,sp[0x8]
80004414:	00 00       	add	r0,r0
80004416:	3f c4       	mov	r4,-4
80004418:	80 06       	ld.sh	r6,r0[0x0]
8000441a:	89 cc       	st.w	r4[0x30],r12
8000441c:	00 00       	add	r0,r0
8000441e:	40 28       	lddsp	r8,sp[0x8]
80004420:	80 06       	ld.sh	r6,r0[0x0]
80004422:	8a 18       	ld.sh	r8,r5[0x2]

80004424 <ConmgrReturnMutex>:
80004424:	d4 01       	pushm	lr
80004426:	48 6c       	lddpc	r12,8000443c <ConmgrReturnMutex+0x18>
80004428:	e0 a0 14 a6 	rcall	80006d74 <StopTimer>
8000442c:	48 59       	lddpc	r9,80004440 <ConmgrReturnMutex+0x1c>
8000442e:	30 08       	mov	r8,0
80004430:	30 0a       	mov	r10,0
80004432:	93 18       	st.w	r9[0x4],r8
 *
 */
void ConmgrReturnMutex(void)
{
    StopTimer(&ScmCmdTimer); // command sequence did not time out
    ScmCmd.apiLocked = FALSE; // open up for new commands
80004434:	b2 8a       	st.b	r9[0x0],r10
    ScmCmd.ScmTimeout_fptr = NULL;
    connection_state = CON_IDLE; // done - not waiting on anything now
80004436:	48 49       	lddpc	r9,80004444 <ConmgrReturnMutex+0x20>
80004438:	93 08       	st.w	r9[0x0],r8
}
8000443a:	d8 02       	popm	pc
8000443c:	00 00       	add	r0,r0
8000443e:	3f c4       	mov	r4,-4
80004440:	00 00       	add	r0,r0
80004442:	40 28       	lddsp	r8,sp[0x8]
80004444:	00 00       	add	r0,r0
80004446:	40 30       	lddsp	r0,sp[0xc]

80004448 <OpenSerialPort_CB>:
80004448:	eb cd 40 80 	pushm	r7,lr
 * params  : result of open port process
 * returns : --
 * effects : if successful, moves state machine on to CREATE_ADC_INIC state
 *******************************************************************************/
void OpenSerialPort_CB(uint16_t cb_result)
{
8000444c:	18 97       	mov	r7,r12

    ConmgrReturnMutex();  //we're done (pass or fail), return mutex, stop timeout timer
8000444e:	ce bf       	rcall	80004424 <ConmgrReturnMutex>
80004450:	58 07       	cp.w	r7,0
    if (NSR_S_OK == cb_result)
80004452:	c0 d0       	breq	8000446c <OpenSerialPort_CB+0x24>
80004454:	5c 77       	castu.h	r7
        MyNode.StreamingPort = TRUE;
        RED_LED_OFF(); // turn off error light if it was on
    }
    else
    {
        LOG_ERR("Error opening serial streaming port: Error Code = %04X\n", cb_result);
80004456:	48 bc       	lddpc	r12,80004480 <OpenSerialPort_CB+0x38>
80004458:	1a d7       	st.w	--sp,r7
8000445a:	e0 a0 9b 45 	rcall	80017ae4 <printf>
8000445e:	30 09       	mov	r9,0
        
        MyNode.StreamingPort = FALSE; // signal port is not open (should have FALSE already anyway)
80004460:	48 98       	lddpc	r8,80004484 <OpenSerialPort_CB+0x3c>
80004462:	2f fd       	sub	sp,-4
80004464:	f1 69 00 13 	st.b	r8[19],r9
80004468:	e3 cd 80 80 	ldm	sp++,r7,pc
8000446c:	48 7c       	lddpc	r12,80004488 <OpenSerialPort_CB+0x40>
{

    ConmgrReturnMutex();  //we're done (pass or fail), return mutex, stop timeout timer
    if (NSR_S_OK == cb_result)
    {
        LOG_NOR("Serial Streaming Port Opened OK\n");
8000446e:	e0 a0 9b d1 	rcall	80017c10 <puts>
80004472:	30 19       	mov	r9,1
        MyNode.StreamingPort = TRUE;
80004474:	48 48       	lddpc	r8,80004484 <OpenSerialPort_CB+0x3c>
80004476:	f1 69 00 13 	st.b	r8[19],r9
8000447a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000447e:	d7 03       	nop
80004480:	80 06       	ld.sh	r6,r0[0x0]
80004482:	8a 74       	ld.sh	r4,r5[0xe]
80004484:	00 00       	add	r0,r0
80004486:	40 06       	lddsp	r6,sp[0x0]
80004488:	80 06       	ld.sh	r6,r0[0x0]
8000448a:	8a 54       	ld.sh	r4,r5[0xa]

8000448c <kill_net_connections>:
8000448c:	d4 01       	pushm	lr
8000448e:	c6 bd       	rcall	80004764 <Amp_KillConnections>
80004490:	e0 a0 08 36 	rcall	800054fc <Auxin_KillConnections>
80004494:	d8 02       	popm	pc
80004496:	d7 03       	nop

80004498 <ConmgrGetMutex>:
 */
void kill_net_connections(void)
{
    Amp_KillConnections();
    Auxin_KillConnections();
}
80004498:	eb cd 40 c0 	pushm	r6-r7,lr
8000449c:	48 c7       	lddpc	r7,800044cc <ConmgrGetMutex+0x34>
8000449e:	16 96       	mov	r6,r11
 *  RETURNS:        TRUE - mutex granted / FALSE mutex denied, SCM is already busy
 *
 */
uint8_t ConmgrGetMutex(uint16_t timeout, Type_ScmTimeout_fptr Timeout_fn)
{
    if(!ScmCmd.apiLocked)
800044a0:	0f 89       	ld.ub	r9,r7[0x0]
800044a2:	30 08       	mov	r8,0
800044a4:	f0 09 18 00 	cp.b	r9,r8
800044a8:	c0 30       	breq	800044ae <ConmgrGetMutex+0x16>
800044aa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
    {
        StartTimer(&ScmCmdTimer, timeout, TIMER_ONE_SHOT);  // start the timeout timer
800044ae:	f7 dc c0 10 	bfextu	r11,r12,0x0,0x10
800044b2:	30 1a       	mov	r10,1
800044b4:	48 7c       	lddpc	r12,800044d0 <ConmgrGetMutex+0x38>
800044b6:	e0 a0 14 af 	rcall	80006e14 <StartTimer>
        ScmCmd.apiLocked = TRUE;
800044ba:	30 19       	mov	r9,1
        ScmCmd.ScmTimeout_fptr = Timeout_fn;
        connection_state = SCM_PENDING; // INIC's connection manager is busy
800044bc:	30 18       	mov	r8,1
uint8_t ConmgrGetMutex(uint16_t timeout, Type_ScmTimeout_fptr Timeout_fn)
{
    if(!ScmCmd.apiLocked)
    {
        StartTimer(&ScmCmdTimer, timeout, TIMER_ONE_SHOT);  // start the timeout timer
        ScmCmd.apiLocked = TRUE;
800044be:	ae 89       	st.b	r7[0x0],r9
        ScmCmd.ScmTimeout_fptr = Timeout_fn;
800044c0:	8f 16       	st.w	r7[0x4],r6
        connection_state = SCM_PENDING; // INIC's connection manager is busy
800044c2:	48 59       	lddpc	r9,800044d4 <ConmgrGetMutex+0x3c>
800044c4:	10 9c       	mov	r12,r8
800044c6:	93 08       	st.w	r9[0x0],r8
    }
    else
    {
        return (FALSE);
    }
}
800044c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800044cc:	00 00       	add	r0,r0
800044ce:	40 28       	lddsp	r8,sp[0x8]
800044d0:	00 00       	add	r0,r0
800044d2:	3f c4       	mov	r4,-4
800044d4:	00 00       	add	r0,r0
800044d6:	40 30       	lddsp	r0,sp[0xc]

800044d8 <SCError_CB>:
800044d8:	eb cd 40 80 	pushm	r7,lr
 *                  out current information
 *  RETURNS:      nothing
 */
/*-------------------------------------------------------------------------------------------------------------------*/
void SCError_CB(uint8_t handle)
{
800044dc:	20 1d       	sub	sp,4
	uint8_t result;

	if (handle == DAC_connection.ConnectionHandle) // stereo source we were listening to went away
800044de:	4a 17       	lddpc	r7,80004560 <SCError_CB+0x88>
800044e0:	0f e8       	ld.ub	r8,r7[0x6]
800044e2:	f8 08 18 00 	cp.b	r8,r12
800044e6:	c2 10       	breq	80004528 <SCError_CB+0x50>
					
				}
			}
		}
	}
	else if (handle == ADC_connection.ConnectionHandle)
800044e8:	49 f7       	lddpc	r7,80004564 <SCError_CB+0x8c>
800044ea:	0f e8       	ld.ub	r8,r7[0x6]
800044ec:	f8 08 18 00 	cp.b	r8,r12
800044f0:	c0 70       	breq	800044fe <SCError_CB+0x26>
		}
	}

	else
	{
		LOG_ERR("Handle reported by SCError was not a valid connection handle for this node\n");
800044f2:	49 ec       	lddpc	r12,80004568 <SCError_CB+0x90>
800044f4:	e0 a0 9b 8e 	rcall	80017c10 <puts>
	}
}
800044f8:	2f fd       	sub	sp,-4
800044fa:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
	}
	else if (handle == ADC_connection.ConnectionHandle)
	{
		// then this connection had an error - destroy and rebuild - just like changing channels
		if (ADC_connection.ConnectionLabel != INVALID_LABEL) // making sure we had a valid connection before error
800044fe:	8e 29       	ld.sh	r9,r7[0x4]
80004500:	30 08       	mov	r8,0
80004502:	f0 09 19 00 	cp.h	r9,r8
80004506:	cf 90       	breq	800044f8 <SCError_CB+0x20>
		{
			LOG_ERR("Disconnec and de-allocate stereo source (AuxIn)\n");
80004508:	49 9c       	lddpc	r12,8000456c <SCError_CB+0x94>
8000450a:	e0 a0 9b 83 	rcall	80017c10 <puts>
			ADC_connection.LocalCommand = TRUE; // flag that we don't want to send a response
8000450e:	30 18       	mov	r8,1
			if (ConmgrGetMutex(300, SCError_Timeout))
80004510:	fe cb 01 b8 	sub	r11,pc,440
	{
		// then this connection had an error - destroy and rebuild - just like changing channels
		if (ADC_connection.ConnectionLabel != INVALID_LABEL) // making sure we had a valid connection before error
		{
			LOG_ERR("Disconnec and de-allocate stereo source (AuxIn)\n");
			ADC_connection.LocalCommand = TRUE; // flag that we don't want to send a response
80004514:	ef 68 00 09 	st.b	r7[9],r8
			if (ConmgrGetMutex(300, SCError_Timeout))
80004518:	e0 6c 01 2c 	mov	r12,300
8000451c:	cb ef       	rcall	80004498 <ConmgrGetMutex>
8000451e:	ce d0       	breq	800044f8 <SCError_CB+0x20>
			{
				result = ADC_DisConnectSockets(); // starts deallocation process
80004520:	e0 a0 08 44 	rcall	800055a8 <ADC_DisConnectSockets>
				if (result != ERR_NO)
80004524:	ce a0       	breq	800044f8 <SCError_CB+0x20>
80004526:	c1 48       	rjmp	8000454e <SCError_CB+0x76>
	uint8_t result;

	if (handle == DAC_connection.ConnectionHandle) // stereo source we were listening to went away
	{
		// then this connection had an error - kill sockets & notify source
		if (DAC_connection.ConnectionLabel != INVALID_LABEL) // sanity check, making sure we had a valid connection before error
80004528:	8e 29       	ld.sh	r9,r7[0x4]
8000452a:	30 08       	mov	r8,0
8000452c:	f0 09 19 00 	cp.h	r9,r8
80004530:	ce 40       	breq	800044f8 <SCError_CB+0x20>
		{
			LOG_ERR("Dis-connecting stereo sink connection\n");
80004532:	49 0c       	lddpc	r12,80004570 <SCError_CB+0x98>
80004534:	e0 a0 9b 6e 	rcall	80017c10 <puts>
			DAC_connection.LocalCommand = TRUE; // destroy own sockets w/o being commanded, no response
80004538:	30 18       	mov	r8,1
			if (ConmgrGetMutex(300, SCError_Timeout))
8000453a:	fe cb 01 e2 	sub	r11,pc,482
	{
		// then this connection had an error - kill sockets & notify source
		if (DAC_connection.ConnectionLabel != INVALID_LABEL) // sanity check, making sure we had a valid connection before error
		{
			LOG_ERR("Dis-connecting stereo sink connection\n");
			DAC_connection.LocalCommand = TRUE; // destroy own sockets w/o being commanded, no response
8000453e:	ef 68 00 09 	st.b	r7[9],r8
			if (ConmgrGetMutex(300, SCError_Timeout))
80004542:	e0 6c 01 2c 	mov	r12,300
80004546:	ca 9f       	rcall	80004498 <ConmgrGetMutex>
80004548:	cd 80       	breq	800044f8 <SCError_CB+0x20>
			{
				result = DAC_DisConnectSockets(); // starts disconnect process
8000454a:	c7 bd       	rcall	80004840 <DAC_DisConnectSockets>
8000454c:	cd 60       	breq	800044f8 <SCError_CB+0x20>
				if (result != ERR_NO)
8000454e:	50 0c       	stdsp	sp[0x0],r12
			if (ConmgrGetMutex(300, SCError_Timeout))
			{
				result = ADC_DisConnectSockets(); // starts deallocation process
				if (result != ERR_NO)
				{
					ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80004550:	c6 af       	rcall	80004424 <ConmgrReturnMutex>
80004552:	40 0c       	lddsp	r12,sp[0x0]
80004554:	1a dc       	st.w	--sp,r12
					LOG_ERR("Error starting ADC disconnect sockets process following SCError: result = %02X\n", result);
80004556:	48 8c       	lddpc	r12,80004574 <SCError_CB+0x9c>
80004558:	e0 a0 9a c6 	rcall	80017ae4 <printf>
8000455c:	2f fd       	sub	sp,-4
8000455e:	cc db       	rjmp	800044f8 <SCError_CB+0x20>
80004560:	00 00       	add	r0,r0
80004562:	40 38       	lddsp	r8,sp[0xc]
80004564:	00 00       	add	r0,r0
80004566:	40 70       	lddsp	r0,sp[0x1c]
80004568:	80 06       	ld.sh	r6,r0[0x0]
8000456a:	8b 54       	st.w	r5[0x14],r4
8000456c:	80 06       	ld.sh	r6,r0[0x0]
8000456e:	8b 24       	st.w	r5[0x8],r4
80004570:	80 06       	ld.sh	r6,r0[0x0]
80004572:	8a ac       	ld.uh	r12,r5[0x4]
80004574:	80 06       	ld.sh	r6,r0[0x0]
80004576:	8a d4       	ld.uh	r4,r5[0xa]

80004578 <InitPorts>:
80004578:	d4 01       	pushm	lr
8000457a:	20 1d       	sub	sp,4
8000457c:	fe cb 02 14 	sub	r11,pc,532
80004580:	e0 6c 00 c8 	mov	r12,200
80004584:	c8 af       	rcall	80004498 <ConmgrGetMutex>
80004586:	c0 e0       	breq	800045a2 <InitPorts+0x2a>
80004588:	cf 8e       	rcall	80004378 <OpenSerialPort>
8000458a:	c1 01       	brne	800045aa <InitPorts+0x32>
8000458c:	48 c8       	lddpc	r8,800045bc <InitPorts+0x44>
8000458e:	11 99       	ld.ub	r9,r8[0x1]
80004590:	30 08       	mov	r8,0
80004592:	f0 09 18 00 	cp.b	r9,r8
80004596:	c0 41       	brne	8000459e <InitPorts+0x26>
	else
	{
		LOG_ERR("Could not open ports because Connection Manager is busy\n");
	}

	if (TIMER_IDLE == TemperatureTimer.flag) // sanity check - don't start another timer if its already running
80004598:	48 ac       	lddpc	r12,800045c0 <InitPorts+0x48>
	{
		LOG_NOR("Starting Temperature polling timer\n");
8000459a:	e0 a0 9b 3b 	rcall	80017c10 <puts>
8000459e:	2f fd       	sub	sp,-4
		// *netbugger* StartTimer(&TemperatureTimer, TEMP_POLLING_TIME, TIMER_PERIODIC);
	}
}
800045a0:	d8 02       	popm	pc
800045a2:	48 9c       	lddpc	r12,800045c4 <InitPorts+0x4c>
			RED_LED_ON();
		}
	}
	else
	{
		LOG_ERR("Could not open ports because Connection Manager is busy\n");
800045a4:	e0 a0 9b 36 	rcall	80017c10 <puts>
800045a8:	cf 2b       	rjmp	8000458c <InitPorts+0x14>
800045aa:	50 0c       	stdsp	sp[0x0],r12
	if (ConmgrGetMutex(200, InitPorts_Timeout))
	{
		result = OpenSerialPort();  // starts Open Port process
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
800045ac:	c3 cf       	rcall	80004424 <ConmgrReturnMutex>
800045ae:	40 0c       	lddsp	r12,sp[0x0]
800045b0:	1a dc       	st.w	--sp,r12
			LOG_ERR("Error starting Open Port process: result = %02X\n", result);
800045b2:	48 6c       	lddpc	r12,800045c8 <InitPorts+0x50>
800045b4:	e0 a0 9a 98 	rcall	80017ae4 <printf>
800045b8:	2f fd       	sub	sp,-4
800045ba:	ce 9b       	rjmp	8000458c <InitPorts+0x14>
800045bc:	00 00       	add	r0,r0
800045be:	40 24       	lddsp	r4,sp[0x8]
800045c0:	80 06       	ld.sh	r6,r0[0x0]
800045c2:	8c 0c       	ld.sh	r12,r6[0x0]
800045c4:	80 06       	ld.sh	r6,r0[0x0]
800045c6:	8b d4       	st.w	r5[0x34],r4
800045c8:	80 06       	ld.sh	r6,r0[0x0]
800045ca:	8b a0       	st.w	r5[0x28],r0

800045cc <ConmgrInit>:
800045cc:	d4 01       	pushm	lr
800045ce:	48 b9       	lddpc	r9,800045f8 <ConmgrInit+0x2c>
800045d0:	30 08       	mov	r8,0
800045d2:	f3 68 00 14 	st.b	r9[20],r8
800045d6:	f3 68 00 13 	st.b	r9[19],r8
800045da:	48 99       	lddpc	r9,800045fc <ConmgrInit+0x30>
800045dc:	93 08       	st.w	r9[0x0],r8
800045de:	fe b0 fd e1 	rcall	800041a0 <CODEC_setDefaultValues>
800045e2:	e0 a0 07 39 	rcall	80005454 <Init_Amp>
800045e6:	e0 a0 07 61 	rcall	800054a8 <Init_Auxin>

    /* initialize fblocks */
    Init_Amp(); // initialize amplifier parameters - incl gain/mute
    Init_Auxin(); // initialize aux in parameters

    InitializeTimer(&TemperatureTimer);
800045ea:	48 6c       	lddpc	r12,80004600 <ConmgrInit+0x34>
800045ec:	e0 a0 13 be 	rcall	80006d68 <InitializeTimer>
    InitializeTimer(&ScmCmdTimer);
800045f0:	48 5c       	lddpc	r12,80004604 <ConmgrInit+0x38>
800045f2:	e0 a0 13 bb 	rcall	80006d68 <InitializeTimer>

}
800045f6:	d8 02       	popm	pc
800045f8:	00 00       	add	r0,r0
800045fa:	40 06       	lddsp	r6,sp[0x0]
800045fc:	00 00       	add	r0,r0
800045fe:	40 30       	lddsp	r0,sp[0xc]
80004600:	00 00       	add	r0,r0
80004602:	40 24       	lddsp	r4,sp[0x8]
80004604:	00 00       	add	r0,r0
80004606:	3f c4       	mov	r4,-4

80004608 <DacRegisterWrite>:

	return result;
}

Type_Result DacRegisterWrite(uint8_t regAddr, uint8_t regData)
{
80004608:	d4 01       	pushm	lr
8000460a:	20 1d       	sub	sp,4
8000460c:	ba 8b       	st.b	sp[0x0],r11
	Type_Result result;

	result = dac_write(&regData, 1, regAddr);
8000460e:	f5 dc b0 08 	bfexts	r10,r12,0x0,0x8
80004612:	30 1b       	mov	r11,1
80004614:	1a 9c       	mov	r12,sp
80004616:	e0 a0 11 85 	rcall	80006920 <dac_write>
8000461a:	30 08       	mov	r8,0
8000461c:	f8 08 0d 4c 	min	r12,r12,r8
	{
		return ERR_NONE;
	}

	return result;
}
80004620:	5c 8c       	casts.h	r12
80004622:	2f fd       	sub	sp,-4
80004624:	d8 02       	popm	pc
80004626:	d7 03       	nop

80004628 <DacSetEvents>:
80004628:	eb cd 40 80 	pushm	r7,lr
*  DESCRIPTION:	Sets the INT_ENABLE register in DAC with value passed in
*  RETURNS:		>0 = success, <0 is one of the I2C errors
*/
/*-------------------------------------------------------------------------------------------------------------------*/
int16_t DacSetEvents(uint8_t int_events)
{
8000462c:	18 97       	mov	r7,r12
	LOG_NOR("Setting DAC Int Enable Events ... \n");
8000462e:	48 5c       	lddpc	r12,80004640 <DacSetEvents+0x18>
80004630:	e0 a0 9a f0 	rcall	80017c10 <puts>

	return (DacRegisterWrite(INT_ENABLE, int_events));
80004634:	0e 9b       	mov	r11,r7
80004636:	30 4c       	mov	r12,4
80004638:	ce 8f       	rcall	80004608 <DacRegisterWrite>
8000463a:	e3 cd 80 80 	ldm	sp++,r7,pc
}
8000463e:	d7 03       	nop
80004640:	80 06       	ld.sh	r6,r0[0x0]
80004642:	8c 30       	ld.sh	r0,r6[0x6]

80004644 <Amp_SinkInfo_Get_N>:
*
****************************************************************************/
uint8_t Amp_SinkInfo_Get_N(struct Msg_Tx_Type *Tx_Ptr)
{

	Tx_Ptr->Data[0] = AMP_SINK_NR; // SinkNumber
80004644:	30 19       	mov	r9,1
80004646:	78 08       	ld.w	r8,r12[0x0]
80004648:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = 0;                                        // MSB of blockwidth
8000464a:	78 09       	ld.w	r9,r12[0x0]
8000464c:	30 08       	mov	r8,0
	Tx_Ptr->Data[2] = AUDIO_STEREO * RES_16BIT;                 // LSB of blockwitdh - only support stereo (4 bytes)
8000464e:	30 4a       	mov	r10,4
****************************************************************************/
uint8_t Amp_SinkInfo_Get_N(struct Msg_Tx_Type *Tx_Ptr)
{

	Tx_Ptr->Data[0] = AMP_SINK_NR; // SinkNumber
	Tx_Ptr->Data[1] = 0;                                        // MSB of blockwidth
80004650:	b2 98       	st.b	r9[0x1],r8
	Tx_Ptr->Data[2] = AUDIO_STEREO * RES_16BIT;                 // LSB of blockwitdh - only support stereo (4 bytes)
80004652:	78 09       	ld.w	r9,r12[0x0]
80004654:	b2 aa       	st.b	r9[0x2],r10
	Tx_Ptr->Data[3] = (u8_t) (DAC_connection.ConnectionLabel>>8);   // MSB of connection label
80004656:	48 e9       	lddpc	r9,8000468c <Amp_SinkInfo_Get_N+0x48>
80004658:	78 0a       	ld.w	r10,r12[0x0]
8000465a:	13 cb       	ld.ub	r11,r9[0x4]
8000465c:	b4 bb       	st.b	r10[0x3],r11
	Tx_Ptr->Data[4] = (u8_t) DAC_connection.ConnectionLabel;        // LSB of connection label
8000465e:	92 2a       	ld.sh	r10,r9[0x4]
80004660:	78 09       	ld.w	r9,r12[0x0]
80004662:	b2 ca       	st.b	r9[0x4],r10
	Tx_Ptr->Data[5] = 0;                                        // Transmission Class 0 = Synchronous
80004664:	78 09       	ld.w	r9,r12[0x0]
80004666:	b2 d8       	st.b	r9[0x5],r8
	Tx_Ptr->Data[6] = 0;                                        // Content Protection 0 = None
80004668:	78 09       	ld.w	r9,r12[0x0]
8000466a:	b2 e8       	st.b	r9[0x6],r8
	Tx_Ptr->Data[7] = 0;                                        // Content Type 0 = Audio
8000466c:	78 09       	ld.w	r9,r12[0x0]
8000466e:	b2 f8       	st.b	r9[0x7],r8
	Tx_Ptr->Data[8] = 2;                                        // Content Description, short stream 2 bytes follow
80004670:	78 09       	ld.w	r9,r12[0x0]
80004672:	30 28       	mov	r8,2
80004674:	f3 68 00 08 	st.b	r9[8],r8
	Tx_Ptr->Data[9] = AUDIO_STEREO;                             // AudioChannels 2 = Stereo
80004678:	78 09       	ld.w	r9,r12[0x0]
8000467a:	f3 68 00 09 	st.b	r9[9],r8
	Tx_Ptr->Data[10] = RES_16BIT;                                // Resolution 2 = 16-Bit Audio
8000467e:	78 09       	ld.w	r9,r12[0x0]
80004680:	f3 68 00 0a 	st.b	r9[10],r8

	Tx_Ptr->Length  = 11;
80004684:	30 b8       	mov	r8,11
80004686:	b8 28       	st.h	r12[0x4],r8
	return (OP_STATUS);
}
80004688:	30 cc       	mov	r12,12
8000468a:	5e fc       	retal	r12
8000468c:	00 00       	add	r0,r0
8000468e:	40 38       	lddsp	r8,sp[0xc]

80004690 <Amp_Mute_Get_N>:
*  Return(s):      	OP_Type
*
****************************************************************************/
uint8_t Amp_Mute_Get_N(struct Msg_Tx_Type *Tx_Ptr)
{
	Tx_Ptr->Data[0] = AMP_SINK_NR; // SinkNumber
80004690:	78 08       	ld.w	r8,r12[0x0]
80004692:	30 19       	mov	r9,1
80004694:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = Amp.pMute; // Status
80004696:	48 58       	lddpc	r8,800046a8 <Amp_Mute_Get_N+0x18>
80004698:	11 e9       	ld.ub	r9,r8[0x6]
8000469a:	78 08       	ld.w	r8,r12[0x0]
8000469c:	b0 99       	st.b	r8[0x1],r9
	Tx_Ptr->Length = 2;
8000469e:	30 28       	mov	r8,2
800046a0:	b8 28       	st.h	r12[0x4],r8
	return (OP_STATUS);
}
800046a2:	30 cc       	mov	r12,12
800046a4:	5e fc       	retal	r12
800046a6:	d7 03       	nop
800046a8:	00 00       	add	r0,r0
800046aa:	40 42       	lddsp	r2,sp[0x10]

800046ac <Amp_SyncDataInfo_Get>:
*
****************************************************************************/
uint8_t Amp_SyncDataInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	Tx_Ptr->Data[0] = 0; // No source resources for FBlock Amp
800046ac:	30 09       	mov	r9,0
800046ae:	78 08       	ld.w	r8,r12[0x0]
800046b0:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = 1; // FBlock Amp has 1 sink connection
800046b2:	78 09       	ld.w	r9,r12[0x0]
800046b4:	30 18       	mov	r8,1
800046b6:	b2 98       	st.b	r9[0x1],r8
	Tx_Ptr->Data[2] = AMP_SINK_NR; // ...and that's the SinkNr
800046b8:	78 09       	ld.w	r9,r12[0x0]
800046ba:	b2 a8       	st.b	r9[0x2],r8

	Tx_Ptr->Length = 3; //
800046bc:	30 38       	mov	r8,3
800046be:	b8 28       	st.h	r12[0x4],r8

	return (OP_STATUS);

}
800046c0:	30 cc       	mov	r12,12
800046c2:	5e fc       	retal	r12

800046c4 <Amp_Events_Get>:
	temp &= (1 << LCK | 1 << SHPS | 1 << VMIN | 1 << IOHL | 1 << IOHR); // only allow these sources - also clears bit 2 for Temp bit
	if (Amp.O_Temp)
	{
		temp |= TEMP_EVENT; // set bit 2
	}
	Tx_Ptr->Data[0] = temp; // That's Events
800046c4:	78 0a       	ld.w	r10,r12[0x0]

	uint8_t temp = 0;

	//temp = DacGetStatus(); // gets Status A
	temp &= (1 << LCK | 1 << SHPS | 1 << VMIN | 1 << IOHL | 1 << IOHR); // only allow these sources - also clears bit 2 for Temp bit
	if (Amp.O_Temp)
800046c6:	48 b8       	lddpc	r8,800046f0 <Amp_Events_Get+0x2c>
800046c8:	30 09       	mov	r9,0
800046ca:	f1 3b 00 0a 	ld.ub	r11,r8[10]
800046ce:	f2 0b 18 00 	cp.b	r11,r9
800046d2:	f9 b9 00 00 	moveq	r9,0
800046d6:	f9 b9 01 04 	movne	r9,4
	{
		temp |= TEMP_EVENT; // set bit 2
	}
	Tx_Ptr->Data[0] = temp; // That's Events
800046da:	b4 89       	st.b	r10[0x0],r9
	//temp = DacGetStatusB(); //
	Tx_Ptr->Data[1] = temp; // Amp Status is direct from DAC
800046dc:	78 0a       	ld.w	r10,r12[0x0]
800046de:	b4 99       	st.b	r10[0x1],r9
	Tx_Ptr->Data[2] = Amp.EventMask; // Just returning our current mask value - user sent earlier
800046e0:	f1 39 00 0d 	ld.ub	r9,r8[13]
800046e4:	78 08       	ld.w	r8,r12[0x0]
800046e6:	b0 a9       	st.b	r8[0x2],r9
	Tx_Ptr->Length = 3;
800046e8:	30 38       	mov	r8,3
800046ea:	b8 28       	st.h	r12[0x4],r8
uint8_t Amp_Events_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	// Parameter checking - no parameters

	return (Amp_Events_Get_N(Tx_Ptr)); // let the notification command do the work
}
800046ec:	30 cc       	mov	r12,12
800046ee:	5e fc       	retal	r12
800046f0:	00 00       	add	r0,r0
800046f2:	40 42       	lddsp	r2,sp[0x10]

800046f4 <Amp_Events_Get_N>:
	temp &= (1 << LCK | 1 << SHPS | 1 << VMIN | 1 << IOHL | 1 << IOHR); // only allow these sources - also clears bit 2 for Temp bit
	if (Amp.O_Temp)
	{
		temp |= TEMP_EVENT; // set bit 2
	}
	Tx_Ptr->Data[0] = temp; // That's Events
800046f4:	78 0a       	ld.w	r10,r12[0x0]

	uint8_t temp = 0;

	//temp = DacGetStatus(); // gets Status A
	temp &= (1 << LCK | 1 << SHPS | 1 << VMIN | 1 << IOHL | 1 << IOHR); // only allow these sources - also clears bit 2 for Temp bit
	if (Amp.O_Temp)
800046f6:	48 b8       	lddpc	r8,80004720 <Amp_Events_Get_N+0x2c>
800046f8:	30 09       	mov	r9,0
800046fa:	f1 3b 00 0a 	ld.ub	r11,r8[10]
800046fe:	f2 0b 18 00 	cp.b	r11,r9
80004702:	f9 b9 00 00 	moveq	r9,0
80004706:	f9 b9 01 04 	movne	r9,4
	{
		temp |= TEMP_EVENT; // set bit 2
	}
	Tx_Ptr->Data[0] = temp; // That's Events
8000470a:	b4 89       	st.b	r10[0x0],r9
	//temp = DacGetStatusB(); //
	Tx_Ptr->Data[1] = temp; // Amp Status is direct from DAC
8000470c:	78 0a       	ld.w	r10,r12[0x0]
8000470e:	b4 99       	st.b	r10[0x1],r9
	Tx_Ptr->Data[2] = Amp.EventMask; // Just returning our current mask value - user sent earlier
80004710:	f1 39 00 0d 	ld.ub	r9,r8[13]
80004714:	78 08       	ld.w	r8,r12[0x0]
80004716:	b0 a9       	st.b	r8[0x2],r9
	Tx_Ptr->Length = 3;
80004718:	30 38       	mov	r8,3
8000471a:	b8 28       	st.h	r12[0x4],r8
	return (OP_STATUS);
}
8000471c:	30 cc       	mov	r12,12
8000471e:	5e fc       	retal	r12
80004720:	00 00       	add	r0,r0
80004722:	40 42       	lddsp	r2,sp[0x10]

80004724 <Amp_PrintTemp>:
	}
	NtfPropertyChangedFkt(FBLOCK_AMP, 0, AMP_EVENTS); // trigger notification
}

void Amp_PrintTemp(uint8_t Temp)
{
80004724:	eb cd 40 80 	pushm	r7,lr
80004728:	18 97       	mov	r7,r12
	LOG_NOR("Temp is ");
8000472a:	48 cc       	lddpc	r12,80004758 <Amp_PrintTemp+0x34>
8000472c:	e0 a0 99 dc 	rcall	80017ae4 <printf>
	if (0 != (0x80 & Temp)) // High order bit set ==> negative 2's compliment
80004730:	30 08       	mov	r8,0
80004732:	f0 07 18 00 	cp.b	r7,r8
80004736:	c0 b5       	brlt	8000474c <Amp_PrintTemp+0x28>
	{
		LOG_NOR("-");
		Temp = (0xFF - Temp) + 1; // 2 comp invert
	}
	LOG_NOR("%d", Temp);
80004738:	1a d7       	st.w	--sp,r7
8000473a:	48 9c       	lddpc	r12,8000475c <Amp_PrintTemp+0x38>
8000473c:	e0 a0 99 d4 	rcall	80017ae4 <printf>
	LOG_NOR(" deg C\n");
80004740:	48 8c       	lddpc	r12,80004760 <Amp_PrintTemp+0x3c>
80004742:	e0 a0 9a 67 	rcall	80017c10 <puts>
80004746:	2f fd       	sub	sp,-4
}
80004748:	e3 cd 80 80 	ldm	sp++,r7,pc
void Amp_PrintTemp(uint8_t Temp)
{
	LOG_NOR("Temp is ");
	if (0 != (0x80 & Temp)) // High order bit set ==> negative 2's compliment
	{
		LOG_NOR("-");
8000474c:	32 dc       	mov	r12,45
8000474e:	e0 a0 99 e3 	rcall	80017b14 <putchar>
		Temp = (0xFF - Temp) + 1; // 2 comp invert
80004752:	5c 37       	neg	r7
80004754:	5c 57       	castu.b	r7
80004756:	cf 1b       	rjmp	80004738 <Amp_PrintTemp+0x14>
80004758:	80 06       	ld.sh	r6,r0[0x0]
8000475a:	8e fc       	ld.uh	r12,r7[0xe]
8000475c:	80 06       	ld.sh	r6,r0[0x0]
8000475e:	bb fc       	*unknown*
80004760:	80 06       	ld.sh	r6,r0[0x0]
80004762:	8f 08       	st.w	r7[0x0],r8

80004764 <Amp_KillConnections>:
80004764:	d4 01       	pushm	lr
80004766:	48 9c       	lddpc	r12,80004788 <Amp_KillConnections+0x24>
80004768:	e0 a0 9a 54 	rcall	80017c10 <puts>
8000476c:	30 09       	mov	r9,0
8000476e:	48 88       	lddpc	r8,8000478c <Amp_KillConnections+0x28>
	LOG_NOR("Initializing Amp connections\n");
	DAC_connection.Network_handle = INVALID_SOCKET;
	DAC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
	DAC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	DAC_connection.Connecting = FALSE; // not currently working on connecting
	DAC_connection.LocalCommand = FALSE; // not doing stuff on our own
80004770:	f1 69 00 09 	st.b	r8[9],r9
*/
void Amp_KillConnections(void)
{
	LOG_NOR("Initializing Amp connections\n");
	DAC_connection.Network_handle = INVALID_SOCKET;
	DAC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
80004774:	b0 29       	st.h	r8[0x4],r9
	DAC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	DAC_connection.Connecting = FALSE; // not currently working on connecting
80004776:	b0 f9       	st.b	r8[0x7],r9
*
*/
void Amp_KillConnections(void)
{
	LOG_NOR("Initializing Amp connections\n");
	DAC_connection.Network_handle = INVALID_SOCKET;
80004778:	3f f9       	mov	r9,-1
	DAC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
	DAC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
8000477a:	b0 e9       	st.b	r8[0x6],r9
*
*/
void Amp_KillConnections(void)
{
	LOG_NOR("Initializing Amp connections\n");
	DAC_connection.Network_handle = INVALID_SOCKET;
8000477c:	b0 a9       	st.b	r8[0x2],r9
	DAC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	DAC_connection.Connecting = FALSE; // not currently working on connecting
	DAC_connection.LocalCommand = FALSE; // not doing stuff on our own
	YELLOW2_LED_OFF(); // DAC connection LED should be off

	AmpRetained_Tx_Ptr = NULL; // no messages waiting for response
8000477e:	30 09       	mov	r9,0
80004780:	48 48       	lddpc	r8,80004790 <Amp_KillConnections+0x2c>
80004782:	91 09       	st.w	r8[0x0],r9
}
80004784:	d8 02       	popm	pc
80004786:	d7 03       	nop
80004788:	80 06       	ld.sh	r6,r0[0x0]
8000478a:	8f 10       	st.w	r7[0x4],r0
8000478c:	00 00       	add	r0,r0
8000478e:	40 38       	lddsp	r8,sp[0xc]
80004790:	00 00       	add	r0,r0
80004792:	40 34       	lddsp	r4,sp[0xc]

80004794 <Amp_UpdateTemp>:
80004794:	eb cd 40 80 	pushm	r7,lr
void Amp_UpdateTemp(void)
{
//	Amp.pTemperature = PM_GetTemp(); // update Amp's Temperature property

	// Notification
	if (Amp.pTemperature != Amp.nTemperature) // see if new value is different
80004798:	48 97       	lddpc	r7,800047bc <Amp_UpdateTemp+0x28>
8000479a:	0f c8       	ld.ub	r8,r7[0x4]
8000479c:	0f d9       	ld.ub	r9,r7[0x5]
8000479e:	f0 09 18 00 	cp.b	r9,r8
800047a2:	c0 a0       	breq	800047b6 <Amp_UpdateTemp+0x22>
	{
		Amp.nTemperature = Amp.pTemperature; // make reference & actual the same
		NtfPropertyChangedFkt(FBLOCK_AMP, 0, AMP_TEMPERATURE); // trigger notification
800047a4:	32 2c       	mov	r12,34
//	Amp.pTemperature = PM_GetTemp(); // update Amp's Temperature property

	// Notification
	if (Amp.pTemperature != Amp.nTemperature) // see if new value is different
	{
		Amp.nTemperature = Amp.pTemperature; // make reference & actual the same
800047a6:	ae d8       	st.b	r7[0x5],r8
		NtfPropertyChangedFkt(FBLOCK_AMP, 0, AMP_TEMPERATURE); // trigger notification
800047a8:	e0 6a 0c 04 	mov	r10,3076
800047ac:	30 0b       	mov	r11,0
800047ae:	e0 a0 89 a9 	rcall	80015b00 <NtfPropertyChangedFkt>
		Amp_PrintTemp(Amp.pTemperature);
800047b2:	0f cc       	ld.ub	r12,r7[0x4]
800047b4:	cb 8f       	rcall	80004724 <Amp_PrintTemp>
800047b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800047ba:	d7 03       	nop
800047bc:	00 00       	add	r0,r0
800047be:	40 42       	lddsp	r2,sp[0x10]

800047c0 <Set_Volume>:
800047c0:	eb cd 40 80 	pushm	r7,lr
800047c4:	48 c7       	lddpc	r7,800047f4 <Set_Volume+0x34>
800047c6:	30 0c       	mov	r12,0
	//    uint8_t attn;

	// Volume to attenuation mapping - simply 40 (0x28) - value
	//   attn = 40 - Amp.pVolume; // 0 in -> 0x28 out (-73dB), 40 in -> 00 out (+6 dB)
	//   DacSetAttenuation(attn);
	CODEC_setVolume(0, Amp.pVolume);
800047c8:	0f 8b       	ld.ub	r11,r7[0x0]
800047ca:	fe b0 fc c7 	rcall	80004158 <CODEC_setVolume>
	CODEC_setVolume(1, 0);
800047ce:	30 0b       	mov	r11,0
800047d0:	30 1c       	mov	r12,1
800047d2:	fe b0 fc c3 	rcall	80004158 <CODEC_setVolume>
	//CODEC_setAttenuation(2, attn);
	
	if (Amp.pVolume != Amp.nVolume)
800047d6:	0f 89       	ld.ub	r9,r7[0x0]
800047d8:	0f 98       	ld.ub	r8,r7[0x1]
800047da:	f0 09 18 00 	cp.b	r9,r8
800047de:	c0 90       	breq	800047f0 <Set_Volume+0x30>
	{
		NtfPropertyChangedFkt(FBLOCK_AMP, 0, AMP_VOLUME); // trigger notification
800047e0:	e0 6a 04 00 	mov	r10,1024
800047e4:	30 0b       	mov	r11,0
800047e6:	32 2c       	mov	r12,34
800047e8:	e0 a0 89 8c 	rcall	80015b00 <NtfPropertyChangedFkt>
		Amp.nVolume = Amp.pVolume;
800047ec:	0f 88       	ld.ub	r8,r7[0x0]
800047ee:	ae 98       	st.b	r7[0x1],r8
800047f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800047f4:	00 00       	add	r0,r0
800047f6:	40 42       	lddsp	r2,sp[0x10]

800047f8 <DAC_Network_DestroySocket>:
800047f8:	d4 01       	pushm	lr
800047fa:	48 7c       	lddpc	r12,80004814 <DAC_Network_DestroySocket+0x1c>
800047fc:	e0 a0 9a 0a 	rcall	80017c10 <puts>
*******************************************************************************/
uint8_t DAC_Network_DestroySocket(void)
{
	uint8_t result;
	LOG_NOR("Destroying DAC Network -> INIC socket...\n");
	result = ScmDestroySocket(DAC_connection.Network_handle, DAC_Network_DestroySocket_CB);
80004800:	48 68       	lddpc	r8,80004818 <DAC_Network_DestroySocket+0x20>
80004802:	e0 6a 04 04 	mov	r10,1028
80004806:	11 ac       	ld.ub	r12,r8[0x2]
80004808:	fe cb fb c4 	sub	r11,pc,-1084
8000480c:	e0 a0 6f 60 	rcall	800126cc <ScmSendHandleMsg>
	return (result);
}
80004810:	d8 02       	popm	pc
80004812:	d7 03       	nop
80004814:	80 06       	ld.sh	r6,r0[0x0]
80004816:	8f 50       	st.w	r7[0x14],r0
80004818:	00 00       	add	r0,r0
8000481a:	40 38       	lddsp	r8,sp[0xc]

8000481c <DAC_INIC_DestroySocket>:
8000481c:	d4 01       	pushm	lr
8000481e:	48 7c       	lddpc	r12,80004838 <DAC_INIC_DestroySocket+0x1c>
80004820:	e0 a0 99 f8 	rcall	80017c10 <puts>
*******************************************************************************/
uint8_t DAC_INIC_DestroySocket(void)
{
	uint8_t result;
	LOG_NOR("Destroying DAC -> INIC Socket...\n");
	result = ScmDestroySocket(DAC_connection.INIC_handle, DAC_INIC_DestroySocket_CB);
80004824:	48 68       	lddpc	r8,8000483c <DAC_INIC_DestroySocket+0x20>
80004826:	e0 6a 04 04 	mov	r10,1028
8000482a:	11 9c       	ld.ub	r12,r8[0x1]
8000482c:	fe cb fb 58 	sub	r11,pc,-1192
80004830:	e0 a0 6f 4e 	rcall	800126cc <ScmSendHandleMsg>
	return(result);
}
80004834:	d8 02       	popm	pc
80004836:	d7 03       	nop
80004838:	80 06       	ld.sh	r6,r0[0x0]
8000483a:	8f 7c       	st.w	r7[0x1c],r12
8000483c:	00 00       	add	r0,r0
8000483e:	40 38       	lddsp	r8,sp[0xc]

80004840 <DAC_DisConnectSockets>:
80004840:	d4 01       	pushm	lr
80004842:	48 7c       	lddpc	r12,8000485c <DAC_DisConnectSockets+0x1c>
80004844:	e0 a0 99 e6 	rcall	80017c10 <puts>
uint8_t DAC_DisConnectSockets(void)
{
	uint8_t result;

	LOG_NOR("Dis-connecting DAC from Network...\n");
	result = ScmDisconnectSockets(DAC_connection.ConnectionHandle, DAC_DisConnectSockets_CB); // only needs handle to disconnect socket
80004848:	48 68       	lddpc	r8,80004860 <DAC_DisConnectSockets+0x20>
8000484a:	e0 6a 04 06 	mov	r10,1030
8000484e:	11 ec       	ld.ub	r12,r8[0x6]
80004850:	fe cb fa f0 	sub	r11,pc,-1296
80004854:	e0 a0 6f 3c 	rcall	800126cc <ScmSendHandleMsg>
	return (result);
}
80004858:	d8 02       	popm	pc
8000485a:	d7 03       	nop
8000485c:	80 06       	ld.sh	r6,r0[0x0]
8000485e:	8f a0       	st.w	r7[0x28],r0
80004860:	00 00       	add	r0,r0
80004862:	40 38       	lddsp	r8,sp[0xc]

80004864 <DAC_ConnectSockets>:
80004864:	d4 01       	pushm	lr
80004866:	48 7c       	lddpc	r12,80004880 <DAC_ConnectSockets+0x1c>
80004868:	e0 a0 99 d4 	rcall	80017c10 <puts>
*******************************************************************************/
uint8_t DAC_ConnectSockets(void)
{
	uint8_t result;
	LOG_NOR("Connecting Network to DAC...\n");
	result = ScmConnectSockets(DAC_connection.Network_handle, DAC_connection.INIC_handle, DAC_ConnectSockets_CB);
8000486c:	48 68       	lddpc	r8,80004884 <DAC_ConnectSockets+0x20>
8000486e:	fe c9 fa 82 	sub	r9,pc,-1406
80004872:	11 ac       	ld.ub	r12,r8[0x2]
80004874:	30 0a       	mov	r10,0
80004876:	11 9b       	ld.ub	r11,r8[0x1]
80004878:	e0 a0 6e e4 	rcall	80012640 <ScmConnectSocketsExt>
	return (result);
}
8000487c:	d8 02       	popm	pc
8000487e:	d7 03       	nop
80004880:	80 06       	ld.sh	r6,r0[0x0]
80004882:	8f c4       	st.w	r7[0x30],r4
80004884:	00 00       	add	r0,r0
80004886:	40 38       	lddsp	r8,sp[0xc]

80004888 <DAC_Network_CreateSocket>:
80004888:	d4 01       	pushm	lr
8000488a:	20 ad       	sub	sp,40
8000488c:	48 cc       	lddpc	r12,800048bc <DAC_Network_CreateSocket+0x34>
8000488e:	e0 a0 99 c1 	rcall	80017c10 <puts>
	uint8_t result;
	TScmSocketDesc SocketDesc;

	LOG_NOR("Creating DAC Network -> INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_MOST;
	SocketDesc.direction = SCM_IN;
80004892:	30 08       	mov	r8,0
	SocketDesc.datatype = SCM_TYPE_SYNC;
80004894:	ba a8       	st.b	sp[0x2],r8
	uint8_t result;
	TScmSocketDesc SocketDesc;

	LOG_NOR("Creating DAC Network -> INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_MOST;
	SocketDesc.direction = SCM_IN;
80004896:	ba 98       	st.b	sp[0x1],r8
{
	uint8_t result;
	TScmSocketDesc SocketDesc;

	LOG_NOR("Creating DAC Network -> INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_MOST;
80004898:	30 28       	mov	r8,2
8000489a:	ba 88       	st.b	sp[0x0],r8
	SocketDesc.direction = SCM_IN;
	SocketDesc.datatype = SCM_TYPE_SYNC;
	SocketDesc.blockwidth = 0x0004;
8000489c:	30 48       	mov	r8,4
8000489e:	ba 28       	st.h	sp[0x4],r8
	SocketDesc.most.list_len = 0x01;
800048a0:	30 18       	mov	r8,1
800048a2:	fb 68 00 11 	st.b	sp[17],r8
	SocketDesc.most.list_ptr = &DAC_connection.ConnectionLabel; // has to be filled in correctly before we get here
800048a6:	48 78       	lddpc	r8,800048c0 <DAC_Network_CreateSocket+0x38>
800048a8:	2f c8       	sub	r8,-4

	result = ScmCreateSocket(&SocketDesc, DAC_Network_CreateSocket_CB);
800048aa:	fe cb fa 6e 	sub	r11,pc,-1426
800048ae:	50 58       	stdsp	sp[0x14],r8
800048b0:	1a 9c       	mov	r12,sp
800048b2:	e0 a0 70 29 	rcall	80012904 <ScmCreateSocket>
	return (result);
}
800048b6:	2f 6d       	sub	sp,-40
800048b8:	d8 02       	popm	pc
800048ba:	d7 03       	nop
800048bc:	80 06       	ld.sh	r6,r0[0x0]
800048be:	8f e4       	st.w	r7[0x38],r4
800048c0:	00 00       	add	r0,r0
800048c2:	40 38       	lddsp	r8,sp[0xc]

800048c4 <DAC_INIC_CreateSocket>:
800048c4:	d4 01       	pushm	lr
800048c6:	20 ad       	sub	sp,40
800048c8:	48 cc       	lddpc	r12,800048f8 <DAC_INIC_CreateSocket+0x34>
800048ca:	e0 a0 99 a3 	rcall	80017c10 <puts>

	// create socket from INIC to DAC
	LOG_NOR("Creating DAC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
	SocketDesc.direction = SCM_OUT;
	SocketDesc.datatype = SCM_TYPE_STREAM;
800048ce:	30 08       	mov	r8,0
	SocketDesc.blockwidth = 0x0004;
	SocketDesc.streaming.interface_id = SCM_STREAM_INTERFACE_SX2;
	SocketDesc.streaming.offset = 0x00;
800048d0:	fb 68 00 21 	st.b	sp[33],r8

	// create socket from INIC to DAC
	LOG_NOR("Creating DAC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
	SocketDesc.direction = SCM_OUT;
	SocketDesc.datatype = SCM_TYPE_STREAM;
800048d4:	ba a8       	st.b	sp[0x2],r8
	uint8_t result;
	TScmSocketDesc SocketDesc;

	// create socket from INIC to DAC
	LOG_NOR("Creating DAC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
800048d6:	30 38       	mov	r8,3
800048d8:	ba 88       	st.b	sp[0x0],r8
	SocketDesc.direction = SCM_OUT;
800048da:	30 18       	mov	r8,1
800048dc:	ba 98       	st.b	sp[0x1],r8
	SocketDesc.datatype = SCM_TYPE_STREAM;
	SocketDesc.blockwidth = 0x0004;
800048de:	30 48       	mov	r8,4
800048e0:	ba 28       	st.h	sp[0x4],r8
	SocketDesc.streaming.interface_id = SCM_STREAM_INTERFACE_SX2;
800048e2:	30 58       	mov	r8,5
	SocketDesc.streaming.offset = 0x00;

	result = ScmCreateSocket(&SocketDesc, DAC_INIC_CreateSocket_CB);
800048e4:	fe cb fa 34 	sub	r11,pc,-1484
	LOG_NOR("Creating DAC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
	SocketDesc.direction = SCM_OUT;
	SocketDesc.datatype = SCM_TYPE_STREAM;
	SocketDesc.blockwidth = 0x0004;
	SocketDesc.streaming.interface_id = SCM_STREAM_INTERFACE_SX2;
800048e8:	fb 68 00 20 	st.b	sp[32],r8
	SocketDesc.streaming.offset = 0x00;

	result = ScmCreateSocket(&SocketDesc, DAC_INIC_CreateSocket_CB);
800048ec:	1a 9c       	mov	r12,sp
800048ee:	e0 a0 70 0b 	rcall	80012904 <ScmCreateSocket>
	return (result);
}
800048f2:	2f 6d       	sub	sp,-40
800048f4:	d8 02       	popm	pc
800048f6:	d7 03       	nop
800048f8:	80 06       	ld.sh	r6,r0[0x0]
800048fa:	90 0c       	ld.sh	r12,r8[0x0]

800048fc <Amp_Events_Set>:
800048fc:	eb cd 40 c0 	pushm	r6-r7,lr
80004900:	76 08       	ld.w	r8,r11[0x0]
80004902:	48 c7       	lddpc	r7,80004930 <Amp_Events_Set+0x34>
*                  There is no response to a Set command
*  RETURNS:		Nothing
*/
/*-------------------------------------------------------------------------------------------------------------------*/
uint8_t Amp_Events_Set(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
80004904:	16 96       	mov	r6,r11
	// Parameter checking - 3 parameters - EventEnable, TempHi, TempLo

	// Cmd OK -
	Amp.EventMask = Rx_Ptr->Data[0]; // just read and save the mask - check against when we get events
80004906:	11 8c       	ld.ub	r12,r8[0x0]
80004908:	ef 6c 00 0d 	st.b	r7[13],r12
	DacSetEvents(Amp.EventMask); // bits are in correct positions already -
8000490c:	c8 ee       	rcall	80004628 <DacSetEvents>
8000490e:	48 ac       	lddpc	r12,80004934 <Amp_Events_Set+0x38>
//	PM_SetTempLimit(Rx_Ptr->Data[1], PM_TLIMHI_REG); // Set upper limit (could do error checking on input value)
//	PM_SetTempLimit(Rx_Ptr->Data[2], PM_TLIMLO_REG); // Set lower limit (could do error checking on input value)
	// Now read current Temperature limits
//	drvi2c_ByteAddrByteRead(PM_ADDR, PM_TLIMHI_REG, &Amp.HiTemp);
	LOG_NOR("Hi temperature limit: ");
80004910:	e0 a0 98 ea 	rcall	80017ae4 <printf>
80004914:	ef 3c 00 0b 	ld.ub	r12,r7[11]
	Amp_PrintTemp(Amp.HiTemp);
80004918:	c0 6f       	rcall	80004724 <Amp_PrintTemp>
8000491a:	48 8c       	lddpc	r12,80004938 <Amp_Events_Set+0x3c>
8000491c:	e0 a0 98 e4 	rcall	80017ae4 <printf>
//	drvi2c_ByteAddrByteRead(PM_ADDR, PM_TLIMLO_REG, &Amp.LoTemp);
	LOG_NOR("Low temperature limit: ");
80004920:	ef 3c 00 0c 	ld.ub	r12,r7[12]
	Amp_PrintTemp(Amp.LoTemp);
80004924:	c0 0f       	rcall	80004724 <Amp_PrintTemp>
80004926:	30 08       	mov	r8,0
80004928:	30 0c       	mov	r12,0
8000492a:	ac 28       	st.h	r6[0x4],r8

	Rx_Ptr->Length = 0; // In case this message gets passed on the Events_Get - fix the length
8000492c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004930:	00 00       	add	r0,r0
	return (OP_NO_REPORT);
}
80004932:	40 42       	lddsp	r2,sp[0x10]
80004934:	80 06       	ld.sh	r6,r0[0x0]
80004936:	90 2c       	ld.sh	r12,r8[0x4]
80004938:	80 06       	ld.sh	r6,r0[0x0]
8000493a:	90 44       	ld.sh	r4,r8[0x8]

8000493c <Amp_Volume_Dec>:
8000493c:	d4 01       	pushm	lr
8000493e:	48 b8       	lddpc	r8,80004968 <Amp_Volume_Dec+0x2c>
80004940:	f1 39 00 1a 	ld.ub	r9,r8[26]
80004944:	30 08       	mov	r8,0
80004946:	f0 09 18 00 	cp.b	r9,r8
8000494a:	c0 60       	breq	80004956 <Amp_Volume_Dec+0x1a>
8000494c:	48 88       	lddpc	r8,8000496c <Amp_Volume_Dec+0x30>
8000494e:	11 8c       	ld.ub	r12,r8[0x0]
{

	// step parameter is ignored - always dec 1dB
	if (MyNode.CodecPresent)
	{
		if (Amp.pVolume != 0)
80004950:	58 0c       	cp.w	r12,0
80004952:	c0 61       	brne	8000495e <Amp_Volume_Dec+0x22>
	}
	else
	{
		return (CmdErrorMsg(Tx_Ptr, I2C_ERROR));
	}
}
80004954:	d8 02       	popm	pc

		return (OP_NO_REPORT);
	}
	else
	{
		return (CmdErrorMsg(Tx_Ptr, I2C_ERROR));
80004956:	32 1b       	mov	r11,33
80004958:	e0 a0 79 0e 	rcall	80013b74 <CmdErrorMsg>
	}
}
8000495c:	d8 02       	popm	pc
	// step parameter is ignored - always dec 1dB
	if (MyNode.CodecPresent)
	{
		if (Amp.pVolume != 0)
		{
			Amp.pVolume -= 1;
8000495e:	20 1c       	sub	r12,1
80004960:	b0 8c       	st.b	r8[0x0],r12
			Set_Volume();
80004962:	c2 ff       	rcall	800047c0 <Set_Volume>
80004964:	d8 0a       	popm	pc,r12=0
80004966:	d7 03       	nop
80004968:	00 00       	add	r0,r0
8000496a:	40 06       	lddsp	r6,sp[0x0]
8000496c:	00 00       	add	r0,r0
8000496e:	40 42       	lddsp	r2,sp[0x10]

80004970 <Amp_Volume_Inc>:
80004970:	d4 01       	pushm	lr
80004972:	48 b8       	lddpc	r8,8000499c <Amp_Volume_Inc+0x2c>
80004974:	f1 39 00 1a 	ld.ub	r9,r8[26]
****************************************************************************/
uint8_t Amp_Volume_Inc(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	// step parameter is ignored - always inc 1 step
	if (MyNode.CodecPresent)
80004978:	30 08       	mov	r8,0
8000497a:	f0 09 18 00 	cp.b	r9,r8
8000497e:	c0 b0       	breq	80004994 <Amp_Volume_Inc+0x24>
	{
		if (Amp.pVolume != VOLMAX)
80004980:	48 88       	lddpc	r8,800049a0 <Amp_Volume_Inc+0x30>
80004982:	32 8a       	mov	r10,40
80004984:	11 89       	ld.ub	r9,r8[0x0]
80004986:	f4 09 18 00 	cp.b	r9,r10
8000498a:	c0 40       	breq	80004992 <Amp_Volume_Inc+0x22>
		{
			Amp.pVolume += 1;
8000498c:	2f f9       	sub	r9,-1
8000498e:	b0 89       	st.b	r8[0x0],r9
			Set_Volume();
80004990:	c1 8f       	rcall	800047c0 <Set_Volume>
80004992:	d8 0a       	popm	pc,r12=0
80004994:	32 1b       	mov	r11,33
		}
		return (OP_NO_REPORT);
	}
	else
	{
		return (CmdErrorMsg(Tx_Ptr, I2C_ERROR));
80004996:	e0 a0 78 ef 	rcall	80013b74 <CmdErrorMsg>
8000499a:	d8 02       	popm	pc
	}
}
8000499c:	00 00       	add	r0,r0
8000499e:	40 06       	lddsp	r6,sp[0x0]
800049a0:	00 00       	add	r0,r0
800049a2:	40 42       	lddsp	r2,sp[0x10]

800049a4 <Amp_Volume_Set>:
800049a4:	d4 01       	pushm	lr
800049a6:	32 89       	mov	r9,40
800049a8:	76 0a       	ld.w	r10,r11[0x0]
800049aa:	15 88       	ld.ub	r8,r10[0x0]
800049ac:	f2 08 18 00 	cp.b	r8,r9
*
****************************************************************************/
uint8_t Amp_Volume_Set(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	// Parameter checking - 1 parameter - volume setting
	if (Rx_Ptr->Data[0] > VOLMAX)
800049b0:	e0 8b 00 11 	brhi	800049d2 <Amp_Volume_Set+0x2e>
	return (CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));

	if (MyNode.CodecPresent)
800049b4:	48 a9       	lddpc	r9,800049dc <Amp_Volume_Set+0x38>
800049b6:	f3 3a 00 1a 	ld.ub	r10,r9[26]
800049ba:	30 09       	mov	r9,0
800049bc:	f2 0a 18 00 	cp.b	r10,r9
800049c0:	c0 51       	brne	800049ca <Amp_Volume_Set+0x26>
		Set_Volume();
		return (OP_NO_REPORT);
	}
	else
	{
		return (CmdErrorMsg(Tx_Ptr, I2C_ERROR));
800049c2:	32 1b       	mov	r11,33
800049c4:	e0 a0 78 d8 	rcall	80013b74 <CmdErrorMsg>
	}
}
800049c8:	d8 02       	popm	pc
	if (Rx_Ptr->Data[0] > VOLMAX)
	return (CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));

	if (MyNode.CodecPresent)
	{
		Amp.pVolume = Rx_Ptr->Data[0]; // Get the Volume from message
800049ca:	48 69       	lddpc	r9,800049e0 <Amp_Volume_Set+0x3c>
800049cc:	b2 88       	st.b	r9[0x0],r8
		Set_Volume();
800049ce:	cf 9e       	rcall	800047c0 <Set_Volume>
800049d0:	d8 0a       	popm	pc,r12=0
800049d2:	30 19       	mov	r9,1
****************************************************************************/
uint8_t Amp_Volume_Set(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	// Parameter checking - 1 parameter - volume setting
	if (Rx_Ptr->Data[0] > VOLMAX)
	return (CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
800049d4:	12 9b       	mov	r11,r9
800049d6:	e0 a0 78 dd 	rcall	80013b90 <CmdErrorParamWrong>
800049da:	d8 02       	popm	pc
800049dc:	00 00       	add	r0,r0
800049de:	40 06       	lddsp	r6,sp[0x0]
800049e0:	00 00       	add	r0,r0
800049e2:	40 42       	lddsp	r2,sp[0x10]

800049e4 <Amp_SinkName_Get>:
800049e4:	d4 01       	pushm	lr
800049e6:	76 0a       	ld.w	r10,r11[0x0]
800049e8:	30 1b       	mov	r11,1
800049ea:	15 89       	ld.ub	r9,r10[0x0]
800049ec:	12 9e       	mov	lr,r9
800049ee:	f6 09 18 00 	cp.b	r9,r11
800049f2:	c2 a1       	brne	80004a46 <Amp_SinkName_Get+0x62>
{

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));

	Tx_Ptr->Data[0] = AMP_SINK_NR;
800049f4:	78 0a       	ld.w	r10,r12[0x0]
800049f6:	b4 89       	st.b	r10[0x0],r9
	Tx_Ptr->Data[1] = ISO8859;
800049f8:	78 0a       	ld.w	r10,r12[0x0]
800049fa:	b4 99       	st.b	r10[0x1],r9
	Tx_Ptr->Data[2] = 'A';
800049fc:	34 1a       	mov	r10,65
800049fe:	78 09       	ld.w	r9,r12[0x0]
80004a00:	b2 aa       	st.b	r9[0x2],r10
	Tx_Ptr->Data[3] = 'u';
80004a02:	78 0a       	ld.w	r10,r12[0x0]
80004a04:	37 59       	mov	r9,117
80004a06:	b4 b9       	st.b	r10[0x3],r9
	Tx_Ptr->Data[4] = 'd';
80004a08:	78 0a       	ld.w	r10,r12[0x0]
80004a0a:	36 4b       	mov	r11,100
80004a0c:	b4 cb       	st.b	r10[0x4],r11
	Tx_Ptr->Data[5] = 'i';
80004a0e:	78 0a       	ld.w	r10,r12[0x0]
80004a10:	36 9b       	mov	r11,105
80004a12:	b4 db       	st.b	r10[0x5],r11
	Tx_Ptr->Data[6] = 'o';
80004a14:	78 0a       	ld.w	r10,r12[0x0]
80004a16:	36 fb       	mov	r11,111
80004a18:	b4 eb       	st.b	r10[0x6],r11
	Tx_Ptr->Data[7] = ' ';
80004a1a:	78 0a       	ld.w	r10,r12[0x0]
80004a1c:	32 0b       	mov	r11,32
80004a1e:	b4 fb       	st.b	r10[0x7],r11
	Tx_Ptr->Data[8] = 'O';
80004a20:	78 0a       	ld.w	r10,r12[0x0]
80004a22:	34 fb       	mov	r11,79
80004a24:	f5 6b 00 08 	st.b	r10[8],r11
	Tx_Ptr->Data[9] = 'u';
80004a28:	78 0a       	ld.w	r10,r12[0x0]
80004a2a:	f5 69 00 09 	st.b	r10[9],r9
	Tx_Ptr->Data[10] = 't';
80004a2e:	37 4a       	mov	r10,116
80004a30:	78 09       	ld.w	r9,r12[0x0]
80004a32:	f3 6a 00 0a 	st.b	r9[10],r10
	Tx_Ptr->Data[11] = 0x00;
80004a36:	30 0a       	mov	r10,0
80004a38:	78 09       	ld.w	r9,r12[0x0]
80004a3a:	f3 6a 00 0b 	st.b	r9[11],r10
	Tx_Ptr->Length = 12;
80004a3e:	30 c9       	mov	r9,12
80004a40:	b8 29       	st.h	r12[0x4],r9
80004a42:	30 cc       	mov	r12,12
	return (OP_STATUS);
}
80004a44:	d8 02       	popm	pc
****************************************************************************/
uint8_t Amp_SinkName_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
80004a46:	30 19       	mov	r9,1
80004a48:	12 9b       	mov	r11,r9
80004a4a:	e0 a0 78 a3 	rcall	80013b90 <CmdErrorParamWrong>
80004a4e:	d8 02       	popm	pc

80004a50 <Amp_Mute_Get>:
80004a50:	d4 01       	pushm	lr
80004a52:	76 0a       	ld.w	r10,r11[0x0]
*
****************************************************************************/
uint8_t Amp_Mute_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
80004a54:	30 1b       	mov	r11,1
80004a56:	15 89       	ld.ub	r9,r10[0x0]
80004a58:	12 9e       	mov	lr,r9
80004a5a:	f6 09 18 00 	cp.b	r9,r11
80004a5e:	c0 b1       	brne	80004a74 <Amp_Mute_Get+0x24>
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));


	Tx_Ptr->Data[0] = AMP_SINK_NR; // SinkNumber
80004a60:	78 0a       	ld.w	r10,r12[0x0]
80004a62:	b4 89       	st.b	r10[0x0],r9
	Tx_Ptr->Data[1] = Amp.pMute; // Status
80004a64:	48 79       	lddpc	r9,80004a80 <Amp_Mute_Get+0x30>
80004a66:	13 ea       	ld.ub	r10,r9[0x6]
80004a68:	78 09       	ld.w	r9,r12[0x0]
80004a6a:	b2 9a       	st.b	r9[0x1],r10
	Tx_Ptr->Length = 2;
80004a6c:	30 29       	mov	r9,2
80004a6e:	b8 29       	st.h	r12[0x4],r9
80004a70:	30 cc       	mov	r12,12
	return (OP_STATUS);
}
80004a72:	d8 02       	popm	pc
****************************************************************************/
uint8_t Amp_Mute_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
80004a74:	30 19       	mov	r9,1
80004a76:	12 9b       	mov	r11,r9
80004a78:	e0 a0 78 8c 	rcall	80013b90 <CmdErrorParamWrong>
80004a7c:	d8 02       	popm	pc
80004a7e:	d7 03       	nop
80004a80:	00 00       	add	r0,r0
80004a82:	40 42       	lddsp	r2,sp[0x10]

80004a84 <Amp_Mute_Set>:
80004a84:	d4 01       	pushm	lr
80004a86:	30 18       	mov	r8,1
*
****************************************************************************/
uint8_t Amp_Mute_Set(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
80004a88:	76 0a       	ld.w	r10,r11[0x0]
80004a8a:	15 8b       	ld.ub	r11,r10[0x0]
80004a8c:	f0 0b 18 00 	cp.b	r11,r8
80004a90:	c1 31       	brne	80004ab6 <Amp_Mute_Set+0x32>
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));

	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION)
80004a92:	49 88       	lddpc	r8,80004af0 <Amp_Mute_Set+0x6c>
80004a94:	11 e9       	ld.ub	r9,r8[0x6]
80004a96:	3f f8       	mov	r8,-1
80004a98:	f0 09 18 00 	cp.b	r9,r8
80004a9c:	c1 a0       	breq	80004ad0 <Amp_Mute_Set+0x4c>
	{
		if (Rx_Ptr->Data[1] == 0x00) // Read Status
80004a9e:	2f fa       	sub	r10,-1
80004aa0:	15 88       	ld.ub	r8,r10[0x0]
80004aa2:	58 08       	cp.w	r8,0
80004aa4:	c0 e0       	breq	80004ac0 <Amp_Mute_Set+0x3c>
		{
			Amp.pMute = FALSE; // Set Flag Mute Off
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
		}
		else if (Rx_Ptr->Data[1] == 0x01)
80004aa6:	f6 08 18 00 	cp.b	r8,r11
80004aaa:	c1 a0       	breq	80004ade <Amp_Mute_Set+0x5a>
			Amp.pMute = TRUE; // Set Flag for Mute
			ScmMuteConnection(DAC_connection.ConnectionHandle, NULL);
		}
		else
		{
			return (CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[1], 1));
80004aac:	30 19       	mov	r9,1
80004aae:	30 2b       	mov	r11,2
80004ab0:	e0 a0 78 70 	rcall	80013b90 <CmdErrorParamWrong>
80004ab4:	d8 02       	popm	pc
****************************************************************************/
uint8_t Amp_Mute_Set(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
80004ab6:	30 19       	mov	r9,1
80004ab8:	12 9b       	mov	r11,r9
80004aba:	e0 a0 78 6b 	rcall	80013b90 <CmdErrorParamWrong>
80004abe:	d8 02       	popm	pc
	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION)
	{
		if (Rx_Ptr->Data[1] == 0x00) // Read Status
		{
			Amp.pMute = FALSE; // Set Flag Mute Off
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
80004ac0:	12 9c       	mov	r12,r9

	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION)
	{
		if (Rx_Ptr->Data[1] == 0x00) // Read Status
		{
			Amp.pMute = FALSE; // Set Flag Mute Off
80004ac2:	48 d9       	lddpc	r9,80004af4 <Amp_Mute_Set+0x70>
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
80004ac4:	10 9b       	mov	r11,r8

	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION)
	{
		if (Rx_Ptr->Data[1] == 0x00) // Read Status
		{
			Amp.pMute = FALSE; // Set Flag Mute Off
80004ac6:	b2 e8       	st.b	r9[0x6],r8
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
80004ac8:	e0 6a 04 0d 	mov	r10,1037
80004acc:	e0 a0 6e 00 	rcall	800126cc <ScmSendHandleMsg>
		{
			return (CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[1], 1));
		}
	}

	NtfPropertyChangedFkt(FBLOCK_AMP, 0, FUNC_MUTE); // trigger notification
80004ad0:	e0 6a 01 13 	mov	r10,275
80004ad4:	30 0b       	mov	r11,0
80004ad6:	32 2c       	mov	r12,34
80004ad8:	e0 a0 88 14 	rcall	80015b00 <NtfPropertyChangedFkt>
80004adc:	d8 0a       	popm	pc,r12=0
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
		}
		else if (Rx_Ptr->Data[1] == 0x01)
		{
			Amp.pMute = TRUE; // Set Flag for Mute
			ScmMuteConnection(DAC_connection.ConnectionHandle, NULL);
80004ade:	12 9c       	mov	r12,r9
			Amp.pMute = FALSE; // Set Flag Mute Off
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
		}
		else if (Rx_Ptr->Data[1] == 0x01)
		{
			Amp.pMute = TRUE; // Set Flag for Mute
80004ae0:	48 59       	lddpc	r9,80004af4 <Amp_Mute_Set+0x70>
			ScmMuteConnection(DAC_connection.ConnectionHandle, NULL);
80004ae2:	e0 6a 04 0c 	mov	r10,1036
			Amp.pMute = FALSE; // Set Flag Mute Off
			ScmDemuteConnection(DAC_connection.ConnectionHandle, NULL);
		}
		else if (Rx_Ptr->Data[1] == 0x01)
		{
			Amp.pMute = TRUE; // Set Flag for Mute
80004ae6:	b2 e8       	st.b	r9[0x6],r8
			ScmMuteConnection(DAC_connection.ConnectionHandle, NULL);
80004ae8:	30 0b       	mov	r11,0
80004aea:	e0 a0 6d f1 	rcall	800126cc <ScmSendHandleMsg>
80004aee:	cf 1b       	rjmp	80004ad0 <Amp_Mute_Set+0x4c>
80004af0:	00 00       	add	r0,r0
80004af2:	40 38       	lddsp	r8,sp[0xc]
80004af4:	00 00       	add	r0,r0
80004af6:	40 42       	lddsp	r2,sp[0x10]

80004af8 <Amp_SinkInfo_Get>:
80004af8:	d4 01       	pushm	lr
80004afa:	30 18       	mov	r8,1
80004afc:	76 0a       	ld.w	r10,r11[0x0]
80004afe:	15 89       	ld.ub	r9,r10[0x0]
80004b00:	f0 09 18 00 	cp.b	r9,r8
*
****************************************************************************/
uint8_t Amp_SinkInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	// parameter checking - 1 parameter -> SinkNr
	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
80004b04:	c0 60       	breq	80004b10 <Amp_SinkInfo_Get+0x18>
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
80004b06:	30 19       	mov	r9,1
80004b08:	12 9b       	mov	r11,r9
80004b0a:	e0 a0 78 43 	rcall	80013b90 <CmdErrorParamWrong>
80004b0e:	d8 02       	popm	pc

	return (Amp_SinkInfo_Get_N(Tx_Ptr)); // Let the notification function do the work below
80004b10:	fe b0 fd 9a 	rcall	80004644 <Amp_SinkInfo_Get_N>
}
80004b14:	d8 02       	popm	pc
80004b16:	d7 03       	nop

80004b18 <Amp_DisConnect_Result>:
80004b18:	eb cd 40 80 	pushm	r7,lr
80004b1c:	4a 08       	lddpc	r8,80004b9c <Amp_DisConnect_Result+0x84>
80004b1e:	30 09       	mov	r9,0
*
****************************************************************************/
void Amp_DisConnect_Result(uint16_t result)
{

	if (DAC_connection.LocalCommand) // if we're doing this on our own (not commanded to)
80004b20:	f1 3a 00 09 	ld.ub	r10,r8[9]
80004b24:	f2 0a 18 00 	cp.b	r10,r9
80004b28:	c0 b0       	breq	80004b3e <Amp_DisConnect_Result+0x26>
	{ // ... then don't reply
		DAC_connection.LocalCommand = FALSE; // no longer working on local command (if we were)
80004b2a:	f1 69 00 09 	st.b	r8[9],r9

		CmdInsertSenderHandle(AmpRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		MsgSend(AmpRetained_Tx_Ptr); // send response now
		AmpRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
	}
	NtfPropertyChangedFkt(FBLOCK_AMP, 0, FUNC_SINKINFO); // trigger notification
80004b2e:	e0 6a 01 10 	mov	r10,272
80004b32:	30 0b       	mov	r11,0
80004b34:	32 2c       	mov	r12,34
80004b36:	e0 a0 87 e5 	rcall	80015b00 <NtfPropertyChangedFkt>
80004b3a:	e3 cd 80 80 	ldm	sp++,r7,pc
	{ // ... then don't reply
		DAC_connection.LocalCommand = FALSE; // no longer working on local command (if we were)
	}
	else // reply to whoever told us to disconnect
	{
		if (AmpRetained_Tx_Ptr == NULL) // sanity check - should have valid pointer when we get here
80004b3e:	49 97       	lddpc	r7,80004ba0 <Amp_DisConnect_Result+0x88>
80004b40:	6e 09       	ld.w	r9,r7[0x0]
80004b42:	58 09       	cp.w	r9,0
80004b44:	c2 70       	breq	80004b92 <Amp_DisConnect_Result+0x7a>
		{
			LOG_ERR("Tried to respond to AmpDisConnect, but had no valid message pointer\n");
			return;
		}

		if (result == NSR_S_OK) // return is OK
80004b46:	58 0c       	cp.w	r12,0
80004b48:	c1 a1       	brne	80004b7c <Amp_DisConnect_Result+0x64>
		{
			DAC_connection.ConnectionLabel = INVALID_LABEL; // this label no longer in use
80004b4a:	b0 2c       	st.h	r8[0x4],r12
			AmpRetained_Tx_Ptr->Operation = OP_RESULTACK; // response to start/result
80004b4c:	30 d8       	mov	r8,13
80004b4e:	f3 68 00 0c 	st.b	r9[12],r8
			AmpRetained_Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
80004b52:	30 19       	mov	r9,1
80004b54:	6e 08       	ld.w	r8,r7[0x0]
80004b56:	70 08       	ld.w	r8,r8[0x0]
80004b58:	b0 89       	st.b	r8[0x0],r9
			AmpRetained_Tx_Ptr->Length = 1; //
80004b5a:	30 19       	mov	r9,1
80004b5c:	6e 08       	ld.w	r8,r7[0x0]
80004b5e:	b0 29       	st.h	r8[0x4],r9
			AmpRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
			AmpRetained_Tx_Ptr->Data[0] = ERR_PROCESSING; // error processing this request
			AmpRetained_Tx_Ptr->Length = 1; //
		}

		CmdInsertSenderHandle(AmpRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80004b60:	49 18       	lddpc	r8,80004ba4 <Amp_DisConnect_Result+0x8c>
80004b62:	6e 0c       	ld.w	r12,r7[0x0]
80004b64:	90 0a       	ld.sh	r10,r8[0x0]
80004b66:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80004b6a:	5c 5a       	castu.b	r10
80004b6c:	e0 a0 78 62 	rcall	80013c30 <CmdInsertSenderHandle>
		MsgSend(AmpRetained_Tx_Ptr); // send response now
80004b70:	6e 0c       	ld.w	r12,r7[0x0]
80004b72:	e0 a0 27 01 	rcall	80009974 <MsgSend>
		AmpRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
80004b76:	30 08       	mov	r8,0
80004b78:	8f 08       	st.w	r7[0x0],r8
80004b7a:	cd ab       	rjmp	80004b2e <Amp_DisConnect_Result+0x16>
			AmpRetained_Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
			AmpRetained_Tx_Ptr->Length = 1; //
		}
		else
		{
			AmpRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
80004b7c:	30 98       	mov	r8,9
80004b7e:	f3 68 00 0c 	st.b	r9[12],r8
			AmpRetained_Tx_Ptr->Data[0] = ERR_PROCESSING; // error processing this request
80004b82:	34 29       	mov	r9,66
80004b84:	6e 08       	ld.w	r8,r7[0x0]
80004b86:	70 08       	ld.w	r8,r8[0x0]
80004b88:	b0 89       	st.b	r8[0x0],r9
			AmpRetained_Tx_Ptr->Length = 1; //
80004b8a:	30 19       	mov	r9,1
80004b8c:	6e 08       	ld.w	r8,r7[0x0]
80004b8e:	b0 29       	st.h	r8[0x4],r9
80004b90:	ce 8b       	rjmp	80004b60 <Amp_DisConnect_Result+0x48>
	}
	else // reply to whoever told us to disconnect
	{
		if (AmpRetained_Tx_Ptr == NULL) // sanity check - should have valid pointer when we get here
		{
			LOG_ERR("Tried to respond to AmpDisConnect, but had no valid message pointer\n");
80004b92:	48 6c       	lddpc	r12,80004ba8 <Amp_DisConnect_Result+0x90>
80004b94:	e0 a0 98 3e 	rcall	80017c10 <puts>
			return;
80004b98:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b9c:	00 00       	add	r0,r0
80004b9e:	40 38       	lddsp	r8,sp[0xc]
80004ba0:	00 00       	add	r0,r0
80004ba2:	40 34       	lddsp	r4,sp[0xc]
80004ba4:	00 00       	add	r0,r0
80004ba6:	06 18       	sub	r8,r3
80004ba8:	80 06       	ld.sh	r6,r0[0x0]
80004baa:	90 5c       	ld.sh	r12,r8[0xa]

80004bac <Amp_DisconnectTimeout>:
80004bac:	d4 01       	pushm	lr
80004bae:	48 4c       	lddpc	r12,80004bbc <Amp_DisconnectTimeout+0x10>
80004bb0:	e0 a0 98 30 	rcall	80017c10 <puts>
80004bb4:	e0 6c 80 00 	mov	r12,32768
80004bb8:	cb 0f       	rcall	80004b18 <Amp_DisConnect_Result>
80004bba:	d8 02       	popm	pc

void Amp_DisconnectTimeout(void)
{
	LOG_ERR("Timed out while disconnecting stereo DAC from Network\n");
	Amp_DisConnect_Result(NSR_E_FAILED);
}
80004bbc:	80 06       	ld.sh	r6,r0[0x0]
80004bbe:	90 a0       	ld.uh	r0,r8[0x4]

80004bc0 <Amp_Connect_Result>:
80004bc0:	eb cd 40 80 	pushm	r7,lr
80004bc4:	49 c7       	lddpc	r7,80004c34 <Amp_Connect_Result+0x74>
80004bc6:	6e 08       	ld.w	r8,r7[0x0]
80004bc8:	58 08       	cp.w	r8,0
80004bca:	c2 f0       	breq	80004c28 <Amp_Connect_Result+0x68>
	{
		LOG_ERR("Tried to respond to AmpConnect, but had no valid message pointer\n");
		return;
	}

	if (NSR_S_OK == result) // return is OK
80004bcc:	58 0c       	cp.w	r12,0
80004bce:	c2 20       	breq	80004c12 <Amp_Connect_Result+0x52>
		AmpRetained_Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		AmpRetained_Tx_Ptr->Length = 1; //
	}
	else
	{
		AmpRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
80004bd0:	30 99       	mov	r9,9
80004bd2:	f1 69 00 0c 	st.b	r8[12],r9
		AmpRetained_Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
80004bd6:	34 29       	mov	r9,66
80004bd8:	6e 08       	ld.w	r8,r7[0x0]
80004bda:	70 08       	ld.w	r8,r8[0x0]
80004bdc:	b0 89       	st.b	r8[0x0],r9
		AmpRetained_Tx_Ptr->Length = 1; //
80004bde:	30 19       	mov	r9,1
80004be0:	6e 08       	ld.w	r8,r7[0x0]
80004be2:	b0 29       	st.h	r8[0x4],r9
	}
	DAC_connection.Connecting = FALSE; // done connecting now
80004be4:	49 58       	lddpc	r8,80004c38 <Amp_Connect_Result+0x78>
80004be6:	30 09       	mov	r9,0
80004be8:	b0 f9       	st.b	r8[0x7],r9
	CmdInsertSenderHandle(AmpRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80004bea:	49 58       	lddpc	r8,80004c3c <Amp_Connect_Result+0x7c>
80004bec:	6e 0c       	ld.w	r12,r7[0x0]
80004bee:	90 0a       	ld.sh	r10,r8[0x0]
80004bf0:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80004bf4:	5c 5a       	castu.b	r10
80004bf6:	e0 a0 78 1d 	rcall	80013c30 <CmdInsertSenderHandle>
	MsgSend(AmpRetained_Tx_Ptr); // send response now
80004bfa:	6e 0c       	ld.w	r12,r7[0x0]
80004bfc:	e0 a0 26 bc 	rcall	80009974 <MsgSend>
	AmpRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
80004c00:	30 0b       	mov	r11,0
	NtfPropertyChangedFkt(FBLOCK_AMP, 0, FUNC_SINKINFO); // trigger notification
80004c02:	e0 6a 01 10 	mov	r10,272
		AmpRetained_Tx_Ptr->Length = 1; //
	}
	DAC_connection.Connecting = FALSE; // done connecting now
	CmdInsertSenderHandle(AmpRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
	MsgSend(AmpRetained_Tx_Ptr); // send response now
	AmpRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
80004c06:	8f 0b       	st.w	r7[0x0],r11
	NtfPropertyChangedFkt(FBLOCK_AMP, 0, FUNC_SINKINFO); // trigger notification
80004c08:	32 2c       	mov	r12,34
80004c0a:	e0 a0 87 7b 	rcall	80015b00 <NtfPropertyChangedFkt>
80004c0e:	e3 cd 80 80 	ldm	sp++,r7,pc
		return;
	}

	if (NSR_S_OK == result) // return is OK
	{
		AmpRetained_Tx_Ptr->Operation = OP_RESULTACK; // response to start/result
80004c12:	30 d9       	mov	r9,13
80004c14:	f1 69 00 0c 	st.b	r8[12],r9
		AmpRetained_Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
80004c18:	30 19       	mov	r9,1
80004c1a:	6e 08       	ld.w	r8,r7[0x0]
80004c1c:	70 08       	ld.w	r8,r8[0x0]
80004c1e:	b0 89       	st.b	r8[0x0],r9
		AmpRetained_Tx_Ptr->Length = 1; //
80004c20:	30 19       	mov	r9,1
80004c22:	6e 08       	ld.w	r8,r7[0x0]
80004c24:	b0 29       	st.h	r8[0x4],r9
80004c26:	cd fb       	rjmp	80004be4 <Amp_Connect_Result+0x24>
void Amp_Connect_Result(uint16_t result)
{

	if (NULL == AmpRetained_Tx_Ptr) // sanity check - should have valid pointer when we get here
	{
		LOG_ERR("Tried to respond to AmpConnect, but had no valid message pointer\n");
80004c28:	48 6c       	lddpc	r12,80004c40 <Amp_Connect_Result+0x80>
80004c2a:	e0 a0 97 f3 	rcall	80017c10 <puts>
		return;
80004c2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c32:	d7 03       	nop
80004c34:	00 00       	add	r0,r0
80004c36:	40 34       	lddsp	r4,sp[0xc]
80004c38:	00 00       	add	r0,r0
80004c3a:	40 38       	lddsp	r8,sp[0xc]
80004c3c:	00 00       	add	r0,r0
80004c3e:	06 18       	sub	r8,r3
80004c40:	80 06       	ld.sh	r6,r0[0x0]
80004c42:	90 d8       	ld.uh	r8,r8[0xa]

80004c44 <DAC_Network_DestroySocket_CB>:
80004c44:	eb cd 40 80 	pushm	r7,lr
80004c48:	20 1d       	sub	sp,4
80004c4a:	18 97       	mov	r7,r12
80004c4c:	58 0c       	cp.w	r12,0
80004c4e:	c1 01       	brne	80004c6e <DAC_Network_DestroySocket_CB+0x2a>
80004c50:	49 dc       	lddpc	r12,80004cc4 <DAC_Network_DestroySocket_CB+0x80>
80004c52:	e0 a0 97 df 	rcall	80017c10 <puts>
	uint8_t result;

	if (NSR_S_OK == cb_result)
	{
		LOG_NOR("DAC Network -> INIC Socket Destroyed OK\n");
		DAC_connection.Network_handle = INVALID_SOCKET; // socket killed
80004c56:	49 d8       	lddpc	r8,80004cc8 <DAC_Network_DestroySocket_CB+0x84>
80004c58:	3f f9       	mov	r9,-1
80004c5a:	b0 a9       	st.b	r8[0x2],r9
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
80004c5c:	11 fa       	ld.ub	r10,r8[0x7]
80004c5e:	ee 0a 18 00 	cp.b	r10,r7
80004c62:	c1 c0       	breq	80004c9a <DAC_Network_DestroySocket_CB+0x56>
		{
			result = DAC_INIC_CreateSocket(); // process started by "Connect" so now get on with connecting
80004c64:	c3 0e       	rcall	800048c4 <DAC_INIC_CreateSocket>
80004c66:	c2 21       	brne	80004caa <DAC_Network_DestroySocket_CB+0x66>
			if (ERR_NO != result)
80004c68:	2f fd       	sub	sp,-4
			Amp_DisConnect_Result(cb_result); // dis-connect has failed
		}
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
	}
}
80004c6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c6e:	5c 77       	castu.h	r7
			ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
		}
	}
	else
	{
		LOG_ERR("Error Destroying DAC Network -> INIC Socket: Error Code = %02X\n", cb_result);
80004c70:	49 7c       	lddpc	r12,80004ccc <DAC_Network_DestroySocket_CB+0x88>
80004c72:	1a d7       	st.w	--sp,r7
80004c74:	e0 a0 97 38 	rcall	80017ae4 <printf>
80004c78:	49 48       	lddpc	r8,80004cc8 <DAC_Network_DestroySocket_CB+0x84>
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
80004c7a:	2f fd       	sub	sp,-4
80004c7c:	11 f9       	ld.ub	r9,r8[0x7]
80004c7e:	30 08       	mov	r8,0
80004c80:	f0 09 18 00 	cp.b	r9,r8
80004c84:	c0 81       	brne	80004c94 <DAC_Network_DestroySocket_CB+0x50>
80004c86:	0e 9c       	mov	r12,r7
		{
			Amp_Connect_Result(cb_result); // connection failed - can't disconnect
		}
		else  // doing disconnect only
		{
			Amp_DisConnect_Result(cb_result); // dis-connect has failed
80004c88:	c4 8f       	rcall	80004b18 <Amp_DisConnect_Result>
80004c8a:	fe b0 fb cd 	rcall	80004424 <ConmgrReturnMutex>
		}
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80004c8e:	2f fd       	sub	sp,-4
80004c90:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
}
80004c94:	0e 9c       	mov	r12,r7
80004c96:	c9 5f       	rcall	80004bc0 <Amp_Connect_Result>
	else
	{
		LOG_ERR("Error Destroying DAC Network -> INIC Socket: Error Code = %02X\n", cb_result);
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
		{
			Amp_Connect_Result(cb_result); // connection failed - can't disconnect
80004c98:	cf 9b       	rjmp	80004c8a <DAC_Network_DestroySocket_CB+0x46>
80004c9a:	0e 9c       	mov	r12,r7
80004c9c:	b0 27       	st.h	r8[0x4],r7
80004c9e:	c3 df       	rcall	80004b18 <Amp_DisConnect_Result>
			}
		} // don't respond yet - will do when connection is finished
		else
		{
			DAC_connection.ConnectionLabel = INVALID_LABEL; // this label no longer in use
			Amp_DisConnect_Result(cb_result); // normal exit of disconnect process
80004ca0:	fe b0 fb c2 	rcall	80004424 <ConmgrReturnMutex>
80004ca4:	2f fd       	sub	sp,-4
80004ca6:	e3 cd 80 80 	ldm	sp++,r7,pc
			RED_LED_OFF(); // turn off error light if it was on
			ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
80004caa:	50 0c       	stdsp	sp[0x0],r12
			Amp_DisConnect_Result(cb_result); // dis-connect has failed
		}
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
	}
}
80004cac:	fe b0 fb bc 	rcall	80004424 <ConmgrReturnMutex>
80004cb0:	40 0c       	lddsp	r12,sp[0x0]
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
		{
			result = DAC_INIC_CreateSocket(); // process started by "Connect" so now get on with connecting
			if (ERR_NO != result)
			{
				ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80004cb2:	1a dc       	st.w	--sp,r12
80004cb4:	48 7c       	lddpc	r12,80004cd0 <DAC_Network_DestroySocket_CB+0x8c>
80004cb6:	e0 a0 97 17 	rcall	80017ae4 <printf>
				RED_LED_ON(); // turn on error light
				LOG_ERR("Error starting DAC connection process after disconnect: result = %02X\n", result);
80004cba:	e0 6c 80 00 	mov	r12,32768
80004cbe:	c8 1f       	rcall	80004bc0 <Amp_Connect_Result>
80004cc0:	2f fd       	sub	sp,-4
				Amp_Connect_Result(NSR_E_FAILED); // connection failed - can't disconnect
80004cc2:	cd 3b       	rjmp	80004c68 <DAC_Network_DestroySocket_CB+0x24>
80004cc4:	80 06       	ld.sh	r6,r0[0x0]
80004cc6:	91 1c       	st.w	r8[0x4],r12
80004cc8:	00 00       	add	r0,r0
80004cca:	40 38       	lddsp	r8,sp[0xc]
80004ccc:	80 06       	ld.sh	r6,r0[0x0]
80004cce:	91 8c       	st.w	r8[0x20],r12
80004cd0:	80 06       	ld.sh	r6,r0[0x0]
80004cd2:	91 44       	st.w	r8[0x10],r4

80004cd4 <DAC_INIC_DestroySocket_CB>:
80004cd4:	eb cd 40 c0 	pushm	r6-r7,lr
80004cd8:	20 1d       	sub	sp,4
80004cda:	18 97       	mov	r7,r12
80004cdc:	58 0c       	cp.w	r12,0
80004cde:	c0 d1       	brne	80004cf8 <DAC_INIC_DestroySocket_CB+0x24>
80004ce0:	49 cc       	lddpc	r12,80004d50 <DAC_INIC_DestroySocket_CB+0x7c>
80004ce2:	e0 a0 97 97 	rcall	80017c10 <puts>
80004ce6:	3f f8       	mov	r8,-1
80004ce8:	49 b6       	lddpc	r6,80004d54 <DAC_INIC_DestroySocket_CB+0x80>
80004cea:	ac 98       	st.b	r6[0x1],r8
80004cec:	fe b0 fd 86 	rcall	800047f8 <DAC_Network_DestroySocket>
80004cf0:	c1 a1       	brne	80004d24 <DAC_INIC_DestroySocket_CB+0x50>
80004cf2:	2f fd       	sub	sp,-4
80004cf4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
		}
	}
	else
	{
		LOG_ERR("Error Destroying DAC -> INIC Socket: Error Code = %04X\n", cb_result);
80004cf8:	5c 77       	castu.h	r7
80004cfa:	49 8c       	lddpc	r12,80004d58 <DAC_INIC_DestroySocket_CB+0x84>
80004cfc:	1a d7       	st.w	--sp,r7
80004cfe:	e0 a0 96 f3 	rcall	80017ae4 <printf>
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
80004d02:	49 58       	lddpc	r8,80004d54 <DAC_INIC_DestroySocket_CB+0x80>
80004d04:	2f fd       	sub	sp,-4
80004d06:	11 f9       	ld.ub	r9,r8[0x7]
80004d08:	30 08       	mov	r8,0
80004d0a:	f0 09 18 00 	cp.b	r9,r8
80004d0e:	c0 81       	brne	80004d1e <DAC_INIC_DestroySocket_CB+0x4a>
		{
			Amp_Connect_Result(cb_result); // connection failed - can't disconnect
		}
		else  // doing disconnect only
		{
			Amp_DisConnect_Result(cb_result); // dis-connect has failed
80004d10:	0e 9c       	mov	r12,r7
80004d12:	c0 3f       	rcall	80004b18 <Amp_DisConnect_Result>
80004d14:	fe b0 fb 88 	rcall	80004424 <ConmgrReturnMutex>
		}
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80004d18:	2f fd       	sub	sp,-4
	}
}
80004d1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d1e:	0e 9c       	mov	r12,r7
	else
	{
		LOG_ERR("Error Destroying DAC -> INIC Socket: Error Code = %04X\n", cb_result);
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
		{
			Amp_Connect_Result(cb_result); // connection failed - can't disconnect
80004d20:	c5 0f       	rcall	80004bc0 <Amp_Connect_Result>
80004d22:	cf 9b       	rjmp	80004d14 <DAC_INIC_DestroySocket_CB+0x40>
80004d24:	50 0c       	stdsp	sp[0x0],r12
80004d26:	fe b0 fb 7f 	rcall	80004424 <ConmgrReturnMutex>
		DAC_connection.INIC_handle = INVALID_SOCKET; // socket killed
		RED_LED_OFF(); // turn off error light if it was on
		result = DAC_Network_DestroySocket();  // now kill the network socket to complete disconnect
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80004d2a:	40 0c       	lddsp	r12,sp[0x0]
80004d2c:	1a dc       	st.w	--sp,r12
			RED_LED_ON();
			LOG_ERR("Error starting DAC->Network destroy sockets: result = %02X\n", result);
80004d2e:	48 cc       	lddpc	r12,80004d5c <DAC_INIC_DestroySocket_CB+0x88>
80004d30:	e0 a0 96 da 	rcall	80017ae4 <printf>
80004d34:	0d f8       	ld.ub	r8,r6[0x7]
80004d36:	2f fd       	sub	sp,-4
			if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
80004d38:	ee 08 18 00 	cp.b	r8,r7
80004d3c:	c0 50       	breq	80004d46 <DAC_INIC_DestroySocket_CB+0x72>
80004d3e:	e0 6c 80 00 	mov	r12,32768
			{
				Amp_Connect_Result(NSR_E_FAILED); // connection failed - can't disconnect
80004d42:	c3 ff       	rcall	80004bc0 <Amp_Connect_Result>
80004d44:	cd 7b       	rjmp	80004cf2 <DAC_INIC_DestroySocket_CB+0x1e>
80004d46:	e0 6c 80 00 	mov	r12,32768
80004d4a:	ce 7e       	rcall	80004b18 <Amp_DisConnect_Result>
			}
			else  // doing disconnect only
			{
				Amp_DisConnect_Result(NSR_E_FAILED); // dis-connect has failed
80004d4c:	cd 3b       	rjmp	80004cf2 <DAC_INIC_DestroySocket_CB+0x1e>
80004d4e:	d7 03       	nop
80004d50:	80 06       	ld.sh	r6,r0[0x0]
80004d52:	91 cc       	st.w	r8[0x30],r12
80004d54:	00 00       	add	r0,r0
80004d56:	40 38       	lddsp	r8,sp[0xc]
80004d58:	80 06       	ld.sh	r6,r0[0x0]
80004d5a:	92 28       	ld.sh	r8,r9[0x4]
80004d5c:	80 06       	ld.sh	r6,r0[0x0]
80004d5e:	91 ec       	st.w	r8[0x38],r12

80004d60 <DAC_DisConnectSockets_CB>:
80004d60:	eb cd 40 c0 	pushm	r6-r7,lr
80004d64:	20 1d       	sub	sp,4
80004d66:	18 97       	mov	r7,r12
80004d68:	58 0c       	cp.w	r12,0
80004d6a:	c0 d1       	brne	80004d84 <DAC_DisConnectSockets_CB+0x24>
80004d6c:	49 cc       	lddpc	r12,80004ddc <DAC_DisConnectSockets_CB+0x7c>
80004d6e:	e0 a0 97 51 	rcall	80017c10 <puts>
80004d72:	3f f8       	mov	r8,-1
80004d74:	49 b6       	lddpc	r6,80004de0 <DAC_DisConnectSockets_CB+0x80>
80004d76:	ac e8       	st.b	r6[0x6],r8
80004d78:	fe b0 fd 52 	rcall	8000481c <DAC_INIC_DestroySocket>
80004d7c:	c1 a1       	brne	80004db0 <DAC_DisConnectSockets_CB+0x50>
80004d7e:	2f fd       	sub	sp,-4
			Amp_DisConnect_Result(cb_result); // dis-connect has failed
		}
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
	}
}
80004d80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
		}
	}
	else
	{
		LOG_ERR("Error DisConnecting DAC Sockets: Error Code = %04X\n", cb_result);
80004d84:	5c 77       	castu.h	r7
80004d86:	49 8c       	lddpc	r12,80004de4 <DAC_DisConnectSockets_CB+0x84>
80004d88:	1a d7       	st.w	--sp,r7
80004d8a:	e0 a0 96 ad 	rcall	80017ae4 <printf>
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
80004d8e:	49 58       	lddpc	r8,80004de0 <DAC_DisConnectSockets_CB+0x80>
80004d90:	2f fd       	sub	sp,-4
80004d92:	11 f9       	ld.ub	r9,r8[0x7]
80004d94:	30 08       	mov	r8,0
80004d96:	f0 09 18 00 	cp.b	r9,r8
80004d9a:	c0 81       	brne	80004daa <DAC_DisConnectSockets_CB+0x4a>
		{
			Amp_Connect_Result(cb_result); // connection failed - can't disconnect
		}
		else  // doing disconnect only
		{
			Amp_DisConnect_Result(cb_result); // dis-connect has failed
80004d9c:	0e 9c       	mov	r12,r7
80004d9e:	cb de       	rcall	80004b18 <Amp_DisConnect_Result>
80004da0:	fe b0 fb 42 	rcall	80004424 <ConmgrReturnMutex>
		}
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80004da4:	2f fd       	sub	sp,-4
	}
}
80004da6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004daa:	0e 9c       	mov	r12,r7
	else
	{
		LOG_ERR("Error DisConnecting DAC Sockets: Error Code = %04X\n", cb_result);
		if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
		{
			Amp_Connect_Result(cb_result); // connection failed - can't disconnect
80004dac:	c0 af       	rcall	80004bc0 <Amp_Connect_Result>
80004dae:	cf 9b       	rjmp	80004da0 <DAC_DisConnectSockets_CB+0x40>
80004db0:	50 0c       	stdsp	sp[0x0],r12
80004db2:	fe b0 fb 39 	rcall	80004424 <ConmgrReturnMutex>
		YELLOW2_LED_OFF(); // audio no longer streaming
		RED_LED_OFF(); // turn off error light if it was on
		result = DAC_INIC_DestroySocket(); // go ahead and kill the INIC socket - not being used now
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80004db6:	40 0c       	lddsp	r12,sp[0x0]
80004db8:	1a dc       	st.w	--sp,r12
			//RED_LED_ON();
			LOG_ERR("Error starting DAC->INIC disconnect sockets: result = %02X\n", result);
80004dba:	48 cc       	lddpc	r12,80004de8 <DAC_DisConnectSockets_CB+0x88>
80004dbc:	e0 a0 96 94 	rcall	80017ae4 <printf>
80004dc0:	0d f8       	ld.ub	r8,r6[0x7]
80004dc2:	2f fd       	sub	sp,-4
			if (DAC_connection.Connecting) // were we disconnecting so we could connect to another source?
80004dc4:	ee 08 18 00 	cp.b	r8,r7
80004dc8:	c0 50       	breq	80004dd2 <DAC_DisConnectSockets_CB+0x72>
80004dca:	e0 6c 80 00 	mov	r12,32768
			{
				Amp_Connect_Result(NSR_E_FAILED); // connection failed - can't disconnect
80004dce:	cf 9e       	rcall	80004bc0 <Amp_Connect_Result>
80004dd0:	cd 7b       	rjmp	80004d7e <DAC_DisConnectSockets_CB+0x1e>
80004dd2:	e0 6c 80 00 	mov	r12,32768
80004dd6:	ca 1e       	rcall	80004b18 <Amp_DisConnect_Result>
			}
			else  // doing disconnect only
			{
				Amp_DisConnect_Result(NSR_E_FAILED); // dis-connect has failed
80004dd8:	cd 3b       	rjmp	80004d7e <DAC_DisConnectSockets_CB+0x1e>
80004dda:	d7 03       	nop
80004ddc:	80 06       	ld.sh	r6,r0[0x0]
80004dde:	92 60       	ld.sh	r0,r9[0xc]
80004de0:	00 00       	add	r0,r0
80004de2:	40 38       	lddsp	r8,sp[0xc]
80004de4:	80 06       	ld.sh	r6,r0[0x0]
80004de6:	92 b8       	ld.uh	r8,r9[0x6]
80004de8:	80 06       	ld.sh	r6,r0[0x0]
80004dea:	92 7c       	ld.sh	r12,r9[0xe]

80004dec <DAC_ConnectSockets_CB>:
80004dec:	eb cd 40 e0 	pushm	r5-r7,lr
80004df0:	18 97       	mov	r7,r12
80004df2:	16 95       	mov	r5,r11
80004df4:	fe b0 fb 18 	rcall	80004424 <ConmgrReturnMutex>
80004df8:	58 07       	cp.w	r7,0
80004dfa:	c0 f0       	breq	80004e18 <DAC_ConnectSockets_CB+0x2c>
80004dfc:	0e 96       	mov	r6,r7
80004dfe:	48 dc       	lddpc	r12,80004e30 <DAC_ConnectSockets_CB+0x44>
80004e00:	5c 76       	castu.h	r6
80004e02:	1a d6       	st.w	--sp,r6
80004e04:	e0 a0 96 70 	rcall	80017ae4 <printf>
80004e08:	3f f9       	mov	r9,-1
80004e0a:	48 b8       	lddpc	r8,80004e34 <DAC_ConnectSockets_CB+0x48>
		RED_LED_OFF(); // turn off error light if it was on
	}
	else
	{
		LOG_ERR("Error Connecting DAC Sockets: Error Code = %04X\n", cb_result);
		DAC_connection.ConnectionHandle = INVALID_CONNECTION;
80004e0c:	2f fd       	sub	sp,-4
80004e0e:	b0 e9       	st.b	r8[0x6],r9
		RED_LED_ON(); // turn on error light
	}
	/* pass or fail, we're done now */
	Amp_Connect_Result(cb_result); // send reply now
80004e10:	0c 9c       	mov	r12,r6
80004e12:	cd 7e       	rcall	80004bc0 <Amp_Connect_Result>
80004e14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
}
80004e18:	48 8c       	lddpc	r12,80004e38 <DAC_ConnectSockets_CB+0x4c>
{

	ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
	if (NSR_S_OK == cb_result)
	{
		LOG_NOR("DAC Sockets Connected OK\n");
80004e1a:	e0 a0 96 fb 	rcall	80017c10 <puts>
80004e1e:	48 68       	lddpc	r8,80004e34 <DAC_ConnectSockets_CB+0x48>
		DAC_connection.ConnectionHandle = connection_handle;
80004e20:	0e 96       	mov	r6,r7
		DAC_connection.Connecting = FALSE; // no longer connecting - done
80004e22:	b0 e5       	st.b	r8[0x6],r5

	ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
	if (NSR_S_OK == cb_result)
	{
		LOG_NOR("DAC Sockets Connected OK\n");
		DAC_connection.ConnectionHandle = connection_handle;
80004e24:	b0 f7       	st.b	r8[0x7],r7
		DAC_connection.Connecting = FALSE; // no longer connecting - done
80004e26:	0c 9c       	mov	r12,r6
		LOG_ERR("Error Connecting DAC Sockets: Error Code = %04X\n", cb_result);
		DAC_connection.ConnectionHandle = INVALID_CONNECTION;
		RED_LED_ON(); // turn on error light
	}
	/* pass or fail, we're done now */
	Amp_Connect_Result(cb_result); // send reply now
80004e28:	cc ce       	rcall	80004bc0 <Amp_Connect_Result>
80004e2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
}
80004e2e:	d7 03       	nop
80004e30:	80 06       	ld.sh	r6,r0[0x0]
80004e32:	93 08       	st.w	r9[0x0],r8
80004e34:	00 00       	add	r0,r0
80004e36:	40 38       	lddsp	r8,sp[0xc]
80004e38:	80 06       	ld.sh	r6,r0[0x0]
80004e3a:	92 ec       	ld.uh	r12,r9[0xc]

80004e3c <DAC_Network_CreateSocket_CB>:
80004e3c:	d4 01       	pushm	lr
80004e3e:	20 1d       	sub	sp,4
80004e40:	58 0c       	cp.w	r12,0
80004e42:	c0 d1       	brne	80004e5c <DAC_Network_CreateSocket_CB+0x20>
80004e44:	50 0b       	stdsp	sp[0x0],r11
80004e46:	49 7c       	lddpc	r12,80004ea0 <DAC_Network_CreateSocket_CB+0x64>
80004e48:	e0 a0 96 e4 	rcall	80017c10 <puts>
80004e4c:	49 68       	lddpc	r8,80004ea4 <DAC_Network_CreateSocket_CB+0x68>
80004e4e:	40 0b       	lddsp	r11,sp[0x0]
	uint8_t result;

	if (NSR_S_OK == cb_result)
	{
		LOG_NOR("DAC Network -> INIC Socket created OK\n");
		DAC_connection.Network_handle = handle; // our socket handle for NETWORK side
80004e50:	b0 ab       	st.b	r8[0x2],r11
		// only get a handle for an "IN" socket
		RED_LED_OFF(); // turn off error light if it was on
		result = DAC_ConnectSockets(); // connect the two sockets now
80004e52:	fe b0 fd 09 	rcall	80004864 <DAC_ConnectSockets>
		if (ERR_NO != result)
80004e56:	c1 71       	brne	80004e84 <DAC_Network_CreateSocket_CB+0x48>
		LOG_ERR("Error Creating DAC Network -> INIC Socket: Error Code = %04X\n", cb_result);
		DAC_connection.Network_handle = INVALID_SOCKET;
		DAC_connection.ConnectionLabel = INVALID_LABEL;
		Amp_Connect_Result(NSR_E_FAILED);
	}
}
80004e58:	2f fd       	sub	sp,-4
80004e5a:	d8 02       	popm	pc
			Amp_Connect_Result(NSR_E_FAILED);
		}
	}
	else
	{
		ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
80004e5c:	50 0c       	stdsp	sp[0x0],r12
80004e5e:	fe b0 fa e3 	rcall	80004424 <ConmgrReturnMutex>
		RED_LED_ON(); // turn on error light
		LOG_ERR("Error Creating DAC Network -> INIC Socket: Error Code = %04X\n", cb_result);
80004e62:	40 0c       	lddsp	r12,sp[0x0]
80004e64:	5c 7c       	castu.h	r12
80004e66:	1a dc       	st.w	--sp,r12
80004e68:	49 0c       	lddpc	r12,80004ea8 <DAC_Network_CreateSocket_CB+0x6c>
80004e6a:	e0 a0 96 3d 	rcall	80017ae4 <printf>
		DAC_connection.Network_handle = INVALID_SOCKET;
80004e6e:	3f f9       	mov	r9,-1
80004e70:	48 d8       	lddpc	r8,80004ea4 <DAC_Network_CreateSocket_CB+0x68>
80004e72:	b0 a9       	st.b	r8[0x2],r9
		DAC_connection.ConnectionLabel = INVALID_LABEL;
80004e74:	30 09       	mov	r9,0
		Amp_Connect_Result(NSR_E_FAILED);
80004e76:	e0 6c 80 00 	mov	r12,32768
	{
		ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
		RED_LED_ON(); // turn on error light
		LOG_ERR("Error Creating DAC Network -> INIC Socket: Error Code = %04X\n", cb_result);
		DAC_connection.Network_handle = INVALID_SOCKET;
		DAC_connection.ConnectionLabel = INVALID_LABEL;
80004e7a:	b0 29       	st.h	r8[0x4],r9
		Amp_Connect_Result(NSR_E_FAILED);
80004e7c:	ca 2e       	rcall	80004bc0 <Amp_Connect_Result>
80004e7e:	2f fd       	sub	sp,-4
80004e80:	2f fd       	sub	sp,-4
	}
}
80004e82:	d8 02       	popm	pc
80004e84:	50 0c       	stdsp	sp[0x0],r12
		// only get a handle for an "IN" socket
		RED_LED_OFF(); // turn off error light if it was on
		result = DAC_ConnectSockets(); // connect the two sockets now
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80004e86:	fe b0 fa cf 	rcall	80004424 <ConmgrReturnMutex>
80004e8a:	40 0c       	lddsp	r12,sp[0x0]
			RED_LED_ON(); // turn on error light
			LOG_ERR("Error starting DAC->Network connect sockets: result = %02X\n", result);
80004e8c:	1a dc       	st.w	--sp,r12
80004e8e:	48 8c       	lddpc	r12,80004eac <DAC_Network_CreateSocket_CB+0x70>
80004e90:	e0 a0 96 2a 	rcall	80017ae4 <printf>
80004e94:	e0 6c 80 00 	mov	r12,32768
			Amp_Connect_Result(NSR_E_FAILED);
80004e98:	c9 4e       	rcall	80004bc0 <Amp_Connect_Result>
80004e9a:	2f fd       	sub	sp,-4
80004e9c:	2f fd       	sub	sp,-4
80004e9e:	d8 02       	popm	pc
		LOG_ERR("Error Creating DAC Network -> INIC Socket: Error Code = %04X\n", cb_result);
		DAC_connection.Network_handle = INVALID_SOCKET;
		DAC_connection.ConnectionLabel = INVALID_LABEL;
		Amp_Connect_Result(NSR_E_FAILED);
	}
}
80004ea0:	80 06       	ld.sh	r6,r0[0x0]
80004ea2:	93 3c       	st.w	r9[0xc],r12
80004ea4:	00 00       	add	r0,r0
80004ea6:	40 38       	lddsp	r8,sp[0xc]
80004ea8:	80 06       	ld.sh	r6,r0[0x0]
80004eaa:	93 a0       	st.w	r9[0x28],r0
80004eac:	80 06       	ld.sh	r6,r0[0x0]
80004eae:	93 64       	st.w	r9[0x18],r4

80004eb0 <DAC_INIC_CreateSocket_CB>:
80004eb0:	d4 01       	pushm	lr
80004eb2:	20 1d       	sub	sp,4
80004eb4:	58 0c       	cp.w	r12,0
80004eb6:	c0 d1       	brne	80004ed0 <DAC_INIC_CreateSocket_CB+0x20>
80004eb8:	50 0b       	stdsp	sp[0x0],r11
80004eba:	49 5c       	lddpc	r12,80004f0c <DAC_INIC_CreateSocket_CB+0x5c>
80004ebc:	e0 a0 96 aa 	rcall	80017c10 <puts>
80004ec0:	49 48       	lddpc	r8,80004f10 <DAC_INIC_CreateSocket_CB+0x60>
80004ec2:	40 0b       	lddsp	r11,sp[0x0]
80004ec4:	b0 9b       	st.b	r8[0x1],r11
80004ec6:	fe b0 fc e1 	rcall	80004888 <DAC_Network_CreateSocket>
		LOG_NOR("DAC->INIC Socket created OK\n");
		DAC_connection.INIC_handle = handle; // our socket handle for INIC side
		// won't have a list_len, or list_ptr for INIC socket - only a handle
		RED_LED_OFF(); // turn off error light if it was on
		result = DAC_Network_CreateSocket(); // INIC socket done, go create network socket
		if (ERR_NO != result)
80004eca:	c1 31       	brne	80004ef0 <DAC_INIC_CreateSocket_CB+0x40>
		DAC_connection.INIC_handle = INVALID_SOCKET;
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
		Amp_Connect_Result(NSR_E_FAILED);
	}
}
80004ecc:	2f fd       	sub	sp,-4
80004ece:	d8 02       	popm	pc
			Amp_Connect_Result(NSR_E_FAILED);
		}
	}
	else
	{
		LOG_ERR("Error Creating DAC->INIC Socket: Error Code = %04X\n", cb_result);
80004ed0:	5c 7c       	castu.h	r12
80004ed2:	1a dc       	st.w	--sp,r12
80004ed4:	49 0c       	lddpc	r12,80004f14 <DAC_INIC_CreateSocket_CB+0x64>
80004ed6:	e0 a0 96 07 	rcall	80017ae4 <printf>
		DAC_connection.INIC_handle = INVALID_SOCKET;
80004eda:	3f f9       	mov	r9,-1
80004edc:	48 d8       	lddpc	r8,80004f10 <DAC_INIC_CreateSocket_CB+0x60>
80004ede:	b0 99       	st.b	r8[0x1],r9
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
80004ee0:	fe b0 fa a2 	rcall	80004424 <ConmgrReturnMutex>
		Amp_Connect_Result(NSR_E_FAILED);
80004ee4:	e0 6c 80 00 	mov	r12,32768
80004ee8:	c6 ce       	rcall	80004bc0 <Amp_Connect_Result>
80004eea:	2f fd       	sub	sp,-4
80004eec:	2f fd       	sub	sp,-4
	}
}
80004eee:	d8 02       	popm	pc
80004ef0:	50 0c       	stdsp	sp[0x0],r12
		// won't have a list_len, or list_ptr for INIC socket - only a handle
		RED_LED_OFF(); // turn off error light if it was on
		result = DAC_Network_CreateSocket(); // INIC socket done, go create network socket
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80004ef2:	fe b0 fa 99 	rcall	80004424 <ConmgrReturnMutex>
80004ef6:	40 0c       	lddsp	r12,sp[0x0]
			RED_LED_ON(); // turn on error light
			LOG_ERR("Error starting DAC->Network socket creation: result = %02X\n", result);
80004ef8:	1a dc       	st.w	--sp,r12
80004efa:	48 8c       	lddpc	r12,80004f18 <DAC_INIC_CreateSocket_CB+0x68>
80004efc:	e0 a0 95 f4 	rcall	80017ae4 <printf>
80004f00:	e0 6c 80 00 	mov	r12,32768
			Amp_Connect_Result(NSR_E_FAILED);
80004f04:	c5 ee       	rcall	80004bc0 <Amp_Connect_Result>
80004f06:	2f fd       	sub	sp,-4
80004f08:	2f fd       	sub	sp,-4
80004f0a:	d8 02       	popm	pc
		DAC_connection.INIC_handle = INVALID_SOCKET;
		RED_LED_ON(); // turn on error light
		ConmgrReturnMutex();  //we're done, return mutex, stop timeout timer
		Amp_Connect_Result(NSR_E_FAILED);
	}
}
80004f0c:	80 06       	ld.sh	r6,r0[0x0]
80004f0e:	93 e0       	st.w	r9[0x38],r0
80004f10:	00 00       	add	r0,r0
80004f12:	40 38       	lddsp	r8,sp[0xc]
80004f14:	80 06       	ld.sh	r6,r0[0x0]
80004f16:	94 38       	ld.sh	r8,r10[0x6]
80004f18:	80 06       	ld.sh	r6,r0[0x0]
80004f1a:	93 fc       	st.w	r9[0x3c],r12

80004f1c <Amp_ConnectTimeout>:
80004f1c:	d4 01       	pushm	lr
80004f1e:	48 4c       	lddpc	r12,80004f2c <Amp_ConnectTimeout+0x10>
80004f20:	e0 a0 96 78 	rcall	80017c10 <puts>
80004f24:	e0 6c 80 00 	mov	r12,32768
80004f28:	c4 ce       	rcall	80004bc0 <Amp_Connect_Result>
80004f2a:	d8 02       	popm	pc
80004f2c:	80 06       	ld.sh	r6,r0[0x0]
80004f2e:	94 6c       	ld.sh	r12,r10[0xc]

80004f30 <Amp_DisConnect_StartResultACK>:
80004f30:	eb cd 40 c0 	pushm	r6-r7,lr

void Amp_ConnectTimeout(void)
{
	LOG_NOR("Timeout while connecting stereo DAC\n");
	Amp_Connect_Result(NSR_E_FAILED);
}
80004f34:	20 1d       	sub	sp,4
80004f36:	76 08       	ld.w	r8,r11[0x0]
80004f38:	18 97       	mov	r7,r12
80004f3a:	f0 ca ff fe 	sub	r10,r8,-2
****************************************************************************/
uint8_t Amp_DisConnect_StartResultACK(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint8_t result;

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
80004f3e:	30 1b       	mov	r11,1
80004f40:	15 89       	ld.ub	r9,r10[0x0]
80004f42:	12 96       	mov	r6,r9
80004f44:	f6 09 18 00 	cp.b	r9,r11
80004f48:	c2 d1       	brne	80004fa2 <Amp_DisConnect_StartResultACK+0x72>
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	// parameters OK
	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
80004f4a:	11 9a       	ld.ub	r10,r8[0x1]
80004f4c:	11 88       	ld.ub	r8,r8[0x0]
80004f4e:	f5 e8 10 8a 	or	r10,r10,r8<<0x8
80004f52:	4a 48       	lddpc	r8,80004fe0 <Amp_DisConnect_StartResultACK+0xb0>
80004f54:	5c 8a       	casts.h	r10
80004f56:	b0 0a       	st.h	r8[0x0],r10
	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION) // IF socket is connected - then disconnect
80004f58:	4a 36       	lddpc	r6,80004fe4 <Amp_DisConnect_StartResultACK+0xb4>
80004f5a:	3f f8       	mov	r8,-1
80004f5c:	0d eb       	ld.ub	r11,r6[0x6]
80004f5e:	f0 0b 18 00 	cp.b	r11,r8
80004f62:	c1 30       	breq	80004f88 <Amp_DisConnect_StartResultACK+0x58>
	{
		if (ConmgrGetMutex(300, Amp_DisconnectTimeout))
80004f64:	fe cb 03 b8 	sub	r11,pc,952
80004f68:	e0 6c 01 2c 	mov	r12,300
80004f6c:	fe b0 fa 96 	rcall	80004498 <ConmgrGetMutex>
		{
			DAC_connection.Connecting = FALSE; // make sure this is false
80004f70:	c3 00       	breq	80004fd0 <Amp_DisConnect_StartResultACK+0xa0>
80004f72:	30 08       	mov	r8,0
			result = DAC_DisConnectSockets(); // start disconnect process
80004f74:	ac f8       	st.b	r6[0x7],r8
80004f76:	fe b0 fc 65 	rcall	80004840 <DAC_DisConnectSockets>
			if (ERR_NO == result)
			{
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
80004f7a:	c1 b1       	brne	80004fb0 <Amp_DisConnect_StartResultACK+0x80>
80004f7c:	49 b8       	lddpc	r8,80004fe8 <Amp_DisConnect_StartResultACK+0xb8>
80004f7e:	34 0c       	mov	r12,64
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // We can send the result now - we are already connected
	}
}
80004f80:	91 07       	st.w	r8[0x0],r7
80004f82:	2f fd       	sub	sp,-4
80004f84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
		}
	}
	else // Not connected, so just reply that its done
	{
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
80004f88:	78 08       	ld.w	r8,r12[0x0]
		Tx_Ptr->Length = 1; //
80004f8a:	b0 89       	st.b	r8[0x0],r9
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80004f8c:	30 18       	mov	r8,1
80004f8e:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80004f92:	b8 28       	st.h	r12[0x4],r8
80004f94:	5c 5a       	castu.b	r10
80004f96:	e0 a0 76 4d 	rcall	80013c30 <CmdInsertSenderHandle>
		return (OP_RESULTACK); // We can send the result now - we are already connected
	}
}
80004f9a:	30 dc       	mov	r12,13
80004f9c:	2f fd       	sub	sp,-4
80004f9e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
uint8_t Amp_DisConnect_StartResultACK(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint8_t result;

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));
80004fa2:	30 19       	mov	r9,1
80004fa4:	30 2b       	mov	r11,2
80004fa6:	e0 a0 75 f5 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // We can send the result now - we are already connected
	}
}
80004faa:	2f fd       	sub	sp,-4
80004fac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80004fb0:	50 0c       	stdsp	sp[0x0],r12
80004fb2:	fe b0 fa 39 	rcall	80004424 <ConmgrReturnMutex>
				LOG_ERR("Error starting DAC disconnect sockets process: result = %02X\n", result);
80004fb6:	40 0c       	lddsp	r12,sp[0x0]
80004fb8:	1a dc       	st.w	--sp,r12
80004fba:	48 dc       	lddpc	r12,80004fec <Amp_DisConnect_StartResultACK+0xbc>
80004fbc:	e0 a0 95 94 	rcall	80017ae4 <printf>
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
80004fc0:	6e 08       	ld.w	r8,r7[0x0]
80004fc2:	34 29       	mov	r9,66
				Tx_Ptr->Length = 1; //
				return (OP_ERRORACK);  // Return with error - allocate failed
80004fc4:	b0 89       	st.b	r8[0x0],r9
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
				LOG_ERR("Error starting DAC disconnect sockets process: result = %02X\n", result);
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
				Tx_Ptr->Length = 1; //
80004fc6:	2f fd       	sub	sp,-4
80004fc8:	30 18       	mov	r8,1
80004fca:	30 9c       	mov	r12,9
				return (OP_ERRORACK);  // Return with error - allocate failed
80004fcc:	ae 28       	st.h	r7[0x4],r8
			}
		}
		else
		{
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
80004fce:	ce 7b       	rjmp	80004f9c <Amp_DisConnect_StartResultACK+0x6c>
80004fd0:	0e 9c       	mov	r12,r7
80004fd2:	34 0b       	mov	r11,64
80004fd4:	e0 a0 75 d0 	rcall	80013b74 <CmdErrorMsg>
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // We can send the result now - we are already connected
	}
}
80004fd8:	2f fd       	sub	sp,-4
80004fda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fde:	d7 03       	nop
80004fe0:	00 00       	add	r0,r0
80004fe2:	06 18       	sub	r8,r3
80004fe4:	00 00       	add	r0,r0
80004fe6:	40 38       	lddsp	r8,sp[0xc]
80004fe8:	00 00       	add	r0,r0
80004fea:	40 34       	lddsp	r4,sp[0xc]
80004fec:	80 06       	ld.sh	r6,r0[0x0]
80004fee:	94 90       	ld.uh	r0,r10[0x2]

80004ff0 <Amp_DisConnect_StartResult>:
80004ff0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ff4:	20 1d       	sub	sp,4
80004ff6:	30 19       	mov	r9,1
80004ff8:	76 0a       	ld.w	r10,r11[0x0]
80004ffa:	18 97       	mov	r7,r12
80004ffc:	15 88       	ld.ub	r8,r10[0x0]
80004ffe:	f2 08 18 00 	cp.b	r8,r9
80005002:	c1 f1       	brne	80005040 <Amp_DisConnect_StartResult+0x50>
80005004:	49 d6       	lddpc	r6,80005078 <Amp_DisConnect_StartResult+0x88>
80005006:	3f f9       	mov	r9,-1
80005008:	0d ea       	ld.ub	r10,r6[0x6]
8000500a:	f2 0a 18 00 	cp.b	r10,r9
	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 0, &Rx_Ptr->Data[0], 1));

	// parameters OK
	//DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION) // IF socket is connected - then disconnect
8000500e:	c0 91       	brne	80005020 <Amp_DisConnect_StartResult+0x30>
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
		}
	}
	else // Not connected, so just reply that its done
	{
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
80005010:	78 09       	ld.w	r9,r12[0x0]
80005012:	b2 88       	st.b	r9[0x0],r8
		Tx_Ptr->Length = 1; //
80005014:	30 18       	mov	r8,1
80005016:	b8 28       	st.h	r12[0x4],r8
80005018:	30 cc       	mov	r12,12
		//CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULT); // We can send the result now - we are already connected
	}
}
8000501a:	2f fd       	sub	sp,-4
8000501c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

	// parameters OK
	//DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	if (DAC_connection.ConnectionHandle != INVALID_CONNECTION) // IF socket is connected - then disconnect
	{
		if (ConmgrGetMutex(300, Amp_DisconnectTimeout))
80005020:	fe cb 04 74 	sub	r11,pc,1140
80005024:	e0 6c 01 2c 	mov	r12,300
80005028:	fe b0 fa 38 	rcall	80004498 <ConmgrGetMutex>
		{
			DAC_connection.Connecting = FALSE; // make sure this is false
8000502c:	c1 10       	breq	8000504e <Amp_DisConnect_StartResult+0x5e>
8000502e:	30 08       	mov	r8,0
			result = DAC_DisConnectSockets(); // start disconnect process
80005030:	ac f8       	st.b	r6[0x7],r8
80005032:	fe b0 fc 07 	rcall	80004840 <DAC_DisConnectSockets>
			if (ERR_NO == result)
			{
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
80005036:	c1 11       	brne	80005058 <Amp_DisConnect_StartResult+0x68>
80005038:	49 18       	lddpc	r8,8000507c <Amp_DisConnect_StartResult+0x8c>
8000503a:	34 0c       	mov	r12,64
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
8000503c:	91 07       	st.w	r8[0x0],r7
uint8_t Amp_DisConnect_StartResult(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint8_t result;

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 0, &Rx_Ptr->Data[0], 1));
8000503e:	ce eb       	rjmp	8000501a <Amp_DisConnect_StartResult+0x2a>
80005040:	30 19       	mov	r9,1
80005042:	30 0b       	mov	r11,0
80005044:	e0 a0 75 a6 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		//CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULT); // We can send the result now - we are already connected
	}
}
80005048:	2f fd       	sub	sp,-4
8000504a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
				return (OP_ERRORACK);  // Return with error - allocate failed
			}
		}
		else
		{
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
8000504e:	0e 9c       	mov	r12,r7
80005050:	34 0b       	mov	r11,64
80005052:	e0 a0 75 91 	rcall	80013b74 <CmdErrorMsg>
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80005056:	ce 2b       	rjmp	8000501a <Amp_DisConnect_StartResult+0x2a>
80005058:	50 0c       	stdsp	sp[0x0],r12
8000505a:	fe b0 f9 e5 	rcall	80004424 <ConmgrReturnMutex>
				LOG_ERR("Error starting DAC disconnect sockets process: result = %02X\n", result);
8000505e:	40 0c       	lddsp	r12,sp[0x0]
80005060:	1a dc       	st.w	--sp,r12
80005062:	48 8c       	lddpc	r12,80005080 <Amp_DisConnect_StartResult+0x90>
80005064:	e0 a0 95 40 	rcall	80017ae4 <printf>
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
80005068:	6e 08       	ld.w	r8,r7[0x0]
8000506a:	34 29       	mov	r9,66
				Tx_Ptr->Length = 1; //
				return (OP_ERRORACK);  // Return with error - allocate failed
8000506c:	b0 89       	st.b	r8[0x0],r9
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
				LOG_ERR("Error starting DAC disconnect sockets process: result = %02X\n", result);
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
				Tx_Ptr->Length = 1; //
8000506e:	2f fd       	sub	sp,-4
80005070:	30 18       	mov	r8,1
80005072:	30 9c       	mov	r12,9
				return (OP_ERRORACK);  // Return with error - allocate failed
80005074:	ae 28       	st.h	r7[0x4],r8
80005076:	cd 2b       	rjmp	8000501a <Amp_DisConnect_StartResult+0x2a>
80005078:	00 00       	add	r0,r0
8000507a:	40 38       	lddsp	r8,sp[0xc]
8000507c:	00 00       	add	r0,r0
8000507e:	40 34       	lddsp	r4,sp[0xc]
80005080:	80 06       	ld.sh	r6,r0[0x0]
80005082:	94 90       	ld.uh	r0,r10[0x2]

80005084 <Amp_Connect_StartResultACK>:
80005084:	eb cd 40 f8 	pushm	r3-r7,lr
80005088:	20 1d       	sub	sp,4
8000508a:	30 19       	mov	r9,1
8000508c:	76 08       	ld.w	r8,r11[0x0]
8000508e:	18 96       	mov	r6,r12
80005090:	f0 ca ff fe 	sub	r10,r8,-2
80005094:	15 87       	ld.ub	r7,r10[0x0]
80005096:	0e 95       	mov	r5,r7
80005098:	f2 07 18 00 	cp.b	r7,r9
8000509c:	c0 80       	breq	800050ac <Amp_Connect_StartResultACK+0x28>
8000509e:	30 19       	mov	r9,1
	BlockWidth (word) 3:4
	ConnectionLabel (word) 5:6
	*/

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));
800050a0:	30 2b       	mov	r11,2
800050a2:	e0 a0 75 77 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK);  // Just report connection was OK
	}
}
800050a6:	2f fd       	sub	sp,-4
800050a8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
	*/

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
800050ac:	11 8a       	ld.ub	r10,r8[0x0]
800050ae:	11 99       	ld.ub	r9,r8[0x1]
800050b0:	f3 ea 10 89 	or	r9,r9,r10<<0x8
800050b4:	4b 43       	lddpc	r3,80005184 <Amp_Connect_StartResultACK+0x100>
800050b6:	a6 09       	st.h	r3[0x0],r9
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[3]);
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[5]);
800050b8:	11 e9       	ld.ub	r9,r8[0x6]

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[3]);
800050ba:	11 b4       	ld.ub	r4,r8[0x3]
800050bc:	11 ca       	ld.ub	r10,r8[0x4]
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[5]);
800050be:	11 d5       	ld.ub	r5,r8[0x5]
800050c0:	f3 e5 10 85 	or	r5,r9,r5<<0x8
800050c4:	5c 85       	casts.h	r5
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
800050c6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[3]);
800050ca:	f5 e4 10 84 	or	r4,r10,r4<<0x8
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[5]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
800050ce:	1a d8       	st.w	--sp,r8
800050d0:	4a ec       	lddpc	r12,80005188 <Amp_Connect_StartResultACK+0x104>
800050d2:	50 1b       	stdsp	sp[0x4],r11
800050d4:	e0 a0 95 08 	rcall	80017ae4 <printf>

	if (Rx_Ptr->Data[2] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[3]);
800050d8:	5c 84       	casts.h	r4
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[5]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
	
	if (AUDIO_STEREO*RES_16BIT != blockWidth)
800050da:	2f fd       	sub	sp,-4
800050dc:	30 48       	mov	r8,4
800050de:	40 0b       	lddsp	r11,sp[0x0]
800050e0:	f0 04 19 00 	cp.h	r4,r8
800050e4:	c2 c1       	brne	8000513c <Amp_Connect_StartResultACK+0xb8>
	{
		return (CmdErrorParamWrong(Tx_Ptr, 3, &Rx_Ptr->Data[3], 2));
	}

	if (newConnection != DAC_connection.ConnectionLabel)
800050e6:	4a a4       	lddpc	r4,8000518c <Amp_Connect_StartResultACK+0x108>
800050e8:	88 28       	ld.sh	r8,r4[0x4]
800050ea:	ea 08 19 00 	cp.h	r8,r5
800050ee:	c1 70       	breq	8000511c <Amp_Connect_StartResultACK+0x98>
	{
		if (ConmgrGetMutex(500, Amp_ConnectTimeout))
800050f0:	fe cb 01 d4 	sub	r11,pc,468
800050f4:	e0 6c 01 f4 	mov	r12,500
800050f8:	fe b0 f9 d0 	rcall	80004498 <ConmgrGetMutex>
		{
			/* We're establishing new connection or changing connections */
			DAC_connection.ConnectionLabel = newConnection;
800050fc:	c3 f0       	breq	8000517a <Amp_Connect_StartResultACK+0xf6>
			DAC_connection.Connecting = TRUE; // flag that we're in connection process in case we need to disconnect first
800050fe:	a8 25       	st.h	r4[0x4],r5
			if (INVALID_CONNECTION == DAC_connection.ConnectionHandle) // already connected?
80005100:	a8 f7       	st.b	r4[0x7],r7
80005102:	09 e9       	ld.ub	r9,r4[0x6]
80005104:	3f f8       	mov	r8,-1
80005106:	f0 09 18 00 	cp.b	r9,r8
			{ // if not, just do the connection
				result = DAC_INIC_CreateSocket();  // that starts connection process -
			}
			else
			{ // if so disconnect - then disconnect will check "Connecting" flag & contiune w/ connection
				result = DAC_DisConnectSockets(); // must disconnect first - then connect
8000510a:	c3 50       	breq	80005174 <Amp_Connect_StartResultACK+0xf0>
8000510c:	fe b0 fb 9a 	rcall	80004840 <DAC_DisConnectSockets>
			}

			if (ERR_NO == result)
80005110:	58 0c       	cp.w	r12,0
			{
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
80005112:	c1 f1       	brne	80005150 <Amp_Connect_StartResultACK+0xcc>
80005114:	49 f8       	lddpc	r8,80005190 <Amp_Connect_StartResultACK+0x10c>
80005116:	34 0c       	mov	r12,64
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
80005118:	91 06       	st.w	r8[0x0],r6
		}
	}
	else
	{
		/* already connected to that connection label */
		Tx_Ptr->Operation = OP_RESULT; // response to start/result
8000511a:	cc 6b       	rjmp	800050a6 <Amp_Connect_StartResultACK+0x22>
8000511c:	30 c8       	mov	r8,12
8000511e:	ed 68 00 0c 	st.b	r6[12],r8
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
80005122:	6c 08       	ld.w	r8,r6[0x0]
		Tx_Ptr->Length = 1; //
80005124:	b0 87       	st.b	r8[0x0],r7
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80005126:	30 18       	mov	r8,1
	else
	{
		/* already connected to that connection label */
		Tx_Ptr->Operation = OP_RESULT; // response to start/result
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
80005128:	0c 9c       	mov	r12,r6
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
8000512a:	ac 28       	st.h	r6[0x4],r8
8000512c:	86 0a       	ld.sh	r10,r3[0x0]
8000512e:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80005132:	5c 5a       	castu.b	r10
80005134:	e0 a0 75 7e 	rcall	80013c30 <CmdInsertSenderHandle>
		return (OP_RESULTACK);  // Just report connection was OK
80005138:	30 dc       	mov	r12,13
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[5]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
	
	if (AUDIO_STEREO*RES_16BIT != blockWidth)
	{
		return (CmdErrorParamWrong(Tx_Ptr, 3, &Rx_Ptr->Data[3], 2));
8000513a:	cb 6b       	rjmp	800050a6 <Amp_Connect_StartResultACK+0x22>
8000513c:	76 0a       	ld.w	r10,r11[0x0]
8000513e:	0c 9c       	mov	r12,r6
80005140:	2f da       	sub	r10,-3
80005142:	30 29       	mov	r9,2
80005144:	30 3b       	mov	r11,3
80005146:	e0 a0 75 25 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK);  // Just report connection was OK
	}
}
8000514a:	2f fd       	sub	sp,-4
8000514c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80005150:	50 0c       	stdsp	sp[0x0],r12
80005152:	fe b0 f9 69 	rcall	80004424 <ConmgrReturnMutex>
//				RED_LED_ON();
				DAC_connection.ConnectionLabel = INVALID_LABEL;  // not connected to newConnection
80005156:	40 0c       	lddsp	r12,sp[0x0]
				LOG_ERR("Error starting DAC->INIC socket creation: result = %02X\n", result);
80005158:	30 08       	mov	r8,0
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
//				RED_LED_ON();
				DAC_connection.ConnectionLabel = INVALID_LABEL;  // not connected to newConnection
8000515a:	1a dc       	st.w	--sp,r12
				LOG_ERR("Error starting DAC->INIC socket creation: result = %02X\n", result);
8000515c:	a8 28       	st.h	r4[0x4],r8
8000515e:	48 ec       	lddpc	r12,80005194 <Amp_Connect_StartResultACK+0x110>
80005160:	e0 a0 94 c2 	rcall	80017ae4 <printf>
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
80005164:	6c 08       	ld.w	r8,r6[0x0]
80005166:	34 29       	mov	r9,66
				Tx_Ptr->Length = 1; //
				return (OP_ERRORACK);  // Return with error - allocate failed
80005168:	b0 89       	st.b	r8[0x0],r9
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
//				RED_LED_ON();
				DAC_connection.ConnectionLabel = INVALID_LABEL;  // not connected to newConnection
				LOG_ERR("Error starting DAC->INIC socket creation: result = %02X\n", result);
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
				Tx_Ptr->Length = 1; //
8000516a:	2f fd       	sub	sp,-4
8000516c:	30 18       	mov	r8,1
8000516e:	30 9c       	mov	r12,9
				return (OP_ERRORACK);  // Return with error - allocate failed
80005170:	ac 28       	st.h	r6[0x4],r8
			/* We're establishing new connection or changing connections */
			DAC_connection.ConnectionLabel = newConnection;
			DAC_connection.Connecting = TRUE; // flag that we're in connection process in case we need to disconnect first
			if (INVALID_CONNECTION == DAC_connection.ConnectionHandle) // already connected?
			{ // if not, just do the connection
				result = DAC_INIC_CreateSocket();  // that starts connection process -
80005172:	c9 ab       	rjmp	800050a6 <Amp_Connect_StartResultACK+0x22>
80005174:	fe b0 fb a8 	rcall	800048c4 <DAC_INIC_CreateSocket>
				return (OP_ERRORACK);  // Return with error - allocate failed
			}
		}
		else
		{
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
80005178:	cc cb       	rjmp	80005110 <Amp_Connect_StartResultACK+0x8c>
8000517a:	0c 9c       	mov	r12,r6
8000517c:	34 0b       	mov	r11,64
8000517e:	e0 a0 74 fb 	rcall	80013b74 <CmdErrorMsg>
80005182:	c9 2b       	rjmp	800050a6 <Amp_Connect_StartResultACK+0x22>
80005184:	00 00       	add	r0,r0
80005186:	06 18       	sub	r8,r3
80005188:	80 06       	ld.sh	r6,r0[0x0]
8000518a:	94 d0       	ld.uh	r0,r10[0xa]
8000518c:	00 00       	add	r0,r0
8000518e:	40 38       	lddsp	r8,sp[0xc]
80005190:	00 00       	add	r0,r0
80005192:	40 34       	lddsp	r4,sp[0xc]
80005194:	80 06       	ld.sh	r6,r0[0x0]
80005196:	94 fc       	ld.uh	r12,r10[0xe]

80005198 <Amp_Connect_StartResult>:
80005198:	d4 21       	pushm	r4-r7,lr
8000519a:	20 1d       	sub	sp,4
8000519c:	30 18       	mov	r8,1
8000519e:	76 0a       	ld.w	r10,r11[0x0]
800051a0:	18 96       	mov	r6,r12
800051a2:	15 87       	ld.ub	r7,r10[0x0]
800051a4:	f0 07 18 00 	cp.b	r7,r8
800051a8:	c0 70       	breq	800051b6 <Amp_Connect_StartResult+0x1e>
800051aa:	30 19       	mov	r9,1
800051ac:	30 0b       	mov	r11,0
800051ae:	e0 a0 74 f1 	rcall	80013b90 <CmdErrorParamWrong>
800051b2:	2f fd       	sub	sp,-4
800051b4:	d8 22       	popm	r4-r7,pc
800051b6:	15 d8       	ld.ub	r8,r10[0x5]
800051b8:	15 b9       	ld.ub	r9,r10[0x3]
800051ba:	15 c5       	ld.ub	r5,r10[0x4]
	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 0, &Rx_Ptr->Data[0], 1));

	//DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[2]);
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[4]);
800051bc:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800051c0:	5c 85       	casts.h	r5
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
800051c2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 0, &Rx_Ptr->Data[0], 1));

	//DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[2]);
800051c6:	15 a4       	ld.ub	r4,r10[0x2]
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[4]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
800051c8:	4a bc       	lddpc	r12,80005274 <Amp_Connect_StartResult+0xdc>
800051ca:	1a d8       	st.w	--sp,r8

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 0, &Rx_Ptr->Data[0], 1));

	//DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[2]);
800051cc:	f3 e4 10 84 	or	r4,r9,r4<<0x8
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[4]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
800051d0:	50 1b       	stdsp	sp[0x4],r11
800051d2:	e0 a0 94 89 	rcall	80017ae4 <printf>

	if (Rx_Ptr->Data[0] != AMP_SINK_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 0, &Rx_Ptr->Data[0], 1));

	//DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
	DECODE_WORD(&blockWidth, &Rx_Ptr->Data[2]);
800051d6:	5c 84       	casts.h	r4
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[4]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
	
	if (AUDIO_STEREO*RES_16BIT != blockWidth)
800051d8:	2f fd       	sub	sp,-4
800051da:	30 48       	mov	r8,4
800051dc:	40 0b       	lddsp	r11,sp[0x0]
800051de:	f0 04 19 00 	cp.h	r4,r8
800051e2:	c2 61       	brne	8000522e <Amp_Connect_StartResult+0x96>
	{
		return (CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 2));
	}

	if (newConnection != DAC_connection.ConnectionLabel)
800051e4:	4a 54       	lddpc	r4,80005278 <Amp_Connect_StartResult+0xe0>
800051e6:	88 28       	ld.sh	r8,r4[0x4]
800051e8:	ea 08 19 00 	cp.h	r8,r5
800051ec:	c0 b1       	brne	80005202 <Amp_Connect_StartResult+0x6a>
		}
	}
	else
	{
		/* already connected to that connection label */
		Tx_Ptr->Operation = OP_RESULT; // response to start/result
800051ee:	30 c8       	mov	r8,12
800051f0:	ed 68 00 0c 	st.b	r6[12],r8
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
800051f4:	6c 08       	ld.w	r8,r6[0x0]
800051f6:	b0 87       	st.b	r8[0x0],r7
		Tx_Ptr->Length = 1; //
800051f8:	30 cc       	mov	r12,12
800051fa:	30 18       	mov	r8,1
800051fc:	ac 28       	st.h	r6[0x4],r8
		//CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULT);  // Just report connection was OK
	}
}
800051fe:	2f fd       	sub	sp,-4
80005200:	d8 22       	popm	r4-r7,pc
		return (CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 2));
	}

	if (newConnection != DAC_connection.ConnectionLabel)
	{
		if (ConmgrGetMutex(500, Amp_ConnectTimeout))
80005202:	fe cb 02 e6 	sub	r11,pc,742
80005206:	e0 6c 01 f4 	mov	r12,500
8000520a:	fe b0 f9 47 	rcall	80004498 <ConmgrGetMutex>
		{
			/* We're establishing new connection or changing connections */
			DAC_connection.ConnectionLabel = newConnection;
8000520e:	c2 e0       	breq	8000526a <Amp_Connect_StartResult+0xd2>
			DAC_connection.Connecting = TRUE; // flag that we're in connection process in case we need to disconnect first
80005210:	a8 25       	st.h	r4[0x4],r5
			if (INVALID_CONNECTION == DAC_connection.ConnectionHandle) // already connected?
80005212:	a8 f7       	st.b	r4[0x7],r7
80005214:	09 e9       	ld.ub	r9,r4[0x6]
80005216:	3f f8       	mov	r8,-1
80005218:	f0 09 18 00 	cp.b	r9,r8
			{ // if not, just do the connection
				result = DAC_INIC_CreateSocket();  // that starts connection process -
			}
			else
			{ // if so disconnect - then disconnect will check "Connecting" flag & contiune w/ connection
				result = DAC_DisConnectSockets(); // must disconnect first - then connect
8000521c:	c1 20       	breq	80005240 <Amp_Connect_StartResult+0xa8>
8000521e:	fe b0 fb 11 	rcall	80004840 <DAC_DisConnectSockets>
			}

			if (ERR_NO == result)
80005222:	58 0c       	cp.w	r12,0
			{
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
80005224:	c1 11       	brne	80005246 <Amp_Connect_StartResult+0xae>
80005226:	49 68       	lddpc	r8,8000527c <Amp_Connect_StartResult+0xe4>
80005228:	34 0c       	mov	r12,64
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
8000522a:	91 06       	st.w	r8[0x0],r6
	DECODE_WORD(&newConnection, &Rx_Ptr->Data[4]);
	LOG_NOR("Connection Label for Stereo Amp is: %04X\n", newConnection);
	
	if (AUDIO_STEREO*RES_16BIT != blockWidth)
	{
		return (CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 2));
8000522c:	cc 3b       	rjmp	800051b2 <Amp_Connect_StartResult+0x1a>
8000522e:	76 0a       	ld.w	r10,r11[0x0]
80005230:	30 29       	mov	r9,2
80005232:	0c 9c       	mov	r12,r6
80005234:	2f ea       	sub	r10,-2
80005236:	12 9b       	mov	r11,r9
80005238:	e0 a0 74 ac 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[0] = AMP_SINK_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		//CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULT);  // Just report connection was OK
	}
}
8000523c:	2f fd       	sub	sp,-4
			/* We're establishing new connection or changing connections */
			DAC_connection.ConnectionLabel = newConnection;
			DAC_connection.Connecting = TRUE; // flag that we're in connection process in case we need to disconnect first
			if (INVALID_CONNECTION == DAC_connection.ConnectionHandle) // already connected?
			{ // if not, just do the connection
				result = DAC_INIC_CreateSocket();  // that starts connection process -
8000523e:	d8 22       	popm	r4-r7,pc
80005240:	fe b0 fb 42 	rcall	800048c4 <DAC_INIC_CreateSocket>
				AmpRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80005244:	ce fb       	rjmp	80005222 <Amp_Connect_StartResult+0x8a>
80005246:	50 0c       	stdsp	sp[0x0],r12
80005248:	fe b0 f8 ee 	rcall	80004424 <ConmgrReturnMutex>
//				RED_LED_ON();
				DAC_connection.ConnectionLabel = INVALID_LABEL;  // not connected to newConnection
8000524c:	40 0c       	lddsp	r12,sp[0x0]
				LOG_NOR("Error starting DAC->INIC socket creation: result = %02X\n", result);
8000524e:	30 08       	mov	r8,0
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
//				RED_LED_ON();
				DAC_connection.ConnectionLabel = INVALID_LABEL;  // not connected to newConnection
80005250:	1a dc       	st.w	--sp,r12
				LOG_NOR("Error starting DAC->INIC socket creation: result = %02X\n", result);
80005252:	a8 28       	st.h	r4[0x4],r8
80005254:	48 bc       	lddpc	r12,80005280 <Amp_Connect_StartResult+0xe8>
80005256:	e0 a0 94 47 	rcall	80017ae4 <printf>
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
8000525a:	6c 08       	ld.w	r8,r6[0x0]
8000525c:	34 29       	mov	r9,66
				Tx_Ptr->Length = 1; //
				return (OP_ERRORACK);  // Return with error - allocate failed
8000525e:	b0 89       	st.b	r8[0x0],r9
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
//				RED_LED_ON();
				DAC_connection.ConnectionLabel = INVALID_LABEL;  // not connected to newConnection
				LOG_NOR("Error starting DAC->INIC socket creation: result = %02X\n", result);
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
				Tx_Ptr->Length = 1; //
80005260:	2f fd       	sub	sp,-4
80005262:	30 18       	mov	r8,1
80005264:	30 9c       	mov	r12,9
				return (OP_ERRORACK);  // Return with error - allocate failed
80005266:	ac 28       	st.h	r6[0x4],r8
			}
		}
		else
		{
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
80005268:	ca 5b       	rjmp	800051b2 <Amp_Connect_StartResult+0x1a>
8000526a:	0c 9c       	mov	r12,r6
8000526c:	34 0b       	mov	r11,64
8000526e:	e0 a0 74 83 	rcall	80013b74 <CmdErrorMsg>
80005272:	ca 0b       	rjmp	800051b2 <Amp_Connect_StartResult+0x1a>
80005274:	80 06       	ld.sh	r6,r0[0x0]
80005276:	94 d0       	ld.uh	r0,r10[0xa]
80005278:	00 00       	add	r0,r0
8000527a:	40 38       	lddsp	r8,sp[0xc]
8000527c:	00 00       	add	r0,r0
8000527e:	40 34       	lddsp	r4,sp[0xc]
80005280:	80 06       	ld.sh	r6,r0[0x0]
80005282:	94 fc       	ld.uh	r12,r10[0xe]

80005284 <Amp_FBlockInfo_Get>:
80005284:	eb cd 40 e0 	pushm	r5-r7,lr
80005288:	20 5d       	sub	sp,20
8000528a:	4e 88       	lddpc	r8,80005428 <Amp_FBlockInfo_Get+0x1a4>
8000528c:	f1 39 00 08 	ld.ub	r9,r8[8]
80005290:	fb 69 00 08 	st.b	sp[8],r9
80005294:	f0 e8 00 00 	ld.d	r8,r8[0]
80005298:	18 97       	mov	r7,r12
8000529a:	fa e9 00 00 	st.d	sp[0],r8
8000529e:	16 96       	mov	r6,r11
800052a0:	fa cc ff ee 	sub	r12,sp,-18
	uint16_t rx_id;
	uint8_t  name[] = "AudioAmp";
	uint8_t  i;
	uint8_t  version[3];

	CmdDecodeWord(&rx_id, &Rx_Ptr->Data[0]);
800052a4:	76 0b       	ld.w	r11,r11[0x0]
800052a6:	e0 a0 74 2e 	rcall	80013b02 <CmdDecodeWord>

	Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
800052aa:	6c 08       	ld.w	r8,r6[0x0]
800052ac:	11 89       	ld.ub	r9,r8[0x0]
800052ae:	6e 08       	ld.w	r8,r7[0x0]
800052b0:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
800052b2:	6c 08       	ld.w	r8,r6[0x0]
800052b4:	11 99       	ld.ub	r9,r8[0x1]
800052b6:	6e 08       	ld.w	r8,r7[0x0]
800052b8:	b0 99       	st.b	r8[0x1],r9
	Tx_Ptr->Length  = (u16_t)2;
800052ba:	30 29       	mov	r9,2
800052bc:	ae 29       	st.h	r7[0x4],r9
*
****************************************************************************/
uint8_t Amp_FBlockInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint16_t rx_id;
	uint8_t  name[] = "AudioAmp";
800052be:	1a 95       	mov	r5,sp
	Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
	Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
	Tx_Ptr->Length  = (u16_t)2;


	if (rx_id < 0x1000)                             /* FktID ?*/
800052c0:	fb 08 00 12 	ld.sh	r8,sp[18]
800052c4:	e0 6a 0f ff 	mov	r10,4095
800052c8:	f4 08 19 00 	cp.h	r8,r10
800052cc:	e0 8b 00 1f 	brhi	8000530a <Amp_FBlockInfo_Get+0x86>
	{
		Tx_Ptr->Length  = (u16_t)3;
800052d0:	30 39       	mov	r9,3
800052d2:	ae 29       	st.h	r7[0x4],r9

		switch (rx_id)
800052d4:	e0 69 01 16 	mov	r9,278
800052d8:	f2 08 19 00 	cp.h	r8,r9
800052dc:	c1 00       	breq	800052fc <Amp_FBlockInfo_Get+0x78>
800052de:	e0 88 00 41 	brls	80005360 <Amp_FBlockInfo_Get+0xdc>
800052e2:	e0 69 04 00 	mov	r9,1024
800052e6:	f2 08 19 00 	cp.h	r8,r9
800052ea:	c0 90       	breq	800052fc <Amp_FBlockInfo_Get+0x78>
800052ec:	c4 13       	brcs	8000536e <Amp_FBlockInfo_Get+0xea>
800052ee:	f0 c8 0c 03 	sub	r8,r8,3075
800052f2:	30 19       	mov	r9,1
800052f4:	f2 08 19 00 	cp.h	r8,r9
800052f8:	e0 8b 00 3b 	brhi	8000536e <Amp_FBlockInfo_Get+0xea>
			case FUNC_SINKNAME:
			case FUNC_SYNCDATAINFO:
			case AMP_VOLUME:
			case AMP_EVENTS:
			case AMP_TEMPERATURE:
			Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
800052fc:	6e 08       	ld.w	r8,r7[0x0]
800052fe:	31 29       	mov	r9,18
80005300:	30 cc       	mov	r12,12
80005302:	b0 a9       	st.b	r8[0x2],r9
			break;
		}
	}

	return(OP_STATUS);
}
80005304:	2f bd       	sub	sp,-20
80005306:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			break;
		}
	}
	else
	{
		switch (rx_id)
8000530a:	fe 7a f0 03 	mov	r10,-4093
8000530e:	f4 08 19 00 	cp.h	r8,r10
80005312:	c4 60       	breq	8000539e <Amp_FBlockInfo_Get+0x11a>
80005314:	e0 88 00 34 	brls	8000537c <Amp_FBlockInfo_Get+0xf8>
80005318:	fe 7a f0 05 	mov	r10,-4091
8000531c:	f4 08 19 00 	cp.h	r8,r10
80005320:	c7 10       	breq	80005402 <Amp_FBlockInfo_Get+0x17e>
80005322:	c6 43       	brcs	800053ea <Amp_FBlockInfo_Get+0x166>
80005324:	fe 79 f0 06 	mov	r9,-4090
80005328:	f2 08 19 00 	cp.h	r8,r9
8000532c:	c3 21       	brne	80005390 <Amp_FBlockInfo_Get+0x10c>
			Tx_Ptr->Data[6] = (u8_t)'C';
			Tx_Ptr->Length  = (u16_t)7;
			break;

			case FBI_FBLOCK_TYPE:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
8000532e:	30 19       	mov	r9,1
80005330:	6e 08       	ld.w	r8,r7[0x0]
80005332:	b0 a9       	st.b	r8[0x2],r9
			Tx_Ptr->Data[3] = (u8_t)'S';
80005334:	35 39       	mov	r9,83
80005336:	6e 08       	ld.w	r8,r7[0x0]
80005338:	b0 b9       	st.b	r8[0x3],r9
			Tx_Ptr->Data[4] = (u8_t)'t';
8000533a:	37 49       	mov	r9,116
8000533c:	6e 08       	ld.w	r8,r7[0x0]
8000533e:	b0 c9       	st.b	r8[0x4],r9
			Tx_Ptr->Data[5] = (u8_t)'e';
80005340:	6e 09       	ld.w	r9,r7[0x0]
80005342:	36 58       	mov	r8,101
80005344:	b2 d8       	st.b	r9[0x5],r8
			Tx_Ptr->Data[6] = (u8_t)'r';
80005346:	6e 09       	ld.w	r9,r7[0x0]
80005348:	37 2a       	mov	r10,114
8000534a:	b2 ea       	st.b	r9[0x6],r10
			Tx_Ptr->Data[7] = (u8_t)'e';
8000534c:	6e 09       	ld.w	r9,r7[0x0]
8000534e:	b2 f8       	st.b	r9[0x7],r8
			Tx_Ptr->Data[8] = (u8_t)'o';
80005350:	36 f9       	mov	r9,111
80005352:	6e 08       	ld.w	r8,r7[0x0]
80005354:	f1 69 00 08 	st.b	r8[8],r9
			Tx_Ptr->Length  = (u16_t)9;
80005358:	30 cc       	mov	r12,12
8000535a:	30 98       	mov	r8,9
8000535c:	ae 28       	st.h	r7[0x4],r8
			break;
8000535e:	cd 3b       	rjmp	80005304 <Amp_FBlockInfo_Get+0x80>

	if (rx_id < 0x1000)                             /* FktID ?*/
	{
		Tx_Ptr->Length  = (u16_t)3;

		switch (rx_id)
80005360:	f0 c8 01 10 	sub	r8,r8,272
80005364:	30 49       	mov	r9,4
80005366:	f2 08 19 00 	cp.h	r8,r9
8000536a:	fe 98 ff c9 	brls	800052fc <Amp_FBlockInfo_Get+0x78>
			case AMP_EVENTS:
			case AMP_TEMPERATURE:
			Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
			break;
			default:
			Tx_Ptr->Data[2] = MAT_UNKNOWN;
8000536e:	6e 08       	ld.w	r8,r7[0x0]
80005370:	30 09       	mov	r9,0
80005372:	30 cc       	mov	r12,12
80005374:	b0 a9       	st.b	r8[0x2],r9
			break;
		}
	}

	return(OP_STATUS);
}
80005376:	2f bd       	sub	sp,-20
80005378:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			break;
		}
	}
	else
	{
		switch (rx_id)
8000537c:	fe 79 f0 01 	mov	r9,-4095
80005380:	f2 08 19 00 	cp.h	r8,r9
80005384:	c2 30       	breq	800053ca <Amp_FBlockInfo_Get+0x146>
80005386:	fe 79 f0 02 	mov	r9,-4094
8000538a:	f2 08 19 00 	cp.h	r8,r9
8000538e:	c0 80       	breq	8000539e <Amp_FBlockInfo_Get+0x11a>
			Tx_Ptr->Data[8] = (u8_t)'o';
			Tx_Ptr->Length  = (u16_t)9;
			break;

			default :
			return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 2));
80005390:	6c 0a       	ld.w	r10,r6[0x0]
80005392:	0e 9c       	mov	r12,r7
80005394:	30 29       	mov	r9,2
80005396:	30 1b       	mov	r11,1
80005398:	e0 a0 73 fc 	rcall	80013b90 <CmdErrorParamWrong>
8000539c:	cb 4b       	rjmp	80005304 <Amp_FBlockInfo_Get+0x80>
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_FBLOCK_VERSION:
			version[0] = AMP_VERSION_MAJOR;
			version[1] = AMP_VERSION_MINOR;
8000539e:	30 09       	mov	r9,0
			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_FBLOCK_VERSION:
			version[0] = AMP_VERSION_MAJOR;
800053a0:	30 18       	mov	r8,1
			version[1] = AMP_VERSION_MINOR;
			version[2] = AMP_VERSION_BUILD;
800053a2:	fb 69 00 0e 	st.b	sp[14],r9
			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_FBLOCK_VERSION:
			version[0] = AMP_VERSION_MAJOR;
800053a6:	fb 68 00 0c 	st.b	sp[12],r8
			version[1] = AMP_VERSION_MINOR;
800053aa:	fb 69 00 0d 	st.b	sp[13],r9
			version[2] = AMP_VERSION_BUILD;

			Tx_Ptr->Data[2] = FRMT_ISO8859;
800053ae:	6e 09       	ld.w	r9,r7[0x0]
800053b0:	b2 a8       	st.b	r9[0x2],r8
			version[0]  = GFB_VERSION_MAJOR;
			version[1]  = GFB_VERSION_MINOR;
			version[2]  = GFB_VERSION_BUILD;

			Tx_Ptr->Data[2] = FRMT_ISO8859;
			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
800053b2:	6e 0b       	ld.w	r11,r7[0x0]
800053b4:	fa cc ff f4 	sub	r12,sp,-12
800053b8:	2f db       	sub	r11,-3
800053ba:	e0 a0 1c 53 	rcall	80008c60 <MsgVersionToISO8859>
			Tx_Ptr->Length  = (word)((word)i + (word)3);
800053be:	2f dc       	sub	r12,-3
800053c0:	ae 2c       	st.h	r7[0x4],r12
800053c2:	30 cc       	mov	r12,12
			break;
		}
	}

	return(OP_STATUS);
}
800053c4:	2f bd       	sub	sp,-20
800053c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	else
	{
		switch (rx_id)
		{
			case FBI_FBLOCK_NAME:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
800053ca:	6e 08       	ld.w	r8,r7[0x0]
800053cc:	30 19       	mov	r9,1
800053ce:	b0 a9       	st.b	r8[0x2],r9
800053d0:	30 08       	mov	r8,0
			for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
			{
				Tx_Ptr->Data[i+3] = (byte)name[i];
800053d2:	6e 09       	ld.w	r9,r7[0x0]
800053d4:	ea 08 07 0a 	ld.ub	r10,r5[r8]
800053d8:	10 09       	add	r9,r8
800053da:	b2 ba       	st.b	r9[0x3],r10
800053dc:	2f f8       	sub	r8,-1
	{
		switch (rx_id)
		{
			case FBI_FBLOCK_NAME:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
			for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
800053de:	58 98       	cp.w	r8,9
800053e0:	cf 91       	brne	800053d2 <Amp_FBlockInfo_Get+0x14e>
			{
				Tx_Ptr->Data[i+3] = (byte)name[i];
			}
			Tx_Ptr->Length = (word)i + (word)3;
800053e2:	30 c8       	mov	r8,12
800053e4:	30 cc       	mov	r12,12
800053e6:	ae 28       	st.h	r7[0x4],r8
			break;
800053e8:	c8 eb       	rjmp	80005304 <Amp_FBlockInfo_Get+0x80>
			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_MOST_VERSION:
			version[0]  = GFB_VERSION_MAJOR;
800053ea:	30 38       	mov	r8,3
			version[1]  = GFB_VERSION_MINOR;
			version[2]  = GFB_VERSION_BUILD;
800053ec:	fb 69 00 0e 	st.b	sp[14],r9
			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_MOST_VERSION:
			version[0]  = GFB_VERSION_MAJOR;
800053f0:	fb 68 00 0c 	st.b	sp[12],r8
			version[1]  = GFB_VERSION_MINOR;
800053f4:	30 08       	mov	r8,0
800053f6:	fb 68 00 0d 	st.b	sp[13],r8
			version[2]  = GFB_VERSION_BUILD;

			Tx_Ptr->Data[2] = FRMT_ISO8859;
800053fa:	30 19       	mov	r9,1
800053fc:	6e 08       	ld.w	r8,r7[0x0]
800053fe:	b0 a9       	st.b	r8[0x2],r9
80005400:	cd 9b       	rjmp	800053b2 <Amp_FBlockInfo_Get+0x12e>
			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_SYSTEM_INTEGRATOR:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
80005402:	30 19       	mov	r9,1
80005404:	6e 08       	ld.w	r8,r7[0x0]
80005406:	b0 a9       	st.b	r8[0x2],r9
			Tx_Ptr->Data[3] = (u8_t)'S';
80005408:	6e 09       	ld.w	r9,r7[0x0]
8000540a:	35 38       	mov	r8,83
8000540c:	b2 b8       	st.b	r9[0x3],r8
			Tx_Ptr->Data[4] = (u8_t)'M';
8000540e:	6e 09       	ld.w	r9,r7[0x0]
80005410:	34 da       	mov	r10,77
80005412:	b2 ca       	st.b	r9[0x4],r10
			Tx_Ptr->Data[5] = (u8_t)'S';
80005414:	6e 09       	ld.w	r9,r7[0x0]
80005416:	b2 d8       	st.b	r9[0x5],r8
			Tx_Ptr->Data[6] = (u8_t)'C';
80005418:	34 39       	mov	r9,67
8000541a:	6e 08       	ld.w	r8,r7[0x0]
8000541c:	b0 e9       	st.b	r8[0x6],r9
			Tx_Ptr->Length  = (u16_t)7;
8000541e:	30 cc       	mov	r12,12
80005420:	30 78       	mov	r8,7
80005422:	ae 28       	st.h	r7[0x4],r8
			break;
80005424:	c7 0b       	rjmp	80005304 <Amp_FBlockInfo_Get+0x80>
80005426:	d7 03       	nop
80005428:	80 06       	ld.sh	r6,r0[0x0]
8000542a:	95 38       	st.w	r10[0xc],r8

8000542c <Amp_NotificationCheck_Get>:
8000542c:	d4 01       	pushm	lr
8000542e:	e0 a0 82 81 	rcall	80015930 <NtfCheck>
80005432:	d8 02       	popm	pc

80005434 <Amp_Notification_Get>:
80005434:	d4 01       	pushm	lr
80005436:	e0 a0 83 c5 	rcall	80015bc0 <NtfGetNotificationMatrix>
	#ifdef NTF_MIN
	return(NtfGetNotificationMatrix(Tx_Ptr,Rx_Ptr));
	#else
	return (NIL);
	#endif
}
8000543a:	d8 02       	popm	pc

8000543c <Amp_Notification_Set>:
8000543c:	d4 01       	pushm	lr
8000543e:	e0 a0 84 35 	rcall	80015ca8 <NtfSetNotificationMatrix>
	#ifdef NTF_MIN
	return(NtfSetNotificationMatrix(Tx_Ptr,Rx_Ptr));
	#else
	return (NIL);
	#endif
}
80005442:	d8 02       	popm	pc

80005444 <Amp_FuncIDs_Get>:
80005444:	d4 01       	pushm	lr
80005446:	48 3b       	lddpc	r11,80005450 <Amp_FuncIDs_Get+0xc>
*  Return(s):      OP_Type
*
****************************************************************************/
uint8_t Amp_FuncIDs_Get(struct Msg_Tx_Type *Tx_Ptr)
{
	CmdGetFunctionIds(Tx_Ptr, Func_Amp);
80005448:	e0 a0 74 52 	rcall	80013cec <CmdGetFunctionIds>
	return (OP_STATUS);
}
8000544c:	30 cc       	mov	r12,12
8000544e:	d8 02       	popm	pc
80005450:	80 06       	ld.sh	r6,r0[0x0]
80005452:	8e 0c       	ld.sh	r12,r7[0x0]

80005454 <Init_Amp>:
80005454:	eb cd 40 80 	pushm	r7,lr
{
	uint8_t i;
	uint8_t j;

	/* Initialize connection properties */
	Amp_KillConnections();
80005458:	fe b0 f9 86 	rcall	80004764 <Amp_KillConnections>
	DAC_connection.INIC_handle = INVALID_SOCKET;
8000545c:	49 08       	lddpc	r8,8000549c <Init_Amp+0x48>
8000545e:	3f f9       	mov	r9,-1
80005460:	b0 99       	st.b	r8[0x1],r9

	// Init pMute
	Amp.pMute = FALSE;
80005462:	30 08       	mov	r8,0
80005464:	48 f7       	lddpc	r7,800054a0 <Init_Amp+0x4c>
80005466:	ae e8       	st.b	r7[0x6],r8
	CODEC_demute();
80005468:	fe b0 f6 86 	rcall	80004174 <CODEC_demute>
	//DacDemute();

	// Init pVolume
	//Amp.pVolume = DEFAULT_VOLUME; // start off -12dB
	Amp.pVolume = AVN_DEFAULT_VOLUME;	//netbugger AVN default Volume
8000546c:	31 e8       	mov	r8,30
8000546e:	ae 88       	st.b	r7[0x0],r8
	Set_Volume();
80005470:	fe b0 f9 a8 	rcall	800047c0 <Set_Volume>

	// Init pConnectionLabel
	Amp.pConnectionLabel = INVALID_LABEL;
80005474:	30 08       	mov	r8,0
	// Init Notification Matrix
	for (i=0;i<NUM_NTF_PROP_AMP;i++) // Number of Properties

	{
		for (j=0;j<NTF_SIZE_DEVICE_TAB+1;j++) // Number of entries in the Device Index Table for each property
		NtfMatrix_Amp[i][j] = (TNtfMatrix)NTF_DEV_INDEX_FREE; // clear whole notification matrix of FBlock
80005476:	31 f9       	mov	r9,31

	// Init pConnectionLabel
	Amp.pConnectionLabel = INVALID_LABEL;

	// Init Amp Temperature varaibles
	Amp.O_Temp = FALSE;
80005478:	ef 68 00 0a 	st.b	r7[10],r8
	//Amp.pVolume = DEFAULT_VOLUME; // start off -12dB
	Amp.pVolume = AVN_DEFAULT_VOLUME;	//netbugger AVN default Volume
	Set_Volume();

	// Init pConnectionLabel
	Amp.pConnectionLabel = INVALID_LABEL;
8000547c:	ae 48       	st.h	r7[0x8],r8

	// Init Amp Temperature varaibles
	Amp.O_Temp = FALSE;
8000547e:	48 a8       	lddpc	r8,800054a4 <Init_Amp+0x50>
*  Side-effect(s): -none-
*
*  Return(s):      -none-
*
****************************************************************************/
void Init_Amp(void)
80005480:	f0 ca ff e2 	sub	r10,r8,-30
	// Init Notification Matrix
	for (i=0;i<NUM_NTF_PROP_AMP;i++) // Number of Properties

	{
		for (j=0;j<NTF_SIZE_DEVICE_TAB+1;j++) // Number of entries in the Device Index Table for each property
		NtfMatrix_Amp[i][j] = (TNtfMatrix)NTF_DEV_INDEX_FREE; // clear whole notification matrix of FBlock
80005484:	b0 89       	st.b	r8[0x0],r9
80005486:	b0 99       	st.b	r8[0x1],r9
80005488:	b0 a9       	st.b	r8[0x2],r9
8000548a:	b0 b9       	st.b	r8[0x3],r9
8000548c:	b0 c9       	st.b	r8[0x4],r9
8000548e:	b0 d9       	st.b	r8[0x5],r9
80005490:	2f a8       	sub	r8,-6
	Amp.O_Temp = FALSE;


	#ifdef NTF_MIN
	// Init Notification Matrix
	for (i=0;i<NUM_NTF_PROP_AMP;i++) // Number of Properties
80005492:	14 38       	cp.w	r8,r10
80005494:	cf 81       	brne	80005484 <Init_Amp+0x30>
	{
		for (j=0;j<NTF_SIZE_DEVICE_TAB+1;j++) // Number of entries in the Device Index Table for each property
		NtfMatrix_Amp[i][j] = (TNtfMatrix)NTF_DEV_INDEX_FREE; // clear whole notification matrix of FBlock
	}
	#endif
}
80005496:	e3 cd 80 80 	ldm	sp++,r7,pc
8000549a:	d7 03       	nop
8000549c:	00 00       	add	r0,r0
8000549e:	40 38       	lddsp	r8,sp[0xc]
800054a0:	00 00       	add	r0,r0
800054a2:	40 42       	lddsp	r2,sp[0x10]
800054a4:	00 00       	add	r0,r0
800054a6:	40 50       	lddsp	r0,sp[0x14]

800054a8 <Init_Auxin>:
{
	uint8_t i;
	uint8_t j;

	Auxin.SrcActivity = 0x02;
	Auxin.pConnectionLabel = 0xFFFF;
800054a8:	3f f9       	mov	r9,-1
	Auxin.pNodeDelay = 0;

	ADC_connection.INIC_handle = INVALID_SOCKET;
800054aa:	49 18       	lddpc	r8,800054ec <Init_Auxin+0x44>
void Init_Auxin(void)
{
	uint8_t i;
	uint8_t j;

	Auxin.SrcActivity = 0x02;
800054ac:	49 1a       	lddpc	r10,800054f0 <Init_Auxin+0x48>
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
800054ae:	b0 e9       	st.b	r8[0x6],r9

	Auxin.SrcActivity = 0x02;
	Auxin.pConnectionLabel = 0xFFFF;
	Auxin.pNodeDelay = 0;

	ADC_connection.INIC_handle = INVALID_SOCKET;
800054b0:	b0 99       	st.b	r8[0x1],r9
*  RETURNS:        nothing
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
800054b2:	b0 a9       	st.b	r8[0x2],r9
{
	uint8_t i;
	uint8_t j;

	Auxin.SrcActivity = 0x02;
	Auxin.pConnectionLabel = 0xFFFF;
800054b4:	b4 29       	st.h	r10[0x4],r9
	Auxin.pNodeDelay = 0;
800054b6:	30 09       	mov	r9,0
{
	ADC_connection.Network_handle = INVALID_SOCKET;
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
	ADC_connection.LocalCommand = FALSE; // not doing stuff on our own
800054b8:	f1 69 00 09 	st.b	r8[9],r9
	uint8_t i;
	uint8_t j;

	Auxin.SrcActivity = 0x02;
	Auxin.pConnectionLabel = 0xFFFF;
	Auxin.pNodeDelay = 0;
800054bc:	b4 99       	st.b	r10[0x1],r9
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
800054be:	30 09       	mov	r9,0
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
800054c0:	b0 f9       	st.b	r8[0x7],r9
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
800054c2:	b0 29       	st.h	r8[0x4],r9
void Init_Auxin(void)
{
	uint8_t i;
	uint8_t j;

	Auxin.SrcActivity = 0x02;
800054c4:	30 28       	mov	r8,2
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
	ADC_connection.LocalCommand = FALSE; // not doing stuff on our own
	GREEN_LED_OFF(); // ADC connection LED should be off

	AuxinRetained_Tx_Ptr = NULL; // no messages waiting for response
800054c6:	30 09       	mov	r9,0
void Init_Auxin(void)
{
	uint8_t i;
	uint8_t j;

	Auxin.SrcActivity = 0x02;
800054c8:	b4 88       	st.b	r10[0x0],r8
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
	ADC_connection.LocalCommand = FALSE; // not doing stuff on our own
	GREEN_LED_OFF(); // ADC connection LED should be off

	AuxinRetained_Tx_Ptr = NULL; // no messages waiting for response
800054ca:	48 b8       	lddpc	r8,800054f4 <Init_Auxin+0x4c>
800054cc:	91 09       	st.w	r8[0x0],r9
800054ce:	48 b8       	lddpc	r8,800054f8 <Init_Auxin+0x50>
	//------------------------------------------
	for (i=0;i<NUM_NTF_PROP_AUXIN;i++) // Number of Properties

	{
		for (j=0;j<NTF_SIZE_DEVICE_TAB+1;j++) // Number of entries in the Device Index Table for each property
		NtfMatrix_Auxin[i][j] = (TNtfMatrix)NTF_DEV_INDEX_FREE; // clear whole notification matrix of FBlock
800054d0:	31 f9       	mov	r9,31
*  Side-effect(s): -none-
*
*  Return(s):      -none-
*
****************************************************************************/
void Init_Auxin(void)
800054d2:	f0 ca ff ee 	sub	r10,r8,-18
	//------------------------------------------
	for (i=0;i<NUM_NTF_PROP_AUXIN;i++) // Number of Properties

	{
		for (j=0;j<NTF_SIZE_DEVICE_TAB+1;j++) // Number of entries in the Device Index Table for each property
		NtfMatrix_Auxin[i][j] = (TNtfMatrix)NTF_DEV_INDEX_FREE; // clear whole notification matrix of FBlock
800054d6:	b0 89       	st.b	r8[0x0],r9
800054d8:	b0 99       	st.b	r8[0x1],r9
800054da:	b0 a9       	st.b	r8[0x2],r9
800054dc:	b0 b9       	st.b	r8[0x3],r9
800054de:	b0 c9       	st.b	r8[0x4],r9
800054e0:	b0 d9       	st.b	r8[0x5],r9
800054e2:	2f a8       	sub	r8,-6


	#ifdef NTF_MIN
	// Init Notification Matrix
	//------------------------------------------
	for (i=0;i<NUM_NTF_PROP_AUXIN;i++) // Number of Properties
800054e4:	14 38       	cp.w	r8,r10
800054e6:	cf 81       	brne	800054d6 <Init_Auxin+0x2e>
	{
		for (j=0;j<NTF_SIZE_DEVICE_TAB+1;j++) // Number of entries in the Device Index Table for each property
		NtfMatrix_Auxin[i][j] = (TNtfMatrix)NTF_DEV_INDEX_FREE; // clear whole notification matrix of FBlock
	}
	#endif
}
800054e8:	5e fc       	retal	r12
800054ea:	d7 03       	nop
800054ec:	00 00       	add	r0,r0
800054ee:	40 70       	lddsp	r0,sp[0x1c]
800054f0:	00 00       	add	r0,r0
800054f2:	40 80       	lddsp	r0,sp[0x20]
800054f4:	00 00       	add	r0,r0
800054f6:	40 7c       	lddsp	r12,sp[0x1c]
800054f8:	00 00       	add	r0,r0
800054fa:	40 88       	lddsp	r8,sp[0x20]

800054fc <Auxin_KillConnections>:
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
800054fc:	30 09       	mov	r9,0
*  RETURNS:        nothing
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
800054fe:	48 78       	lddpc	r8,80005518 <Auxin_KillConnections+0x1c>
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
	ADC_connection.LocalCommand = FALSE; // not doing stuff on our own
80005500:	f1 69 00 09 	st.b	r8[9],r9
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
80005504:	b0 29       	st.h	r8[0x4],r9
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
80005506:	b0 f9       	st.b	r8[0x7],r9
*  RETURNS:        nothing
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
80005508:	3f f9       	mov	r9,-1
	ADC_connection.ConnectionLabel = INVALID_LABEL; // MOST50
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
8000550a:	b0 e9       	st.b	r8[0x6],r9
*  RETURNS:        nothing
*
*/
void Auxin_KillConnections(void)
{
	ADC_connection.Network_handle = INVALID_SOCKET;
8000550c:	b0 a9       	st.b	r8[0x2],r9
	ADC_connection.ConnectionHandle = INVALID_CONNECTION; // MOST25 & MOST50 - same
	ADC_connection.Connecting = FALSE; // not currently working on connecting
	ADC_connection.LocalCommand = FALSE; // not doing stuff on our own
	GREEN_LED_OFF(); // ADC connection LED should be off

	AuxinRetained_Tx_Ptr = NULL; // no messages waiting for response
8000550e:	30 09       	mov	r9,0
80005510:	48 38       	lddpc	r8,8000551c <Auxin_KillConnections+0x20>
80005512:	91 09       	st.w	r8[0x0],r9
}
80005514:	5e fc       	retal	r12
80005516:	d7 03       	nop
80005518:	00 00       	add	r0,r0
8000551a:	40 70       	lddsp	r0,sp[0x1c]
8000551c:	00 00       	add	r0,r0
8000551e:	40 7c       	lddsp	r12,sp[0x1c]

80005520 <Auxin_SourceInfo_N>:
*
****************************************************************************/
uint8_t Auxin_SourceInfo_N(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	Tx_Ptr->Data[0] = AUXIN_SOURCE_NR;                          // SourceNr
80005520:	30 19       	mov	r9,1
80005522:	78 08       	ld.w	r8,r12[0x0]
80005524:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = 0;                                        // MSB of blockwidth
80005526:	78 09       	ld.w	r9,r12[0x0]
80005528:	30 08       	mov	r8,0
	Tx_Ptr->Data[2] = AUDIO_STEREO * RES_16BIT;                 // LSB of blockwitdh - only support stereo (4 bytes)
8000552a:	30 4a       	mov	r10,4
****************************************************************************/
uint8_t Auxin_SourceInfo_N(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	Tx_Ptr->Data[0] = AUXIN_SOURCE_NR;                          // SourceNr
	Tx_Ptr->Data[1] = 0;                                        // MSB of blockwidth
8000552c:	b2 98       	st.b	r9[0x1],r8
	Tx_Ptr->Data[2] = AUDIO_STEREO * RES_16BIT;                 // LSB of blockwitdh - only support stereo (4 bytes)
8000552e:	78 09       	ld.w	r9,r12[0x0]
80005530:	b2 aa       	st.b	r9[0x2],r10
	Tx_Ptr->Data[3] = (u8_t) (ADC_connection.ConnectionLabel>>8);   // MSB of connection label
80005532:	48 e9       	lddpc	r9,80005568 <Auxin_SourceInfo_N+0x48>
80005534:	78 0a       	ld.w	r10,r12[0x0]
80005536:	13 cb       	ld.ub	r11,r9[0x4]
80005538:	b4 bb       	st.b	r10[0x3],r11
	Tx_Ptr->Data[4] = (u8_t) ADC_connection.ConnectionLabel;        // LSB of connection label
8000553a:	92 2a       	ld.sh	r10,r9[0x4]
8000553c:	78 09       	ld.w	r9,r12[0x0]
8000553e:	b2 ca       	st.b	r9[0x4],r10
	Tx_Ptr->Data[5] = 0;                                        // Transmission Class 0 = Synchronous
80005540:	78 09       	ld.w	r9,r12[0x0]
80005542:	b2 d8       	st.b	r9[0x5],r8
	Tx_Ptr->Data[6] = 0;                                        // Content Protection 0 = None
80005544:	78 09       	ld.w	r9,r12[0x0]
80005546:	b2 e8       	st.b	r9[0x6],r8
	Tx_Ptr->Data[7] = 0;                                        // Content Type 0 = Audio
80005548:	78 09       	ld.w	r9,r12[0x0]
8000554a:	b2 f8       	st.b	r9[0x7],r8
	Tx_Ptr->Data[8] = 2;                                        // Content Description, short stream 2 bytes follow
8000554c:	78 09       	ld.w	r9,r12[0x0]
8000554e:	30 28       	mov	r8,2
80005550:	f3 68 00 08 	st.b	r9[8],r8
	Tx_Ptr->Data[9] = AUDIO_STEREO;                             // AudioChannels 2 = Stereo
80005554:	78 09       	ld.w	r9,r12[0x0]
80005556:	f3 68 00 09 	st.b	r9[9],r8
	Tx_Ptr->Data[10] = RES_16BIT;                                // Resolution 2 = 16-Bit Audio
8000555a:	78 09       	ld.w	r9,r12[0x0]
8000555c:	f3 68 00 0a 	st.b	r9[10],r8

	Tx_Ptr->Length  = 11;
80005560:	30 b8       	mov	r8,11
80005562:	b8 28       	st.h	r12[0x4],r8
	return (OP_RESULT);
}
80005564:	30 cc       	mov	r12,12
80005566:	5e fc       	retal	r12
80005568:	00 00       	add	r0,r0
8000556a:	40 70       	lddsp	r0,sp[0x1c]

8000556c <Auxin_SyncDataInfo_Get>:
*
****************************************************************************/
uint8_t Auxin_SyncDataInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	Tx_Ptr->Data[0] = 0x01; // Source Count
8000556c:	78 09       	ld.w	r9,r12[0x0]
8000556e:	30 18       	mov	r8,1
80005570:	b2 88       	st.b	r9[0x0],r8
	Tx_Ptr->Data[1] = AUXIN_SOURCE_NR; // SrcNr
80005572:	78 09       	ld.w	r9,r12[0x0]
80005574:	b2 98       	st.b	r9[0x1],r8
	Tx_Ptr->Data[1] = 0x00; // Sink Count
80005576:	30 09       	mov	r9,0
80005578:	78 08       	ld.w	r8,r12[0x0]
8000557a:	b0 99       	st.b	r8[0x1],r9
	Tx_Ptr->Length = 0x03;
8000557c:	30 38       	mov	r8,3
8000557e:	b8 28       	st.h	r12[0x4],r8

	return (OP_STATUS);
}
80005580:	30 cc       	mov	r12,12
80005582:	5e fc       	retal	r12

80005584 <ADC_Network_DestroySocket>:
* params  : none
* returns : result pass/fail
* effects : NetServices triggers ADC_Network_DestroySocket_CB when done
*******************************************************************************/
uint8_t ADC_Network_DestroySocket(void)
{
80005584:	d4 01       	pushm	lr
	uint8_t result;

	LOG_NOR("Destroying ADC to Network socket...\n");
80005586:	48 7c       	lddpc	r12,800055a0 <ADC_Network_DestroySocket+0x1c>
80005588:	e0 a0 93 44 	rcall	80017c10 <puts>
	result = ScmDestroySocket(ADC_connection.Network_handle, ADC_Network_DestroySocket_CB);
8000558c:	48 68       	lddpc	r8,800055a4 <ADC_Network_DestroySocket+0x20>
8000558e:	e0 6a 04 04 	mov	r10,1028
80005592:	11 ac       	ld.ub	r12,r8[0x2]
80005594:	fe cb fd 5c 	sub	r11,pc,-676
80005598:	e0 a0 68 9a 	rcall	800126cc <ScmSendHandleMsg>
	return (result);
}
8000559c:	d8 02       	popm	pc
8000559e:	d7 03       	nop
800055a0:	80 06       	ld.sh	r6,r0[0x0]
800055a2:	97 e4       	st.w	r11[0x38],r4
800055a4:	00 00       	add	r0,r0
800055a6:	40 70       	lddsp	r0,sp[0x1c]

800055a8 <ADC_DisConnectSockets>:
800055a8:	d4 01       	pushm	lr
800055aa:	48 7c       	lddpc	r12,800055c4 <ADC_DisConnectSockets+0x1c>
800055ac:	e0 a0 93 32 	rcall	80017c10 <puts>
uint8_t ADC_DisConnectSockets(void)
{
	uint8_t result;

	LOG_NOR("Dis-connecting ADC from Network...\n");
	result = ScmDisconnectSockets(ADC_connection.ConnectionHandle, ADC_DisConnectSockets_CB); // only needs handle to disconnect socket
800055b0:	48 68       	lddpc	r8,800055c8 <ADC_DisConnectSockets+0x20>
800055b2:	e0 6a 04 06 	mov	r10,1030
800055b6:	11 ec       	ld.ub	r12,r8[0x6]
800055b8:	fe cb fd 38 	sub	r11,pc,-712
800055bc:	e0 a0 68 88 	rcall	800126cc <ScmSendHandleMsg>
	return (result);
}
800055c0:	d8 02       	popm	pc
800055c2:	d7 03       	nop
800055c4:	80 06       	ld.sh	r6,r0[0x0]
800055c6:	98 08       	ld.sh	r8,r12[0x0]
800055c8:	00 00       	add	r0,r0
800055ca:	40 70       	lddsp	r0,sp[0x1c]

800055cc <ADC_ConnectSockets>:
800055cc:	d4 01       	pushm	lr
800055ce:	48 7c       	lddpc	r12,800055e8 <ADC_ConnectSockets+0x1c>
800055d0:	e0 a0 93 20 	rcall	80017c10 <puts>
{
	uint8_t result;

	/* connect ADC sockets */
	LOG_NOR("Connecting ADC to Network...\n");
	result = ScmConnectSockets(ADC_connection.INIC_handle, ADC_connection.Network_handle, ADC_ConnectSockets_CB);
800055d4:	48 68       	lddpc	r8,800055ec <ADC_ConnectSockets+0x20>
800055d6:	fe c9 fb d2 	sub	r9,pc,-1070
800055da:	11 9c       	ld.ub	r12,r8[0x1]
800055dc:	30 0a       	mov	r10,0
800055de:	11 ab       	ld.ub	r11,r8[0x2]
800055e0:	e0 a0 68 30 	rcall	80012640 <ScmConnectSocketsExt>
	return (result);
}
800055e4:	d8 02       	popm	pc
800055e6:	d7 03       	nop
800055e8:	80 06       	ld.sh	r6,r0[0x0]
800055ea:	98 2c       	ld.sh	r12,r12[0x4]
800055ec:	00 00       	add	r0,r0
800055ee:	40 70       	lddsp	r0,sp[0x1c]

800055f0 <ADC_Network_CreateSocket>:
800055f0:	d4 01       	pushm	lr
800055f2:	20 ad       	sub	sp,40
800055f4:	48 dc       	lddpc	r12,80005628 <ADC_Network_CreateSocket+0x38>
800055f6:	e0 a0 93 0d 	rcall	80017c10 <puts>
{
	uint8_t result;
	TScmSocketDesc SocketDesc;

	LOG_NOR("Creating ADC INIC to Network socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_MOST;
800055fa:	30 28       	mov	r8,2
800055fc:	ba 88       	st.b	sp[0x0],r8
	SocketDesc.direction = SCM_OUT;
800055fe:	30 18       	mov	r8,1
80005600:	ba 98       	st.b	sp[0x1],r8
	SocketDesc.datatype = SCM_TYPE_SYNC;
80005602:	30 08       	mov	r8,0
80005604:	ba a8       	st.b	sp[0x2],r8
	SocketDesc.blockwidth = 0x0004;
80005606:	30 48       	mov	r8,4
80005608:	ba 28       	st.h	sp[0x4],r8
	SocketDesc.most.flags = ADC_connection.ConnectType;
8000560a:	48 98       	lddpc	r8,8000562c <ADC_Network_CreateSocket+0x3c>
8000560c:	f1 38 00 08 	ld.ub	r8,r8[8]
80005610:	fb 68 00 10 	st.b	sp[16],r8
	SocketDesc.most.result_list_ptr = scm_buf;
80005614:	48 78       	lddpc	r8,80005630 <ADC_Network_CreateSocket+0x40>

	result = ScmCreateSocket(&SocketDesc, ADC_Network_CreateSocket_CB);
80005616:	fe cb fb ca 	sub	r11,pc,-1078
8000561a:	50 68       	stdsp	sp[0x18],r8
8000561c:	1a 9c       	mov	r12,sp
8000561e:	e0 a0 69 73 	rcall	80012904 <ScmCreateSocket>
	return (result);
}
80005622:	2f 6d       	sub	sp,-40
80005624:	d8 02       	popm	pc
80005626:	d7 03       	nop
80005628:	80 06       	ld.sh	r6,r0[0x0]
8000562a:	98 4c       	ld.sh	r12,r12[0x8]
8000562c:	00 00       	add	r0,r0
8000562e:	40 70       	lddsp	r0,sp[0x1c]
80005630:	00 00       	add	r0,r0
80005632:	3f c6       	mov	r6,-4

80005634 <ADC_INIC_CreateSocket>:
80005634:	d4 01       	pushm	lr
80005636:	20 ad       	sub	sp,40
80005638:	48 bc       	lddpc	r12,80005664 <ADC_INIC_CreateSocket+0x30>
8000563a:	e0 a0 92 eb 	rcall	80017c10 <puts>
	uint8_t result;

	// create socket from INIC to ADC
	LOG_NOR("Creating ADC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
	SocketDesc.direction = SCM_IN;
8000563e:	30 08       	mov	r8,0
	SocketDesc.datatype = SCM_TYPE_SYNC;
	SocketDesc.blockwidth = 0x0004;
	SocketDesc.streaming.interface_id = SCM_STREAM_INTERFACE_SR0;
	SocketDesc.streaming.offset = 0x00;
80005640:	fb 68 00 21 	st.b	sp[33],r8
	uint8_t result;

	// create socket from INIC to ADC
	LOG_NOR("Creating ADC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
	SocketDesc.direction = SCM_IN;
80005644:	ba 98       	st.b	sp[0x1],r8
	SocketDesc.datatype = SCM_TYPE_SYNC;
80005646:	ba a8       	st.b	sp[0x2],r8
	SocketDesc.blockwidth = 0x0004;
	SocketDesc.streaming.interface_id = SCM_STREAM_INTERFACE_SR0;
80005648:	fb 68 00 20 	st.b	sp[32],r8
	TScmSocketDesc SocketDesc;
	uint8_t result;

	// create socket from INIC to ADC
	LOG_NOR("Creating ADC to INIC socket...\n");
	SocketDesc.port_id = SCM_PORT_ID_STREAM;
8000564c:	30 38       	mov	r8,3
8000564e:	ba 88       	st.b	sp[0x0],r8
	SocketDesc.direction = SCM_IN;
	SocketDesc.datatype = SCM_TYPE_SYNC;
	SocketDesc.blockwidth = 0x0004;
80005650:	30 48       	mov	r8,4
	SocketDesc.streaming.interface_id = SCM_STREAM_INTERFACE_SR0;
	SocketDesc.streaming.offset = 0x00;
	result = ScmCreateSocket(&SocketDesc, ADC_INIC_CreateSocket_CB);
80005652:	fe cb fb 4e 	sub	r11,pc,-1202
80005656:	ba 28       	st.h	sp[0x4],r8
80005658:	1a 9c       	mov	r12,sp
8000565a:	e0 a0 69 55 	rcall	80012904 <ScmCreateSocket>
	return (result);
}
8000565e:	2f 6d       	sub	sp,-40
80005660:	d8 02       	popm	pc
80005662:	d7 03       	nop
80005664:	80 06       	ld.sh	r6,r0[0x0]
80005666:	98 74       	ld.sh	r4,r12[0xe]

80005668 <Auxin_SourceName_Get>:
80005668:	d4 01       	pushm	lr
8000566a:	76 0a       	ld.w	r10,r11[0x0]
8000566c:	30 1b       	mov	r11,1
8000566e:	15 89       	ld.ub	r9,r10[0x0]
*
****************************************************************************/
uint8_t Auxin_SourceName_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AUXIN_SOURCE_NR)
80005670:	12 9e       	mov	lr,r9
80005672:	f6 09 18 00 	cp.b	r9,r11
80005676:	c2 71       	brne	800056c4 <Auxin_SourceName_Get+0x5c>
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));

	Tx_Ptr->Data[0] = AUXIN_SOURCE_NR;
80005678:	78 0a       	ld.w	r10,r12[0x0]
8000567a:	b4 89       	st.b	r10[0x0],r9
	Tx_Ptr->Data[1] = ISO8859;
8000567c:	78 0a       	ld.w	r10,r12[0x0]
8000567e:	b4 99       	st.b	r10[0x1],r9
	Tx_Ptr->Data[2] = 'A';
80005680:	34 1a       	mov	r10,65
80005682:	78 09       	ld.w	r9,r12[0x0]
80005684:	b2 aa       	st.b	r9[0x2],r10
	Tx_Ptr->Data[3] = 'u';
80005686:	37 5a       	mov	r10,117
80005688:	78 09       	ld.w	r9,r12[0x0]
8000568a:	b2 ba       	st.b	r9[0x3],r10
	Tx_Ptr->Data[4] = 'd';
8000568c:	36 4a       	mov	r10,100
8000568e:	78 09       	ld.w	r9,r12[0x0]
80005690:	b2 ca       	st.b	r9[0x4],r10
	Tx_Ptr->Data[5] = 'i';
80005692:	36 9a       	mov	r10,105
80005694:	78 09       	ld.w	r9,r12[0x0]
80005696:	b2 da       	st.b	r9[0x5],r10
	Tx_Ptr->Data[6] = 'o';
80005698:	36 fa       	mov	r10,111
8000569a:	78 09       	ld.w	r9,r12[0x0]
8000569c:	b2 ea       	st.b	r9[0x6],r10
	Tx_Ptr->Data[7] = ' ';
8000569e:	32 0a       	mov	r10,32
800056a0:	78 09       	ld.w	r9,r12[0x0]
800056a2:	b2 fa       	st.b	r9[0x7],r10
	Tx_Ptr->Data[8] = 'I';
800056a4:	34 9a       	mov	r10,73
800056a6:	78 09       	ld.w	r9,r12[0x0]
800056a8:	f3 6a 00 08 	st.b	r9[8],r10
	Tx_Ptr->Data[9] = 'n';
800056ac:	36 ea       	mov	r10,110
800056ae:	78 09       	ld.w	r9,r12[0x0]
800056b0:	f3 6a 00 09 	st.b	r9[9],r10
	Tx_Ptr->Data[10] = 0x00;
800056b4:	30 0a       	mov	r10,0
800056b6:	78 09       	ld.w	r9,r12[0x0]
800056b8:	f3 6a 00 0a 	st.b	r9[10],r10
	Tx_Ptr->Length = 11;
800056bc:	30 b9       	mov	r9,11
800056be:	b8 29       	st.h	r12[0x4],r9
800056c0:	30 cc       	mov	r12,12

	return (OP_STATUS);
}
800056c2:	d8 02       	popm	pc
****************************************************************************/
uint8_t Auxin_SourceName_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{

	if (Rx_Ptr->Data[0] != AUXIN_SOURCE_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
800056c4:	30 19       	mov	r9,1
800056c6:	12 9b       	mov	r11,r9
800056c8:	e0 a0 72 64 	rcall	80013b90 <CmdErrorParamWrong>
800056cc:	d8 02       	popm	pc
800056ce:	d7 03       	nop

800056d0 <Auxin_SourceInfo_Get>:
800056d0:	d4 01       	pushm	lr
800056d2:	30 18       	mov	r8,1
*
****************************************************************************/
uint8_t Auxin_SourceInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	// parameter checking - 1 parameter -> SinkNr
	if (Rx_Ptr->Data[0] != AUXIN_SOURCE_NR)
800056d4:	76 0a       	ld.w	r10,r11[0x0]
800056d6:	15 89       	ld.ub	r9,r10[0x0]
800056d8:	f0 09 18 00 	cp.b	r9,r8
800056dc:	c0 60       	breq	800056e8 <Auxin_SourceInfo_Get+0x18>
	return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 1));
800056de:	30 19       	mov	r9,1
800056e0:	12 9b       	mov	r11,r9
800056e2:	e0 a0 72 57 	rcall	80013b90 <CmdErrorParamWrong>
800056e6:	d8 02       	popm	pc

	// Can call Auxin_SourceInfo_N here - code from here is the same
	return (Auxin_SourceInfo_N(Tx_Ptr, Rx_Ptr));
800056e8:	c1 cf       	rcall	80005520 <Auxin_SourceInfo_N>
800056ea:	d8 02       	popm	pc

800056ec <Auxin_SourceActivity_StartResult>:
}
800056ec:	eb cd 40 e0 	pushm	r5-r7,lr
800056f0:	30 19       	mov	r9,1
800056f2:	76 08       	ld.w	r8,r11[0x0]
800056f4:	18 97       	mov	r7,r12
800056f6:	f0 ca ff fe 	sub	r10,r8,-2
	/* parameters:  SenderHandle (word  0:1)
	SourceNr, (byte) 2
	Activity, (byte) 3
	*/

	if (Rx_Ptr->Data[2] != AUXIN_SOURCE_NR)
800056fa:	15 8b       	ld.ub	r11,r10[0x0]
800056fc:	f2 0b 18 00 	cp.b	r11,r9
80005700:	c3 11       	brne	80005762 <Auxin_SourceActivity_StartResult+0x76>
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
80005702:	11 99       	ld.ub	r9,r8[0x1]
80005704:	11 8a       	ld.ub	r10,r8[0x0]
80005706:	4a 55       	lddpc	r5,80005798 <Auxin_SourceActivity_StartResult+0xac>
80005708:	f3 ea 10 8a 	or	r10,r9,r10<<0x8
8000570c:	5c 8a       	casts.h	r10
8000570e:	aa 0a       	st.h	r5[0x0],r10
	if (ADC_connection.ConnectionHandle != INVALID_CONNECTION) // are we connected?
80005710:	4a 39       	lddpc	r9,8000579c <Auxin_SourceActivity_StartResult+0xb0>
80005712:	3f fb       	mov	r11,-1
80005714:	13 e9       	ld.ub	r9,r9[0x6]
80005716:	f6 09 18 00 	cp.b	r9,r11
8000571a:	c1 00       	breq	8000573a <Auxin_SourceActivity_StartResult+0x4e>
	{
		switch (Rx_Ptr->Data[3])
8000571c:	f0 ca ff fd 	sub	r10,r8,-3
80005720:	15 8b       	ld.ub	r11,r10[0x0]
80005722:	58 0b       	cp.w	r11,0
80005724:	c2 f0       	breq	80005782 <Auxin_SourceActivity_StartResult+0x96>
80005726:	30 26       	mov	r6,2
80005728:	ec 0b 18 00 	cp.b	r11,r6
8000572c:	c2 10       	breq	8000576e <Auxin_SourceActivity_StartResult+0x82>
				Auxin.SrcActivity = SRC_ACTIVITY_ON;
				ScmDemuteConnection(ADC_connection.ConnectionHandle, NULL);
				break;
			}
			default:
			return (CmdErrorParamWrong(Tx_Ptr, 3, &Rx_Ptr->Data[3], 1));
8000572e:	30 19       	mov	r9,1
80005730:	30 3b       	mov	r11,3
80005732:	e0 a0 72 2f 	rcall	80013b90 <CmdErrorParamWrong>
80005736:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			break;
		}
	}
	else
	{
		Auxin.SrcActivity = SRC_ACTIVITY_OFF; // not connected, therefore OFF
8000573a:	49 a6       	lddpc	r6,800057a0 <Auxin_SourceActivity_StartResult+0xb4>
8000573c:	30 08       	mov	r8,0
8000573e:	ac 88       	st.b	r6[0x0],r8
	}

	Tx_Ptr->Data[0] = AUXIN_SOURCE_NR;
80005740:	6e 08       	ld.w	r8,r7[0x0]
80005742:	30 19       	mov	r9,1
80005744:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = Auxin.SrcActivity;
80005746:	6e 08       	ld.w	r8,r7[0x0]
80005748:	0d 89       	ld.ub	r9,r6[0x0]
8000574a:	b0 99       	st.b	r8[0x1],r9
	Tx_Ptr->Length = 0x02;
8000574c:	30 28       	mov	r8,2
	CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
8000574e:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80005752:	0e 9c       	mov	r12,r7
		Auxin.SrcActivity = SRC_ACTIVITY_OFF; // not connected, therefore OFF
	}

	Tx_Ptr->Data[0] = AUXIN_SOURCE_NR;
	Tx_Ptr->Data[1] = Auxin.SrcActivity;
	Tx_Ptr->Length = 0x02;
80005754:	ae 28       	st.h	r7[0x4],r8
	CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80005756:	5c 5a       	castu.b	r10
80005758:	e0 a0 72 6c 	rcall	80013c30 <CmdInsertSenderHandle>
8000575c:	30 dc       	mov	r12,13

	return (OP_RESULTACK);
}
8000575e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	SourceNr, (byte) 2
	Activity, (byte) 3
	*/

	if (Rx_Ptr->Data[2] != AUXIN_SOURCE_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));
80005762:	30 19       	mov	r9,1
80005764:	30 2b       	mov	r11,2
80005766:	e0 a0 72 15 	rcall	80013b90 <CmdErrorParamWrong>
8000576a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			case SRC_ACTIVITY_ON:
			{
				Auxin.SrcActivity = SRC_ACTIVITY_ON;
				ScmDemuteConnection(ADC_connection.ConnectionHandle, NULL);
8000576e:	e0 6a 04 0d 	mov	r10,1037
80005772:	12 9c       	mov	r12,r9
				ScmMuteConnection(ADC_connection.ConnectionHandle, NULL); // mute - no callback
				break;
			}
			case SRC_ACTIVITY_ON:
			{
				Auxin.SrcActivity = SRC_ACTIVITY_ON;
80005774:	48 b6       	lddpc	r6,800057a0 <Auxin_SourceActivity_StartResult+0xb4>
80005776:	ac 8b       	st.b	r6[0x0],r11
				ScmDemuteConnection(ADC_connection.ConnectionHandle, NULL);
80005778:	30 0b       	mov	r11,0
8000577a:	e0 a0 67 a9 	rcall	800126cc <ScmSendHandleMsg>
8000577e:	8a 0a       	ld.sh	r10,r5[0x0]
				break;
80005780:	ce 0b       	rjmp	80005740 <Auxin_SourceActivity_StartResult+0x54>
		// switch on activity parameter
		{
			case SRC_ACTIVITY_OFF:
			{
				Auxin.SrcActivity = SRC_ACTIVITY_OFF;
				ScmMuteConnection(ADC_connection.ConnectionHandle, NULL); // mute - no callback
80005782:	e0 6a 04 0c 	mov	r10,1036
80005786:	12 9c       	mov	r12,r9
		switch (Rx_Ptr->Data[3])
		// switch on activity parameter
		{
			case SRC_ACTIVITY_OFF:
			{
				Auxin.SrcActivity = SRC_ACTIVITY_OFF;
80005788:	48 66       	lddpc	r6,800057a0 <Auxin_SourceActivity_StartResult+0xb4>
8000578a:	ac 8b       	st.b	r6[0x0],r11
				ScmMuteConnection(ADC_connection.ConnectionHandle, NULL); // mute - no callback
8000578c:	30 0b       	mov	r11,0
8000578e:	e0 a0 67 9f 	rcall	800126cc <ScmSendHandleMsg>
80005792:	8a 0a       	ld.sh	r10,r5[0x0]
				break;
80005794:	cd 6b       	rjmp	80005740 <Auxin_SourceActivity_StartResult+0x54>
80005796:	d7 03       	nop
80005798:	00 00       	add	r0,r0
8000579a:	06 1a       	sub	r10,r3
8000579c:	00 00       	add	r0,r0
8000579e:	40 70       	lddsp	r0,sp[0x1c]
800057a0:	00 00       	add	r0,r0
800057a2:	40 80       	lddsp	r0,sp[0x20]

800057a4 <Auxin_DeAllocate_Result>:
800057a4:	eb cd 40 c0 	pushm	r6-r7,lr
800057a8:	49 f6       	lddpc	r6,80005824 <Auxin_DeAllocate_Result+0x80>
800057aa:	30 08       	mov	r8,0
800057ac:	ed 39 00 09 	ld.ub	r9,r6[9]
*  Return(s):      	-none-
*
****************************************************************************/
void Auxin_DeAllocate_Result(uint16_t result)
{
	if (!ADC_connection.LocalCommand)
800057b0:	f0 09 18 00 	cp.b	r9,r8
800057b4:	c2 21       	brne	800057f8 <Auxin_DeAllocate_Result+0x54>
	{
		if (AuxinRetained_Tx_Ptr == NULL) // sanity check - should have valid pointer when we get here
800057b6:	49 d7       	lddpc	r7,80005828 <Auxin_DeAllocate_Result+0x84>
800057b8:	6e 08       	ld.w	r8,r7[0x0]
800057ba:	58 08       	cp.w	r8,0
800057bc:	c2 e0       	breq	80005818 <Auxin_DeAllocate_Result+0x74>
		{
			LOG_ERR("Tried to respond to AuxInDisConnect, but had no valid message pointer\n");
			return;
		}
		if (NSR_S_OK == result) // return is OK
800057be:	58 0c       	cp.w	r12,0
800057c0:	c2 11       	brne	80005802 <Auxin_DeAllocate_Result+0x5e>
		{
			AuxinRetained_Tx_Ptr->Operation = OP_RESULTACK; // response to start/result
800057c2:	30 d9       	mov	r9,13
800057c4:	f1 69 00 0c 	st.b	r8[12],r9
			AuxinRetained_Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // this is the only parameter we send back
800057c8:	30 19       	mov	r9,1
800057ca:	6e 08       	ld.w	r8,r7[0x0]
800057cc:	70 08       	ld.w	r8,r8[0x0]
800057ce:	b0 89       	st.b	r8[0x0],r9
			AuxinRetained_Tx_Ptr->Length = 1; //
800057d0:	30 19       	mov	r9,1
800057d2:	6e 08       	ld.w	r8,r7[0x0]
800057d4:	b0 29       	st.h	r8[0x4],r9
		{
			AuxinRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
			AuxinRetained_Tx_Ptr->Data[0] = ERR_PROCESSING; // error processing this request
			AuxinRetained_Tx_Ptr->Length = 1; //
		}
		CmdInsertSenderHandle(AuxinRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
800057d6:	49 68       	lddpc	r8,8000582c <Auxin_DeAllocate_Result+0x88>
800057d8:	6e 0c       	ld.w	r12,r7[0x0]
800057da:	90 0a       	ld.sh	r10,r8[0x0]
800057dc:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
800057e0:	5c 5a       	castu.b	r10
800057e2:	e0 a0 72 27 	rcall	80013c30 <CmdInsertSenderHandle>
		MsgSend(AuxinRetained_Tx_Ptr); // send response now
800057e6:	6e 0c       	ld.w	r12,r7[0x0]
800057e8:	e0 a0 20 c6 	rcall	80009974 <MsgSend>
		AuxinRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
800057ec:	30 08       	mov	r8,0
		NtfPropertyChanged(&NtfMatrix_Auxin[0][0], 1); // trigger notification, we've allocated
800057ee:	30 1b       	mov	r11,1
			AuxinRetained_Tx_Ptr->Data[0] = ERR_PROCESSING; // error processing this request
			AuxinRetained_Tx_Ptr->Length = 1; //
		}
		CmdInsertSenderHandle(AuxinRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		MsgSend(AuxinRetained_Tx_Ptr); // send response now
		AuxinRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
800057f0:	8f 08       	st.w	r7[0x0],r8
		NtfPropertyChanged(&NtfMatrix_Auxin[0][0], 1); // trigger notification, we've allocated
800057f2:	49 0c       	lddpc	r12,80005830 <Auxin_DeAllocate_Result+0x8c>
800057f4:	e0 a0 81 54 	rcall	80015a9c <NtfPropertyChanged>
	}
	ADC_connection.LocalCommand = FALSE;  // no longer doing local connection (if we were)
800057f8:	30 08       	mov	r8,0
800057fa:	ed 68 00 09 	st.b	r6[9],r8
800057fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			AuxinRetained_Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // this is the only parameter we send back
			AuxinRetained_Tx_Ptr->Length = 1; //
		}
		else
		{
			AuxinRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
80005802:	30 99       	mov	r9,9
80005804:	f1 69 00 0c 	st.b	r8[12],r9
			AuxinRetained_Tx_Ptr->Data[0] = ERR_PROCESSING; // error processing this request
80005808:	34 29       	mov	r9,66
8000580a:	6e 08       	ld.w	r8,r7[0x0]
8000580c:	70 08       	ld.w	r8,r8[0x0]
8000580e:	b0 89       	st.b	r8[0x0],r9
			AuxinRetained_Tx_Ptr->Length = 1; //
80005810:	30 19       	mov	r9,1
80005812:	6e 08       	ld.w	r8,r7[0x0]
80005814:	b0 29       	st.h	r8[0x4],r9
80005816:	ce 0b       	rjmp	800057d6 <Auxin_DeAllocate_Result+0x32>
{
	if (!ADC_connection.LocalCommand)
	{
		if (AuxinRetained_Tx_Ptr == NULL) // sanity check - should have valid pointer when we get here
		{
			LOG_ERR("Tried to respond to AuxInDisConnect, but had no valid message pointer\n");
80005818:	48 7c       	lddpc	r12,80005834 <Auxin_DeAllocate_Result+0x90>
8000581a:	e0 a0 91 fb 	rcall	80017c10 <puts>
			return;
8000581e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005822:	d7 03       	nop
80005824:	00 00       	add	r0,r0
80005826:	40 70       	lddsp	r0,sp[0x1c]
80005828:	00 00       	add	r0,r0
8000582a:	40 7c       	lddsp	r12,sp[0x1c]
8000582c:	00 00       	add	r0,r0
8000582e:	06 1a       	sub	r10,r3
80005830:	00 00       	add	r0,r0
80005832:	40 88       	lddsp	r8,sp[0x20]
80005834:	80 06       	ld.sh	r6,r0[0x0]
80005836:	98 94       	ld.uh	r4,r12[0x2]

80005838 <ADC_Network_DestroySocket_CB>:
80005838:	eb cd 40 c0 	pushm	r6-r7,lr
8000583c:	18 97       	mov	r7,r12
8000583e:	fe b0 f5 f3 	rcall	80004424 <ConmgrReturnMutex>
80005842:	58 07       	cp.w	r7,0
80005844:	c0 c0       	breq	8000585c <ADC_Network_DestroySocket_CB+0x24>
80005846:	0e 96       	mov	r6,r7
		ADC_connection.ConnectionLabel = INVALID_LABEL; // AND connection label is also dead
		RED_LED_OFF(); // turn off error light if it was on
	}
	else
	{
		LOG_ERR("Error Destroying ADC Network Socket: Error Code = %04X\n", cb_result);
80005848:	48 bc       	lddpc	r12,80005874 <ADC_Network_DestroySocket_CB+0x3c>
8000584a:	5c 76       	castu.h	r6
8000584c:	1a d6       	st.w	--sp,r6
8000584e:	e0 a0 91 4b 	rcall	80017ae4 <printf>
		RED_LED_ON(); // turn on error light
	}
	Auxin_DeAllocate_Result(cb_result); // callback to FBlock AuxIn to send appropriate result
80005852:	0c 9c       	mov	r12,r6
		ADC_connection.ConnectionLabel = INVALID_LABEL; // AND connection label is also dead
		RED_LED_OFF(); // turn off error light if it was on
	}
	else
	{
		LOG_ERR("Error Destroying ADC Network Socket: Error Code = %04X\n", cb_result);
80005854:	2f fd       	sub	sp,-4
		RED_LED_ON(); // turn on error light
	}
	Auxin_DeAllocate_Result(cb_result); // callback to FBlock AuxIn to send appropriate result
80005856:	ca 7f       	rcall	800057a4 <Auxin_DeAllocate_Result>
80005858:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}
8000585c:	48 7c       	lddpc	r12,80005878 <ADC_Network_DestroySocket_CB+0x40>
{

	ConmgrReturnMutex();  //we're done now (pass or fail), return mutex, stop timeout timer
	if (NSR_S_OK == cb_result) // return is OK
	{
		LOG_NOR("ADC Network Socket Destroyed OK\n");
8000585e:	e0 a0 91 d9 	rcall	80017c10 <puts>
80005862:	48 78       	lddpc	r8,8000587c <ADC_Network_DestroySocket_CB+0x44>
		ADC_connection.Network_handle = INVALID_SOCKET; // socket killed
80005864:	3f f9       	mov	r9,-1
80005866:	0e 96       	mov	r6,r7
		ADC_connection.ConnectionLabel = INVALID_LABEL; // AND connection label is also dead
80005868:	b0 27       	st.h	r8[0x4],r7
8000586a:	b0 a9       	st.b	r8[0x2],r9

	ConmgrReturnMutex();  //we're done now (pass or fail), return mutex, stop timeout timer
	if (NSR_S_OK == cb_result) // return is OK
	{
		LOG_NOR("ADC Network Socket Destroyed OK\n");
		ADC_connection.Network_handle = INVALID_SOCKET; // socket killed
8000586c:	0c 9c       	mov	r12,r6
	else
	{
		LOG_ERR("Error Destroying ADC Network Socket: Error Code = %04X\n", cb_result);
		RED_LED_ON(); // turn on error light
	}
	Auxin_DeAllocate_Result(cb_result); // callback to FBlock AuxIn to send appropriate result
8000586e:	c9 bf       	rcall	800057a4 <Auxin_DeAllocate_Result>
80005870:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}
80005874:	80 06       	ld.sh	r6,r0[0x0]
80005876:	98 fc       	ld.uh	r12,r12[0xe]
80005878:	80 06       	ld.sh	r6,r0[0x0]
8000587a:	98 dc       	ld.uh	r12,r12[0xa]
8000587c:	00 00       	add	r0,r0
8000587e:	40 70       	lddsp	r0,sp[0x1c]

80005880 <ADC_DisConnectSockets_CB>:
80005880:	eb cd 40 80 	pushm	r7,lr
80005884:	20 1d       	sub	sp,4
80005886:	58 0c       	cp.w	r12,0
80005888:	c0 c1       	brne	800058a0 <ADC_DisConnectSockets_CB+0x20>
8000588a:	49 6c       	lddpc	r12,800058e0 <ADC_DisConnectSockets_CB+0x60>
8000588c:	e0 a0 91 c2 	rcall	80017c10 <puts>
80005890:	3f f9       	mov	r9,-1
80005892:	49 58       	lddpc	r8,800058e4 <ADC_DisConnectSockets_CB+0x64>
	uint8_t result;

	if (NSR_S_OK == cb_result) // sockets dis-connected OK
	{
		LOG_NOR("ADC Sockets DisConnected OK\n");
		ADC_connection.ConnectionHandle = INVALID_CONNECTION;
80005894:	b0 e9       	st.b	r8[0x6],r9
		GREEN_LED_OFF();
		result = ADC_Network_DestroySocket(); // now release the bandwidth
80005896:	c7 7e       	rcall	80005584 <ADC_Network_DestroySocket>
80005898:	c1 41       	brne	800058c0 <ADC_DisConnectSockets_CB+0x40>
		if (ERR_NO != result)
8000589a:	2f fd       	sub	sp,-4
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
		LOG_ERR("Error DisConnecting ADC Sockets: Error Code = %04X\n", cb_result);
		Auxin_DeAllocate_Result(cb_result); // callback to FBlock AuxIn to send "failed" result
		RED_LED_ON(); // turn on error light
	}
}
8000589c:	e3 cd 80 80 	ldm	sp++,r7,pc
800058a0:	50 0c       	stdsp	sp[0x0],r12
		}
		RED_LED_OFF(); // turn off error light if it was on
	}
	else
	{
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
800058a2:	fe b0 f5 c1 	rcall	80004424 <ConmgrReturnMutex>
800058a6:	40 0c       	lddsp	r12,sp[0x0]
		LOG_ERR("Error DisConnecting ADC Sockets: Error Code = %04X\n", cb_result);
800058a8:	ef dc c0 10 	bfextu	r7,r12,0x0,0x10
800058ac:	48 fc       	lddpc	r12,800058e8 <ADC_DisConnectSockets_CB+0x68>
800058ae:	1a d7       	st.w	--sp,r7
800058b0:	e0 a0 91 1a 	rcall	80017ae4 <printf>
800058b4:	0e 9c       	mov	r12,r7
		Auxin_DeAllocate_Result(cb_result); // callback to FBlock AuxIn to send "failed" result
800058b6:	c7 7f       	rcall	800057a4 <Auxin_DeAllocate_Result>
800058b8:	2f fd       	sub	sp,-4
800058ba:	2f fd       	sub	sp,-4
800058bc:	e3 cd 80 80 	ldm	sp++,r7,pc
		RED_LED_ON(); // turn on error light
	}
}
800058c0:	50 0c       	stdsp	sp[0x0],r12
800058c2:	fe b0 f5 b1 	rcall	80004424 <ConmgrReturnMutex>
		ADC_connection.ConnectionHandle = INVALID_CONNECTION;
		GREEN_LED_OFF();
		result = ADC_Network_DestroySocket(); // now release the bandwidth
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
800058c6:	40 0c       	lddsp	r12,sp[0x0]
800058c8:	1a dc       	st.w	--sp,r12
			LOG_ERR("Error starting ADC->Network socket destruction: result = %02X\n", result);
800058ca:	48 9c       	lddpc	r12,800058ec <ADC_DisConnectSockets_CB+0x6c>
800058cc:	e0 a0 91 0c 	rcall	80017ae4 <printf>
800058d0:	e0 6c 80 00 	mov	r12,32768
			Auxin_DeAllocate_Result(NSR_E_FAILED);
800058d4:	c6 8f       	rcall	800057a4 <Auxin_DeAllocate_Result>
800058d6:	2f fd       	sub	sp,-4
800058d8:	2f fd       	sub	sp,-4
800058da:	e3 cd 80 80 	ldm	sp++,r7,pc
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
		LOG_ERR("Error DisConnecting ADC Sockets: Error Code = %04X\n", cb_result);
		Auxin_DeAllocate_Result(cb_result); // callback to FBlock AuxIn to send "failed" result
		RED_LED_ON(); // turn on error light
	}
}
800058de:	d7 03       	nop
800058e0:	80 06       	ld.sh	r6,r0[0x0]
800058e2:	99 34       	st.w	r12[0xc],r4
800058e4:	00 00       	add	r0,r0
800058e6:	40 70       	lddsp	r0,sp[0x1c]
800058e8:	80 06       	ld.sh	r6,r0[0x0]
800058ea:	99 90       	st.w	r12[0x24],r0
800058ec:	80 06       	ld.sh	r6,r0[0x0]
800058ee:	99 50       	st.w	r12[0x14],r0

800058f0 <Auxin_DeAllocateTimeout>:
800058f0:	d4 01       	pushm	lr
800058f2:	48 4c       	lddpc	r12,80005900 <Auxin_DeAllocateTimeout+0x10>
800058f4:	e0 a0 91 8e 	rcall	80017c10 <puts>
800058f8:	e0 6c 80 00 	mov	r12,32768
800058fc:	c5 4f       	rcall	800057a4 <Auxin_DeAllocate_Result>
800058fe:	d8 02       	popm	pc
80005900:	80 06       	ld.sh	r6,r0[0x0]
80005902:	99 c4       	st.w	r12[0x30],r4

80005904 <Auxin_Allocate_Result>:
80005904:	eb cd 40 c0 	pushm	r6-r7,lr

void Auxin_DeAllocateTimeout(void)
{
	LOG_ERR("Timeout while de-allocating and dis-connecting stereo ADC\n");
	Auxin_DeAllocate_Result(NSR_E_FAILED);
}
80005908:	4b 97       	lddpc	r7,800059ec <Auxin_Allocate_Result+0xe8>
8000590a:	18 96       	mov	r6,r12
8000590c:	6e 08       	ld.w	r8,r7[0x0]
8000590e:	58 08       	cp.w	r8,0
*
****************************************************************************/
void Auxin_Allocate_Result(uint16_t result)
{

	if (AuxinRetained_Tx_Ptr == NULL) // sanity check - should have valid pointer when we get here
80005910:	c6 90       	breq	800059e2 <Auxin_Allocate_Result+0xde>
	{
		LOG_ERR("Tried to respond to AuxInConnect, but had no valid message pointer\n");
		return;
	}

	if (result == NSR_S_OK) // return is OK
80005912:	58 0c       	cp.w	r12,0
80005914:	c2 e1       	brne	80005970 <Auxin_Allocate_Result+0x6c>
	{
		AuxinRetained_Tx_Ptr->Operation = OP_RESULTACK; // response to start/result
80005916:	30 d9       	mov	r9,13
80005918:	f1 69 00 0c 	st.b	r8[12],r9
		AuxinRetained_Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // send back our source #
8000591c:	6e 08       	ld.w	r8,r7[0x0]
8000591e:	70 08       	ld.w	r8,r8[0x0]
80005920:	30 19       	mov	r9,1
80005922:	b0 89       	st.b	r8[0x0],r9
		AuxinRetained_Tx_Ptr->Data[1] = 0; // MSB of blockwidth
80005924:	6e 08       	ld.w	r8,r7[0x0]
80005926:	70 08       	ld.w	r8,r8[0x0]
		AuxinRetained_Tx_Ptr->Data[2] = AUDIO_STEREO*RES_16BIT; // LSB of blockwidth
80005928:	30 49       	mov	r9,4

	if (result == NSR_S_OK) // return is OK
	{
		AuxinRetained_Tx_Ptr->Operation = OP_RESULTACK; // response to start/result
		AuxinRetained_Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // send back our source #
		AuxinRetained_Tx_Ptr->Data[1] = 0; // MSB of blockwidth
8000592a:	b0 9c       	st.b	r8[0x1],r12
		AuxinRetained_Tx_Ptr->Data[2] = AUDIO_STEREO*RES_16BIT; // LSB of blockwidth
8000592c:	6e 08       	ld.w	r8,r7[0x0]
8000592e:	70 08       	ld.w	r8,r8[0x0]
80005930:	b0 a9       	st.b	r8[0x2],r9
		AuxinRetained_Tx_Ptr->Data[3] = HB(ADC_connection.ConnectionLabel);
80005932:	4b 08       	lddpc	r8,800059f0 <Auxin_Allocate_Result+0xec>
80005934:	6e 09       	ld.w	r9,r7[0x0]
80005936:	11 ca       	ld.ub	r10,r8[0x4]
80005938:	72 09       	ld.w	r9,r9[0x0]
8000593a:	b2 ba       	st.b	r9[0x3],r10
		AuxinRetained_Tx_Ptr->Data[4] = LB(ADC_connection.ConnectionLabel);
8000593c:	90 29       	ld.sh	r9,r8[0x4]
8000593e:	6e 08       	ld.w	r8,r7[0x0]
80005940:	70 08       	ld.w	r8,r8[0x0]
80005942:	b0 c9       	st.b	r8[0x4],r9
		AuxinRetained_Tx_Ptr->Length = 5; // Both MOST25 and MOST50 end up w/ same length for 4 byte stereo
80005944:	30 59       	mov	r9,5
80005946:	6e 08       	ld.w	r8,r7[0x0]
80005948:	b0 29       	st.h	r8[0x4],r9
		{
			AuxinRetained_Tx_Ptr->Data[0]  = ERR_PROCESSING;             // processing error
			AuxinRetained_Tx_Ptr->Length  = 1;                           //
		}
	}
	CmdInsertSenderHandle(AuxinRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
8000594a:	4a b8       	lddpc	r8,800059f4 <Auxin_Allocate_Result+0xf0>
8000594c:	6e 0c       	ld.w	r12,r7[0x0]
8000594e:	90 0a       	ld.sh	r10,r8[0x0]
80005950:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80005954:	5c 5a       	castu.b	r10
80005956:	e0 a0 71 6d 	rcall	80013c30 <CmdInsertSenderHandle>
	MsgSend(AuxinRetained_Tx_Ptr); // send response now
8000595a:	6e 0c       	ld.w	r12,r7[0x0]
8000595c:	e0 a0 20 0c 	rcall	80009974 <MsgSend>
	AuxinRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
80005960:	30 08       	mov	r8,0
	NtfPropertyChanged(&NtfMatrix_Auxin[0][0], 1); // trigger notification, we've allocated
80005962:	30 1b       	mov	r11,1
			AuxinRetained_Tx_Ptr->Length  = 1;                           //
		}
	}
	CmdInsertSenderHandle(AuxinRetained_Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
	MsgSend(AuxinRetained_Tx_Ptr); // send response now
	AuxinRetained_Tx_Ptr = NULL; // pointer no longer valid - MsgSend will free the message after sending
80005964:	8f 08       	st.w	r7[0x0],r8
	NtfPropertyChanged(&NtfMatrix_Auxin[0][0], 1); // trigger notification, we've allocated
80005966:	4a 5c       	lddpc	r12,800059f8 <Auxin_Allocate_Result+0xf4>
80005968:	e0 a0 80 9a 	rcall	80015a9c <NtfPropertyChanged>
8000596c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		AuxinRetained_Tx_Ptr->Data[4] = LB(ADC_connection.ConnectionLabel);
		AuxinRetained_Tx_Ptr->Length = 5; // Both MOST25 and MOST50 end up w/ same length for 4 byte stereo
	}
	else // got some error during allocate
	{
		LOG_ERR("Allocate failed with error code : %02X\n", result);
80005970:	f1 dc c0 10 	bfextu	r8,r12,0x0,0x10
80005974:	4a 2c       	lddpc	r12,800059fc <Auxin_Allocate_Result+0xf8>
80005976:	1a d8       	st.w	--sp,r8
80005978:	e0 a0 90 b6 	rcall	80017ae4 <printf>
		AuxinRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
8000597c:	6e 08       	ld.w	r8,r7[0x0]
8000597e:	30 99       	mov	r9,9
80005980:	f1 69 00 0c 	st.b	r8[12],r9
		if ( (NSR_E_CRS_NOT_ENOUGH_CHANNELS == result) || (NSR_E_CRS_SOCKET_TABLE_FULL == result) || (NSR_E_CRS_INVALID_BLOCKWIDTH == result))
80005984:	fe 78 a1 07 	mov	r8,-24313
80005988:	2f fd       	sub	sp,-4
8000598a:	f0 06 19 00 	cp.h	r6,r8
8000598e:	5f 09       	sreq	r9
80005990:	fe 78 a1 13 	mov	r8,-24301
80005994:	f0 06 19 00 	cp.h	r6,r8
80005998:	5f 08       	sreq	r8
8000599a:	f3 e8 10 08 	or	r8,r9,r8
8000599e:	c0 e1       	brne	800059ba <Auxin_Allocate_Result+0xb6>
800059a0:	fe 78 a1 08 	mov	r8,-24312
800059a4:	f0 06 19 00 	cp.h	r6,r8
800059a8:	c0 90       	breq	800059ba <Auxin_Allocate_Result+0xb6>
			AuxinRetained_Tx_Ptr->Data[3]  = AUDIO_STEREO*RES_16BIT;     // LSB of blockwidth
			AuxinRetained_Tx_Ptr->Length   = 4;                          //
		}
		else
		{
			AuxinRetained_Tx_Ptr->Data[0]  = ERR_PROCESSING;             // processing error
800059aa:	6e 08       	ld.w	r8,r7[0x0]
800059ac:	34 29       	mov	r9,66
800059ae:	70 08       	ld.w	r8,r8[0x0]
800059b0:	b0 89       	st.b	r8[0x0],r9
			AuxinRetained_Tx_Ptr->Length  = 1;                           //
800059b2:	30 19       	mov	r9,1
800059b4:	6e 08       	ld.w	r8,r7[0x0]
800059b6:	b0 29       	st.h	r8[0x4],r9
800059b8:	cc 9b       	rjmp	8000594a <Auxin_Allocate_Result+0x46>
	{
		LOG_ERR("Allocate failed with error code : %02X\n", result);
		AuxinRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
		if ( (NSR_E_CRS_NOT_ENOUGH_CHANNELS == result) || (NSR_E_CRS_SOCKET_TABLE_FULL == result) || (NSR_E_CRS_INVALID_BLOCKWIDTH == result))
		{
			AuxinRetained_Tx_Ptr->Data[0]  = ERR_FUNC_SPECIFIC;          // not enough bandwidth error response
800059ba:	6e 08       	ld.w	r8,r7[0x0]
800059bc:	32 09       	mov	r9,32
800059be:	70 08       	ld.w	r8,r8[0x0]
800059c0:	b0 89       	st.b	r8[0x0],r9
			AuxinRetained_Tx_Ptr->Data[1]  = AUXIN_SOURCE_NR;
800059c2:	30 19       	mov	r9,1
800059c4:	6e 08       	ld.w	r8,r7[0x0]
800059c6:	70 08       	ld.w	r8,r8[0x0]
800059c8:	b0 99       	st.b	r8[0x1],r9
			AuxinRetained_Tx_Ptr->Data[2]  = 0;
800059ca:	30 09       	mov	r9,0
800059cc:	6e 08       	ld.w	r8,r7[0x0]
800059ce:	70 08       	ld.w	r8,r8[0x0]
800059d0:	b0 a9       	st.b	r8[0x2],r9
			AuxinRetained_Tx_Ptr->Data[3]  = AUDIO_STEREO*RES_16BIT;     // LSB of blockwidth
800059d2:	30 49       	mov	r9,4
800059d4:	6e 08       	ld.w	r8,r7[0x0]
800059d6:	70 08       	ld.w	r8,r8[0x0]
800059d8:	b0 b9       	st.b	r8[0x3],r9
			AuxinRetained_Tx_Ptr->Length   = 4;                          //
800059da:	30 49       	mov	r9,4
800059dc:	6e 08       	ld.w	r8,r7[0x0]
800059de:	b0 29       	st.h	r8[0x4],r9
	}
	else // got some error during allocate
	{
		LOG_ERR("Allocate failed with error code : %02X\n", result);
		AuxinRetained_Tx_Ptr->Operation = OP_ERRORACK; // response to get
		if ( (NSR_E_CRS_NOT_ENOUGH_CHANNELS == result) || (NSR_E_CRS_SOCKET_TABLE_FULL == result) || (NSR_E_CRS_INVALID_BLOCKWIDTH == result))
800059e0:	cb 5b       	rjmp	8000594a <Auxin_Allocate_Result+0x46>
void Auxin_Allocate_Result(uint16_t result)
{

	if (AuxinRetained_Tx_Ptr == NULL) // sanity check - should have valid pointer when we get here
	{
		LOG_ERR("Tried to respond to AuxInConnect, but had no valid message pointer\n");
800059e2:	48 8c       	lddpc	r12,80005a00 <Auxin_Allocate_Result+0xfc>
800059e4:	e0 a0 91 16 	rcall	80017c10 <puts>
		return;
800059e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059ec:	00 00       	add	r0,r0
800059ee:	40 7c       	lddsp	r12,sp[0x1c]
800059f0:	00 00       	add	r0,r0
800059f2:	40 70       	lddsp	r0,sp[0x1c]
800059f4:	00 00       	add	r0,r0
800059f6:	06 1a       	sub	r10,r3
800059f8:	00 00       	add	r0,r0
800059fa:	40 88       	lddsp	r8,sp[0x20]
800059fc:	80 06       	ld.sh	r6,r0[0x0]
800059fe:	9a 44       	ld.sh	r4,sp[0x8]
80005a00:	80 06       	ld.sh	r6,r0[0x0]
80005a02:	9a 00       	ld.sh	r0,sp[0x0]

80005a04 <ADC_ConnectSockets_CB>:
80005a04:	eb cd 40 c0 	pushm	r6-r7,lr
80005a08:	18 97       	mov	r7,r12
80005a0a:	16 96       	mov	r6,r11
80005a0c:	fe b0 f5 0c 	rcall	80004424 <ConmgrReturnMutex>
80005a10:	58 07       	cp.w	r7,0
80005a12:	c0 e0       	breq	80005a2e <ADC_ConnectSockets_CB+0x2a>
80005a14:	5c 77       	castu.h	r7
80005a16:	48 bc       	lddpc	r12,80005a40 <ADC_ConnectSockets_CB+0x3c>
		GREEN_LED_ON();
		RED_LED_OFF(); // turn off error light if it was on
	}
	else
	{
		LOG_ERR("Error Connecting ADC Sockets: Error Code = %04X\n", cb_result);
80005a18:	1a d7       	st.w	--sp,r7
80005a1a:	e0 a0 90 65 	rcall	80017ae4 <printf>
		ADC_connection.ConnectionHandle = INVALID_CONNECTION;
80005a1e:	3f f9       	mov	r9,-1
80005a20:	48 98       	lddpc	r8,80005a44 <ADC_ConnectSockets_CB+0x40>
80005a22:	2f fd       	sub	sp,-4
80005a24:	b0 e9       	st.b	r8[0x6],r9
		RED_LED_ON(); // turn on error light
	}
	Auxin_Allocate_Result(cb_result); // callback to FBlock AuxIn that will send response
80005a26:	0e 9c       	mov	r12,r7
80005a28:	c6 ef       	rcall	80005904 <Auxin_Allocate_Result>
80005a2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}
80005a2e:	48 7c       	lddpc	r12,80005a48 <ADC_ConnectSockets_CB+0x44>
void ADC_ConnectSockets_CB(TMnsResult cb_result, uint8_t connection_handle)
{
	ConmgrReturnMutex();  //we're done, (pass or fail), return mutex, stop timeout timer
	if (NSR_S_OK == cb_result) // sockets connected OK
	{
		LOG_NOR("ADC Sockets Connected OK\n");
80005a30:	e0 a0 90 f0 	rcall	80017c10 <puts>
80005a34:	48 48       	lddpc	r8,80005a44 <ADC_ConnectSockets_CB+0x40>
		ADC_connection.ConnectionHandle = connection_handle;
80005a36:	0e 9c       	mov	r12,r7
	{
		LOG_ERR("Error Connecting ADC Sockets: Error Code = %04X\n", cb_result);
		ADC_connection.ConnectionHandle = INVALID_CONNECTION;
		RED_LED_ON(); // turn on error light
	}
	Auxin_Allocate_Result(cb_result); // callback to FBlock AuxIn that will send response
80005a38:	b0 e6       	st.b	r8[0x6],r6
{
	ConmgrReturnMutex();  //we're done, (pass or fail), return mutex, stop timeout timer
	if (NSR_S_OK == cb_result) // sockets connected OK
	{
		LOG_NOR("ADC Sockets Connected OK\n");
		ADC_connection.ConnectionHandle = connection_handle;
80005a3a:	c6 5f       	rcall	80005904 <Auxin_Allocate_Result>
	{
		LOG_ERR("Error Connecting ADC Sockets: Error Code = %04X\n", cb_result);
		ADC_connection.ConnectionHandle = INVALID_CONNECTION;
		RED_LED_ON(); // turn on error light
	}
	Auxin_Allocate_Result(cb_result); // callback to FBlock AuxIn that will send response
80005a3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}
80005a40:	80 06       	ld.sh	r6,r0[0x0]
80005a42:	9a 88       	ld.uh	r8,sp[0x0]
80005a44:	00 00       	add	r0,r0
80005a46:	40 70       	lddsp	r0,sp[0x1c]
80005a48:	80 06       	ld.sh	r6,r0[0x0]
80005a4a:	9a 6c       	ld.sh	r12,sp[0xc]

80005a4c <ADC_Network_CreateSocket_CB>:
80005a4c:	eb cd 40 80 	pushm	r7,lr
80005a50:	20 2d       	sub	sp,8
80005a52:	58 0c       	cp.w	r12,0
80005a54:	c2 b1       	brne	80005aaa <ADC_Network_CreateSocket_CB+0x5e>
80005a56:	50 1b       	stdsp	sp[0x4],r11
80005a58:	50 09       	stdsp	sp[0x0],r9
80005a5a:	4a 4c       	lddpc	r12,80005ae8 <ADC_Network_CreateSocket_CB+0x9c>
80005a5c:	e0 a0 90 da 	rcall	80017c10 <puts>
	if (NSR_S_OK == cb_result)
	{
		LOG_NOR("ADC->NETWORK Socket created OK\n");
		RED_LED_OFF(); // turn off error light if it was on

		if (list_ptr)
80005a60:	40 09       	lddsp	r9,sp[0x0]
80005a62:	40 1b       	lddsp	r11,sp[0x4]
80005a64:	58 09       	cp.w	r9,0
80005a66:	c3 70       	breq	80005ad4 <ADC_Network_CreateSocket_CB+0x88>
		{
			ADC_connection.Network_handle = handle; // our socket handle for NETWORK side
80005a68:	4a 17       	lddpc	r7,80005aec <ADC_Network_CreateSocket_CB+0xa0>
80005a6a:	ae ab       	st.b	r7[0x2],r11
			ADC_connection.ConnectionLabel = *list_ptr; // get connection label from list
80005a6c:	92 08       	ld.sh	r8,r9[0x0]
			LOG_NOR("Connection Label for AuxIn is: %04X\n", ADC_connection.ConnectionLabel);
80005a6e:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80005a72:	1a d9       	st.w	--sp,r9
		RED_LED_OFF(); // turn off error light if it was on

		if (list_ptr)
		{
			ADC_connection.Network_handle = handle; // our socket handle for NETWORK side
			ADC_connection.ConnectionLabel = *list_ptr; // get connection label from list
80005a74:	ae 28       	st.h	r7[0x4],r8
			LOG_NOR("Connection Label for AuxIn is: %04X\n", ADC_connection.ConnectionLabel);
80005a76:	49 fc       	lddpc	r12,80005af0 <ADC_Network_CreateSocket_CB+0xa4>
80005a78:	e0 a0 90 36 	rcall	80017ae4 <printf>

			Auxin.pConnectionLabel = ADC_connection.ConnectionLabel; // device's copy
80005a7c:	8e 29       	ld.sh	r9,r7[0x4]
80005a7e:	49 e8       	lddpc	r8,80005af4 <ADC_Network_CreateSocket_CB+0xa8>
80005a80:	b0 29       	st.h	r8[0x4],r9

			/* now go connect the sockets */
			result = ADC_ConnectSockets();
80005a82:	fe b0 fd a5 	rcall	800055cc <ADC_ConnectSockets>
			if (ERR_NO != result)
80005a86:	2f fd       	sub	sp,-4
80005a88:	58 0c       	cp.w	r12,0
80005a8a:	c2 20       	breq	80005ace <ADC_Network_CreateSocket_CB+0x82>
			{
				ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80005a8c:	50 1c       	stdsp	sp[0x4],r12
80005a8e:	fe b0 f4 cb 	rcall	80004424 <ConmgrReturnMutex>
				LOG_ERR("Error starting ADC->Network connect sockets: result = %02X\n", result);
80005a92:	40 1c       	lddsp	r12,sp[0x4]
80005a94:	1a dc       	st.w	--sp,r12
80005a96:	49 9c       	lddpc	r12,80005af8 <ADC_Network_CreateSocket_CB+0xac>
80005a98:	e0 a0 90 26 	rcall	80017ae4 <printf>
				Auxin_Allocate_Result(NSR_E_FAILED);
80005a9c:	e0 6c 80 00 	mov	r12,32768
80005aa0:	c3 2f       	rcall	80005904 <Auxin_Allocate_Result>
80005aa2:	2f fd       	sub	sp,-4
80005aa4:	2f ed       	sub	sp,-8
		ADC_connection.ConnectionLabel = INVALID_LABEL;

		Auxin_Allocate_Result(cb_result); // callback to FBlock AuxIn that will send "failed" response
		RED_LED_ON(); // turn on error light
	}
}
80005aa6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005aaa:	50 1c       	stdsp	sp[0x4],r12
			Auxin_Allocate_Result(NSR_E_FAILED);
		}
	}
	else
	{
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80005aac:	fe b0 f4 bc 	rcall	80004424 <ConmgrReturnMutex>
80005ab0:	40 1c       	lddsp	r12,sp[0x4]
		LOG_ERR("Error Creating ADC->NETWORK Socket: Error Code = %04X\n", cb_result);
80005ab2:	ef dc c0 10 	bfextu	r7,r12,0x0,0x10
80005ab6:	49 2c       	lddpc	r12,80005afc <ADC_Network_CreateSocket_CB+0xb0>
80005ab8:	1a d7       	st.w	--sp,r7
80005aba:	e0 a0 90 15 	rcall	80017ae4 <printf>
80005abe:	3f f9       	mov	r9,-1
		ADC_connection.Network_handle = INVALID_SOCKET;
80005ac0:	48 b8       	lddpc	r8,80005aec <ADC_Network_CreateSocket_CB+0xa0>
80005ac2:	b0 a9       	st.b	r8[0x2],r9
80005ac4:	30 09       	mov	r9,0
		ADC_connection.ConnectionLabel = INVALID_LABEL;
80005ac6:	0e 9c       	mov	r12,r7

		Auxin_Allocate_Result(cb_result); // callback to FBlock AuxIn that will send "failed" response
80005ac8:	b0 29       	st.h	r8[0x4],r9
	else
	{
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
		LOG_ERR("Error Creating ADC->NETWORK Socket: Error Code = %04X\n", cb_result);
		ADC_connection.Network_handle = INVALID_SOCKET;
		ADC_connection.ConnectionLabel = INVALID_LABEL;
80005aca:	c1 df       	rcall	80005904 <Auxin_Allocate_Result>

		Auxin_Allocate_Result(cb_result); // callback to FBlock AuxIn that will send "failed" response
80005acc:	2f fd       	sub	sp,-4
80005ace:	2f ed       	sub	sp,-8
80005ad0:	e3 cd 80 80 	ldm	sp++,r7,pc
		RED_LED_ON(); // turn on error light
	}
}
80005ad4:	fe b0 f4 a8 	rcall	80004424 <ConmgrReturnMutex>
				Auxin_Allocate_Result(NSR_E_FAILED);
			}
		}
		else
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80005ad8:	48 ac       	lddpc	r12,80005b00 <ADC_Network_CreateSocket_CB+0xb4>
80005ada:	e0 a0 90 9b 	rcall	80017c10 <puts>
			LOG_ERR("List Pointer is NULL - can't get Connection Label \n");
80005ade:	e0 6c 80 00 	mov	r12,32768
			Auxin_Allocate_Result(NSR_E_FAILED);
80005ae2:	c1 1f       	rcall	80005904 <Auxin_Allocate_Result>
80005ae4:	cf 5b       	rjmp	80005ace <ADC_Network_CreateSocket_CB+0x82>
80005ae6:	d7 03       	nop
80005ae8:	80 06       	ld.sh	r6,r0[0x0]
80005aea:	9a bc       	ld.uh	r12,sp[0x6]
80005aec:	00 00       	add	r0,r0
80005aee:	40 70       	lddsp	r0,sp[0x1c]
80005af0:	80 06       	ld.sh	r6,r0[0x0]
80005af2:	9a dc       	ld.uh	r12,sp[0xa]
80005af4:	00 00       	add	r0,r0
80005af6:	40 80       	lddsp	r0,sp[0x20]
80005af8:	80 06       	ld.sh	r6,r0[0x0]
80005afa:	9b 04       	st.w	sp[0x0],r4
80005afc:	80 06       	ld.sh	r6,r0[0x0]
80005afe:	9b 74       	st.w	sp[0x1c],r4
80005b00:	80 06       	ld.sh	r6,r0[0x0]
80005b02:	9b 40       	st.w	sp[0x10],r0

80005b04 <ADC_INIC_CreateSocket_CB>:
80005b04:	d4 01       	pushm	lr
80005b06:	20 1d       	sub	sp,4
80005b08:	58 0c       	cp.w	r12,0
80005b0a:	c0 d1       	brne	80005b24 <ADC_INIC_CreateSocket_CB+0x20>
80005b0c:	50 0b       	stdsp	sp[0x0],r11
80005b0e:	49 6c       	lddpc	r12,80005b64 <ADC_INIC_CreateSocket_CB+0x60>
80005b10:	e0 a0 90 80 	rcall	80017c10 <puts>
80005b14:	49 58       	lddpc	r8,80005b68 <ADC_INIC_CreateSocket_CB+0x64>
80005b16:	40 0b       	lddsp	r11,sp[0x0]
80005b18:	b0 9b       	st.b	r8[0x1],r11
80005b1a:	fe b0 fd 6b 	rcall	800055f0 <ADC_Network_CreateSocket>
		// won't have a list_len, or list_ptr for INIC socket - only a handle
		RED_LED_OFF(); // turn off error light if it was on

		/* now go create the network side socket */
		result = ADC_Network_CreateSocket();
		if (ERR_NO != result)
80005b1e:	c1 51       	brne	80005b48 <ADC_INIC_CreateSocket_CB+0x44>
		LOG_ERR("Error Creating ADC->INIC Socket: Error Code = %04X\n", cb_result);
		ADC_connection.INIC_handle = INVALID_SOCKET;
		RED_LED_ON(); // turn on error light
		Auxin_Allocate_Result(NSR_E_FAILED);
	}
}
80005b20:	2f fd       	sub	sp,-4
80005b22:	d8 02       	popm	pc
		}

	}
	else
	{
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80005b24:	50 0c       	stdsp	sp[0x0],r12
80005b26:	fe b0 f4 7f 	rcall	80004424 <ConmgrReturnMutex>
		LOG_ERR("Error Creating ADC->INIC Socket: Error Code = %04X\n", cb_result);
80005b2a:	40 0c       	lddsp	r12,sp[0x0]
80005b2c:	5c 7c       	castu.h	r12
80005b2e:	1a dc       	st.w	--sp,r12
80005b30:	48 fc       	lddpc	r12,80005b6c <ADC_INIC_CreateSocket_CB+0x68>
80005b32:	e0 a0 8f d9 	rcall	80017ae4 <printf>
		ADC_connection.INIC_handle = INVALID_SOCKET;
80005b36:	3f f9       	mov	r9,-1
80005b38:	48 c8       	lddpc	r8,80005b68 <ADC_INIC_CreateSocket_CB+0x64>
		RED_LED_ON(); // turn on error light
		Auxin_Allocate_Result(NSR_E_FAILED);
80005b3a:	e0 6c 80 00 	mov	r12,32768
	}
	else
	{
		ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
		LOG_ERR("Error Creating ADC->INIC Socket: Error Code = %04X\n", cb_result);
		ADC_connection.INIC_handle = INVALID_SOCKET;
80005b3e:	b0 99       	st.b	r8[0x1],r9
		RED_LED_ON(); // turn on error light
		Auxin_Allocate_Result(NSR_E_FAILED);
80005b40:	ce 2e       	rcall	80005904 <Auxin_Allocate_Result>
80005b42:	2f fd       	sub	sp,-4
80005b44:	2f fd       	sub	sp,-4
	}
}
80005b46:	d8 02       	popm	pc
80005b48:	50 0c       	stdsp	sp[0x0],r12

		/* now go create the network side socket */
		result = ADC_Network_CreateSocket();
		if (ERR_NO != result)
		{
			ConmgrReturnMutex();  //we're quitting (failed), return mutex, stop timeout timer
80005b4a:	fe b0 f4 6d 	rcall	80004424 <ConmgrReturnMutex>
80005b4e:	40 0c       	lddsp	r12,sp[0x0]
			LOG_ERR("Error starting ADC->Network socket creation: result = %02X\n", result);
80005b50:	1a dc       	st.w	--sp,r12
80005b52:	48 8c       	lddpc	r12,80005b70 <ADC_INIC_CreateSocket_CB+0x6c>
80005b54:	e0 a0 8f c8 	rcall	80017ae4 <printf>
80005b58:	e0 6c 80 00 	mov	r12,32768
			Auxin_Allocate_Result(NSR_E_FAILED);
80005b5c:	cd 4e       	rcall	80005904 <Auxin_Allocate_Result>
80005b5e:	2f fd       	sub	sp,-4
80005b60:	2f fd       	sub	sp,-4
80005b62:	d8 02       	popm	pc
		LOG_ERR("Error Creating ADC->INIC Socket: Error Code = %04X\n", cb_result);
		ADC_connection.INIC_handle = INVALID_SOCKET;
		RED_LED_ON(); // turn on error light
		Auxin_Allocate_Result(NSR_E_FAILED);
	}
}
80005b64:	80 06       	ld.sh	r6,r0[0x0]
80005b66:	9b ac       	st.w	sp[0x28],r12
80005b68:	00 00       	add	r0,r0
80005b6a:	40 70       	lddsp	r0,sp[0x1c]
80005b6c:	80 06       	ld.sh	r6,r0[0x0]
80005b6e:	9c 04       	ld.sh	r4,lr[0x0]
80005b70:	80 06       	ld.sh	r6,r0[0x0]
80005b72:	9b c8       	st.w	sp[0x30],r8

80005b74 <Auxin_AllocateTimeout>:
80005b74:	d4 01       	pushm	lr
80005b76:	48 4c       	lddpc	r12,80005b84 <Auxin_AllocateTimeout+0x10>
80005b78:	e0 a0 90 4c 	rcall	80017c10 <puts>
80005b7c:	e0 6c 80 00 	mov	r12,32768
80005b80:	cc 2e       	rcall	80005904 <Auxin_Allocate_Result>
80005b82:	d8 02       	popm	pc
80005b84:	80 06       	ld.sh	r6,r0[0x0]
80005b86:	9c 38       	ld.sh	r8,lr[0x6]

80005b88 <Auxin_DeAllocate_StartResult>:
80005b88:	eb cd 40 c0 	pushm	r6-r7,lr

void Auxin_AllocateTimeout(void)
{
	LOG_ERR("Timeout while allocating and connecting stereo ADC\n");
	Auxin_Allocate_Result(NSR_E_FAILED);
}
80005b8c:	20 1d       	sub	sp,4
80005b8e:	76 08       	ld.w	r8,r11[0x0]
80005b90:	18 97       	mov	r7,r12
80005b92:	f0 ca ff fe 	sub	r10,r8,-2

	/* parameters:  SenderHandle (word  0:1)
	SourceNr, (byte) 2
	*/

	if (Rx_Ptr->Data[2] != AUXIN_SOURCE_NR)
80005b96:	30 1b       	mov	r11,1
80005b98:	15 89       	ld.ub	r9,r10[0x0]
80005b9a:	12 96       	mov	r6,r9
80005b9c:	f6 09 18 00 	cp.b	r9,r11
80005ba0:	c2 e1       	brne	80005bfc <Auxin_DeAllocate_StartResult+0x74>
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	// Cmd OK - use connection manager to dis-connect
	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);
80005ba2:	11 9a       	ld.ub	r10,r8[0x1]
80005ba4:	11 88       	ld.ub	r8,r8[0x0]
80005ba6:	f5 e8 10 8a 	or	r10,r10,r8<<0x8
80005baa:	4a 48       	lddpc	r8,80005c38 <Auxin_DeAllocate_StartResult+0xb0>
80005bac:	5c 8a       	casts.h	r10
80005bae:	b0 0a       	st.h	r8[0x0],r10
	if (ADC_connection.ConnectionHandle != INVALID_CONNECTION) // Checking to see if we are "allocated" first
80005bb0:	4a 36       	lddpc	r6,80005c3c <Auxin_DeAllocate_StartResult+0xb4>
80005bb2:	3f f8       	mov	r8,-1
80005bb4:	0d eb       	ld.ub	r11,r6[0x6]
80005bb6:	f0 0b 18 00 	cp.b	r11,r8
80005bba:	c1 40       	breq	80005be2 <Auxin_DeAllocate_StartResult+0x5a>
	{
		if (ConmgrGetMutex(300, Auxin_DeAllocateTimeout))
80005bbc:	fe cb 02 cc 	sub	r11,pc,716
80005bc0:	e0 6c 01 2c 	mov	r12,300
80005bc4:	fe b0 f4 6a 	rcall	80004498 <ConmgrGetMutex>
		{
			ADC_connection.LocalCommand = FALSE; // we're commanded to de-allocate (not doing on our own)
80005bc8:	c3 10       	breq	80005c2a <Auxin_DeAllocate_StartResult+0xa2>
80005bca:	30 08       	mov	r8,0
80005bcc:	ed 68 00 09 	st.b	r6[9],r8
			result = ADC_DisConnectSockets(); // starts de-allocation process
80005bd0:	fe b0 fc ec 	rcall	800055a8 <ADC_DisConnectSockets>
			if (ERR_NO == result)
			{
				AuxinRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
80005bd4:	c1 b1       	brne	80005c0a <Auxin_DeAllocate_StartResult+0x82>
80005bd6:	49 b8       	lddpc	r8,80005c40 <Auxin_DeAllocate_StartResult+0xb8>
80005bd8:	34 0c       	mov	r12,64
		Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // no other return needed
	}
}
80005bda:	91 07       	st.w	r8[0x0],r7
80005bdc:	2f fd       	sub	sp,-4
80005bde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
		}
	}
	else // Not connected, so just reply that its done
	{
		Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // this is the only parameter we send back
80005be2:	78 08       	ld.w	r8,r12[0x0]
		Tx_Ptr->Length = 1; //
80005be4:	b0 89       	st.b	r8[0x0],r9
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80005be6:	30 18       	mov	r8,1
80005be8:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
80005bec:	b8 28       	st.h	r12[0x4],r8
80005bee:	5c 5a       	castu.b	r10
80005bf0:	e0 a0 70 20 	rcall	80013c30 <CmdInsertSenderHandle>
		return (OP_RESULTACK); // no other return needed
	}
}
80005bf4:	30 dc       	mov	r12,13
80005bf6:	2f fd       	sub	sp,-4
80005bf8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	/* parameters:  SenderHandle (word  0:1)
	SourceNr, (byte) 2
	*/

	if (Rx_Ptr->Data[2] != AUXIN_SOURCE_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));
80005bfc:	30 19       	mov	r9,1
80005bfe:	30 2b       	mov	r11,2
80005c00:	e0 a0 6f c8 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // no other return needed
	}
}
80005c04:	2f fd       	sub	sp,-4
80005c06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
				AuxinRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80005c0a:	50 0c       	stdsp	sp[0x0],r12
80005c0c:	fe b0 f4 0c 	rcall	80004424 <ConmgrReturnMutex>
				LOG_ERR("Error starting ADC disconnect sockets process: result = %02X\n", result);
80005c10:	40 0c       	lddsp	r12,sp[0x0]
80005c12:	1a dc       	st.w	--sp,r12
80005c14:	48 cc       	lddpc	r12,80005c44 <Auxin_DeAllocate_StartResult+0xbc>
80005c16:	e0 a0 8f 67 	rcall	80017ae4 <printf>
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
80005c1a:	6e 08       	ld.w	r8,r7[0x0]
80005c1c:	34 29       	mov	r9,66
				Tx_Ptr->Length = 1; //
				return (OP_ERRORACK);  // Return with error - allocate failed
80005c1e:	b0 89       	st.b	r8[0x0],r9
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
				LOG_ERR("Error starting ADC disconnect sockets process: result = %02X\n", result);
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
				Tx_Ptr->Length = 1; //
80005c20:	2f fd       	sub	sp,-4
80005c22:	30 18       	mov	r8,1
80005c24:	30 9c       	mov	r12,9
				return (OP_ERRORACK);  // Return with error - allocate failed
80005c26:	ae 28       	st.h	r7[0x4],r8
			}
		}
		else
		{
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY));
80005c28:	ce 7b       	rjmp	80005bf6 <Auxin_DeAllocate_StartResult+0x6e>
80005c2a:	0e 9c       	mov	r12,r7
80005c2c:	34 0b       	mov	r11,64
80005c2e:	e0 a0 6f a3 	rcall	80013b74 <CmdErrorMsg>
		Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // this is the only parameter we send back
		Tx_Ptr->Length = 1; //
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // no other return needed
	}
}
80005c32:	2f fd       	sub	sp,-4
80005c34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c38:	00 00       	add	r0,r0
80005c3a:	06 1a       	sub	r10,r3
80005c3c:	00 00       	add	r0,r0
80005c3e:	40 70       	lddsp	r0,sp[0x1c]
80005c40:	00 00       	add	r0,r0
80005c42:	40 7c       	lddsp	r12,sp[0x1c]
80005c44:	80 06       	ld.sh	r6,r0[0x0]
80005c46:	9c 6c       	ld.sh	r12,lr[0xc]

80005c48 <Auxin_Allocate_StartResult>:
80005c48:	eb cd 40 c0 	pushm	r6-r7,lr
80005c4c:	20 1d       	sub	sp,4
80005c4e:	76 08       	ld.w	r8,r11[0x0]
80005c50:	18 97       	mov	r7,r12
80005c52:	f0 ca ff fe 	sub	r10,r8,-2
80005c56:	30 1b       	mov	r11,1
80005c58:	15 89       	ld.ub	r9,r10[0x0]
80005c5a:	12 96       	mov	r6,r9
80005c5c:	f6 09 18 00 	cp.b	r9,r11
80005c60:	c2 71       	brne	80005cae <Auxin_Allocate_StartResult+0x66>
80005c62:	11 9a       	ld.ub	r10,r8[0x1]
80005c64:	11 88       	ld.ub	r8,r8[0x0]
80005c66:	f5 e8 10 8a 	or	r10,r10,r8<<0x8

	if (Rx_Ptr->Data[2] != AUXIN_SOURCE_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));

	// Cmd OK - use connection manager to connect
	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);  // Save SenderHandle for later reply
80005c6a:	4a 98       	lddpc	r8,80005d0c <Auxin_Allocate_StartResult+0xc4>
80005c6c:	5c 8a       	casts.h	r10
80005c6e:	b0 0a       	st.h	r8[0x0],r10
	if (ADC_connection.ConnectionHandle == INVALID_CONNECTION) // Make sure we're not already allocated and connected
80005c70:	4a 86       	lddpc	r6,80005d10 <Auxin_Allocate_StartResult+0xc8>
80005c72:	3f f8       	mov	r8,-1
80005c74:	0d eb       	ld.ub	r11,r6[0x6]
80005c76:	f0 0b 18 00 	cp.b	r11,r8
80005c7a:	c2 10       	breq	80005cbc <Auxin_Allocate_StartResult+0x74>
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY)); // can't do it now - return error - done
		}
	}
	else // we are already connected, just send back current info as if we just connected
	{ // here, we will pretend we just returned from a successful connect sequence
		Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // send back our source #
80005c7c:	78 08       	ld.w	r8,r12[0x0]
80005c7e:	b0 89       	st.b	r8[0x0],r9
		Tx_Ptr->Data[1] = 0; // MSB of blockwidth
80005c80:	78 08       	ld.w	r8,r12[0x0]
80005c82:	30 09       	mov	r9,0
80005c84:	b0 99       	st.b	r8[0x1],r9
		Tx_Ptr->Data[2] = AUDIO_STEREO*RES_16BIT; // LSB of blockwidth
80005c86:	78 08       	ld.w	r8,r12[0x0]
80005c88:	30 49       	mov	r9,4
80005c8a:	b0 a9       	st.b	r8[0x2],r9
		Tx_Ptr->Data[3] = HB(ADC_connection.ConnectionLabel);
80005c8c:	78 08       	ld.w	r8,r12[0x0]
80005c8e:	0d c9       	ld.ub	r9,r6[0x4]
80005c90:	b0 b9       	st.b	r8[0x3],r9
		Tx_Ptr->Data[4] = LB(ADC_connection.ConnectionLabel);
80005c92:	78 08       	ld.w	r8,r12[0x0]
80005c94:	8c 29       	ld.sh	r9,r6[0x4]
80005c96:	b0 c9       	st.b	r8[0x4],r9
		Tx_Ptr->Length = 5; // Both MOST25 and MOST50/150 end up w/ same length for 4 byte stereo
80005c98:	30 58       	mov	r8,5
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80005c9a:	f7 da c1 08 	bfextu	r11,r10,0x8,0x8
		Tx_Ptr->Data[0] = AUXIN_SOURCE_NR; // send back our source #
		Tx_Ptr->Data[1] = 0; // MSB of blockwidth
		Tx_Ptr->Data[2] = AUDIO_STEREO*RES_16BIT; // LSB of blockwidth
		Tx_Ptr->Data[3] = HB(ADC_connection.ConnectionLabel);
		Tx_Ptr->Data[4] = LB(ADC_connection.ConnectionLabel);
		Tx_Ptr->Length = 5; // Both MOST25 and MOST50/150 end up w/ same length for 4 byte stereo
80005c9e:	b8 28       	st.h	r12[0x4],r8
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
80005ca0:	5c 5a       	castu.b	r10
80005ca2:	e0 a0 6f c7 	rcall	80013c30 <CmdInsertSenderHandle>
80005ca6:	30 dc       	mov	r12,13
		return (OP_RESULTACK); // send response & done
	}
}
80005ca8:	2f fd       	sub	sp,-4
80005caa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	/* parameters:  SenderHandle (word  0:1)
	SourceNr, (byte) 2
	*/

	if (Rx_Ptr->Data[2] != AUXIN_SOURCE_NR)
	return(CmdErrorParamWrong(Tx_Ptr, 2, &Rx_Ptr->Data[2], 1));
80005cae:	30 19       	mov	r9,1
80005cb0:	30 2b       	mov	r11,2
80005cb2:	e0 a0 6f 6f 	rcall	80013b90 <CmdErrorParamWrong>
		Tx_Ptr->Data[4] = LB(ADC_connection.ConnectionLabel);
		Tx_Ptr->Length = 5; // Both MOST25 and MOST50/150 end up w/ same length for 4 byte stereo
		CmdInsertSenderHandle(Tx_Ptr, HB(SenderHandle), LB(SenderHandle));  // Moves parameters over and fixes length.
		return (OP_RESULTACK); // send response & done
	}
}
80005cb6:	2f fd       	sub	sp,-4
80005cb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

	// Cmd OK - use connection manager to connect
	DECODE_WORD(&SenderHandle, &Rx_Ptr->Data[0]);  // Save SenderHandle for later reply
	if (ADC_connection.ConnectionHandle == INVALID_CONNECTION) // Make sure we're not already allocated and connected
	{
		if (ConmgrGetMutex(300, Auxin_AllocateTimeout))
80005cbc:	fe cb 01 48 	sub	r11,pc,328
80005cc0:	e0 6c 01 2c 	mov	r12,300
80005cc4:	fe b0 f3 ea 	rcall	80004498 <ConmgrGetMutex>
		{
			ADC_connection.ConnectType = SCM_MOST_FLAGS_SOURCE_ALLOCATE;
80005cc8:	c1 c0       	breq	80005d00 <Auxin_Allocate_StartResult+0xb8>
80005cca:	30 08       	mov	r8,0
80005ccc:	ed 68 00 08 	st.b	r6[8],r8
			result = ADC_INIC_CreateSocket(); // starts allocation process
80005cd0:	fe b0 fc b2 	rcall	80005634 <ADC_INIC_CreateSocket>
			if (ERR_NO == result)
			{
				AuxinRetained_Tx_Ptr = Tx_Ptr; // keep global pointer to return message - returned later
80005cd4:	c0 51       	brne	80005cde <Auxin_Allocate_StartResult+0x96>
80005cd6:	49 08       	lddpc	r8,80005d14 <Auxin_Allocate_StartResult+0xcc>
80005cd8:	34 0c       	mov	r12,64
				return (CMD_TX_RETAIN); // sending result later in Auxin_Allocate_Result
80005cda:	91 07       	st.w	r8[0x0],r7
			}
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
80005cdc:	ce 6b       	rjmp	80005ca8 <Auxin_Allocate_StartResult+0x60>
80005cde:	50 0c       	stdsp	sp[0x0],r12
80005ce0:	fe b0 f3 a2 	rcall	80004424 <ConmgrReturnMutex>
				LOG_ERR("Error starting ADC->INIC socket creation: result = %02X\n", result);
80005ce4:	40 0c       	lddsp	r12,sp[0x0]
80005ce6:	5c 7c       	castu.h	r12
80005ce8:	1a dc       	st.w	--sp,r12
80005cea:	48 cc       	lddpc	r12,80005d18 <Auxin_Allocate_StartResult+0xd0>
80005cec:	e0 a0 8e fc 	rcall	80017ae4 <printf>
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
80005cf0:	6e 08       	ld.w	r8,r7[0x0]
80005cf2:	34 29       	mov	r9,66
				Tx_Ptr->Length = 1; //
				return (OP_ERRORACK);  // Return with error - allocate failed
80005cf4:	b0 89       	st.b	r8[0x0],r9
			else
			{
				ConmgrReturnMutex();  //we're quitting, return mutex, stop timeout timer
				LOG_ERR("Error starting ADC->INIC socket creation: result = %02X\n", result);
				Tx_Ptr->Data[0] = ERR_PROCESSING; // processing error
				Tx_Ptr->Length = 1; //
80005cf6:	2f fd       	sub	sp,-4
80005cf8:	30 18       	mov	r8,1
80005cfa:	30 9c       	mov	r12,9
				return (OP_ERRORACK);  // Return with error - allocate failed
80005cfc:	ae 28       	st.h	r7[0x4],r8
			}
		}
		else
		{
			return (CmdErrorMsg(Tx_Ptr, ERR_BUSY)); // can't do it now - return error - done
80005cfe:	cd 5b       	rjmp	80005ca8 <Auxin_Allocate_StartResult+0x60>
80005d00:	0e 9c       	mov	r12,r7
80005d02:	34 0b       	mov	r11,64
80005d04:	e0 a0 6f 38 	rcall	80013b74 <CmdErrorMsg>
80005d08:	cd 0b       	rjmp	80005ca8 <Auxin_Allocate_StartResult+0x60>
80005d0a:	d7 03       	nop
80005d0c:	00 00       	add	r0,r0
80005d0e:	06 1a       	sub	r10,r3
80005d10:	00 00       	add	r0,r0
80005d12:	40 70       	lddsp	r0,sp[0x1c]
80005d14:	00 00       	add	r0,r0
80005d16:	40 7c       	lddsp	r12,sp[0x1c]
80005d18:	80 06       	ld.sh	r6,r0[0x0]
80005d1a:	9c ac       	ld.uh	r12,lr[0x4]

80005d1c <Auxin_FBlockInfo_Get>:
80005d1c:	eb cd 40 e0 	pushm	r5-r7,lr
80005d20:	20 4d       	sub	sp,16
80005d22:	4e 08       	lddpc	r8,80005ea0 <Auxin_FBlockInfo_Get+0x184>
80005d24:	11 d9       	ld.ub	r9,r8[0x5]
80005d26:	ba d9       	st.b	sp[0x5],r9
80005d28:	70 09       	ld.w	r9,r8[0x0]
80005d2a:	50 09       	stdsp	sp[0x0],r9
80005d2c:	11 c8       	ld.ub	r8,r8[0x4]
80005d2e:	18 97       	mov	r7,r12
80005d30:	16 95       	mov	r5,r11
80005d32:	ba c8       	st.b	sp[0x4],r8
80005d34:	fa cc ff f2 	sub	r12,sp,-14
	uint16_t rx_id;
	uint8_t  name[] = "AuxIn";
	uint8_t  i;
	uint8_t  version[3];

	CmdDecodeWord(&rx_id, &Rx_Ptr->Data[0]);
80005d38:	76 0b       	ld.w	r11,r11[0x0]
80005d3a:	e0 a0 6e e4 	rcall	80013b02 <CmdDecodeWord>

	Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
80005d3e:	6a 08       	ld.w	r8,r5[0x0]
80005d40:	11 89       	ld.ub	r9,r8[0x0]
80005d42:	6e 08       	ld.w	r8,r7[0x0]
80005d44:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
80005d46:	6a 08       	ld.w	r8,r5[0x0]
80005d48:	11 99       	ld.ub	r9,r8[0x1]
80005d4a:	6e 08       	ld.w	r8,r7[0x0]
80005d4c:	b0 99       	st.b	r8[0x1],r9
	Tx_Ptr->Length  = (u16_t)2;
80005d4e:	30 29       	mov	r9,2
80005d50:	ae 29       	st.h	r7[0x4],r9
*
****************************************************************************/
uint8_t Auxin_FBlockInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint16_t rx_id;
	uint8_t  name[] = "AuxIn";
80005d52:	1a 96       	mov	r6,sp
	Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
	Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
	Tx_Ptr->Length  = (u16_t)2;


	if (rx_id < 0x1000)                             /* FktID ?*/
80005d54:	9a 78       	ld.sh	r8,sp[0xe]
80005d56:	e0 6a 0f ff 	mov	r10,4095
80005d5a:	f4 08 19 00 	cp.h	r8,r10
80005d5e:	e0 8b 00 12 	brhi	80005d82 <Auxin_FBlockInfo_Get+0x66>
	{
		Tx_Ptr->Length  = (u16_t)3;
80005d62:	30 39       	mov	r9,3
80005d64:	ae 29       	st.h	r7[0x4],r9

		switch (rx_id)
80005d66:	f0 c8 01 00 	sub	r8,r8,256
80005d6a:	31 69       	mov	r9,22
80005d6c:	f2 08 19 00 	cp.h	r8,r9
80005d70:	e0 88 00 36 	brls	80005ddc <Auxin_FBlockInfo_Get+0xc0>
			Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
			break;


			default:
			Tx_Ptr->Data[2] = MAT_UNKNOWN;
80005d74:	6e 08       	ld.w	r8,r7[0x0]
80005d76:	30 09       	mov	r9,0
80005d78:	30 cc       	mov	r12,12
80005d7a:	b0 a9       	st.b	r8[0x2],r9
			break;
		}
	}

	return(OP_STATUS);
}
80005d7c:	2f cd       	sub	sp,-16
80005d7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			break;
		}
	}
	else
	{
		switch (rx_id)
80005d82:	fe 7a f0 03 	mov	r10,-4093
80005d86:	f4 08 19 00 	cp.h	r8,r10
80005d8a:	c4 90       	breq	80005e1c <Auxin_FBlockInfo_Get+0x100>
80005d8c:	e0 88 00 37 	brls	80005dfa <Auxin_FBlockInfo_Get+0xde>
80005d90:	fe 7a f0 05 	mov	r10,-4091
80005d94:	f4 08 19 00 	cp.h	r8,r10
80005d98:	c7 10       	breq	80005e7a <Auxin_FBlockInfo_Get+0x15e>
80005d9a:	c6 43       	brcs	80005e62 <Auxin_FBlockInfo_Get+0x146>
80005d9c:	fe 79 f0 06 	mov	r9,-4090
80005da0:	f2 08 19 00 	cp.h	r8,r9
80005da4:	c3 51       	brne	80005e0e <Auxin_FBlockInfo_Get+0xf2>
			Tx_Ptr->Data[6] = (u8_t)'C';
			Tx_Ptr->Length  = (u16_t)7;
			break;

			case FBI_FBLOCK_TYPE:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
80005da6:	30 19       	mov	r9,1
80005da8:	6e 08       	ld.w	r8,r7[0x0]
80005daa:	b0 a9       	st.b	r8[0x2],r9
			Tx_Ptr->Data[3] = (u8_t)'S';
80005dac:	35 39       	mov	r9,83
80005dae:	6e 08       	ld.w	r8,r7[0x0]
80005db0:	b0 b9       	st.b	r8[0x3],r9
			Tx_Ptr->Data[4] = (u8_t)'t';
80005db2:	37 49       	mov	r9,116
80005db4:	6e 08       	ld.w	r8,r7[0x0]
80005db6:	b0 c9       	st.b	r8[0x4],r9
			Tx_Ptr->Data[5] = (u8_t)'e';
80005db8:	6e 09       	ld.w	r9,r7[0x0]
80005dba:	36 58       	mov	r8,101
80005dbc:	b2 d8       	st.b	r9[0x5],r8
			Tx_Ptr->Data[6] = (u8_t)'r';
80005dbe:	6e 09       	ld.w	r9,r7[0x0]
80005dc0:	37 2a       	mov	r10,114
80005dc2:	b2 ea       	st.b	r9[0x6],r10
			Tx_Ptr->Data[7] = (u8_t)'e';
80005dc4:	6e 09       	ld.w	r9,r7[0x0]
80005dc6:	b2 f8       	st.b	r9[0x7],r8
			Tx_Ptr->Data[8] = (u8_t)'o';
80005dc8:	36 f9       	mov	r9,111
80005dca:	6e 08       	ld.w	r8,r7[0x0]
80005dcc:	f1 69 00 08 	st.b	r8[8],r9
			Tx_Ptr->Length  = (u16_t)9;
80005dd0:	30 98       	mov	r8,9
80005dd2:	30 cc       	mov	r12,12
80005dd4:	ae 28       	st.h	r7[0x4],r8
			break;
		}
	}

	return(OP_STATUS);
}
80005dd6:	2f cd       	sub	sp,-16
80005dd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

	if (rx_id < 0x1000)                             /* FktID ?*/
	{
		Tx_Ptr->Length  = (u16_t)3;

		switch (rx_id)
80005ddc:	30 19       	mov	r9,1
80005dde:	f2 08 09 48 	lsl	r8,r9,r8
80005de2:	e4 18 00 40 	andh	r8,0x40
80005de6:	e0 18 00 1f 	andl	r8,0x1f
80005dea:	cc 50       	breq	80005d74 <Auxin_FBlockInfo_Get+0x58>
			case FUNC_ALLOC:
			case FUNC_DEALLOC:
			case FUNC_SOURCEACT:
			case FUNC_SOURCENAME:
			case FUNC_SYNCDATAINFO:
			Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
80005dec:	6e 08       	ld.w	r8,r7[0x0]
80005dee:	31 29       	mov	r9,18
80005df0:	30 cc       	mov	r12,12
80005df2:	b0 a9       	st.b	r8[0x2],r9
			break;
		}
	}

	return(OP_STATUS);
}
80005df4:	2f cd       	sub	sp,-16
80005df6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			break;
		}
	}
	else
	{
		switch (rx_id)
80005dfa:	fe 79 f0 01 	mov	r9,-4095
80005dfe:	f2 08 19 00 	cp.h	r8,r9
80005e02:	c2 30       	breq	80005e48 <Auxin_FBlockInfo_Get+0x12c>
80005e04:	fe 79 f0 02 	mov	r9,-4094
80005e08:	f2 08 19 00 	cp.h	r8,r9
80005e0c:	c0 80       	breq	80005e1c <Auxin_FBlockInfo_Get+0x100>
			Tx_Ptr->Data[8] = (u8_t)'o';
			Tx_Ptr->Length  = (u16_t)9;
			break;

			default :
			return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 2));
80005e0e:	6a 0a       	ld.w	r10,r5[0x0]
80005e10:	0e 9c       	mov	r12,r7
80005e12:	30 29       	mov	r9,2
80005e14:	30 1b       	mov	r11,1
80005e16:	e0 a0 6e bd 	rcall	80013b90 <CmdErrorParamWrong>
80005e1a:	cb 1b       	rjmp	80005d7c <Auxin_FBlockInfo_Get+0x60>
			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_FBLOCK_VERSION:
			version[0] = AUXIN_VERSION_MAJOR;
			version[1] = AUXIN_VERSION_MINOR;
80005e1c:	30 09       	mov	r9,0

			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_FBLOCK_VERSION:
			version[0] = AUXIN_VERSION_MAJOR;
80005e1e:	30 18       	mov	r8,1
			version[1] = AUXIN_VERSION_MINOR;
			version[2] = AUXIN_VERSION_BUILD;
80005e20:	fb 69 00 0a 	st.b	sp[10],r9

			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_FBLOCK_VERSION:
			version[0] = AUXIN_VERSION_MAJOR;
80005e24:	fb 68 00 08 	st.b	sp[8],r8
			version[1] = AUXIN_VERSION_MINOR;
80005e28:	fb 69 00 09 	st.b	sp[9],r9
			version[2] = AUXIN_VERSION_BUILD;

			Tx_Ptr->Data[2] = FRMT_ISO8859;
80005e2c:	6e 09       	ld.w	r9,r7[0x0]
80005e2e:	b2 a8       	st.b	r9[0x2],r8
			version[1]  = GFB_VERSION_MINOR;
			version[2]  = GFB_VERSION_BUILD;

			Tx_Ptr->Data[2] = FRMT_ISO8859;

			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
80005e30:	6e 0b       	ld.w	r11,r7[0x0]
80005e32:	fa cc ff f8 	sub	r12,sp,-8
80005e36:	2f db       	sub	r11,-3
80005e38:	e0 a0 17 14 	rcall	80008c60 <MsgVersionToISO8859>

			Tx_Ptr->Length  = (word)((word)i + (word)3);
80005e3c:	2f dc       	sub	r12,-3
80005e3e:	ae 2c       	st.h	r7[0x4],r12
80005e40:	30 cc       	mov	r12,12
			break;
		}
	}

	return(OP_STATUS);
}
80005e42:	2f cd       	sub	sp,-16
80005e44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	else
	{
		switch (rx_id)
		{
			case FBI_FBLOCK_NAME:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
80005e48:	6e 08       	ld.w	r8,r7[0x0]
80005e4a:	30 19       	mov	r9,1
80005e4c:	b0 a9       	st.b	r8[0x2],r9
80005e4e:	30 08       	mov	r8,0
			for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
			{
				Tx_Ptr->Data[i+3] = (byte)name[i];
80005e50:	6e 09       	ld.w	r9,r7[0x0]
80005e52:	ec 08 07 0a 	ld.ub	r10,r6[r8]
80005e56:	10 09       	add	r9,r8
80005e58:	b2 ba       	st.b	r9[0x3],r10
80005e5a:	2f f8       	sub	r8,-1
	{
		switch (rx_id)
		{
			case FBI_FBLOCK_NAME:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
			for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
80005e5c:	58 68       	cp.w	r8,6
80005e5e:	cf 91       	brne	80005e50 <Auxin_FBlockInfo_Get+0x134>
80005e60:	cb 8b       	rjmp	80005dd0 <Auxin_FBlockInfo_Get+0xb4>

			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_MOST_VERSION:
			version[0]  = GFB_VERSION_MAJOR;
80005e62:	30 38       	mov	r8,3
			version[1]  = GFB_VERSION_MINOR;
			version[2]  = GFB_VERSION_BUILD;
80005e64:	fb 69 00 0a 	st.b	sp[10],r9

			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_MOST_VERSION:
			version[0]  = GFB_VERSION_MAJOR;
80005e68:	fb 68 00 08 	st.b	sp[8],r8
			version[1]  = GFB_VERSION_MINOR;
80005e6c:	30 08       	mov	r8,0
80005e6e:	fb 68 00 09 	st.b	sp[9],r8
			version[2]  = GFB_VERSION_BUILD;

			Tx_Ptr->Data[2] = FRMT_ISO8859;
80005e72:	30 19       	mov	r9,1
80005e74:	6e 08       	ld.w	r8,r7[0x0]
80005e76:	b0 a9       	st.b	r8[0x2],r9
80005e78:	cd cb       	rjmp	80005e30 <Auxin_FBlockInfo_Get+0x114>

			Tx_Ptr->Length  = (word)((word)i + (word)3);
			break;

			case FBI_SYSTEM_INTEGRATOR:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
80005e7a:	30 19       	mov	r9,1
80005e7c:	6e 08       	ld.w	r8,r7[0x0]
80005e7e:	b0 a9       	st.b	r8[0x2],r9
			Tx_Ptr->Data[3] = (u8_t)'S';
80005e80:	6e 09       	ld.w	r9,r7[0x0]
80005e82:	35 38       	mov	r8,83
80005e84:	b2 b8       	st.b	r9[0x3],r8
			Tx_Ptr->Data[4] = (u8_t)'M';
80005e86:	6e 09       	ld.w	r9,r7[0x0]
80005e88:	34 da       	mov	r10,77
80005e8a:	b2 ca       	st.b	r9[0x4],r10
			Tx_Ptr->Data[5] = (u8_t)'S';
80005e8c:	6e 09       	ld.w	r9,r7[0x0]
80005e8e:	b2 d8       	st.b	r9[0x5],r8
			Tx_Ptr->Data[6] = (u8_t)'C';
80005e90:	34 39       	mov	r9,67
80005e92:	6e 08       	ld.w	r8,r7[0x0]
80005e94:	b0 e9       	st.b	r8[0x6],r9
			Tx_Ptr->Length  = (u16_t)7;
80005e96:	30 cc       	mov	r12,12
80005e98:	30 78       	mov	r8,7
80005e9a:	ae 28       	st.h	r7[0x4],r8
			break;
80005e9c:	c7 0b       	rjmp	80005d7c <Auxin_FBlockInfo_Get+0x60>
80005e9e:	d7 03       	nop
80005ea0:	80 06       	ld.sh	r6,r0[0x0]
80005ea2:	9c e8       	ld.uh	r8,lr[0xc]

80005ea4 <Auxin_NotificationCheck_Get>:
80005ea4:	d4 01       	pushm	lr
80005ea6:	e0 a0 7d 45 	rcall	80015930 <NtfCheck>
80005eaa:	d8 02       	popm	pc

80005eac <Auxin_Notification_Get>:
80005eac:	d4 01       	pushm	lr
80005eae:	e0 a0 7e 89 	rcall	80015bc0 <NtfGetNotificationMatrix>
	#ifdef NTF_MIN
	return(NtfGetNotificationMatrix(Tx_Ptr,Rx_Ptr));
	#else
	return (OP_NO_REPORT);
	#endif
}
80005eb2:	d8 02       	popm	pc

80005eb4 <Auxin_Notification_Set>:
80005eb4:	d4 01       	pushm	lr
80005eb6:	e0 a0 7e f9 	rcall	80015ca8 <NtfSetNotificationMatrix>
	#ifdef NTF_MIN
	return(NtfSetNotificationMatrix(Tx_Ptr,Rx_Ptr));
	#else
	return (OP_NO_REPORT);
	#endif
}
80005eba:	d8 02       	popm	pc

80005ebc <Auxin_FuncIDs_Get>:
80005ebc:	d4 01       	pushm	lr
80005ebe:	48 3b       	lddpc	r11,80005ec8 <Auxin_FuncIDs_Get+0xc>
*  Return(s):      OP_Type
*
****************************************************************************/
uint8_t Auxin_FuncIDs_Get(struct Msg_Tx_Type *Tx_Ptr)
{
	CmdGetFunctionIds(Tx_Ptr, Func_Auxin);
80005ec0:	e0 a0 6f 16 	rcall	80013cec <CmdGetFunctionIds>
	return (OP_STATUS);
}
80005ec4:	30 cc       	mov	r12,12
80005ec6:	d8 02       	popm	pc
80005ec8:	80 06       	ld.sh	r6,r0[0x0]
80005eca:	9d 70       	st.w	lr[0x1c],r0

80005ecc <TOOL_GW_Outgoing>:
	return(OP_STATUS);
}


uint8_t TOOL_GW_Outgoing(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *RxPtr)
{
80005ecc:	eb cd 40 c0 	pushm	r6-r7,lr
	int16_t i;
	LOG_NOR("Received from Optical : \n");
80005ed0:	48 ec       	lddpc	r12,80005f08 <TOOL_GW_Outgoing+0x3c>
	return(OP_STATUS);
}


uint8_t TOOL_GW_Outgoing(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *RxPtr)
{
80005ed2:	16 96       	mov	r6,r11
	int16_t i;
	LOG_NOR("Received from Optical : \n");
80005ed4:	e0 a0 8e 9e 	rcall	80017c10 <puts>
	for(i=0; i<RxPtr->Length; i++) {
80005ed8:	8c 29       	ld.sh	r9,r6[0x4]
80005eda:	30 08       	mov	r8,0
80005edc:	f0 09 19 00 	cp.h	r9,r8
80005ee0:	c0 f0       	breq	80005efe <TOOL_GW_Outgoing+0x32>
80005ee2:	30 07       	mov	r7,0
		LOG_NOR("%02X ", RxPtr->Data[i]);
80005ee4:	6c 08       	ld.w	r8,r6[0x0]
80005ee6:	f0 07 07 08 	ld.ub	r8,r8[r7]
80005eea:	48 9c       	lddpc	r12,80005f0c <TOOL_GW_Outgoing+0x40>
80005eec:	1a d8       	st.w	--sp,r8

	return(OP_STATUS);
}


uint8_t TOOL_GW_Outgoing(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *RxPtr)
80005eee:	2f f7       	sub	r7,-1
{
	int16_t i;
	LOG_NOR("Received from Optical : \n");
	for(i=0; i<RxPtr->Length; i++) {
		LOG_NOR("%02X ", RxPtr->Data[i]);
80005ef0:	e0 a0 8d fa 	rcall	80017ae4 <printf>

uint8_t TOOL_GW_Outgoing(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *RxPtr)
{
	int16_t i;
	LOG_NOR("Received from Optical : \n");
	for(i=0; i<RxPtr->Length; i++) {
80005ef4:	8c a8       	ld.uh	r8,r6[0x4]
80005ef6:	2f fd       	sub	sp,-4
80005ef8:	0e 38       	cp.w	r8,r7
80005efa:	fe 99 ff f5 	brgt	80005ee4 <TOOL_GW_Outgoing+0x18>
		LOG_NOR("%02X ", RxPtr->Data[i]);
	}
	LOG_NOR("\n");
80005efe:	30 ac       	mov	r12,10
80005f00:	e0 a0 8e 0a 	rcall	80017b14 <putchar>
	
	return (OP_NO_REPORT);
}
80005f04:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80005f08:	80 06       	ld.sh	r6,r0[0x0]
80005f0a:	9e 48       	ld.sh	r8,pc[0x8]
80005f0c:	80 06       	ld.sh	r6,r0[0x0]
80005f0e:	9e 64       	ld.sh	r4,pc[0xc]

80005f10 <TOOL_FBlockInfo_Get>:
80005f10:	eb cd 40 e0 	pushm	r5-r7,lr
80005f14:	20 4d       	sub	sp,16
80005f16:	4d 98       	lddpc	r8,80006078 <TOOL_FBlockInfo_Get+0x168>
80005f18:	11 c9       	ld.ub	r9,r8[0x4]
80005f1a:	ba c9       	st.b	sp[0x4],r9
 *
 ****************************************************************************/
uint8_t TOOL_FBlockInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint16_t rx_id;
	uint8_t  name[] = "TOOL";
80005f1c:	70 08       	ld.w	r8,r8[0x0]
 *
 *  Return(s):       Status - depending on index passed in
 *
 ****************************************************************************/
uint8_t TOOL_FBlockInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
80005f1e:	18 97       	mov	r7,r12
80005f20:	16 96       	mov	r6,r11
	uint16_t rx_id;
	uint8_t  name[] = "TOOL";
80005f22:	50 08       	stdsp	sp[0x0],r8
	uint8_t  i;
	uint8_t  version[3];

	CmdDecodeWord(&rx_id, &Rx_Ptr->Data[0]);
80005f24:	fa cc ff f2 	sub	r12,sp,-14
80005f28:	76 0b       	ld.w	r11,r11[0x0]
80005f2a:	e0 a0 6d ec 	rcall	80013b02 <CmdDecodeWord>

	Tx_Ptr->Data[0] = Rx_Ptr->Data[0];	/* prepare TX message */
80005f2e:	6c 08       	ld.w	r8,r6[0x0]
80005f30:	11 89       	ld.ub	r9,r8[0x0]
80005f32:	6e 08       	ld.w	r8,r7[0x0]
80005f34:	b0 89       	st.b	r8[0x0],r9
	Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
80005f36:	6c 08       	ld.w	r8,r6[0x0]
80005f38:	11 99       	ld.ub	r9,r8[0x1]
80005f3a:	6e 08       	ld.w	r8,r7[0x0]
80005f3c:	b0 99       	st.b	r8[0x1],r9
	Tx_Ptr->Length  = (uint16_t)2;
80005f3e:	30 29       	mov	r9,2
80005f40:	ae 29       	st.h	r7[0x4],r9
 *
 ****************************************************************************/
uint8_t TOOL_FBlockInfo_Get(struct Msg_Tx_Type *Tx_Ptr, struct Msg_Rx_Type *Rx_Ptr)
{
	uint16_t rx_id;
	uint8_t  name[] = "TOOL";
80005f42:	1a 95       	mov	r5,sp
	Tx_Ptr->Data[0] = Rx_Ptr->Data[0];	/* prepare TX message */
	Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
	Tx_Ptr->Length  = (uint16_t)2;


	if (rx_id < 0x1000)					/* FktID ?*/
80005f44:	9a 78       	ld.sh	r8,sp[0xe]
80005f46:	e0 6a 0f ff 	mov	r10,4095
80005f4a:	f4 08 19 00 	cp.h	r8,r10
80005f4e:	e0 8b 00 0b 	brhi	80005f64 <TOOL_FBlockInfo_Get+0x54>
	{
		Tx_Ptr->Length  = (uint16_t)3;
80005f52:	30 38       	mov	r8,3
80005f54:	ae 28       	st.h	r7[0x4],r8

		switch (rx_id)
		{
			default:
				Tx_Ptr->Data[2] = MAT_UNKNOWN;
80005f56:	30 09       	mov	r9,0
80005f58:	6e 08       	ld.w	r8,r7[0x0]
80005f5a:	30 cc       	mov	r12,12
80005f5c:	b0 a9       	st.b	r8[0x2],r9
				break;
		}
	}

	return(OP_STATUS);
}
80005f5e:	2f cd       	sub	sp,-16
80005f60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
		}
	}
	else
	{
		switch (rx_id)
80005f64:	fe 7a f0 03 	mov	r10,-4093
80005f68:	f4 08 19 00 	cp.h	r8,r10
80005f6c:	c4 00       	breq	80005fec <TOOL_FBlockInfo_Get+0xdc>
80005f6e:	e0 8b 00 13 	brhi	80005f94 <TOOL_FBlockInfo_Get+0x84>
80005f72:	fe 79 f0 01 	mov	r9,-4095
80005f76:	f2 08 19 00 	cp.h	r8,r9
80005f7a:	c6 e0       	breq	80006056 <TOOL_FBlockInfo_Get+0x146>
80005f7c:	fe 79 f0 02 	mov	r9,-4094
80005f80:	f2 08 19 00 	cp.h	r8,r9
80005f84:	c3 40       	breq	80005fec <TOOL_FBlockInfo_Get+0xdc>
				Tx_Ptr->Data[10] = (uint8_t)'L';
				Tx_Ptr->Length  = (uint16_t)11;
				break;

			default :
				return(CmdErrorParamWrong(Tx_Ptr, 1, &Rx_Ptr->Data[0], 2));
80005f86:	6c 0a       	ld.w	r10,r6[0x0]
80005f88:	0e 9c       	mov	r12,r7
80005f8a:	30 29       	mov	r9,2
80005f8c:	30 1b       	mov	r11,1
80005f8e:	e0 a0 6e 01 	rcall	80013b90 <CmdErrorParamWrong>
80005f92:	ce 6b       	rjmp	80005f5e <TOOL_FBlockInfo_Get+0x4e>
				break;
		}
	}
	else
	{
		switch (rx_id)
80005f94:	fe 7a f0 05 	mov	r10,-4091
80005f98:	f4 08 19 00 	cp.h	r8,r10
80005f9c:	c4 a0       	breq	80006030 <TOOL_FBlockInfo_Get+0x120>
80005f9e:	c3 d3       	brcs	80006018 <TOOL_FBlockInfo_Get+0x108>
80005fa0:	fe 79 f0 06 	mov	r9,-4090
80005fa4:	f2 08 19 00 	cp.h	r8,r9
80005fa8:	ce f1       	brne	80005f86 <TOOL_FBlockInfo_Get+0x76>
				Tx_Ptr->Data[6] = (uint8_t)'I';
				Tx_Ptr->Length  = (uint16_t)7;
				break;

			case FBI_FBLOCK_TYPE:
				Tx_Ptr->Data[2] = FRMT_ISO8859;
80005faa:	30 19       	mov	r9,1
80005fac:	6e 08       	ld.w	r8,r7[0x0]
80005fae:	b0 a9       	st.b	r8[0x2],r9
				Tx_Ptr->Data[3] = (uint8_t)'G';
80005fb0:	34 79       	mov	r9,71
80005fb2:	6e 08       	ld.w	r8,r7[0x0]
80005fb4:	b0 b9       	st.b	r8[0x3],r9
				Tx_Ptr->Data[4] = (uint8_t)'W';
80005fb6:	35 79       	mov	r9,87
80005fb8:	6e 08       	ld.w	r8,r7[0x0]
80005fba:	b0 c9       	st.b	r8[0x4],r9
				Tx_Ptr->Data[5] = (uint8_t)'I';
80005fbc:	34 99       	mov	r9,73
80005fbe:	6e 08       	ld.w	r8,r7[0x0]
80005fc0:	b0 d9       	st.b	r8[0x5],r9
				Tx_Ptr->Data[6] = (uint8_t)'F';
80005fc2:	34 69       	mov	r9,70
80005fc4:	6e 08       	ld.w	r8,r7[0x0]
80005fc6:	b0 e9       	st.b	r8[0x6],r9
				Tx_Ptr->Data[7] = (uint8_t)'T';
80005fc8:	35 49       	mov	r9,84
80005fca:	6e 08       	ld.w	r8,r7[0x0]
80005fcc:	b0 f9       	st.b	r8[0x7],r9
				Tx_Ptr->Data[8] = (uint8_t)'O';
80005fce:	6e 09       	ld.w	r9,r7[0x0]
80005fd0:	34 f8       	mov	r8,79
80005fd2:	f3 68 00 08 	st.b	r9[8],r8
				Tx_Ptr->Data[9] = (uint8_t)'O';
80005fd6:	6e 09       	ld.w	r9,r7[0x0]
80005fd8:	f3 68 00 09 	st.b	r9[9],r8
				Tx_Ptr->Data[10] = (uint8_t)'L';
80005fdc:	34 c9       	mov	r9,76
80005fde:	6e 08       	ld.w	r8,r7[0x0]
80005fe0:	f1 69 00 0a 	st.b	r8[10],r9
				Tx_Ptr->Length  = (uint16_t)11;
80005fe4:	30 cc       	mov	r12,12
80005fe6:	30 b8       	mov	r8,11
80005fe8:	ae 28       	st.h	r7[0x4],r8
				break;
80005fea:	cb ab       	rjmp	80005f5e <TOOL_FBlockInfo_Get+0x4e>
				Tx_Ptr->Length  = (word)((word)i + (word)3);
				break;

			case FBI_FBLOCK_VERSION:
				version[0] = TOOL_VERSION_MAJOR;
				version[1] = TOOL_VERSION_MINOR;
80005fec:	30 09       	mov	r9,0

				Tx_Ptr->Length  = (word)((word)i + (word)3);
				break;

			case FBI_FBLOCK_VERSION:
				version[0] = TOOL_VERSION_MAJOR;
80005fee:	30 18       	mov	r8,1
				version[1] = TOOL_VERSION_MINOR;
				version[2] = TOOL_VERSION_BUILD;
80005ff0:	fb 69 00 0a 	st.b	sp[10],r9

				Tx_Ptr->Length  = (word)((word)i + (word)3);
				break;

			case FBI_FBLOCK_VERSION:
				version[0] = TOOL_VERSION_MAJOR;
80005ff4:	fb 68 00 08 	st.b	sp[8],r8
				version[1] = TOOL_VERSION_MINOR;
80005ff8:	fb 69 00 09 	st.b	sp[9],r9
				version[2] = TOOL_VERSION_BUILD;

				Tx_Ptr->Data[2] = FRMT_ISO8859;
80005ffc:	6e 09       	ld.w	r9,r7[0x0]
80005ffe:	b2 a8       	st.b	r9[0x2],r8
				version[1]  = GFB_VERSION_MINOR;
				version[2]  = GFB_VERSION_BUILD;

				Tx_Ptr->Data[2] = FRMT_ISO8859;

				i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
80006000:	6e 0b       	ld.w	r11,r7[0x0]
80006002:	fa cc ff f8 	sub	r12,sp,-8
80006006:	2f db       	sub	r11,-3
80006008:	e0 a0 16 2c 	rcall	80008c60 <MsgVersionToISO8859>

				Tx_Ptr->Length  = (word)((word)i + (word)3);
8000600c:	2f dc       	sub	r12,-3
8000600e:	ae 2c       	st.h	r7[0x4],r12
80006010:	30 cc       	mov	r12,12
				break;
		}
	}

	return(OP_STATUS);
}
80006012:	2f cd       	sub	sp,-16
80006014:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

				Tx_Ptr->Length  = (word)((word)i + (word)3);
				break;

			case FBI_MOST_VERSION:
				version[0]  = GFB_VERSION_MAJOR;
80006018:	30 38       	mov	r8,3
				version[1]  = GFB_VERSION_MINOR;
				version[2]  = GFB_VERSION_BUILD;
8000601a:	fb 69 00 0a 	st.b	sp[10],r9

				Tx_Ptr->Length  = (word)((word)i + (word)3);
				break;

			case FBI_MOST_VERSION:
				version[0]  = GFB_VERSION_MAJOR;
8000601e:	fb 68 00 08 	st.b	sp[8],r8
				version[1]  = GFB_VERSION_MINOR;
80006022:	30 08       	mov	r8,0
80006024:	fb 68 00 09 	st.b	sp[9],r8
				version[2]  = GFB_VERSION_BUILD;

				Tx_Ptr->Data[2] = FRMT_ISO8859;
80006028:	30 19       	mov	r9,1
8000602a:	6e 08       	ld.w	r8,r7[0x0]
8000602c:	b0 a9       	st.b	r8[0x2],r9
8000602e:	ce 9b       	rjmp	80006000 <TOOL_FBlockInfo_Get+0xf0>

				Tx_Ptr->Length  = (word)((word)i + (word)3);
				break;

			case FBI_SYSTEM_INTEGRATOR:
				Tx_Ptr->Data[2] = FRMT_ISO8859;
80006030:	6e 08       	ld.w	r8,r7[0x0]
80006032:	30 19       	mov	r9,1
80006034:	b0 a9       	st.b	r8[0x2],r9
				Tx_Ptr->Data[3] = (uint8_t)'K';
80006036:	34 b9       	mov	r9,75
80006038:	6e 08       	ld.w	r8,r7[0x0]
8000603a:	b0 b9       	st.b	r8[0x3],r9
				Tx_Ptr->Data[4] = (uint8_t)'E';
8000603c:	34 59       	mov	r9,69
8000603e:	6e 08       	ld.w	r8,r7[0x0]
80006040:	b0 c9       	st.b	r8[0x4],r9
				Tx_Ptr->Data[5] = (uint8_t)'T';
80006042:	35 49       	mov	r9,84
80006044:	6e 08       	ld.w	r8,r7[0x0]
80006046:	b0 d9       	st.b	r8[0x5],r9
				Tx_Ptr->Data[6] = (uint8_t)'I';
80006048:	34 99       	mov	r9,73
8000604a:	6e 08       	ld.w	r8,r7[0x0]
8000604c:	b0 e9       	st.b	r8[0x6],r9
				Tx_Ptr->Length  = (uint16_t)7;
8000604e:	30 cc       	mov	r12,12
80006050:	30 78       	mov	r8,7
80006052:	ae 28       	st.h	r7[0x4],r8
				break;
80006054:	c8 5b       	rjmp	80005f5e <TOOL_FBlockInfo_Get+0x4e>
	else
	{
		switch (rx_id)
		{
			case FBI_FBLOCK_NAME:
				Tx_Ptr->Data[2] = FRMT_ISO8859;
80006056:	6e 08       	ld.w	r8,r7[0x0]
80006058:	30 19       	mov	r9,1
8000605a:	b0 a9       	st.b	r8[0x2],r9
8000605c:	30 08       	mov	r8,0
				for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
				{
					Tx_Ptr->Data[i+3] = (byte)name[i];
8000605e:	6e 09       	ld.w	r9,r7[0x0]
80006060:	ea 08 07 0a 	ld.ub	r10,r5[r8]
80006064:	10 09       	add	r9,r8
80006066:	b2 ba       	st.b	r9[0x3],r10
80006068:	2f f8       	sub	r8,-1
	{
		switch (rx_id)
		{
			case FBI_FBLOCK_NAME:
				Tx_Ptr->Data[2] = FRMT_ISO8859;
				for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
8000606a:	58 58       	cp.w	r8,5
8000606c:	cf 91       	brne	8000605e <TOOL_FBlockInfo_Get+0x14e>
				{
					Tx_Ptr->Data[i+3] = (byte)name[i];
				}
				Tx_Ptr->Length = (word)i + (word)3;
8000606e:	30 88       	mov	r8,8
80006070:	30 cc       	mov	r12,12
80006072:	ae 28       	st.h	r7[0x4],r8
				break;
80006074:	c7 5b       	rjmp	80005f5e <TOOL_FBlockInfo_Get+0x4e>
80006076:	d7 03       	nop
80006078:	80 06       	ld.sh	r6,r0[0x0]
8000607a:	9e 6c       	ld.sh	r12,pc[0xc]

8000607c <TOOL_FuncIDs_Get>:
8000607c:	d4 01       	pushm	lr
8000607e:	48 3b       	lddpc	r11,80006088 <TOOL_FuncIDs_Get+0xc>
80006080:	e0 a0 6e 36 	rcall	80013cec <CmdGetFunctionIds>
80006084:	30 cc       	mov	r12,12
80006086:	d8 02       	popm	pc
 ****************************************************************************/
uint8_t TOOL_FuncIDs_Get(struct Msg_Tx_Type *Tx_Ptr)
{
	CmdGetFunctionIds(Tx_Ptr, Func_TOOL);
	return (OP_STATUS);
}
80006088:	80 06       	ld.sh	r6,r0[0x0]
8000608a:	9e 08       	ld.sh	r8,pc[0x0]

8000608c <gui_draw_background>:
		}
	}
} 

static void gui_draw_background(uint16_t x, uint16_t y, uint16_t width, uint16_t height, char bg_flag)
{
8000608c:	d4 01       	pushm	lr
	if (version_flag != 2)	{
8000608e:	49 58       	lddpc	r8,800060e0 <gui_draw_background+0x54>
80006090:	11 8e       	ld.ub	lr,r8[0x0]
80006092:	30 28       	mov	r8,2
80006094:	f0 0e 18 00 	cp.b	lr,r8
80006098:	c1 20       	breq	800060bc <gui_draw_background+0x30>
		et024006_PutPixmap(background_image, ET024006_WIDTH, x, y, x, y, width, height);
8000609a:	5c 7b       	castu.h	r11
8000609c:	5c 79       	castu.h	r9
8000609e:	5c 7a       	castu.h	r10
800060a0:	1a d9       	st.w	--sp,r9
800060a2:	f1 dc c0 10 	bfextu	r8,r12,0x0,0x10
800060a6:	1a da       	st.w	--sp,r10
800060a8:	16 99       	mov	r9,r11
800060aa:	1a db       	st.w	--sp,r11
800060ac:	10 9a       	mov	r10,r8
800060ae:	e0 6b 01 40 	mov	r11,320
800060b2:	48 dc       	lddpc	r12,800060e4 <gui_draw_background+0x58>
800060b4:	fe b0 e1 e2 	rcall	80002478 <et024006_PutPixmap>
800060b8:	2f dd       	sub	sp,-12
800060ba:	d8 02       	popm	pc
	}
	else
	{
		et024006_PutPixmap(background_image2, ET024006_WIDTH, x, y, x, y, width, height);
800060bc:	5c 7b       	castu.h	r11
800060be:	5c 79       	castu.h	r9
800060c0:	5c 7a       	castu.h	r10
800060c2:	1a d9       	st.w	--sp,r9
800060c4:	f1 dc c0 10 	bfextu	r8,r12,0x0,0x10
800060c8:	1a da       	st.w	--sp,r10
800060ca:	16 99       	mov	r9,r11
800060cc:	1a db       	st.w	--sp,r11
800060ce:	10 9a       	mov	r10,r8
800060d0:	e0 6b 01 40 	mov	r11,320
800060d4:	48 5c       	lddpc	r12,800060e8 <gui_draw_background+0x5c>
800060d6:	fe b0 e1 d1 	rcall	80002478 <et024006_PutPixmap>
800060da:	2f dd       	sub	sp,-12
800060dc:	d8 02       	popm	pc
800060de:	d7 03       	nop
800060e0:	00 00       	add	r0,r0
800060e2:	3c 90       	mov	r0,-55
800060e4:	80 01       	ld.sh	r1,r0[0x0]
800060e6:	d7 b8       	*unknown*
800060e8:	80 04       	ld.sh	r4,r0[0x0]
800060ea:	2f b8       	sub	r8,-5

800060ec <gui_set_selection>:
800060ec:	d4 21       	pushm	r4-r7,lr
800060ee:	4f 14       	lddpc	r4,800062b0 <gui_set_selection+0x1c4>
		}
	}		
}

void gui_set_selection(int32_t box_id)
{
800060f0:	18 96       	mov	r6,r12
static int32_t prev_selection = GUI_NO_SEL;
struct gui_box *sb;
uint32_t i;

  // Clear previous selections
	if (prev_selection != GUI_NO_SEL && prev_selection != box_id) {
800060f2:	68 07       	ld.w	r7,r4[0x0]
800060f4:	5b f7       	cp.w	r7,-1
800060f6:	e0 80 00 a7 	breq	80006244 <gui_set_selection+0x158>
800060fa:	18 37       	cp.w	r7,r12
800060fc:	e0 80 00 a4 	breq	80006244 <gui_set_selection+0x158>
    
	i = prev_selection;
	if (version_flag == 2 && i >= 2)			
80006100:	58 17       	cp.w	r7,1
80006102:	f9 b8 0b 01 	movhi	r8,1
80006106:	f9 b8 08 00 	movls	r8,0
8000610a:	4e b5       	lddpc	r5,800062b4 <gui_set_selection+0x1c8>
8000610c:	30 29       	mov	r9,2
8000610e:	0b 8a       	ld.ub	r10,r5[0x0]
80006110:	f2 0a 18 00 	cp.b	r10,r9
80006114:	5f 09       	sreq	r9
80006116:	f3 e8 00 08 	and	r8,r9,r8
		i +=2;
8000611a:	f7 b7 01 fe 	subne	r7,-2
				
    sb = (struct gui_box *) &box[i];
8000611e:	4e 78       	lddpc	r8,800062b8 <gui_set_selection+0x1cc>
80006120:	ee 07 00 17 	add	r7,r7,r7<<0x1
					
    // Don't do anything if the color is transparent
		if (sb->bg_color == GUI_NO_COLOR) {
80006124:	3f f9       	mov	r9,-1
    
	i = prev_selection;
	if (version_flag == 2 && i >= 2)			
		i +=2;
				
    sb = (struct gui_box *) &box[i];
80006126:	f0 07 00 27 	add	r7,r8,r7<<0x2
					
    // Don't do anything if the color is transparent
		if (sb->bg_color == GUI_NO_COLOR) {
8000612a:	8e 58       	ld.sh	r8,r7[0xa]
8000612c:	f2 08 19 00 	cp.h	r8,r9
80006130:	e0 80 00 8c 	breq	80006248 <gui_set_selection+0x15c>
					0);
						
		}
		else {

			et024006_DrawFilledRect(sb->x - 2,
80006134:	5c 78       	castu.h	r8
80006136:	8e 2a       	ld.sh	r10,r7[0x4]
80006138:	8e 1b       	ld.sh	r11,r7[0x2]
8000613a:	8e 0c       	ld.sh	r12,r7[0x0]
8000613c:	30 29       	mov	r9,2
8000613e:	2f ca       	sub	r10,-4
80006140:	20 2b       	sub	r11,2
80006142:	5c 7a       	castu.h	r10
80006144:	5c 7b       	castu.h	r11
80006146:	20 2c       	sub	r12,2
80006148:	5c 7c       	castu.h	r12
8000614a:	fe b0 e1 61 	rcall	8000240c <et024006_DrawFilledRect>
				sb->y - 2,
				sb->width + 4,
				2,
				sb->bg_color);
			et024006_DrawFilledRect(sb->x - 2,
8000614e:	8e 19       	ld.sh	r9,r7[0x2]
80006150:	8e d8       	ld.uh	r8,r7[0xa]
80006152:	8e 2a       	ld.sh	r10,r7[0x4]
80006154:	8e 3b       	ld.sh	r11,r7[0x6]
80006156:	8e 0c       	ld.sh	r12,r7[0x0]
80006158:	12 0b       	add	r11,r9
8000615a:	2f ca       	sub	r10,-4
8000615c:	5c 7b       	castu.h	r11
8000615e:	5c 7a       	castu.h	r10
80006160:	30 29       	mov	r9,2
80006162:	20 2c       	sub	r12,2
80006164:	5c 7c       	castu.h	r12
80006166:	fe b0 e1 53 	rcall	8000240c <et024006_DrawFilledRect>
				sb->y + sb->height,
				sb->width + 4,
				2,
				sb->bg_color);
			et024006_DrawFilledRect(sb->x - 2,
8000616a:	8e d8       	ld.uh	r8,r7[0xa]
8000616c:	8e 39       	ld.sh	r9,r7[0x6]
8000616e:	8e 1b       	ld.sh	r11,r7[0x2]
80006170:	8e 0c       	ld.sh	r12,r7[0x0]
80006172:	30 2a       	mov	r10,2
80006174:	2f c9       	sub	r9,-4
80006176:	20 2b       	sub	r11,2
80006178:	5c 79       	castu.h	r9
8000617a:	5c 7b       	castu.h	r11
8000617c:	20 2c       	sub	r12,2
8000617e:	5c 7c       	castu.h	r12
80006180:	fe b0 e1 46 	rcall	8000240c <et024006_DrawFilledRect>
				sb->y - 2,
				2,sb->height + 4,
				sb->bg_color);
			et024006_DrawFilledRect(sb->x + sb->width,
80006184:	8e 0a       	ld.sh	r10,r7[0x0]
80006186:	8e 39       	ld.sh	r9,r7[0x6]
80006188:	8e 1b       	ld.sh	r11,r7[0x2]
8000618a:	2f c9       	sub	r9,-4
8000618c:	20 2b       	sub	r11,2
8000618e:	8e 2c       	ld.sh	r12,r7[0x4]
80006190:	8e d8       	ld.uh	r8,r7[0xa]
80006192:	14 0c       	add	r12,r10
80006194:	5c 79       	castu.h	r9
80006196:	5c 7b       	castu.h	r11
80006198:	5c 7c       	castu.h	r12
8000619a:	30 2a       	mov	r10,2
8000619c:	fe b0 e1 38 	rcall	8000240c <et024006_DrawFilledRect>

					
		}
  }

  prev_selection = box_id;
800061a0:	89 06       	st.w	r4[0x0],r6
  	if (version_flag == 2 && box_id >= 2)
800061a2:	58 16       	cp.w	r6,1
800061a4:	f9 b8 09 01 	movgt	r8,1
800061a8:	f9 b8 0a 00 	movle	r8,0
800061ac:	0b 8a       	ld.ub	r10,r5[0x0]
800061ae:	30 29       	mov	r9,2
800061b0:	f2 0a 18 00 	cp.b	r10,r9
800061b4:	5f 09       	sreq	r9
800061b6:	f3 e8 00 08 	and	r8,r9,r8
  	box_id+=2;
800061ba:	f7 b6 01 fe 	subne	r6,-2
	if (box_id != GUI_NO_COLOR) {
800061be:	e0 46 ff ff 	cp.w	r6,65535
800061c2:	c4 00       	breq	80006242 <gui_set_selection+0x156>
  // Draw the selection
  sb = (struct gui_box *) &box[box_id];
800061c4:	4b da       	lddpc	r10,800062b8 <gui_set_selection+0x1cc>

		et024006_DrawFilledRect( sb->x - 2,
800061c6:	e0 68 aa 3f 	mov	r8,43583
800061ca:	30 29       	mov	r9,2
  prev_selection = box_id;
  	if (version_flag == 2 && box_id >= 2)
  	box_id+=2;
	if (box_id != GUI_NO_COLOR) {
  // Draw the selection
  sb = (struct gui_box *) &box[box_id];
800061cc:	ec 06 00 16 	add	r6,r6,r6<<0x1
800061d0:	f4 06 00 26 	add	r6,r10,r6<<0x2

		et024006_DrawFilledRect( sb->x - 2,
800061d4:	8c 2a       	ld.sh	r10,r6[0x4]
800061d6:	8c 1b       	ld.sh	r11,r6[0x2]
800061d8:	8c 0c       	ld.sh	r12,r6[0x0]
800061da:	2f ca       	sub	r10,-4
800061dc:	20 2b       	sub	r11,2
800061de:	5c 7a       	castu.h	r10
800061e0:	5c 7b       	castu.h	r11
800061e2:	20 2c       	sub	r12,2
800061e4:	5c 7c       	castu.h	r12
800061e6:	fe b0 e1 13 	rcall	8000240c <et024006_DrawFilledRect>
		sb->y - 2,
		sb->width + 4,
		2,
		GUI_SELECTION_COLOR);
		et024006_DrawFilledRect(sb->x - 2,
800061ea:	8c 19       	ld.sh	r9,r6[0x2]
800061ec:	e0 68 aa 3f 	mov	r8,43583
800061f0:	8c 2a       	ld.sh	r10,r6[0x4]
800061f2:	8c 3b       	ld.sh	r11,r6[0x6]
800061f4:	8c 0c       	ld.sh	r12,r6[0x0]
800061f6:	12 0b       	add	r11,r9
800061f8:	2f ca       	sub	r10,-4
800061fa:	5c 7b       	castu.h	r11
800061fc:	5c 7a       	castu.h	r10
800061fe:	30 29       	mov	r9,2
80006200:	20 2c       	sub	r12,2
80006202:	5c 7c       	castu.h	r12
80006204:	fe b0 e1 04 	rcall	8000240c <et024006_DrawFilledRect>
		sb->y + sb->height,
		sb->width + 4,
		2,
		GUI_SELECTION_COLOR);
		et024006_DrawFilledRect(sb->x - 2,
80006208:	e0 68 aa 3f 	mov	r8,43583
8000620c:	8c 39       	ld.sh	r9,r6[0x6]
8000620e:	8c 1b       	ld.sh	r11,r6[0x2]
80006210:	8c 0c       	ld.sh	r12,r6[0x0]
80006212:	30 2a       	mov	r10,2
80006214:	2f c9       	sub	r9,-4
80006216:	20 2b       	sub	r11,2
80006218:	5c 79       	castu.h	r9
8000621a:	5c 7b       	castu.h	r11
8000621c:	20 2c       	sub	r12,2
8000621e:	5c 7c       	castu.h	r12
80006220:	fe b0 e0 f6 	rcall	8000240c <et024006_DrawFilledRect>
		sb->y - 2,
		2,
		sb->height + 4,
		GUI_SELECTION_COLOR);
		et024006_DrawFilledRect(sb->x + sb->width,
80006224:	8c 08       	ld.sh	r8,r6[0x0]
80006226:	8c 39       	ld.sh	r9,r6[0x6]
80006228:	8c 1b       	ld.sh	r11,r6[0x2]
8000622a:	2f c9       	sub	r9,-4
8000622c:	20 2b       	sub	r11,2
8000622e:	8c 2c       	ld.sh	r12,r6[0x4]
80006230:	5c 79       	castu.h	r9
80006232:	10 0c       	add	r12,r8
80006234:	5c 7b       	castu.h	r11
80006236:	5c 7c       	castu.h	r12
80006238:	e0 68 aa 3f 	mov	r8,43583
8000623c:	30 2a       	mov	r10,2
8000623e:	fe b0 e0 e7 	rcall	8000240c <et024006_DrawFilledRect>
80006242:	d8 22       	popm	r4-r7,pc
80006244:	49 c5       	lddpc	r5,800062b4 <gui_set_selection+0x1c8>
80006246:	ca db       	rjmp	800061a0 <gui_set_selection+0xb4>
    sb = (struct gui_box *) &box[i];
					
    // Don't do anything if the color is transparent
		if (sb->bg_color == GUI_NO_COLOR) {

				gui_draw_background(sb->x - 2,
80006248:	8e 2a       	ld.sh	r10,r7[0x4]
8000624a:	8e 1b       	ld.sh	r11,r7[0x2]
8000624c:	8e 0c       	ld.sh	r12,r7[0x0]
8000624e:	30 08       	mov	r8,0
80006250:	30 29       	mov	r9,2
80006252:	2f ca       	sub	r10,-4
80006254:	20 2b       	sub	r11,2
80006256:	5c 7a       	castu.h	r10
80006258:	5c 7b       	castu.h	r11
8000625a:	20 2c       	sub	r12,2
8000625c:	5c 7c       	castu.h	r12
8000625e:	c1 7f       	rcall	8000608c <gui_draw_background>
80006260:	8e 19       	ld.sh	r9,r7[0x2]
					sb->y - 2,
					sb->width + 4,
					2,
					0);
				gui_draw_background(sb->x - 2,
80006262:	8e 2a       	ld.sh	r10,r7[0x4]
80006264:	8e 3b       	ld.sh	r11,r7[0x6]
80006266:	8e 0c       	ld.sh	r12,r7[0x0]
80006268:	30 08       	mov	r8,0
8000626a:	12 0b       	add	r11,r9
8000626c:	2f ca       	sub	r10,-4
8000626e:	5c 7b       	castu.h	r11
80006270:	5c 7a       	castu.h	r10
80006272:	30 29       	mov	r9,2
80006274:	20 2c       	sub	r12,2
80006276:	5c 7c       	castu.h	r12
80006278:	c0 af       	rcall	8000608c <gui_draw_background>
8000627a:	8e 39       	ld.sh	r9,r7[0x6]
8000627c:	8e 1b       	ld.sh	r11,r7[0x2]
					sb->y + sb->height,
					sb->width + 4,
					2,
					0);
				gui_draw_background(sb->x - 2,
8000627e:	8e 0c       	ld.sh	r12,r7[0x0]
80006280:	30 08       	mov	r8,0
80006282:	30 2a       	mov	r10,2
80006284:	2f c9       	sub	r9,-4
80006286:	20 2b       	sub	r11,2
80006288:	5c 79       	castu.h	r9
8000628a:	5c 7b       	castu.h	r11
8000628c:	20 2c       	sub	r12,2
8000628e:	5c 7c       	castu.h	r12
80006290:	cf ee       	rcall	8000608c <gui_draw_background>
80006292:	8e 08       	ld.sh	r8,r7[0x0]
80006294:	8e 39       	ld.sh	r9,r7[0x6]
80006296:	8e 1b       	ld.sh	r11,r7[0x2]
					sb->y - 2,
					2,
					sb->height + 4,
					0);
				gui_draw_background(sb->x + sb->width,
80006298:	8e 2c       	ld.sh	r12,r7[0x4]
8000629a:	2f c9       	sub	r9,-4
8000629c:	10 0c       	add	r12,r8
8000629e:	5c 79       	castu.h	r9
800062a0:	20 2b       	sub	r11,2
800062a2:	5c 7c       	castu.h	r12
800062a4:	5c 7b       	castu.h	r11
800062a6:	30 08       	mov	r8,0
800062a8:	30 2a       	mov	r10,2
800062aa:	cf 1e       	rcall	8000608c <gui_draw_background>
800062ac:	c7 ab       	rjmp	800061a0 <gui_set_selection+0xb4>
800062ae:	d7 03       	nop
800062b0:	00 00       	add	r0,r0
800062b2:	00 9c       	mov	r12,r0
800062b4:	00 00       	add	r0,r0
800062b6:	3c 90       	mov	r0,-55
800062b8:	80 06       	ld.sh	r6,r0[0x0]
800062ba:	9e 72       	ld.sh	r2,pc[0xe]

800062bc <gui_clear_view>:
800062bc:	d4 01       	pushm	lr
800062be:	48 d8       	lddpc	r8,800062f0 <gui_clear_view+0x34>
800062c0:	11 89       	ld.ub	r9,r8[0x0]
800062c2:	30 28       	mov	r8,2
800062c4:	f0 09 18 00 	cp.b	r9,r8
800062c8:	c0 a0       	breq	800062dc <gui_clear_view+0x20>
800062ca:	30 08       	mov	r8,0
}

void gui_clear_view(void)
{
	if ( version_flag != 2)	{
		gui_draw_background(0, 0, ET024006_WIDTH, ET024006_HEIGHT, 0);
800062cc:	e0 69 00 f0 	mov	r9,240
800062d0:	e0 6a 01 40 	mov	r10,320
800062d4:	10 9b       	mov	r11,r8
800062d6:	10 9c       	mov	r12,r8
800062d8:	cd ae       	rcall	8000608c <gui_draw_background>
800062da:	d8 02       	popm	pc
800062dc:	30 0b       	mov	r11,0
	}		
	
	
	else
	{
		gui_draw_background(0, 0, ET024006_WIDTH, ET024006_HEIGHT, 1);
800062de:	30 18       	mov	r8,1
800062e0:	e0 69 00 f0 	mov	r9,240
800062e4:	e0 6a 01 40 	mov	r10,320
800062e8:	16 9c       	mov	r12,r11
800062ea:	cd 1e       	rcall	8000608c <gui_draw_background>
800062ec:	d8 02       	popm	pc
800062ee:	d7 03       	nop
800062f0:	00 00       	add	r0,r0
800062f2:	3c 90       	mov	r0,-55

800062f4 <gui_change_update_fs>:
800062f4:	eb cd 40 80 	pushm	r7,lr
800062f8:	48 e8       	lddpc	r8,80006330 <gui_change_update_fs+0x3c>
800062fa:	70 0b       	ld.w	r11,r8[0x0]
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800062fc:	e0 68 03 e7 	mov	r8,999
80006300:	f8 0b 06 4a 	mulu.d	r10,r12,r11
80006304:	30 09       	mov	r9,0
80006306:	10 0a       	add	r10,r8
80006308:	f6 09 00 4b 	adc	r11,r11,r9
8000630c:	e0 68 03 e8 	mov	r8,1000
extern dsp16_t signal_out_fft[BUFFER_LENGTH];

extern bool signals_are_updated;
void gui_change_update_fs(uint32_t time_ms)
{
	gui_fs.time_ms = time_ms;
80006310:	48 97       	lddpc	r7,80006334 <gui_change_update_fs+0x40>
80006312:	30 09       	mov	r9,0
80006314:	8f 3c       	st.w	r7[0xc],r12
80006316:	e0 a0 82 3b 	rcall	8001678c <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000631a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000631e:	f0 0a 00 0a 	add	r10,r8,r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006322:	8f 08       	st.w	r7[0x0],r8
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006324:	8f 1a       	st.w	r7[0x4],r10
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80006326:	30 08       	mov	r8,0
80006328:	ef 68 00 08 	st.b	r7[8],r8
	cpu_set_timeout(cpu_ms_2_cy(gui_fs.time_ms, gui_cpu_hz), &gui_fs.cpu_time);
}
8000632c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006330:	00 00       	add	r0,r0
80006332:	2b 9c       	sub	r12,-71
80006334:	00 00       	add	r0,r0
80006336:	2b a4       	sub	r4,-70

80006338 <gui_print_signal_box>:
80006338:	eb cd 40 f8 	pushm	r3-r7,lr
	}
}


static void gui_print_signal_box(int32_t box_id, dsp16_t *signal, uint16_t signal_size)
{
8000633c:	fa cd 04 00 	sub	sp,sp,1024
	extern volatile bool zoom_view;
	extern volatile int32_t zoom_view_id;
	static bool can_tx_flag = false;
	char textPrint [256][4] = {{0, }, };
		
	if (version_flag == 2 && box_id >= 2)
80006340:	fe f6 03 54 	ld.w	r6,pc[852]
80006344:	58 1c       	cp.w	r12,1
80006346:	f9 b8 09 01 	movgt	r8,1
8000634a:	f9 b8 0a 00 	movle	r8,0
8000634e:	0d 8a       	ld.ub	r10,r6[0x0]
80006350:	30 29       	mov	r9,2
80006352:	f2 0a 18 00 	cp.b	r10,r9
80006356:	5f 09       	sreq	r9
80006358:	f3 e8 00 08 	and	r8,r9,r8
}


static void gui_print_signal_box(int32_t box_id, dsp16_t *signal, uint16_t signal_size)
{
	const struct gui_box *sb = &box[box_id];
8000635c:	f8 0c 00 14 	add	r4,r12,r12<<0x1
80006360:	a3 64       	lsl	r4,0x2
	extern volatile int32_t zoom_view_id;
	static bool can_tx_flag = false;
	char textPrint [256][4] = {{0, }, };
		
	if (version_flag == 2 && box_id >= 2)
		sb = &box[box_id + 2];
80006362:	58 08       	cp.w	r8,0
80006364:	f7 b4 01 e8 	subne	r4,-24
80006368:	fe f8 03 30 	ld.w	r8,pc[816]

	if (zoom_view && zoom_view_id != box_id)
8000636c:	fe f3 03 30 	ld.w	r3,pc[816]
	extern volatile int32_t zoom_view_id;
	static bool can_tx_flag = false;
	char textPrint [256][4] = {{0, }, };
		
	if (version_flag == 2 && box_id >= 2)
		sb = &box[box_id + 2];
80006370:	f0 04 00 04 	add	r4,r8,r4
	}
}


static void gui_print_signal_box(int32_t box_id, dsp16_t *signal, uint16_t signal_size)
{
80006374:	18 97       	mov	r7,r12
	char textPrint [256][4] = {{0, }, };
		
	if (version_flag == 2 && box_id >= 2)
		sb = &box[box_id + 2];

	if (zoom_view && zoom_view_id != box_id)
80006376:	07 88       	ld.ub	r8,r3[0x0]
80006378:	58 08       	cp.w	r8,0
8000637a:	c0 a0       	breq	8000638e <gui_print_signal_box+0x56>
8000637c:	fe f8 03 24 	ld.w	r8,pc[804]
80006380:	70 08       	ld.w	r8,r8[0x0]
80006382:	18 38       	cp.w	r8,r12
80006384:	c0 50       	breq	8000638e <gui_print_signal_box+0x56>
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT3_X2, GUI_OUTPUT3_Y, BLUE, YELLOW);
					break;
			}
		}
	}
} 
80006386:	fe 3d fc 00 	sub	sp,-1024
8000638a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
{
	const struct gui_box *sb = &box[box_id];
	extern volatile bool zoom_view;
	extern volatile int32_t zoom_view_id;
	static bool can_tx_flag = false;
	char textPrint [256][4] = {{0, }, };
8000638e:	e0 6a 04 00 	mov	r10,1024
80006392:	30 0b       	mov	r11,0
80006394:	1a 9c       	mov	r12,sp
80006396:	e0 a0 8b 89 	rcall	80017aa8 <memset>
8000639a:	1a 95       	mov	r5,sp
		sb = &box[box_id + 2];

	if (zoom_view && zoom_view_id != box_id)
		return;

	if (zoom_view && zoom_view_id == box_id) {
8000639c:	07 88       	ld.ub	r8,r3[0x0]
8000639e:	58 08       	cp.w	r8,0
800063a0:	c0 60       	breq	800063ac <gui_print_signal_box+0x74>
800063a2:	fe f8 02 fe 	ld.w	r8,pc[766]
800063a6:	70 08       	ld.w	r8,r8[0x0]
800063a8:	0e 38       	cp.w	r8,r7
800063aa:	c6 00       	breq	8000646a <gui_print_signal_box+0x132>
	}
	else {
		
		can_tx_flag = false;
			
		et024006_PutBitmap(buffer, sb->width, sb->x, sb->y, sb->width, sb->height, sb->fg_color, sb->bg_color);
800063ac:	88 d9       	ld.uh	r9,r4[0xa]
800063ae:	88 a8       	ld.uh	r8,r4[0x4]
800063b0:	88 8a       	ld.uh	r10,r4[0x0]
800063b2:	1a d9       	st.w	--sp,r9
800063b4:	88 c9       	ld.uh	r9,r4[0x8]
800063b6:	1a d9       	st.w	--sp,r9
800063b8:	88 b9       	ld.uh	r9,r4[0x6]
	
		
	}
	else {
		
		can_tx_flag = false;
800063ba:	30 0b       	mov	r11,0
			
		et024006_PutBitmap(buffer, sb->width, sb->x, sb->y, sb->width, sb->height, sb->fg_color, sb->bg_color);
800063bc:	1a d9       	st.w	--sp,r9
	
		
	}
	else {
		
		can_tx_flag = false;
800063be:	fe f9 02 e6 	ld.w	r9,pc[742]
			
		et024006_PutBitmap(buffer, sb->width, sb->x, sb->y, sb->width, sb->height, sb->fg_color, sb->bg_color);
800063c2:	fe fc 02 e6 	ld.w	r12,pc[742]
	
		
	}
	else {
		
		can_tx_flag = false;
800063c6:	b2 8b       	st.b	r9[0x0],r11
			
		et024006_PutBitmap(buffer, sb->width, sb->x, sb->y, sb->width, sb->height, sb->fg_color, sb->bg_color);
800063c8:	10 9b       	mov	r11,r8
800063ca:	88 99       	ld.uh	r9,r4[0x2]
800063cc:	fe b0 de c6 	rcall	80002158 <et024006_PutBitmap>
			
		counter_ = 0;
800063d0:	30 09       	mov	r9,0
800063d2:	fe f8 02 da 	ld.w	r8,pc[730]
800063d6:	91 09       	st.w	r8[0x0],r9
			
		if (version_flag != 2)	{
800063d8:	2f dd       	sub	sp,-12
800063da:	0d 89       	ld.ub	r9,r6[0x0]
800063dc:	30 28       	mov	r8,2
800063de:	f0 09 18 00 	cp.b	r9,r8
800063e2:	c2 10       	breq	80006424 <gui_print_signal_box+0xec>
			switch (box_id)
800063e4:	58 27       	cp.w	r7,2
800063e6:	e0 80 00 93 	breq	8000650c <gui_print_signal_box+0x1d4>
800063ea:	58 37       	cp.w	r7,3
800063ec:	cc d1       	brne	80006386 <gui_print_signal_box+0x4e>
				case 2:
					sprintf (textPrint[box_id], "Volume\nUP!\n( %d )", gFwState.fVolSet);
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT2_X, GUI_OUTPUT2_Y, BLUE, YELLOW);
					break;
				case 3:
					sprintf (textPrint[box_id], "Volume\nDOWN!\n( %d )", gFwState.fVolSet);
800063ee:	fe f8 02 c2 	ld.w	r8,pc[706]
800063f2:	11 a8       	ld.ub	r8,r8[0x2]
800063f4:	2f 45       	sub	r5,-12
800063f6:	1a d8       	st.w	--sp,r8
800063f8:	fe fb 02 bc 	ld.w	r11,pc[700]
800063fc:	0a 9c       	mov	r12,r5
800063fe:	e0 a0 8d 3b 	rcall	80017e74 <sprintf>
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT3_X, GUI_OUTPUT3_Y, BLUE, YELLOW);
80006402:	e0 68 ff f0 	mov	r8,65520
80006406:	0a 9c       	mov	r12,r5
80006408:	1a d8       	st.w	--sp,r8
8000640a:	e0 69 00 a0 	mov	r9,160
8000640e:	31 f8       	mov	r8,31
80006410:	33 8a       	mov	r10,56
80006412:	fe fb 02 a6 	ld.w	r11,pc[678]
80006416:	fe b0 de e1 	rcall	800021d8 <et024006_PrintString>
8000641a:	2f ed       	sub	sp,-8
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT3_X2, GUI_OUTPUT3_Y, BLUE, YELLOW);
					break;
			}
		}
	}
} 
8000641c:	fe 3d fc 00 	sub	sp,-1024
80006420:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
					break;
			}
		}
		else
		{
			switch (box_id)
80006424:	58 17       	cp.w	r7,1
80006426:	e0 80 00 9b 	breq	8000655c <gui_print_signal_box+0x224>
8000642a:	e0 8a 00 c3 	brle	800065b0 <gui_print_signal_box+0x278>
8000642e:	58 27       	cp.w	r7,2
80006430:	e0 80 00 ab 	breq	80006586 <gui_print_signal_box+0x24e>
80006434:	58 37       	cp.w	r7,3
80006436:	ca 81       	brne	80006386 <gui_print_signal_box+0x4e>
				case 2:
					sprintf (textPrint[box_id], "F. Vol.\nUP\n(%d)", gFwState.fVolSet);
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT2_X2, GUI_OUTPUT2_Y, BLUE, YELLOW);
					break;
				case 3:
					sprintf (textPrint[box_id], "F. Vol.\nDOWN\n(%d)", gFwState.fVolSet);
80006438:	fe f8 02 78 	ld.w	r8,pc[632]
8000643c:	11 a8       	ld.ub	r8,r8[0x2]
8000643e:	2f 45       	sub	r5,-12
80006440:	1a d8       	st.w	--sp,r8
80006442:	fe fb 02 7a 	ld.w	r11,pc[634]
80006446:	0a 9c       	mov	r12,r5
80006448:	e0 a0 8d 16 	rcall	80017e74 <sprintf>
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT3_X2, GUI_OUTPUT3_Y, BLUE, YELLOW);
8000644c:	e0 68 ff f0 	mov	r8,65520
80006450:	0a 9c       	mov	r12,r5
80006452:	1a d8       	st.w	--sp,r8
80006454:	e0 69 00 a0 	mov	r9,160
80006458:	31 f8       	mov	r8,31
8000645a:	e0 6a 00 80 	mov	r10,128
8000645e:	fe fb 02 5a 	ld.w	r11,pc[602]
80006462:	fe b0 de bb 	rcall	800021d8 <et024006_PrintString>
80006466:	2f ed       	sub	sp,-8
80006468:	c8 fb       	rjmp	80006386 <gui_print_signal_box+0x4e>
	if (zoom_view && zoom_view_id != box_id)
		return;

	if (zoom_view && zoom_view_id == box_id) {
		counter_ += 0x01;
		et024006_PutBitmap(buffer, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_X, GUI_ZOOM_BOX_Y, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_HEIGHT, sb->fg_color, sb->bg_color);
8000646a:	88 c9       	ld.uh	r9,r4[0x8]
8000646c:	88 da       	ld.uh	r10,r4[0xa]
8000646e:	1a da       	st.w	--sp,r10
80006470:	1a d9       	st.w	--sp,r9

	if (zoom_view && zoom_view_id != box_id)
		return;

	if (zoom_view && zoom_view_id == box_id) {
		counter_ += 0x01;
80006472:	fe f8 02 3a 	ld.w	r8,pc[570]
		et024006_PutBitmap(buffer, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_X, GUI_ZOOM_BOX_Y, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_HEIGHT, sb->fg_color, sb->bg_color);
80006476:	e0 6a 00 f0 	mov	r10,240

	if (zoom_view && zoom_view_id != box_id)
		return;

	if (zoom_view && zoom_view_id == box_id) {
		counter_ += 0x01;
8000647a:	70 09       	ld.w	r9,r8[0x0]
8000647c:	2f f9       	sub	r9,-1
8000647e:	91 09       	st.w	r8[0x0],r9
		et024006_PutBitmap(buffer, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_X, GUI_ZOOM_BOX_Y, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_HEIGHT, sb->fg_color, sb->bg_color);
80006480:	1a da       	st.w	--sp,r10
80006482:	e0 68 01 40 	mov	r8,320
80006486:	30 09       	mov	r9,0
80006488:	10 9b       	mov	r11,r8
8000648a:	12 9a       	mov	r10,r9
8000648c:	fe fc 02 1c 	ld.w	r12,pc[540]
80006490:	fe b0 de 64 	rcall	80002158 <et024006_PutBitmap>
		
		if (version_flag != 2)	{
80006494:	0d 89       	ld.ub	r9,r6[0x0]
80006496:	2f dd       	sub	sp,-12
80006498:	30 28       	mov	r8,2
8000649a:	f0 09 18 00 	cp.b	r9,r8
8000649e:	c4 e0       	breq	8000653a <gui_print_signal_box+0x202>
			switch (box_id)
800064a0:	58 17       	cp.w	r7,1
800064a2:	e0 80 00 d0 	breq	80006642 <gui_print_signal_box+0x30a>
800064a6:	e0 8a 00 d6 	brle	80006652 <gui_print_signal_box+0x31a>
					break;
			}
		}	
		else	{
							
				switch (box_id)
800064aa:	58 27       	cp.w	r7,2
800064ac:	e0 80 00 a5 	breq	800065f6 <gui_print_signal_box+0x2be>
800064b0:	58 37       	cp.w	r7,3
800064b2:	e0 80 00 97 	breq	800065e0 <gui_print_signal_box+0x2a8>
800064b6:	ea 07 00 25 	add	r5,r5,r7<<0x2
						sprintf (textPrint[box_id], "[Front volume down!: %d]",  gFwState.fVolSet);
						break;
				}
			}		
			
			et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x16, GUI_ZOOM_BOX_X, (uint16_t)100, BLACK, WHITE);
800064ba:	e0 69 ff ff 	mov	r9,65535
800064be:	30 08       	mov	r8,0
800064c0:	1a d9       	st.w	--sp,r9
800064c2:	10 9a       	mov	r10,r8
800064c4:	36 49       	mov	r9,100
800064c6:	0a 9c       	mov	r12,r5
800064c8:	fe fb 01 f8 	ld.w	r11,pc[504]
800064cc:	fe b0 de 86 	rcall	800021d8 <et024006_PrintString>
			
			if (!can_tx_flag)	{
800064d0:	4f 58       	lddpc	r8,800066a4 <gui_print_signal_box+0x36c>
800064d2:	2f fd       	sub	sp,-4
800064d4:	11 8a       	ld.ub	r10,r8[0x0]
800064d6:	30 09       	mov	r9,0
800064d8:	f2 0a 18 00 	cp.b	r10,r9
800064dc:	fe 91 ff 55 	brne	80006386 <gui_print_signal_box+0x4e>
				can_tx_flag = true;
800064e0:	30 19       	mov	r9,1
800064e2:	b0 89       	st.b	r8[0x0],r9

				if (version_flag == 2)	{
800064e4:	0d 89       	ld.ub	r9,r6[0x0]
800064e6:	30 28       	mov	r8,2
800064e8:	f0 09 18 00 	cp.b	r9,r8
800064ec:	e0 80 00 9b 	breq	80006622 <gui_print_signal_box+0x2ea>
					}
				}
				else
				{
					
					switch (box_id)
800064f0:	58 27       	cp.w	r7,2
800064f2:	e0 80 00 8d 	breq	8000660c <gui_print_signal_box+0x2d4>
800064f6:	58 37       	cp.w	r7,3
800064f8:	fe 91 ff 47 	brne	80006386 <gui_print_signal_box+0x4e>
							}
							break;
						
						case 3:
							//can_example_prepare_data_to_send2 (FRONT_DOWN);
							if (gFwState.fVolSet > AVN_VOLUME_MIN) {
800064fc:	4e d8       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
800064fe:	11 a9       	ld.ub	r9,r8[0x2]
80006500:	58 09       	cp.w	r9,0
80006502:	fe 90 ff 42 	breq	80006386 <gui_print_signal_box+0x4e>
								gFwState.fVolSet --;
80006506:	20 19       	sub	r9,1
80006508:	b0 a9       	st.b	r8[0x2],r9
8000650a:	c3 eb       	rjmp	80006386 <gui_print_signal_box+0x4e>
			{
				case 0:
				case 1:
					break;
				case 2:
					sprintf (textPrint[box_id], "Volume\nUP!\n( %d )", gFwState.fVolSet);
8000650c:	4e 98       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
8000650e:	11 a8       	ld.ub	r8,r8[0x2]
80006510:	2f 85       	sub	r5,-8
80006512:	1a d8       	st.w	--sp,r8
80006514:	4e cb       	lddpc	r11,800066c4 <gui_print_signal_box+0x38c>
80006516:	0a 9c       	mov	r12,r5
80006518:	e0 a0 8c ae 	rcall	80017e74 <sprintf>
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT2_X, GUI_OUTPUT2_Y, BLUE, YELLOW);
8000651c:	e0 68 ff f0 	mov	r8,65520
80006520:	0a 9c       	mov	r12,r5
80006522:	1a d8       	st.w	--sp,r8
80006524:	34 b9       	mov	r9,75
80006526:	31 f8       	mov	r8,31
80006528:	33 8a       	mov	r10,56
8000652a:	4e 4b       	lddpc	r11,800066b8 <gui_print_signal_box+0x380>
8000652c:	fe b0 de 56 	rcall	800021d8 <et024006_PrintString>
					break;
80006530:	2f ed       	sub	sp,-8
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT3_X2, GUI_OUTPUT3_Y, BLUE, YELLOW);
					break;
			}
		}
	}
} 
80006532:	fe 3d fc 00 	sub	sp,-1024
80006536:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
					break;
			}
		}	
		else	{
							
				switch (box_id)
8000653a:	58 17       	cp.w	r7,1
8000653c:	e0 80 00 95 	breq	80006666 <gui_print_signal_box+0x32e>
80006540:	fe 99 ff b5 	brgt	800064aa <gui_print_signal_box+0x172>
80006544:	58 07       	cp.w	r7,0
80006546:	cb 81       	brne	800064b6 <gui_print_signal_box+0x17e>
					case 1:	//LEFT
						sprintf (textPrint[box_id], "[Rear volume up!: %d]",  gFwState.rVolSet );
						break;
								
					case 0:	//RIGHT
						sprintf (textPrint[box_id], "[Rear volume down!: %d]",  gFwState.rVolSet );
80006548:	4d a8       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
8000654a:	11 c8       	ld.ub	r8,r8[0x4]
8000654c:	1a 95       	mov	r5,sp
8000654e:	4d fb       	lddpc	r11,800066c8 <gui_print_signal_box+0x390>
80006550:	1a d8       	st.w	--sp,r8
80006552:	0a 9c       	mov	r12,r5
80006554:	e0 a0 8c 90 	rcall	80017e74 <sprintf>
						break;
80006558:	2f fd       	sub	sp,-4
8000655a:	cb 0b       	rjmp	800064ba <gui_print_signal_box+0x182>
					GUI_SOURCE1_Y,
					RED,
					YELLOW);
					break;
				case 1:
					sprintf (textPrint[box_id], "R. Vol.\nUP\n(%d)", gFwState.rVolSet);
8000655c:	4d 58       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
8000655e:	11 c8       	ld.ub	r8,r8[0x4]
80006560:	2f c5       	sub	r5,-4
80006562:	1a d8       	st.w	--sp,r8
80006564:	4d ab       	lddpc	r11,800066cc <gui_print_signal_box+0x394>
80006566:	0a 9c       	mov	r12,r5
80006568:	e0 a0 8c 86 	rcall	80017e74 <sprintf>
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT1_X, GUI_OUTPUT1_Y, RED, YELLOW);
8000656c:	e0 68 ff f0 	mov	r8,65520
80006570:	0a 9c       	mov	r12,r5
80006572:	1a d8       	st.w	--sp,r8
80006574:	37 09       	mov	r9,112
80006576:	e0 68 f8 00 	mov	r8,63488
8000657a:	31 4a       	mov	r10,20
8000657c:	4c fb       	lddpc	r11,800066b8 <gui_print_signal_box+0x380>
8000657e:	fe b0 de 2d 	rcall	800021d8 <et024006_PrintString>
					break;
80006582:	2f ed       	sub	sp,-8
80006584:	c0 1b       	rjmp	80006386 <gui_print_signal_box+0x4e>
				case 2:
					sprintf (textPrint[box_id], "F. Vol.\nUP\n(%d)", gFwState.fVolSet);
80006586:	4c b8       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
80006588:	11 a8       	ld.ub	r8,r8[0x2]
8000658a:	2f 85       	sub	r5,-8
8000658c:	1a d8       	st.w	--sp,r8
8000658e:	4d 1b       	lddpc	r11,800066d0 <gui_print_signal_box+0x398>
80006590:	0a 9c       	mov	r12,r5
80006592:	e0 a0 8c 71 	rcall	80017e74 <sprintf>
					et024006_PrintString(textPrint[box_id], (const unsigned char*)FONT8x8, GUI_OUTPUT2_X2, GUI_OUTPUT2_Y, BLUE, YELLOW);
80006596:	e0 68 ff f0 	mov	r8,65520
8000659a:	0a 9c       	mov	r12,r5
8000659c:	1a d8       	st.w	--sp,r8
8000659e:	34 b9       	mov	r9,75
800065a0:	31 f8       	mov	r8,31
800065a2:	e0 6a 00 80 	mov	r10,128
800065a6:	4c 5b       	lddpc	r11,800066b8 <gui_print_signal_box+0x380>
800065a8:	fe b0 de 18 	rcall	800021d8 <et024006_PrintString>
					break;
800065ac:	2f ed       	sub	sp,-8
800065ae:	ce ca       	rjmp	80006386 <gui_print_signal_box+0x4e>
					break;
			}
		}
		else
		{
			switch (box_id)
800065b0:	58 07       	cp.w	r7,0
800065b2:	fe 91 fe ea 	brne	80006386 <gui_print_signal_box+0x4e>
			{
				case 0:
					sprintf (textPrint[box_id], "R. Vol.\nDOWN\n(%d)", gFwState.rVolSet);
800065b6:	4b f8       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
800065b8:	11 c8       	ld.ub	r8,r8[0x4]
800065ba:	4c 7b       	lddpc	r11,800066d4 <gui_print_signal_box+0x39c>
800065bc:	1a d8       	st.w	--sp,r8
800065be:	0a 9c       	mov	r12,r5
800065c0:	e0 a0 8c 5a 	rcall	80017e74 <sprintf>
					et024006_PrintString(
800065c4:	e0 68 ff f0 	mov	r8,65520
800065c8:	0a 9c       	mov	r12,r5
800065ca:	1a d8       	st.w	--sp,r8
800065cc:	37 09       	mov	r9,112
800065ce:	e0 68 f8 00 	mov	r8,63488
800065d2:	e0 6a 00 ee 	mov	r10,238
800065d6:	4b 9b       	lddpc	r11,800066b8 <gui_print_signal_box+0x380>
800065d8:	fe b0 de 00 	rcall	800021d8 <et024006_PrintString>
					(const unsigned char*)FONT8x8,
					GUI_SOURCE1_X,
					GUI_SOURCE1_Y,
					RED,
					YELLOW);
					break;
800065dc:	2f ed       	sub	sp,-8
800065de:	cd 4a       	rjmp	80006386 <gui_print_signal_box+0x4e>
					case 2:
						sprintf (textPrint[box_id], "[Front volume up!: %d]",  gFwState.fVolSet);
						break;
								
					case 3:
						sprintf (textPrint[box_id], "[Front volume down!: %d]",  gFwState.fVolSet);
800065e0:	4b 48       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
800065e2:	11 a8       	ld.ub	r8,r8[0x2]
800065e4:	fa c5 ff f4 	sub	r5,sp,-12
800065e8:	4b cb       	lddpc	r11,800066d8 <gui_print_signal_box+0x3a0>
800065ea:	1a d8       	st.w	--sp,r8
800065ec:	0a 9c       	mov	r12,r5
800065ee:	e0 a0 8c 43 	rcall	80017e74 <sprintf>
800065f2:	2f fd       	sub	sp,-4
800065f4:	c6 3b       	rjmp	800064ba <gui_print_signal_box+0x182>
					case 0:	//RIGHT
						sprintf (textPrint[box_id], "[Rear volume down!: %d]",  gFwState.rVolSet );
						break;
								
					case 2:
						sprintf (textPrint[box_id], "[Front volume up!: %d]",  gFwState.fVolSet);
800065f6:	4a f8       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
800065f8:	11 a8       	ld.ub	r8,r8[0x2]
800065fa:	fa c5 ff f8 	sub	r5,sp,-8
800065fe:	4b 8b       	lddpc	r11,800066dc <gui_print_signal_box+0x3a4>
80006600:	1a d8       	st.w	--sp,r8
80006602:	0a 9c       	mov	r12,r5
80006604:	e0 a0 8c 38 	rcall	80017e74 <sprintf>
						break;
80006608:	2f fd       	sub	sp,-4
8000660a:	c5 8b       	rjmp	800064ba <gui_print_signal_box+0x182>
					
					switch (box_id)
					{
						case 2:
							//can_example_prepare_data_to_send2 (FRONT_UP);
							if (gFwState.fVolSet < AVN_VOLUME_MAX) {
8000660c:	4a 98       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
8000660e:	32 7a       	mov	r10,39
80006610:	11 a9       	ld.ub	r9,r8[0x2]
80006612:	f4 09 18 00 	cp.b	r9,r10
80006616:	fe 9b fe b8 	brhi	80006386 <gui_print_signal_box+0x4e>
								gFwState.fVolSet ++;
8000661a:	2f f9       	sub	r9,-1
8000661c:	b0 a9       	st.b	r8[0x2],r9
8000661e:	fe 9f fe b4 	bral	80006386 <gui_print_signal_box+0x4e>
			
			if (!can_tx_flag)	{
				can_tx_flag = true;

				if (version_flag == 2)	{
					switch (box_id)
80006622:	58 17       	cp.w	r7,1
80006624:	c2 c0       	breq	8000667c <gui_print_signal_box+0x344>
80006626:	fe 99 ff 65 	brgt	800064f0 <gui_print_signal_box+0x1b8>
8000662a:	58 07       	cp.w	r7,0
8000662c:	fe 91 fe ad 	brne	80006386 <gui_print_signal_box+0x4e>
							}
							break;
						
						case 0:	//RIGHT
							//can_example_prepare_data_to_send2 (REAR_DOWN);
							if(gFwState.rVolSet > AVN_VOLUME_MIN) {
80006630:	4a 08       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
80006632:	11 c9       	ld.ub	r9,r8[0x4]
80006634:	58 09       	cp.w	r9,0
80006636:	fe 90 fe a8 	breq	80006386 <gui_print_signal_box+0x4e>
								gFwState.rVolSet --;	
8000663a:	20 19       	sub	r9,1
8000663c:	b0 c9       	st.b	r8[0x4],r9
8000663e:	fe 9f fe a4 	bral	80006386 <gui_print_signal_box+0x4e>
		
		if (version_flag != 2)	{
			switch (box_id)
			{
				case 1:	//LEFT
					sprintf (textPrint[box_id], "NONE");	
80006642:	fa c5 ff fc 	sub	r5,sp,-4
80006646:	30 5a       	mov	r10,5
80006648:	4a 6b       	lddpc	r11,800066e0 <gui_print_signal_box+0x3a8>
8000664a:	0a 9c       	mov	r12,r5
8000664c:	e0 a0 89 8a 	rcall	80017960 <memcpy>
					break;
80006650:	c3 5b       	rjmp	800064ba <gui_print_signal_box+0x182>
	if (zoom_view && zoom_view_id == box_id) {
		counter_ += 0x01;
		et024006_PutBitmap(buffer, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_X, GUI_ZOOM_BOX_Y, GUI_ZOOM_BOX_WIDTH, GUI_ZOOM_BOX_HEIGHT, sb->fg_color, sb->bg_color);
		
		if (version_flag != 2)	{
			switch (box_id)
80006652:	58 07       	cp.w	r7,0
80006654:	fe 91 ff 31 	brne	800064b6 <gui_print_signal_box+0x17e>
				case 1:	//LEFT
					sprintf (textPrint[box_id], "NONE");	
					break;
				
				case 0:	//RIGHT	
					sprintf (textPrint[box_id], "NONE");
80006658:	1a 95       	mov	r5,sp
8000665a:	30 5a       	mov	r10,5
8000665c:	4a 1b       	lddpc	r11,800066e0 <gui_print_signal_box+0x3a8>
8000665e:	1a 9c       	mov	r12,sp
80006660:	e0 a0 89 80 	rcall	80017960 <memcpy>
					break;
80006664:	c2 bb       	rjmp	800064ba <gui_print_signal_box+0x182>
		else	{
							
				switch (box_id)
				{
					case 1:	//LEFT
						sprintf (textPrint[box_id], "[Rear volume up!: %d]",  gFwState.rVolSet );
80006666:	49 38       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
80006668:	11 c8       	ld.ub	r8,r8[0x4]
8000666a:	fa c5 ff fc 	sub	r5,sp,-4
8000666e:	49 eb       	lddpc	r11,800066e4 <gui_print_signal_box+0x3ac>
80006670:	1a d8       	st.w	--sp,r8
80006672:	0a 9c       	mov	r12,r5
80006674:	e0 a0 8c 00 	rcall	80017e74 <sprintf>
						break;
80006678:	2f fd       	sub	sp,-4
8000667a:	c2 0b       	rjmp	800064ba <gui_print_signal_box+0x182>
				if (version_flag == 2)	{
					switch (box_id)
					{
						case 1:	//LEFT
							//can_example_prepare_data_to_send2 (REAR_UP);
							if (gFwState.rVolSet < AVN_VOLUME_MAX) {
8000667c:	48 d8       	lddpc	r8,800066b0 <gui_print_signal_box+0x378>
8000667e:	32 7a       	mov	r10,39
80006680:	11 c9       	ld.ub	r9,r8[0x4]
80006682:	f4 09 18 00 	cp.b	r9,r10
80006686:	fe 9b fe 80 	brhi	80006386 <gui_print_signal_box+0x4e>
								gFwState.rVolSet ++;
8000668a:	2f f9       	sub	r9,-1
8000668c:	b0 c9       	st.b	r8[0x4],r9
8000668e:	fe 9f fe 7c 	bral	80006386 <gui_print_signal_box+0x4e>
80006692:	d7 03       	nop
80006694:	00 00       	add	r0,r0
80006696:	3c 90       	mov	r0,-55
80006698:	80 06       	ld.sh	r6,r0[0x0]
8000669a:	9e 72       	ld.sh	r2,pc[0xe]
8000669c:	00 00       	add	r0,r0
8000669e:	3b 40       	mov	r0,-76
800066a0:	00 00       	add	r0,r0
800066a2:	4a 8c       	lddpc	r12,80006740 <gui_task+0x58>
800066a4:	00 00       	add	r0,r0
800066a6:	2b a0       	sub	r0,-70
800066a8:	00 00       	add	r0,r0
800066aa:	06 1c       	sub	r12,r3
800066ac:	00 00       	add	r0,r0
800066ae:	3c 8c       	mov	r12,-56
800066b0:	00 00       	add	r0,r0
800066b2:	4d 69       	lddpc	r9,80006808 <gui_task+0x120>
800066b4:	80 06       	ld.sh	r6,r0[0x0]
800066b6:	9f 3c       	st.w	pc[0xc],r12
800066b8:	80 01       	ld.sh	r1,r0[0x0]
800066ba:	d4 10       	acall	0x104
800066bc:	80 06       	ld.sh	r6,r0[0x0]
800066be:	9f 84       	st.w	pc[0x20],r4
800066c0:	80 01       	ld.sh	r1,r0[0x0]
800066c2:	ce 00       	breq	80006682 <gui_print_signal_box+0x34a>
800066c4:	80 06       	ld.sh	r6,r0[0x0]
800066c6:	9f 28       	st.w	pc[0x8],r8
800066c8:	80 06       	ld.sh	r6,r0[0x0]
800066ca:	9f 10       	st.w	pc[0x4],r0
800066cc:	80 06       	ld.sh	r6,r0[0x0]
800066ce:	9f 64       	st.w	pc[0x18],r4
800066d0:	80 06       	ld.sh	r6,r0[0x0]
800066d2:	9f 74       	st.w	pc[0x1c],r4
800066d4:	80 06       	ld.sh	r6,r0[0x0]
800066d6:	9f 50       	st.w	pc[0x14],r0
800066d8:	80 06       	ld.sh	r6,r0[0x0]
800066da:	9e dc       	ld.uh	r12,pc[0xa]
800066dc:	80 06       	ld.sh	r6,r0[0x0]
800066de:	9e c4       	ld.uh	r4,pc[0x8]
800066e0:	80 06       	ld.sh	r6,r0[0x0]
800066e2:	9e bc       	ld.uh	r12,pc[0x6]
800066e4:	80 06       	ld.sh	r6,r0[0x0]
800066e6:	9e f8       	ld.uh	r8,pc[0xe]

800066e8 <gui_task>:
800066e8:	eb cd 40 b0 	pushm	r4-r5,r7,lr
800066ec:	4d 38       	lddpc	r8,80006838 <gui_task+0x150>
800066ee:	11 89       	ld.ub	r9,r8[0x0]
800066f0:	30 28       	mov	r8,2
800066f2:	f0 09 18 00 	cp.b	r9,r8
800066f6:	c4 10       	breq	80006778 <gui_task+0x90>
800066f8:	e1 ba 00 42 	mfsr	r10,0x108
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800066fc:	4d 07       	lddpc	r7,8000683c <gui_task+0x154>
800066fe:	ef 39 00 08 	ld.ub	r9,r7[8]
80006702:	f0 09 18 00 	cp.b	r9,r8
80006706:	e0 80 00 83 	breq	8000680c <gui_task+0x124>
    return false;

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000670a:	30 1b       	mov	r11,1
8000670c:	f6 09 18 00 	cp.b	r9,r11
80006710:	c0 d0       	breq	8000672a <gui_task+0x42>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006712:	6e 08       	ld.w	r8,r7[0x0]
80006714:	6e 19       	ld.w	r9,r7[0x4]
80006716:	12 38       	cp.w	r8,r9
80006718:	e0 88 00 7c 	brls	80006810 <gui_task+0x128>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000671c:	10 3a       	cp.w	r10,r8
8000671e:	c7 72       	brcc	8000680c <gui_task+0x124>
80006720:	12 3a       	cp.w	r10,r9
80006722:	e0 88 00 75 	brls	8000680c <gui_task+0x124>
80006726:	ef 6b 00 08 	st.b	r7[8],r11
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000672a:	e0 6a 01 00 	mov	r10,256
{
  // Check the last time the printing has been done
	if (version_flag != 2)	{
		if (cpu_is_timeout(&gui_fs.cpu_time)) {

			gui_print_signal_box(GUI_OUTPUT3_ID, signal1_buf,
8000672e:	4c 5b       	lddpc	r11,80006840 <gui_task+0x158>
80006730:	30 3c       	mov	r12,3
80006732:	c0 3e       	rcall	80006338 <gui_print_signal_box>
80006734:	30 2c       	mov	r12,2
80006736:	e0 6a 01 00 	mov	r10,256
			sizeof(signal1_buf)/sizeof(signal1_buf[0]));
			gui_print_signal_box(GUI_OUTPUT2_ID, signal3_buf,
8000673a:	4c 3b       	lddpc	r11,80006844 <gui_task+0x15c>
8000673c:	fe b0 fd fe 	rcall	80006338 <gui_print_signal_box>
80006740:	4c 2a       	lddpc	r10,80006848 <gui_task+0x160>
80006742:	e0 68 03 e8 	mov	r8,1000
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006746:	74 05       	ld.w	r5,r10[0x0]
80006748:	6e 3a       	ld.w	r10,r7[0xc]
8000674a:	30 09       	mov	r9,0
8000674c:	ea 0a 06 44 	mulu.d	r4,r5,r10
80006750:	30 0b       	mov	r11,0
80006752:	e0 6a 03 e7 	mov	r10,999
80006756:	e8 0a 00 0a 	add	r10,r4,r10
8000675a:	ea 0b 00 4b 	adc	r11,r5,r11
8000675e:	e0 a0 80 17 	rcall	8001678c <__avr32_udiv64>
80006762:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006766:	f0 0a 00 0a 	add	r10,r8,r10
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000676a:	8f 08       	st.w	r7[0x0],r8
8000676c:	8f 1a       	st.w	r7[0x4],r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000676e:	30 08       	mov	r8,0
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006770:	ef 68 00 08 	st.b	r7[8],r8
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80006774:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc
80006778:	e1 ba 00 42 	mfsr	r10,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000677c:	4b 07       	lddpc	r7,8000683c <gui_task+0x154>
8000677e:	ef 38 00 08 	ld.ub	r8,r7[8]

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80006782:	f2 08 18 00 	cp.b	r8,r9
80006786:	c4 30       	breq	8000680c <gui_task+0x124>
80006788:	30 19       	mov	r9,1
8000678a:	f2 08 18 00 	cp.b	r8,r9
    return false;

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000678e:	c0 d0       	breq	800067a8 <gui_task+0xc0>
80006790:	6e 08       	ld.w	r8,r7[0x0]
80006792:	6e 1b       	ld.w	r11,r7[0x4]
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006794:	16 38       	cp.w	r8,r11
80006796:	e0 88 00 46 	brls	80006822 <gui_task+0x13a>
8000679a:	10 3a       	cp.w	r10,r8
8000679c:	c3 82       	brcc	8000680c <gui_task+0x124>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000679e:	16 3a       	cp.w	r10,r11
800067a0:	e0 88 00 36 	brls	8000680c <gui_task+0x124>
800067a4:	ef 69 00 08 	st.b	r7[8],r9
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800067a8:	e0 6a 01 00 	mov	r10,256
		}
	}
	else
	{		
		if (cpu_is_timeout(&gui_fs.cpu_time)) {
			gui_print_signal_box(GUI_SOURCE1_ID, signal1_buf,
800067ac:	4a 5b       	lddpc	r11,80006840 <gui_task+0x158>
800067ae:	30 0c       	mov	r12,0
800067b0:	fe b0 fd c4 	rcall	80006338 <gui_print_signal_box>
800067b4:	e0 6a 01 00 	mov	r10,256
			sizeof(signal1_buf)/sizeof(signal1_buf[0]));
			gui_print_signal_box(GUI_OUTPUT3_ID, signal1_buf,
800067b8:	4a 2b       	lddpc	r11,80006840 <gui_task+0x158>
800067ba:	30 3c       	mov	r12,3
800067bc:	fe b0 fd be 	rcall	80006338 <gui_print_signal_box>
800067c0:	e0 6a 01 00 	mov	r10,256
			sizeof(signal1_buf)/sizeof(signal1_buf[0]));
			gui_print_signal_box(GUI_OUTPUT2_ID, signal3_buf,
800067c4:	4a 0b       	lddpc	r11,80006844 <gui_task+0x15c>
800067c6:	30 2c       	mov	r12,2
800067c8:	fe b0 fd b8 	rcall	80006338 <gui_print_signal_box>
800067cc:	30 1c       	mov	r12,1
800067ce:	e0 6a 01 00 	mov	r10,256
			sizeof(signal3_buf)/sizeof(signal3_buf[0]));
			gui_print_signal_box(GUI_OUTPUT1_ID, signal4_buf,
800067d2:	49 fb       	lddpc	r11,8000684c <gui_task+0x164>
800067d4:	fe b0 fd b2 	rcall	80006338 <gui_print_signal_box>
800067d8:	49 ca       	lddpc	r10,80006848 <gui_task+0x160>
800067da:	e0 68 03 e8 	mov	r8,1000
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800067de:	74 05       	ld.w	r5,r10[0x0]
800067e0:	6e 3a       	ld.w	r10,r7[0xc]
800067e2:	30 09       	mov	r9,0
800067e4:	ea 0a 06 44 	mulu.d	r4,r5,r10
800067e8:	30 0b       	mov	r11,0
800067ea:	e0 6a 03 e7 	mov	r10,999
800067ee:	e8 0a 00 0a 	add	r10,r4,r10
800067f2:	ea 0b 00 4b 	adc	r11,r5,r11
800067f6:	e0 a0 7f cb 	rcall	8001678c <__avr32_udiv64>
800067fa:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800067fe:	f0 0a 00 0a 	add	r10,r8,r10
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006802:	8f 08       	st.w	r7[0x0],r8
80006804:	8f 1a       	st.w	r7[0x4],r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006806:	30 08       	mov	r8,0
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006808:	ef 68 00 08 	st.b	r7[8],r8
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000680c:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc
80006810:	10 3a       	cp.w	r10,r8
80006812:	c0 43       	brcs	8000681a <gui_task+0x132>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006814:	12 3a       	cp.w	r10,r9
80006816:	fe 98 ff fb 	brls	8000680c <gui_task+0x124>
8000681a:	30 18       	mov	r8,1
8000681c:	ef 68 00 08 	st.b	r7[8],r8
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006820:	c8 5b       	rjmp	8000672a <gui_task+0x42>
80006822:	10 3a       	cp.w	r10,r8
80006824:	c0 52       	brcc	8000682e <gui_task+0x146>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006826:	30 18       	mov	r8,1
80006828:	ef 68 00 08 	st.b	r7[8],r8
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000682c:	cb eb       	rjmp	800067a8 <gui_task+0xc0>
8000682e:	16 3a       	cp.w	r10,r11
80006830:	fe 98 ff ee 	brls	8000680c <gui_task+0x124>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006834:	cf 9b       	rjmp	80006826 <gui_task+0x13e>
80006836:	d7 03       	nop
80006838:	00 00       	add	r0,r0
8000683a:	3c 90       	mov	r0,-55
8000683c:	00 00       	add	r0,r0
8000683e:	2b a4       	sub	r4,-70
80006840:	00 00       	add	r0,r0
80006842:	4d 74       	lddpc	r4,8000699c <inic_write+0x38>
80006844:	00 00       	add	r0,r0
80006846:	3d 94       	mov	r4,-39
80006848:	00 00       	add	r0,r0
8000684a:	2b 9c       	sub	r12,-71
8000684c:	00 00       	add	r0,r0
8000684e:	4b 58       	lddpc	r8,80006920 <dac_write>

80006850 <gui_init>:
80006850:	d4 01       	pushm	lr
80006852:	48 78       	lddpc	r8,8000686c <gui_init+0x1c>
80006854:	91 0c       	st.w	r8[0x0],r12
80006856:	fe b0 de b9 	rcall	800025c8 <et024006_Init>
8000685a:	37 cc       	mov	r12,124
void gui_init(uint32_t cpu_hz, uint32_t hsb_hz, uint32_t pba_hz, uint32_t pbb_hz)
{
	gui_cpu_hz = cpu_hz;
	// Init the display
	et024006_Init(cpu_hz, hsb_hz);
	gpio_set_gpio_pin(ET024006DHU_BL_PIN);
8000685c:	e0 a0 0f 2c 	rcall	800086b4 <gpio_set_gpio_pin>
	// Draw the background
	gui_clear_view();
80006860:	fe b0 fd 2e 	rcall	800062bc <gui_clear_view>
	// Set the frequency rate of the update of the display
	gui_change_update_fs(DEFAULT_SCREEN_UPDATE_FS_MS);
80006864:	36 4c       	mov	r12,100
80006866:	fe b0 fd 47 	rcall	800062f4 <gui_change_update_fs>
}
8000686a:	d8 02       	popm	pc
8000686c:	00 00       	add	r0,r0
8000686e:	2b 9c       	sub	r12,-71

80006870 <DRVI2C_pv_TraceData>:
 *    -# To-do item 1.
 *    -# To-do item 2.
 */
/*----------------------------------------------------------------------------*/
int16_t DRVI2C_pv_TraceData(twi_package_t *package_ptr, TYPE_BOOL read)
{
80006870:	eb cd 40 c0 	pushm	r6-r7,lr
80006874:	18 97       	mov	r7,r12
80006876:	16 96       	mov	r6,r11
	uint16_t i;

	LOG_DBG("[%d]\n", TmrGetMasterTick_Long());
80006878:	ce 2d       	rcall	80006c3c <TmrGetMasterTick_Long>
8000687a:	1a dc       	st.w	--sp,r12
8000687c:	4a 3c       	lddpc	r12,80006908 <DRVI2C_pv_TraceData+0x98>
8000687e:	e0 a0 89 33 	rcall	80017ae4 <printf>
80006882:	0f b8       	ld.ub	r8,r7[0x3]
	
	LOG_DBG("[%02X]", (uint8_t)(package_ptr->chip) << 1);
80006884:	a1 78       	lsl	r8,0x1
80006886:	4a 2c       	lddpc	r12,8000690c <DRVI2C_pv_TraceData+0x9c>
80006888:	1a d8       	st.w	--sp,r8
8000688a:	e0 a0 89 2d 	rcall	80017ae4 <printf>
8000688e:	2f ed       	sub	sp,-8

	if (read) {
80006890:	58 06       	cp.w	r6,0
80006892:	c3 70       	breq	80006900 <DRVI2C_pv_TraceData+0x90>
80006894:	49 fc       	lddpc	r12,80006910 <DRVI2C_pv_TraceData+0xa0>
		LOG_DBG("[R]");
80006896:	e0 a0 89 27 	rcall	80017ae4 <printf>
8000689a:	0f f9       	ld.ub	r9,r7[0x7]
	} else {
		LOG_DBG("[W]");
	}
	if (package_ptr->addr_length != 0) {
8000689c:	30 08       	mov	r8,0
8000689e:	f0 09 18 00 	cp.b	r9,r8
800068a2:	c1 60       	breq	800068ce <DRVI2C_pv_TraceData+0x5e>
800068a4:	30 06       	mov	r6,0
800068a6:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
		for(i=0; i<package_ptr->addr_length; i++) {
			LOG_DBG("%02X", (uint8_t)package_ptr->addr[i]);
800068aa:	ee 08 00 08 	add	r8,r7,r8
800068ae:	11 c8       	ld.ub	r8,r8[0x4]
800068b0:	49 9c       	lddpc	r12,80006914 <DRVI2C_pv_TraceData+0xa4>
800068b2:	1a d8       	st.w	--sp,r8
800068b4:	e0 a0 89 18 	rcall	80017ae4 <printf>
800068b8:	2f f6       	sub	r6,-1
		LOG_DBG("[R]");
	} else {
		LOG_DBG("[W]");
	}
	if (package_ptr->addr_length != 0) {
		for(i=0; i<package_ptr->addr_length; i++) {
800068ba:	2f fd       	sub	sp,-4
800068bc:	5c 86       	casts.h	r6
800068be:	0f f8       	ld.ub	r8,r7[0x7]
800068c0:	ec 08 19 00 	cp.h	r8,r6
800068c4:	fe 9b ff f1 	brhi	800068a6 <DRVI2C_pv_TraceData+0x36>
800068c8:	37 3c       	mov	r12,115
			LOG_DBG("%02X", (uint8_t)package_ptr->addr[i]);
		}
		LOG_DBG("s");
800068ca:	e0 a0 89 25 	rcall	80017b14 <putchar>
800068ce:	6e 38       	ld.w	r8,r7[0xc]
	}
	for(i=0; i < package_ptr->length; i++) {
800068d0:	58 08       	cp.w	r8,0
800068d2:	c1 20       	breq	800068f6 <DRVI2C_pv_TraceData+0x86>
800068d4:	30 08       	mov	r8,0
800068d6:	10 96       	mov	r6,r8
800068d8:	6e 29       	ld.w	r9,r7[0x8]
		LOG_DBG("%02X.", *((uint8_t*)(package_ptr->buffer)+i));
800068da:	f2 08 07 08 	ld.ub	r8,r9[r8]
800068de:	48 fc       	lddpc	r12,80006918 <DRVI2C_pv_TraceData+0xa8>
800068e0:	1a d8       	st.w	--sp,r8
800068e2:	e0 a0 89 01 	rcall	80017ae4 <printf>
800068e6:	2f f6       	sub	r6,-1
		for(i=0; i<package_ptr->addr_length; i++) {
			LOG_DBG("%02X", (uint8_t)package_ptr->addr[i]);
		}
		LOG_DBG("s");
	}
	for(i=0; i < package_ptr->length; i++) {
800068e8:	2f fd       	sub	sp,-4
800068ea:	5c 86       	casts.h	r6
800068ec:	6e 39       	ld.w	r9,r7[0xc]
800068ee:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
800068f2:	12 38       	cp.w	r8,r9
800068f4:	cf 23       	brcs	800068d8 <DRVI2C_pv_TraceData+0x68>
800068f6:	30 ac       	mov	r12,10
		LOG_DBG("%02X.", *((uint8_t*)(package_ptr->buffer)+i));
	}
	LOG_DBG("\n");
800068f8:	e0 a0 89 0e 	rcall	80017b14 <putchar>
800068fc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

	return ERR_NONE;
}
80006900:	48 7c       	lddpc	r12,8000691c <DRVI2C_pv_TraceData+0xac>
	LOG_DBG("[%02X]", (uint8_t)(package_ptr->chip) << 1);

	if (read) {
		LOG_DBG("[R]");
	} else {
		LOG_DBG("[W]");
80006902:	e0 a0 88 f1 	rcall	80017ae4 <printf>
80006906:	cc ab       	rjmp	8000689a <DRVI2C_pv_TraceData+0x2a>
80006908:	80 06       	ld.sh	r6,r0[0x0]
8000690a:	9f a8       	st.w	pc[0x28],r8
8000690c:	80 06       	ld.sh	r6,r0[0x0]
8000690e:	9f b0       	st.w	pc[0x2c],r0
80006910:	80 06       	ld.sh	r6,r0[0x0]
80006912:	9f b8       	st.w	pc[0x2c],r8
80006914:	80 06       	ld.sh	r6,r0[0x0]
80006916:	9f c0       	st.w	pc[0x30],r0
80006918:	80 06       	ld.sh	r6,r0[0x0]
8000691a:	9f c8       	st.w	pc[0x30],r8
8000691c:	80 06       	ld.sh	r6,r0[0x0]
8000691e:	9f bc       	st.w	pc[0x2c],r12

80006920 <dac_write>:
80006920:	eb cd 40 c0 	pushm	r6-r7,lr
80006924:	20 5d       	sub	sp,20
80006926:	34 88       	mov	r8,72
80006928:	50 08       	stdsp	sp[0x0],r8
8000692a:	30 18       	mov	r8,1
8000692c:	50 3b       	stdsp	sp[0xc],r11
8000692e:	50 2c       	stdsp	sp[0x8],r12
	twi_package_t packet;
	status_code_t	status;

	packet.chip = CODEC_ADDR;
	packet.addr_length = 1;
	packet.addr[0] = addr;
80006930:	ba ca       	st.b	sp[0x4],r10
	volatile avr32_twi_t *twi = &AVR32_TWIM0;
	twi_package_t packet;
	status_code_t	status;

	packet.chip = CODEC_ADDR;
	packet.addr_length = 1;
80006932:	ba f8       	st.b	sp[0x7],r8
 * \return STATUS_OK   if all bytes were written, error code otherwise
 */
static inline status_code_t twi_master_write (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
	return (twim_write_packet (twim, package));
80006934:	fe 7c 38 00 	mov	r12,-51200
80006938:	1a 9b       	mov	r11,sp
8000693a:	1a 96       	mov	r6,sp
8000693c:	fe b0 e4 14 	rcall	80003164 <twim_write_packet>
80006940:	18 97       	mov	r7,r12
	packet.addr[0] = addr;
	packet.length = buflen;
	packet.buffer = (void*)buf;
	status = twi_master_write (twi, &packet);
	if(status != STATUS_OK) {
80006942:	c0 81       	brne	80006952 <dac_write+0x32>
		LOG_ERR("twi_master_write fail, status=%d\n", status);
		return ERR_DRVI2C_WRITE;
	}

	DRVI2C_pv_TraceData(&packet,FALSE);
80006944:	1a 9c       	mov	r12,sp
80006946:	0e 9b       	mov	r11,r7
80006948:	c9 4f       	rcall	80006870 <DRVI2C_pv_TraceData>
8000694a:	0e 9c       	mov	r12,r7
8000694c:	2f bd       	sub	sp,-20

	return ERR_NONE;
}
8000694e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006952:	1a dc       	st.w	--sp,r12
	packet.addr[0] = addr;
	packet.length = buflen;
	packet.buffer = (void*)buf;
	status = twi_master_write (twi, &packet);
	if(status != STATUS_OK) {
		LOG_ERR("twi_master_write fail, status=%d\n", status);
80006954:	48 3c       	lddpc	r12,80006960 <dac_write+0x40>
80006956:	e0 a0 88 c7 	rcall	80017ae4 <printf>
8000695a:	39 5c       	mov	r12,-107
8000695c:	2f fd       	sub	sp,-4
		return ERR_DRVI2C_WRITE;
8000695e:	cf 7b       	rjmp	8000694c <dac_write+0x2c>
80006960:	80 06       	ld.sh	r6,r0[0x0]
80006962:	9f d0       	st.w	pc[0x34],r0

80006964 <inic_write>:
80006964:	eb cd 40 c0 	pushm	r6-r7,lr
80006968:	20 5d       	sub	sp,20
8000696a:	32 08       	mov	r8,32
8000696c:	50 08       	stdsp	sp[0x0],r8
8000696e:	30 08       	mov	r8,0
80006970:	50 3b       	stdsp	sp[0xc],r11
80006972:	50 2c       	stdsp	sp[0x8],r12
	volatile avr32_twi_t *twi = &AVR32_TWIM0;
	twi_package_t packet;
	status_code_t	status;

	packet.chip = I2C_INIC_ADDR;
	packet.addr_length = 0;
80006974:	ba f8       	st.b	sp[0x7],r8
80006976:	fe 7c 38 00 	mov	r12,-51200
8000697a:	1a 9b       	mov	r11,sp
8000697c:	1a 96       	mov	r6,sp
8000697e:	fe b0 e3 f3 	rcall	80003164 <twim_write_packet>
80006982:	18 97       	mov	r7,r12
	packet.length = buflen;
	packet.buffer = (void*)buf;
	status = twi_master_write (twi, &packet);
	if(status != STATUS_OK) {
80006984:	c0 81       	brne	80006994 <inic_write+0x30>
		LOG_ERR("twi_master_write fail, status=%d\n", status);
		return ERR_DRVI2C_WRITE;
	}

	DRVI2C_pv_TraceData(&packet, FALSE);
80006986:	1a 9c       	mov	r12,sp
80006988:	0e 9b       	mov	r11,r7
8000698a:	c7 3f       	rcall	80006870 <DRVI2C_pv_TraceData>
8000698c:	0e 9c       	mov	r12,r7
8000698e:	2f bd       	sub	sp,-20

	return ERR_NONE;
}
80006990:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006994:	1a dc       	st.w	--sp,r12
	packet.addr_length = 0;
	packet.length = buflen;
	packet.buffer = (void*)buf;
	status = twi_master_write (twi, &packet);
	if(status != STATUS_OK) {
		LOG_ERR("twi_master_write fail, status=%d\n", status);
80006996:	48 4c       	lddpc	r12,800069a4 <inic_write+0x40>
80006998:	e0 a0 88 a6 	rcall	80017ae4 <printf>
8000699c:	39 5c       	mov	r12,-107
8000699e:	2f fd       	sub	sp,-4
		return ERR_DRVI2C_WRITE;
800069a0:	cf 7b       	rjmp	8000698e <inic_write+0x2a>
800069a2:	d7 03       	nop
800069a4:	80 06       	ld.sh	r6,r0[0x0]
800069a6:	9f d0       	st.w	pc[0x34],r0

800069a8 <dac_read>:
800069a8:	eb cd 40 e0 	pushm	r5-r7,lr
800069ac:	20 5d       	sub	sp,20
800069ae:	34 88       	mov	r8,72
800069b0:	50 08       	stdsp	sp[0x0],r8
800069b2:	30 18       	mov	r8,1

	packet.chip = CODEC_ADDR;
	packet.addr_length = 1;
	packet.addr[0] = addr;
	packet.length = 1;
	packet.buffer = (void*)buf;
800069b4:	50 2c       	stdsp	sp[0x8],r12
	twi_package_t packet;
	status_code_t	status;

	packet.chip = CODEC_ADDR;
	packet.addr_length = 1;
	packet.addr[0] = addr;
800069b6:	ba ca       	st.b	sp[0x4],r10
	volatile avr32_twi_t *twi = &AVR32_TWIM0;
	twi_package_t packet;
	status_code_t	status;

	packet.chip = CODEC_ADDR;
	packet.addr_length = 1;
800069b8:	ba f8       	st.b	sp[0x7],r8
	packet.addr[0] = addr;
	packet.length = 1;
800069ba:	30 15       	mov	r5,1
 * \return STATUS_OK   If all bytes were read, error code otherwise
 */
static inline status_code_t twi_master_read (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
	return (twim_read_packet (twim, package));
800069bc:	fe 7c 38 00 	mov	r12,-51200
800069c0:	50 35       	stdsp	sp[0xc],r5
800069c2:	1a 9b       	mov	r11,sp
800069c4:	1a 96       	mov	r6,sp
800069c6:	fe b0 e4 3f 	rcall	80003244 <twim_read_packet>
800069ca:	18 97       	mov	r7,r12
	packet.buffer = (void*)buf;
	
	status = twi_master_read (twi, &packet);
	if(status != STATUS_OK) {
800069cc:	c0 81       	brne	800069dc <dac_read+0x34>
		LOG_ERR("twi_master_read fail, status=%d\n", status);
		return ERR_DRVI2C_READ;
	}
	
	DRVI2C_pv_TraceData(&packet,TRUE);
800069ce:	0a 9b       	mov	r11,r5
800069d0:	1a 9c       	mov	r12,sp
800069d2:	c4 ff       	rcall	80006870 <DRVI2C_pv_TraceData>
800069d4:	0e 9c       	mov	r12,r7
800069d6:	2f bd       	sub	sp,-20

	return ERR_NONE;

}
800069d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800069dc:	1a dc       	st.w	--sp,r12
	packet.length = 1;
	packet.buffer = (void*)buf;
	
	status = twi_master_read (twi, &packet);
	if(status != STATUS_OK) {
		LOG_ERR("twi_master_read fail, status=%d\n", status);
800069de:	48 4c       	lddpc	r12,800069ec <dac_read+0x44>
800069e0:	e0 a0 88 82 	rcall	80017ae4 <printf>
800069e4:	39 6c       	mov	r12,-106
800069e6:	2f fd       	sub	sp,-4
		return ERR_DRVI2C_READ;
800069e8:	cf 7b       	rjmp	800069d6 <dac_read+0x2e>
800069ea:	d7 03       	nop
800069ec:	80 06       	ld.sh	r6,r0[0x0]
800069ee:	9f f4       	st.w	pc[0x3c],r4

800069f0 <inic_read>:
800069f0:	eb cd 40 e0 	pushm	r5-r7,lr
800069f4:	20 5d       	sub	sp,20
800069f6:	32 08       	mov	r8,32
800069f8:	50 08       	stdsp	sp[0x0],r8
800069fa:	30 08       	mov	r8,0
	status_code_t	status;
    int16_t length;

	packet.chip = I2C_INIC_ADDR;
	packet.addr_length = 0;
	packet.length = buflen;	//PML Length
800069fc:	50 3b       	stdsp	sp[0xc],r11
 *    -# To-do item 1.
 *    -# To-do item 2.
 */
/*----------------------------------------------------------------------------*/
int16_t inic_read(uint8_t *buf, int buflen)
{
800069fe:	18 97       	mov	r7,r12
    int16_t length;

	packet.chip = I2C_INIC_ADDR;
	packet.addr_length = 0;
	packet.length = buflen;	//PML Length
	packet.buffer = (void*)buf;
80006a00:	50 2c       	stdsp	sp[0x8],r12
	twi_package_t packet;
	status_code_t	status;
    int16_t length;

	packet.chip = I2C_INIC_ADDR;
	packet.addr_length = 0;
80006a02:	ba f8       	st.b	sp[0x7],r8
80006a04:	fe 7c 38 00 	mov	r12,-51200
80006a08:	1a 9b       	mov	r11,sp
80006a0a:	1a 95       	mov	r5,sp
80006a0c:	fe b0 e4 1c 	rcall	80003244 <twim_read_packet>
80006a10:	18 96       	mov	r6,r12
	packet.length = buflen;	//PML Length
	packet.buffer = (void*)buf;
	status = twi_master_read (twi, &packet);
	if(status != STATUS_OK) {
80006a12:	c0 f1       	brne	80006a30 <inic_read+0x40>
		return ERR_DRVI2C_READ;
	}
	
	length = ((uint16_t)(buf[0]) << 8);
	length |= buf[1];	
	packet.length = length+2;
80006a14:	0f 98       	ld.ub	r8,r7[0x1]
	if(status != STATUS_OK) {
		LOG_ERR("twi_master_read fail, status=%d\n", status);
		return ERR_DRVI2C_READ;
	}
	
	length = ((uint16_t)(buf[0]) << 8);
80006a16:	ef 29 00 00 	ld.sb	r9,r7[0]
	length |= buf[1];	
	packet.length = length+2;
80006a1a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006a1e:	2f e8       	sub	r8,-2
	
	DRVI2C_pv_TraceData(&packet,TRUE);
80006a20:	1a 9c       	mov	r12,sp
		return ERR_DRVI2C_READ;
	}
	
	length = ((uint16_t)(buf[0]) << 8);
	length |= buf[1];	
	packet.length = length+2;
80006a22:	50 38       	stdsp	sp[0xc],r8
	
	DRVI2C_pv_TraceData(&packet,TRUE);
80006a24:	30 1b       	mov	r11,1
80006a26:	c2 5f       	rcall	80006870 <DRVI2C_pv_TraceData>
80006a28:	0c 9c       	mov	r12,r6
80006a2a:	2f bd       	sub	sp,-20

    return ERR_NONE;
}
80006a2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006a30:	1a dc       	st.w	--sp,r12
	packet.addr_length = 0;
	packet.length = buflen;	//PML Length
	packet.buffer = (void*)buf;
	status = twi_master_read (twi, &packet);
	if(status != STATUS_OK) {
		LOG_ERR("twi_master_read fail, status=%d\n", status);
80006a32:	48 4c       	lddpc	r12,80006a40 <inic_read+0x50>
80006a34:	e0 a0 88 58 	rcall	80017ae4 <printf>
80006a38:	39 6c       	mov	r12,-106
80006a3a:	2f fd       	sub	sp,-4
		return ERR_DRVI2C_READ;
80006a3c:	cf 7b       	rjmp	80006a2a <inic_read+0x3a>
80006a3e:	d7 03       	nop
80006a40:	80 06       	ld.sh	r6,r0[0x0]
80006a42:	9f f4       	st.w	pc[0x3c],r4

80006a44 <i2c_master_init>:
80006a44:	d4 01       	pushm	lr
80006a46:	30 2b       	mov	r11,2
80006a48:	48 5c       	lddpc	r12,80006a5c <i2c_master_init+0x18>
80006a4a:	e0 a0 0e 0b 	rcall	80008660 <gpio_enable_module>
80006a4e:	48 5b       	lddpc	r11,80006a60 <i2c_master_init+0x1c>
    
	// TWI gpio pins configuration
    gpio_enable_module(TWIM_GPIO_MAP, sizeof(TWIM_GPIO_MAP) / sizeof(TWIM_GPIO_MAP[0]));

    // initialize TWI driver with options
    status = twim_master_init(&AVR32_TWIM0, &TWIM_OPTIONS);
80006a50:	fe 7c 38 00 	mov	r12,-51200
80006a54:	fe b0 e4 7a 	rcall	80003348 <twim_master_init>
        LOG_ERR("ERROR - I2C init failed\r\n");
    }
	*/

    return status;
}
80006a58:	5c 8c       	casts.h	r12
80006a5a:	d8 02       	popm	pc
80006a5c:	80 06       	ld.sh	r6,r0[0x0]
80006a5e:	9f 98       	st.w	pc[0x24],r8
80006a60:	80 06       	ld.sh	r6,r0[0x0]
80006a62:	a0 18       	st.h	r0[0x2],r8

80006a64 <lld_start_interfaces>:

//#define HOLD_DUT_IN_RESET()	
//#define RELEASE_DUT_RESET()
void lld_start_interfaces (void)
{
	lld_running = TRUE;
80006a64:	48 39       	lddpc	r9,80006a70 <lld_start_interfaces+0xc>
80006a66:	30 18       	mov	r8,1
80006a68:	b2 88       	st.b	r9[0x0],r8
	lld_ready = TRUE;
80006a6a:	48 39       	lddpc	r9,80006a74 <lld_start_interfaces+0x10>
80006a6c:	b2 88       	st.b	r9[0x0],r8
}
80006a6e:	5e fc       	retal	r12
80006a70:	00 00       	add	r0,r0
80006a72:	40 e0       	lddsp	r0,sp[0x38]
80006a74:	00 00       	add	r0,r0
80006a76:	40 9c       	lddsp	r12,sp[0x24]

80006a78 <i2c_rx_callback>:
  * @see i2c_rx_ptr
  * @see i2c_enable_rx()
  * @see lld_i2c_rx_retry
  */
void i2c_rx_callback(void)
{
80006a78:	eb cd 40 fc 	pushm	r2-r7,lr
    if (lld_running)
80006a7c:	49 b8       	lddpc	r8,80006ae8 <i2c_rx_callback+0x70>
80006a7e:	11 89       	ld.ub	r9,r8[0x0]
80006a80:	30 08       	mov	r8,0
80006a82:	f0 09 18 00 	cp.b	r9,r8
80006a86:	c0 c1       	brne	80006a9e <i2c_rx_callback+0x26>
80006a88:	49 97       	lddpc	r7,80006aec <i2c_rx_callback+0x74>

    /* RX is going to be (re-)enabled if lld_start_interfaces() was not yet
     * called and we ignore incoming data or if we successfully copied the data
     * into a message buffer and gave it to PmsRx().
     */
    if (!lld_i2c_rx_retry)
80006a8a:	0f 89       	ld.ub	r9,r7[0x0]
80006a8c:	30 08       	mov	r8,0
80006a8e:	f0 09 18 00 	cp.b	r9,r8
80006a92:	c0 41       	brne	80006a9a <i2c_rx_callback+0x22>
    {
        lld_ready = TRUE;
80006a94:	30 19       	mov	r9,1
80006a96:	49 78       	lddpc	r8,80006af0 <i2c_rx_callback+0x78>
80006a98:	b0 89       	st.b	r8[0x0],r9
80006a9a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
{
    if (lld_running)
    {

        uint16_t size = ((i2c_pm_buff[0] << 8) | // PML + 2 is total size of message
                          i2c_pm_buff[1]) + 2;
80006a9e:	49 66       	lddpc	r6,80006af4 <i2c_rx_callback+0x7c>
80006aa0:	0d 98       	ld.ub	r8,r6[0x1]

        HMBMBUF handle = PmsGetRxBuf(size);

        lld_i2c_rx_retry = handle ? FALSE : TRUE; // if we got a buffer, retry will be FALSE - we can pass NS the message now
80006aa2:	49 37       	lddpc	r7,80006aec <i2c_rx_callback+0x74>
{
    if (lld_running)
    {

        uint16_t size = ((i2c_pm_buff[0] << 8) | // PML + 2 is total size of message
                          i2c_pm_buff[1]) + 2;
80006aa4:	0d 82       	ld.ub	r2,r6[0x0]
80006aa6:	f1 e2 10 82 	or	r2,r8,r2<<0x8
80006aaa:	5c 82       	casts.h	r2
80006aac:	e4 c3 ff fe 	sub	r3,r2,-2
80006ab0:	5c 83       	casts.h	r3

        HMBMBUF handle = PmsGetRxBuf(size);
80006ab2:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
80006ab6:	e0 a0 32 27 	rcall	8000cf04 <PmsGetRxBuf>

        lld_i2c_rx_retry = handle ? FALSE : TRUE; // if we got a buffer, retry will be FALSE - we can pass NS the message now
80006aba:	5f 05       	sreq	r5
80006abc:	ae 85       	st.b	r7[0x0],r5
    {

        uint16_t size = ((i2c_pm_buff[0] << 8) | // PML + 2 is total size of message
                          i2c_pm_buff[1]) + 2;

        HMBMBUF handle = PmsGetRxBuf(size);
80006abe:	18 94       	mov	r4,r12

        lld_i2c_rx_retry = handle ? FALSE : TRUE; // if we got a buffer, retry will be FALSE - we can pass NS the message now
        // if no buffer avail, retry is TRUE - we hold the message until NS has buffer
        // signaled by callback lld_on_buf_freed.
        if (!lld_i2c_rx_retry)
80006ac0:	58 05       	cp.w	r5,0
80006ac2:	ce c1       	brne	80006a9a <i2c_rx_callback+0x22>
        {
            uint8_t *src_ptr = i2c_pm_buff;
            uint8_t *tgt_ptr = MbmGetBufData(handle);
80006ac4:	e0 a0 1c f8 	rcall	8000a4b4 <MbmGetBufData>

            while (size) // copy message into NS buffer
80006ac8:	58 03       	cp.w	r3,0
80006aca:	c0 b0       	breq	80006ae0 <i2c_rx_callback+0x68>
  * @see lld_on_buf_freed()
  * @see i2c_rx_ptr
  * @see i2c_enable_rx()
  * @see lld_i2c_rx_retry
  */
void i2c_rx_callback(void)
80006acc:	2f f2       	sub	r2,-1
80006ace:	5c 72       	castu.h	r2
80006ad0:	2f f2       	sub	r2,-1
            uint8_t *src_ptr = i2c_pm_buff;
            uint8_t *tgt_ptr = MbmGetBufData(handle);

            while (size) // copy message into NS buffer
            {
                *(tgt_ptr++) = *(src_ptr++);
80006ad2:	ec 05 07 08 	ld.ub	r8,r6[r5]
80006ad6:	f8 05 0b 08 	st.b	r12[r5],r8
80006ada:	2f f5       	sub	r5,-1
        if (!lld_i2c_rx_retry)
        {
            uint8_t *src_ptr = i2c_pm_buff;
            uint8_t *tgt_ptr = MbmGetBufData(handle);

            while (size) // copy message into NS buffer
80006adc:	04 35       	cp.w	r5,r2
80006ade:	cf a1       	brne	80006ad2 <i2c_rx_callback+0x5a>
            {
                *(tgt_ptr++) = *(src_ptr++);
                size--;
            }

            PmsRx(handle); // tell NetServices it has a new message to handle
80006ae0:	08 9c       	mov	r12,r4
80006ae2:	e0 a0 30 b1 	rcall	8000cc44 <PmsRx>
80006ae6:	cd 2b       	rjmp	80006a8a <i2c_rx_callback+0x12>
80006ae8:	00 00       	add	r0,r0
80006aea:	40 e0       	lddsp	r0,sp[0x38]
80006aec:	00 00       	add	r0,r0
80006aee:	2b b4       	sub	r4,-69
80006af0:	00 00       	add	r0,r0
80006af2:	40 9c       	lddsp	r12,sp[0x24]
80006af4:	00 00       	add	r0,r0
80006af6:	40 a0       	lddsp	r0,sp[0x28]

80006af8 <check_for_port_message>:
80006af8:	eb cd 40 e0 	pushm	r5-r7,lr
80006afc:	49 18       	lddpc	r8,80006b40 <check_for_port_message+0x48>
80006afe:	11 89       	ld.ub	r9,r8[0x0]
80006b00:	30 08       	mov	r8,0
80006b02:	f0 09 18 00 	cp.b	r9,r8
 */
void check_for_port_message (void)
{
	s16_t pm_size;

	if (lld_running)										// NetServices ready to accept message
80006b06:	c0 60       	breq	80006b12 <check_for_port_message+0x1a>
	{
		if (lld_ready)										// not currently holding a previous message
80006b08:	48 f7       	lddpc	r7,80006b44 <check_for_port_message+0x4c>
80006b0a:	0f 89       	ld.ub	r9,r7[0x0]
80006b0c:	f0 09 18 00 	cp.b	r9,r8
80006b10:	c0 31       	brne	80006b16 <check_for_port_message+0x1e>
80006b12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		{
			if (DUT_INT_ASSERTED())	 			    // wait for INT to go low - INIC wants to talk to us
80006b16:	31 dc       	mov	r12,29
80006b18:	e0 a0 0d c3 	rcall	8000869e <gpio_get_pin_value>
80006b1c:	18 96       	mov	r6,r12
80006b1e:	cf a1       	brne	80006b12 <check_for_port_message+0x1a>
			{
				inic_read(i2c_pm_buff, sizeof(i2c_pm_buff));
80006b20:	48 a5       	lddpc	r5,80006b48 <check_for_port_message+0x50>
80006b22:	34 0b       	mov	r11,64
80006b24:	0a 9c       	mov	r12,r5
80006b26:	c6 5f       	rcall	800069f0 <inic_read>
80006b28:	0b 98       	ld.ub	r8,r5[0x1]
				pm_size = (i2c_pm_buff[0] << 8) | (i2c_pm_buff[1]);
80006b2a:	0b 89       	ld.ub	r9,r5[0x0]
80006b2c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006b30:	ec 08 19 00 	cp.h	r8,r6
80006b34:	fe 9a ff ef 	brle	80006b12 <check_for_port_message+0x1a>
80006b38:	ae 86       	st.b	r7[0x0],r6
				if (pm_size > 0 )							// if 0 or less, then we got an i2c error
				{
					lld_ready = FALSE;						// our i2c_pm_buffer is in use now - cleared when message passed on to NS
80006b3a:	c9 ff       	rcall	80006a78 <i2c_rx_callback>
					i2c_rx_callback ();
80006b3c:	ce bb       	rjmp	80006b12 <check_for_port_message+0x1a>
80006b3e:	d7 03       	nop
80006b40:	00 00       	add	r0,r0
80006b42:	40 e0       	lddsp	r0,sp[0x38]
80006b44:	00 00       	add	r0,r0
80006b46:	40 9c       	lddsp	r12,sp[0x24]
80006b48:	00 00       	add	r0,r0
80006b4a:	40 a0       	lddsp	r0,sp[0x28]

80006b4c <lld_on_buf_freed>:
80006b4c:	d4 01       	pushm	lr
80006b4e:	48 88       	lddpc	r8,80006b6c <lld_on_buf_freed+0x20>
80006b50:	11 89       	ld.ub	r9,r8[0x0]
80006b52:	30 08       	mov	r8,0
80006b54:	f0 09 18 00 	cp.b	r9,r8
80006b58:	c0 60       	breq	80006b64 <lld_on_buf_freed+0x18>
80006b5a:	48 69       	lddpc	r9,80006b70 <lld_on_buf_freed+0x24>

void lld_on_buf_freed(void)
{
    if (lld_running)
    {
        if (lld_i2c_rx_retry)					// do we have a buffer waiting to send to net services?
80006b5c:	13 89       	ld.ub	r9,r9[0x0]
80006b5e:	f0 09 18 00 	cp.b	r9,r8
80006b62:	c0 21       	brne	80006b66 <lld_on_buf_freed+0x1a>
80006b64:	d8 02       	popm	pc
		{
		    i2c_rx_callback();
80006b66:	c8 9f       	rcall	80006a78 <i2c_rx_callback>
80006b68:	d8 02       	popm	pc
80006b6a:	d7 03       	nop
80006b6c:	00 00       	add	r0,r0
80006b6e:	40 e0       	lddsp	r0,sp[0x38]
80006b70:	00 00       	add	r0,r0
80006b72:	2b b4       	sub	r4,-69

80006b74 <lld_i2c_transmit>:
80006b74:	eb cd 40 f8 	pushm	r3-r7,lr
  * @return TRUE if the message buffer is going to be transmitted, otherwise
  *         FALSE if for any reason a transmission is not possible now.
  *
  */
uint8_t lld_i2c_transmit(HMBMBUF handle, uint8_t *add_ptr, uint16_t add_size)
{
80006b78:	20 2d       	sub	sp,8
	uint16_t size;
    uint16_t length;

	success = FALSE;                                        //

	if (lld_running)
80006b7a:	4a 08       	lddpc	r8,80006bf8 <lld_i2c_transmit+0x84>
  * @return TRUE if the message buffer is going to be transmitted, otherwise
  *         FALSE if for any reason a transmission is not possible now.
  *
  */
uint8_t lld_i2c_transmit(HMBMBUF handle, uint8_t *add_ptr, uint16_t add_size)
{
80006b7c:	18 97       	mov	r7,r12
	uint16_t size;
    uint16_t length;

	success = FALSE;                                        //

	if (lld_running)
80006b7e:	11 89       	ld.ub	r9,r8[0x0]
80006b80:	30 08       	mov	r8,0
80006b82:	f0 09 18 00 	cp.b	r9,r8
80006b86:	c0 41       	brne	80006b8e <lld_i2c_transmit+0x1a>
  * @param  add_size is the size of the extra payload referenced by add_ptr.
  * @return TRUE if the message buffer is going to be transmitted, otherwise
  *         FALSE if for any reason a transmission is not possible now.
  *
  */
uint8_t lld_i2c_transmit(HMBMBUF handle, uint8_t *add_ptr, uint16_t add_size)
80006b88:	2f ed       	sub	sp,-8
80006b8a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
	success = FALSE;                                        //

	if (lld_running)
	{
		tgt_ptr = &i2c_temp_buff[0];                       // this is our local buffer
		size = MbmGetBufLength(handle);
80006b8e:	50 1b       	stdsp	sp[0x4],r11
80006b90:	50 0a       	stdsp	sp[0x0],r10
80006b92:	e0 a0 1c 6b 	rcall	8000a468 <MbmGetBufLength>
80006b96:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
		src_ptr = MbmGetBufData(handle);                    // pointer to NetServices copy of the message
80006b9a:	0e 9c       	mov	r12,r7
80006b9c:	e0 a0 1c 8c 	rcall	8000a4b4 <MbmGetBufData>
		copy_count = add_ptr ? 2 : 1;				        // copying 2 buffers or just 1?
80006ba0:	40 1b       	lddsp	r11,sp[0x4]
80006ba2:	40 0a       	lddsp	r10,sp[0x0]
80006ba4:	58 0b       	cp.w	r11,0
80006ba6:	f9 b4 01 02 	movne	r4,2
80006baa:	f9 b4 00 01 	moveq	r4,1
80006bae:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80006bb2:	49 3e       	lddpc	lr,80006bfc <lld_i2c_transmit+0x88>
80006bb4:	e7 da b0 10 	bfexts	r3,r10,0x0,0x10
		length = size + add_size;

		while (copy_count != 0)						        // copy all data into our own buffer
		{
			while (size != 0)
80006bb8:	58 05       	cp.w	r5,0
80006bba:	c0 d0       	breq	80006bd4 <lld_i2c_transmit+0x60>
  * @param  add_size is the size of the extra payload referenced by add_ptr.
  * @return TRUE if the message buffer is going to be transmitted, otherwise
  *         FALSE if for any reason a transmission is not possible now.
  *
  */
uint8_t lld_i2c_transmit(HMBMBUF handle, uint8_t *add_ptr, uint16_t add_size)
80006bbc:	20 15       	sub	r5,1
80006bbe:	30 08       	mov	r8,0
80006bc0:	5c 75       	castu.h	r5
80006bc2:	2f f5       	sub	r5,-1

		while (copy_count != 0)						        // copy all data into our own buffer
		{
			while (size != 0)
			{
				*(tgt_ptr++) = *(src_ptr++);
80006bc4:	f8 08 07 09 	ld.ub	r9,r12[r8]
80006bc8:	fc 08 0b 09 	st.b	lr[r8],r9
80006bcc:	2f f8       	sub	r8,-1
		copy_count = add_ptr ? 2 : 1;				        // copying 2 buffers or just 1?
		length = size + add_size;

		while (copy_count != 0)						        // copy all data into our own buffer
		{
			while (size != 0)
80006bce:	0a 38       	cp.w	r8,r5
80006bd0:	cf a1       	brne	80006bc4 <lld_i2c_transmit+0x50>
80006bd2:	10 0e       	add	lr,r8
			{
				*(tgt_ptr++) = *(src_ptr++);
				size--;
			}
			if (--copy_count)						        // if extra data, move src pointer and adjust size - copy additional data
80006bd4:	20 14       	sub	r4,1
80006bd6:	16 9c       	mov	r12,r11
80006bd8:	5c 54       	castu.b	r4
80006bda:	06 95       	mov	r5,r3
80006bdc:	ce e1       	brne	80006bb8 <lld_i2c_transmit+0x44>
			{
				src_ptr = add_ptr;
				size = add_size;
			}
		}
		inic_write(i2c_temp_buff, length);
80006bde:	ec 0a 00 0a 	add	r10,r6,r10
80006be2:	48 7c       	lddpc	r12,80006bfc <lld_i2c_transmit+0x88>
80006be4:	f7 da c0 10 	bfextu	r11,r10,0x0,0x10
80006be8:	cb ee       	rcall	80006964 <inic_write>
80006bea:	0e 9c       	mov	r12,r7
		PmsTxRelease(handle);                               // signal to NetServices that we're done with the message buffer
80006bec:	e0 a0 40 5e 	rcall	8000eca8 <PmsTxRelease>
80006bf0:	2f ed       	sub	sp,-8
80006bf2:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
80006bf6:	d7 03       	nop
80006bf8:	00 00       	add	r0,r0
80006bfa:	40 e0       	lddsp	r0,sp[0x38]
80006bfc:	00 00       	add	r0,r0
80006bfe:	40 e4       	lddsp	r4,sp[0x38]

80006c00 <lld_reset>:
80006c00:	d4 01       	pushm	lr
80006c02:	fe b0 e7 b1 	rcall	80003b64 <inic_HoldReset>
80006c06:	e1 b8 00 42 	mfsr	r8,0x108
80006c0a:	e0 6a 17 00 	mov	r10,5888
80006c0e:	ea 1a 00 11 	orh	r10,0x11
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006c12:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006c16:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006c1a:	14 38       	cp.w	r8,r10
80006c1c:	e0 88 00 0a 	brls	80006c30 <lld_reset+0x30>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006c20:	12 38       	cp.w	r8,r9
80006c22:	fe 98 ff fa 	brls	80006c16 <lld_reset+0x16>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006c26:	12 3a       	cp.w	r10,r9
80006c28:	cf 72       	brcc	80006c16 <lld_reset+0x16>

void lld_reset (void)
{
	HOLD_DUT_IN_RESET();
	delay_ms(70);
	RELEASE_DUT_RESET();
80006c2a:	fe b0 e7 8b 	rcall	80003b40 <inic_ReleaseReset>

}
80006c2e:	d8 02       	popm	pc
80006c30:	12 38       	cp.w	r8,r9
80006c32:	fe 98 ff fa 	brls	80006c26 <lld_reset+0x26>

void lld_reset (void)
{
	HOLD_DUT_IN_RESET();
	delay_ms(70);
	RELEASE_DUT_RESET();
80006c36:	fe b0 e7 85 	rcall	80003b40 <inic_ReleaseReset>

}
80006c3a:	d8 02       	popm	pc

80006c3c <TmrGetMasterTick_Long>:
*  RETURNS:		unsigned long MasterTick
*/
/*-------------------------------------------------------------------------------------------------------------------*/
u32_t TmrGetMasterTick_Long (void)
{
	return(MasterTick);
80006c3c:	48 28       	lddpc	r8,80006c44 <TmrGetMasterTick_Long+0x8>
80006c3e:	70 0c       	ld.w	r12,r8[0x0]
}
80006c40:	5e fc       	retal	r12
80006c42:	d7 03       	nop
80006c44:	00 00       	add	r0,r0
80006c46:	2b b8       	sub	r8,-69

80006c48 <TmrGetMasterTick_Word>:
*  RETURNS:		unsigned int MasterTick
*/
/*-------------------------------------------------------------------------------------------------------------------*/
uint16_t TmrGetMasterTick_Word (void)
{
	return( (uint16_t) MasterTick);
80006c48:	48 28       	lddpc	r8,80006c50 <TmrGetMasterTick_Word+0x8>
80006c4a:	70 0c       	ld.w	r12,r8[0x0]
}
80006c4c:	5c 8c       	casts.h	r12
80006c4e:	5e fc       	retal	r12
80006c50:	00 00       	add	r0,r0
80006c52:	2b b8       	sub	r8,-69

80006c54 <TmrTableInit>:
*  DESCRIPTION:	Sets all Timer slots to "Available" i.e. cleared
*  RETURNS:		Nothing
*/
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTableInit( void )
{
80006c54:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
	MaxTimersUsed = 0;
80006c58:	30 08       	mov	r8,0
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTableInit( void )
{
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
80006c5a:	30 a9       	mov	r9,10
80006c5c:	48 db       	lddpc	r11,80006c90 <TmrTableInit+0x3c>
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
80006c5e:	10 97       	mov	r7,r8
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTableInit( void )
{
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
80006c60:	b6 89       	st.b	r11[0x0],r9

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
		ptmr->TmrCount = 0;
80006c62:	30 0a       	mov	r10,0
void TmrTableInit( void )
{
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
	MaxTimersUsed = 0;
80006c64:	48 c9       	lddpc	r9,80006c94 <TmrTableInit+0x40>
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
		ptmr->TmrCount = 0;
		ptmr->TmrInit = 0;
		ptmr->TmrFlag = NULL;
80006c66:	30 0c       	mov	r12,0
void TmrTableInit( void )
{
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
	MaxTimersUsed = 0;
80006c68:	b2 88       	st.b	r9[0x0],r8
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
		ptmr->TmrCount = 0;
		ptmr->TmrInit = 0;
		ptmr->TmrFlag = NULL;
		if (NumTimersInUse > 0)
80006c6a:	16 96       	mov	r6,r11
void TmrTableInit( void )
{
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
	MaxTimersUsed = 0;
80006c6c:	48 b8       	lddpc	r8,80006c98 <TmrTableInit+0x44>
*  PARAMETERS:		None
*  DESCRIPTION:	Sets all Timer slots to "Available" i.e. cleared
*  RETURNS:		Nothing
*/
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTableInit( void )
80006c6e:	f0 ce ff 88 	sub	lr,r8,-120
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
80006c72:	b0 87       	st.b	r8[0x0],r7
		ptmr->TmrCount = 0;
80006c74:	b0 1a       	st.h	r8[0x2],r10
		ptmr->TmrInit = 0;
80006c76:	b0 2a       	st.h	r8[0x4],r10
		ptmr->TmrFlag = NULL;
80006c78:	91 2c       	st.w	r8[0x8],r12
		if (NumTimersInUse > 0)
80006c7a:	17 89       	ld.ub	r9,r11[0x0]
		{
			NumTimersInUse--;
80006c7c:	58 09       	cp.w	r9,0
80006c7e:	f7 b9 01 01 	subne	r9,1
80006c82:	ed f9 1e 00 	st.bne	r6[0x0],r9
80006c86:	2f 48       	sub	r8,-12
{
	uint8_t i;

	NumTimersInUse = MAX_TIMERS;
	MaxTimersUsed = 0;
	for (i=0; i<MAX_TIMERS ; i++ )
80006c88:	1c 38       	cp.w	r8,lr
80006c8a:	cf 41       	brne	80006c72 <TmrTableInit+0x1e>
	{
		TmrKill(i);                     // clears timer slot and decrements NumTimersInUse
	}
}
80006c8c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c90:	00 00       	add	r0,r0
80006c92:	41 9c       	lddsp	r12,sp[0x64]
80006c94:	00 00       	add	r0,r0
80006c96:	41 9d       	lddsp	sp,sp[0x64]
80006c98:	00 00       	add	r0,r0
80006c9a:	41 24       	lddsp	r4,sp[0x48]

80006c9c <TmrNewTime>:
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrNewTime (uint8_t tmr, uint16_t ticks)
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)                           // sanity check on parameter
80006c9c:	30 98       	mov	r8,9
80006c9e:	f0 0c 18 00 	cp.b	r12,r8
80006ca2:	5e bc       	rethi	r12
	{
		ptmr = &TmrTable[tmr];                      // pointer to timer slot
80006ca4:	48 78       	lddpc	r8,80006cc0 <TmrNewTime+0x24>
80006ca6:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80006caa:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
		if (ptmr->TmrStatus && TIMER_ACTIVE)        // make sure timer is in use
80006cae:	30 08       	mov	r8,0
80006cb0:	19 89       	ld.ub	r9,r12[0x0]
		{
			ptmr->TmrInit = ticks;                  // sets new init value
			ptmr->TmrCount = ticks;                 // AND essentially restarts time over at new value
80006cb2:	f0 09 18 00 	cp.b	r9,r8
80006cb6:	f9 fb 1c 01 	st.hne	r12[0x2],r11
	if (tmr < MAX_TIMERS)                           // sanity check on parameter
	{
		ptmr = &TmrTable[tmr];                      // pointer to timer slot
		if (ptmr->TmrStatus && TIMER_ACTIVE)        // make sure timer is in use
		{
			ptmr->TmrInit = ticks;                  // sets new init value
80006cba:	f9 fb 1c 02 	st.hne	r12[0x4],r11
80006cbe:	5e fc       	retal	r12
80006cc0:	00 00       	add	r0,r0
80006cc2:	41 24       	lddsp	r4,sp[0x48]

80006cc4 <TmrTicksLeft>:
{
	struct TIMER *ptmr;
	uint16_t time_left;

	time_left = 0xFFFF;                             // invalid timer count
	if (tmr < MAX_TIMERS)
80006cc4:	30 98       	mov	r8,9
80006cc6:	f0 0c 18 00 	cp.b	r12,r8
80006cca:	e0 8b 00 09 	brhi	80006cdc <TmrTicksLeft+0x18>
	{
		ptmr = &TmrTable[tmr];
		time_left = ptmr->TmrCount;
80006cce:	48 58       	lddpc	r8,80006ce0 <TmrTicksLeft+0x1c>
80006cd0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80006cd4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006cd8:	98 1c       	ld.sh	r12,r12[0x2]
	}
	return(time_left);

}
80006cda:	5e fc       	retal	r12
{
	struct TIMER *ptmr;
	uint16_t time_left;

	time_left = 0xFFFF;                             // invalid timer count
	if (tmr < MAX_TIMERS)
80006cdc:	5e fe       	retal	-1
80006cde:	d7 03       	nop
80006ce0:	00 00       	add	r0,r0
80006ce2:	41 24       	lddsp	r4,sp[0x48]

80006ce4 <TmrTask>:
*                  TIMER_PERIODIC, then the timer is started over
*  RETURNS:		Nothing
*/
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTask (void)
{
80006ce4:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t i;
	struct TIMER *ptmr;

	if (TimerTickDone)												// check flag to see if its time to update timers
80006ce8:	49 d9       	lddpc	r9,80006d5c <TmrTask+0x78>
80006cea:	13 88       	ld.ub	r8,r9[0x0]
80006cec:	58 08       	cp.w	r8,0
80006cee:	c2 a0       	breq	80006d42 <TmrTask+0x5e>
	{
		TimerTickDone = FALSE;										// reset flag for next tick
80006cf0:	49 ce       	lddpc	lr,80006d60 <TmrTask+0x7c>
80006cf2:	30 0c       	mov	r12,0
*                  TmrKill is called to free up that slot.  If the mode was
*                  TIMER_PERIODIC, then the timer is started over
*  RETURNS:		Nothing
*/
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTask (void)
80006cf4:	1c 98       	mov	r8,lr
	uint8_t i;
	struct TIMER *ptmr;

	if (TimerTickDone)												// check flag to see if its time to update timers
	{
		TimerTickDone = FALSE;										// reset flag for next tick
80006cf6:	fc cb ff fc 	sub	r11,lr,-4
80006cfa:	fc ca ff f8 	sub	r10,lr,-8
80006cfe:	b2 8c       	st.b	r9[0x0],r12
*                  TmrKill is called to free up that slot.  If the mode was
*                  TIMER_PERIODIC, then the timer is started over
*  RETURNS:		Nothing
*/
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrTask (void)
80006d00:	29 4e       	sub	lr,-108
				if (ptmr->TmrStatus & TIMER_ENABLE)				    // and if this timer slot is enabled
				{
					ptmr->TmrCount--;                               // decrement timer count
					if (ptmr->TmrCount == 0)                        // if its 0, then timer has expired
					{
						*ptmr->TmrFlag = TIMER_EXPIRED;             // set this timer's flag
80006d02:	30 27       	mov	r7,2
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
		ptmr->TmrCount = 0;
		ptmr->TmrInit = 0;
		ptmr->TmrFlag = NULL;
		if (NumTimersInUse > 0)
80006d04:	49 86       	lddpc	r6,80006d64 <TmrTask+0x80>
80006d06:	c0 68       	rjmp	80006d12 <TmrTask+0x2e>
		{
			NumTimersInUse--;
80006d08:	2f 4b       	sub	r11,-12
80006d0a:	2f 4a       	sub	r10,-12

	if (TimerTickDone)												// check flag to see if its time to update timers
	{
		TimerTickDone = FALSE;										// reset flag for next tick
		ptmr = &TmrTable[0];
		for (i=0; i<MAX_TIMERS ; i++ )
80006d0c:	1c 38       	cp.w	r8,lr
80006d0e:	c1 a0       	breq	80006d42 <TmrTask+0x5e>
							TmrKill(i);                             // release this timer slot
						}
					}
				}
			}
			ptmr++;                                                 // check next timer slot
80006d10:	2f 48       	sub	r8,-12
	{
		TimerTickDone = FALSE;										// reset flag for next tick
		ptmr = &TmrTable[0];
		for (i=0; i<MAX_TIMERS ; i++ )
		{
			if (ptmr->TmrStatus & TIMER_ACTIVE)                     // if this timer slot is used
80006d12:	11 89       	ld.ub	r9,r8[0x0]
80006d14:	f8 09 18 00 	cp.b	r9,r12
80006d18:	cf 84       	brge	80006d08 <TmrTask+0x24>
			{
				if (ptmr->TmrStatus & TIMER_ENABLE)				    // and if this timer slot is enabled
80006d1a:	ed b9 00 06 	bld	r9,0x6
80006d1e:	cf 51       	brne	80006d08 <TmrTask+0x24>
				{
					ptmr->TmrCount--;                               // decrement timer count
80006d20:	90 19       	ld.sh	r9,r8[0x2]
80006d22:	20 19       	sub	r9,1
80006d24:	5c 89       	casts.h	r9
80006d26:	b0 19       	st.h	r8[0x2],r9
					if (ptmr->TmrCount == 0)                        // if its 0, then timer has expired
80006d28:	cf 01       	brne	80006d08 <TmrTask+0x24>
					{
						*ptmr->TmrFlag = TIMER_EXPIRED;             // set this timer's flag
80006d2a:	74 09       	ld.w	r9,r10[0x0]
80006d2c:	b2 87       	st.b	r9[0x0],r7
						if (ptmr->TmrStatus & TIMER_PERIODIC)       // reset timer?
80006d2e:	11 89       	ld.ub	r9,r8[0x0]
80006d30:	e2 19 00 02 	andl	r9,0x2,COH
80006d34:	c0 90       	breq	80006d46 <TmrTask+0x62>
						{
							ptmr->TmrCount = ptmr->TmrInit;
80006d36:	96 09       	ld.sh	r9,r11[0x0]
80006d38:	b0 19       	st.h	r8[0x2],r9
		ptmr->TmrCount = 0;
		ptmr->TmrInit = 0;
		ptmr->TmrFlag = NULL;
		if (NumTimersInUse > 0)
		{
			NumTimersInUse--;
80006d3a:	2f 4b       	sub	r11,-12
80006d3c:	2f 4a       	sub	r10,-12

	if (TimerTickDone)												// check flag to see if its time to update timers
	{
		TimerTickDone = FALSE;										// reset flag for next tick
		ptmr = &TmrTable[0];
		for (i=0; i<MAX_TIMERS ; i++ )
80006d3e:	1c 38       	cp.w	r8,lr
80006d40:	ce 81       	brne	80006d10 <TmrTask+0x2c>
80006d42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
80006d46:	b0 8c       	st.b	r8[0x0],r12
		ptmr->TmrCount = 0;
80006d48:	b0 19       	st.h	r8[0x2],r9
		ptmr->TmrInit = 0;
80006d4a:	b6 09       	st.h	r11[0x0],r9
		ptmr->TmrFlag = NULL;
80006d4c:	95 09       	st.w	r10[0x0],r9
		if (NumTimersInUse > 0)
80006d4e:	0d 89       	ld.ub	r9,r6[0x0]
		{
			NumTimersInUse--;
80006d50:	58 09       	cp.w	r9,0
80006d52:	f7 b9 01 01 	subne	r9,1
80006d56:	ed f9 1e 00 	st.bne	r6[0x0],r9
80006d5a:	cd 7b       	rjmp	80006d08 <TmrTask+0x24>
80006d5c:	00 00       	add	r0,r0
80006d5e:	2b bc       	sub	r12,-69
80006d60:	00 00       	add	r0,r0
80006d62:	41 24       	lddsp	r4,sp[0x48]
80006d64:	00 00       	add	r0,r0
80006d66:	41 9c       	lddsp	r12,sp[0x64]

80006d68 <InitializeTimer>:
}


void InitializeTimer(TIMER_T *tmr)
{
	tmr->flag = TIMER_IDLE;                         // timer is not currently running
80006d68:	30 08       	mov	r8,0
80006d6a:	b8 98       	st.b	r12[0x1],r8
	tmr->handle = NO_SLOTS;                         // invalid handle
80006d6c:	3f f8       	mov	r8,-1
80006d6e:	b8 88       	st.b	r12[0x0],r8
}
80006d70:	5e fc       	retal	r12
80006d72:	d7 03       	nop

80006d74 <StopTimer>:
	return(result);
}

void StopTimer(TIMER_T *tmr)
{
	TmrKill(tmr->handle);                           // stop counting, get rid of timer of timer slot
80006d74:	19 88       	ld.ub	r8,r12[0x0]
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrKill (uint8_t tmr)
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
80006d76:	30 99       	mov	r9,9
80006d78:	f2 08 18 00 	cp.b	r8,r9
80006d7c:	e0 8b 00 14 	brhi	80006da4 <StopTimer+0x30>
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
		ptmr->TmrCount = 0;
80006d80:	30 09       	mov	r9,0
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
80006d82:	f0 08 00 18 	add	r8,r8,r8<<0x1
80006d86:	48 ba       	lddpc	r10,80006db0 <StopTimer+0x3c>
80006d88:	f4 08 00 28 	add	r8,r10,r8<<0x2
		ptmr->TmrStatus = TIMER_CLEAR;
80006d8c:	b0 89       	st.b	r8[0x0],r9
		ptmr->TmrCount = 0;
		ptmr->TmrInit = 0;
80006d8e:	b0 29       	st.h	r8[0x4],r9

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrStatus = TIMER_CLEAR;
		ptmr->TmrCount = 0;
80006d90:	b0 19       	st.h	r8[0x2],r9
		ptmr->TmrInit = 0;
		ptmr->TmrFlag = NULL;
80006d92:	30 09       	mov	r9,0
80006d94:	91 29       	st.w	r8[0x8],r9
		if (NumTimersInUse > 0)
80006d96:	48 88       	lddpc	r8,80006db4 <StopTimer+0x40>
80006d98:	11 89       	ld.ub	r9,r8[0x0]
		{
			NumTimersInUse--;
80006d9a:	58 09       	cp.w	r9,0
80006d9c:	f7 b9 01 01 	subne	r9,1
80006da0:	f1 f9 1e 00 	st.bne	r8[0x0],r9
}

void StopTimer(TIMER_T *tmr)
{
	TmrKill(tmr->handle);                           // stop counting, get rid of timer of timer slot
	tmr->flag = TIMER_IDLE;                         // timer is not running
80006da4:	30 08       	mov	r8,0
80006da6:	b8 98       	st.b	r12[0x1],r8
	tmr->handle = NO_SLOTS;                         // invalid handle
80006da8:	3f f8       	mov	r8,-1
80006daa:	b8 88       	st.b	r12[0x0],r8
}
80006dac:	5e fc       	retal	r12
80006dae:	d7 03       	nop
80006db0:	00 00       	add	r0,r0
80006db2:	41 24       	lddsp	r4,sp[0x48]
80006db4:	00 00       	add	r0,r0
80006db6:	41 9c       	lddsp	r12,sp[0x64]

80006db8 <TmrGetHandle>:
*  RETURNS:		Handle = index of first empty slot in timer table
*                  or 0xFF (NO_SLOTS) if all are busy
*/
/*-------------------------------------------------------------------------------------------------------------------*/
uint8_t TmrGetHandle ( void )
{
80006db8:	d4 01       	pushm	lr
80006dba:	30 0c       	mov	r12,0
80006dbc:	49 28       	lddpc	r8,80006e04 <TmrGetHandle+0x4c>
	ptmr = &TmrTable[0];
	timer_handle = NO_SLOTS;                        // assume we're all full

	for (i=0 ; i<MAX_TIMERS; i++)
	{
		if (ptmr->TmrStatus == TIMER_CLEAR)
80006dbe:	18 9b       	mov	r11,r12
	uint8_t timer_handle;

	ptmr = &TmrTable[0];
	timer_handle = NO_SLOTS;                        // assume we're all full

	for (i=0 ; i<MAX_TIMERS; i++)
80006dc0:	30 ae       	mov	lr,10
80006dc2:	c0 28       	rjmp	80006dc6 <TmrGetHandle+0xe>
	{
		if (ptmr->TmrStatus == TIMER_CLEAR)
		break;                                  // (make sure your compiler does not inc i when breaking out of loop!)
		ptmr++;                                     // next timer slot
80006dc4:	2f 48       	sub	r8,-12
	uint8_t timer_handle;

	ptmr = &TmrTable[0];
	timer_handle = NO_SLOTS;                        // assume we're all full

	for (i=0 ; i<MAX_TIMERS; i++)
80006dc6:	f8 ca ff ff 	sub	r10,r12,-1
	{
		if (ptmr->TmrStatus == TIMER_CLEAR)
80006dca:	11 89       	ld.ub	r9,r8[0x0]
80006dcc:	f6 09 18 00 	cp.b	r9,r11
80006dd0:	c0 c0       	breq	80006de8 <TmrGetHandle+0x30>
	uint8_t timer_handle;

	ptmr = &TmrTable[0];
	timer_handle = NO_SLOTS;                        // assume we're all full

	for (i=0 ; i<MAX_TIMERS; i++)
80006dd2:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80006dd6:	fc 0c 18 00 	cp.b	r12,lr
80006dda:	cf 51       	brne	80006dc4 <TmrGetHandle+0xc>
		DEBUG_PRINT_DECIMAL(NumTimersInUse, 3);
		DEBUG_PRINT_STRING(" timers currently in use\n");
		#endif
	}
	else
	LOG_ERR("No Timer Slots available\n");
80006ddc:	48 bc       	lddpc	r12,80006e08 <TmrGetHandle+0x50>
80006dde:	e0 a0 87 19 	rcall	80017c10 <puts>
80006de2:	e0 6c 00 ff 	mov	r12,255
80006de6:	d8 02       	popm	pc
	}

	if (i < MAX_TIMERS)                             // found an empty slot before the end?
	{
		timer_handle = i;                           // timer slot index is handle
		NumTimersInUse++;
80006de8:	48 99       	lddpc	r9,80006e0c <TmrGetHandle+0x54>
80006dea:	13 88       	ld.ub	r8,r9[0x0]
80006dec:	2f f8       	sub	r8,-1
80006dee:	b2 88       	st.b	r9[0x0],r8
		if (NumTimersInUse > MaxTimersUsed)
80006df0:	48 89       	lddpc	r9,80006e10 <TmrGetHandle+0x58>
80006df2:	13 8a       	ld.ub	r10,r9[0x0]
		MaxTimersUsed++;
80006df4:	f4 08 18 00 	cp.b	r8,r10
80006df8:	f7 ba 0b ff 	subhi	r10,-1
80006dfc:	f3 fa be 00 	st.bhi	r9[0x0],r10
	}
	else
	LOG_ERR("No Timer Slots available\n");

	return(timer_handle);
}
80006e00:	d8 02       	popm	pc
80006e02:	d7 03       	nop
80006e04:	00 00       	add	r0,r0
80006e06:	41 24       	lddsp	r4,sp[0x48]
80006e08:	80 06       	ld.sh	r6,r0[0x0]
80006e0a:	a0 30       	st.h	r0[0x6],r0
80006e0c:	00 00       	add	r0,r0
80006e0e:	41 9c       	lddsp	r12,sp[0x64]
80006e10:	00 00       	add	r0,r0
80006e12:	41 9d       	lddsp	sp,sp[0x64]

80006e14 <StartTimer>:
80006e14:	eb cd 40 b0 	pushm	r4-r5,r7,lr
	tmr->flag = TIMER_IDLE;                         // timer is not currently running
	tmr->handle = NO_SLOTS;                         // invalid handle
}

uint8_t StartTimer(TIMER_T *tmr, uint16_t time, uint8_t t_mode)
{
80006e18:	20 2d       	sub	sp,8
	uint8_t result = TRUE;

	if (TIMER_IDLE == tmr->flag)                    // sanity check - don't start another timer if its already running
80006e1a:	30 08       	mov	r8,0
	tmr->flag = TIMER_IDLE;                         // timer is not currently running
	tmr->handle = NO_SLOTS;                         // invalid handle
}

uint8_t StartTimer(TIMER_T *tmr, uint16_t time, uint8_t t_mode)
{
80006e1c:	18 97       	mov	r7,r12
	uint8_t result = TRUE;

	if (TIMER_IDLE == tmr->flag)                    // sanity check - don't start another timer if its already running
80006e1e:	19 99       	ld.ub	r9,r12[0x1]
80006e20:	f0 09 18 00 	cp.b	r9,r8
80006e24:	c2 f1       	brne	80006e82 <StartTimer+0x6e>
	{
		tmr->handle = TmrGetHandle();
80006e26:	50 1b       	stdsp	sp[0x4],r11
80006e28:	50 0a       	stdsp	sp[0x0],r10
80006e2a:	cc 7f       	rcall	80006db8 <TmrGetHandle>
80006e2c:	ae 8c       	st.b	r7[0x0],r12
80006e2e:	3f f8       	mov	r8,-1
		if (tmr->handle != NO_SLOTS)
80006e30:	40 1b       	lddsp	r11,sp[0x4]
80006e32:	40 0a       	lddsp	r10,sp[0x0]
80006e34:	f0 0c 18 00 	cp.b	r12,r8
80006e38:	c2 c0       	breq	80006e90 <StartTimer+0x7c>
80006e3a:	30 18       	mov	r8,1
		{
			tmr->flag = TIMER_RUNNING;              // init timer variable
80006e3c:	ae 98       	st.b	r7[0x1],r8
80006e3e:	30 99       	mov	r9,9
/*-------------------------------------------------------------------------------------------------------------------*/
void TmrStartTimer (uint8_t tmr, uint16_t ticks, uint8_t mode, uint8_t *tmr_flag)
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
80006e40:	f2 0c 18 00 	cp.b	r12,r9
80006e44:	e0 8b 00 1c 	brhi	80006e7c <StartTimer+0x68>
80006e48:	e0 69 cc cd 	mov	r9,52429
	{
		tmr->handle = TmrGetHandle();
		if (tmr->handle != NO_SLOTS)
		{
			tmr->flag = TIMER_RUNNING;              // init timer variable
			TmrStartTimer (tmr->handle, time/TIMER_TICK, t_mode, &tmr->flag);
80006e4c:	ea 19 cc cc 	orh	r9,0xcccc
80006e50:	eb db c0 10 	bfextu	r5,r11,0x0,0x10
80006e54:	ea 09 06 44 	mulu.d	r4,r5,r9
80006e58:	49 19       	lddpc	r9,80006e9c <StartTimer+0x88>
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
80006e5a:	f7 d5 b0 70 	bfexts	r11,r5,0x3,0x10
	{
		tmr->handle = TmrGetHandle();
		if (tmr->handle != NO_SLOTS)
		{
			tmr->flag = TIMER_RUNNING;              // init timer variable
			TmrStartTimer (tmr->handle, time/TIMER_TICK, t_mode, &tmr->flag);
80006e5e:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
80006e62:	ea 1a ff ff 	orh	r10,0xffff
		ptmr->TmrCount = ticks;
		ptmr->TmrInit = ticks;
		ptmr->TmrStatus = (TIMER_ACTIVE | TIMER_ENABLE | mode);
80006e66:	e8 1a ff c0 	orl	r10,0xffc0
80006e6a:	f2 0c 00 2c 	add	r12,r9,r12<<0x2
{
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
80006e6e:	ee c9 ff ff 	sub	r9,r7,-1
		ptmr->TmrCount = ticks;
		ptmr->TmrInit = ticks;
		ptmr->TmrStatus = (TIMER_ACTIVE | TIMER_ENABLE | mode);
		ptmr->TmrFlag = tmr_flag;
80006e72:	b8 2b       	st.h	r12[0x4],r11

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrCount = ticks;
		ptmr->TmrInit = ticks;
80006e74:	b8 8a       	st.b	r12[0x0],r10
		ptmr->TmrStatus = (TIMER_ACTIVE | TIMER_ENABLE | mode);
80006e76:	b8 1b       	st.h	r12[0x2],r11
	struct TIMER *ptmr;

	if (tmr < MAX_TIMERS)
	{
		ptmr = &TmrTable[tmr];
		ptmr->TmrCount = ticks;
80006e78:	99 29       	st.w	r12[0x8],r9
		ptmr->TmrInit = ticks;
		ptmr->TmrStatus = (TIMER_ACTIVE | TIMER_ENABLE | mode);
		ptmr->TmrFlag = tmr_flag;
80006e7a:	ae 98       	st.b	r7[0x1],r8
		*tmr_flag = TIMER_RUNNING;                  // user should do this before calling - MUST do it for periodic interrupts
80006e7c:	2f ed       	sub	sp,-8
80006e7e:	e3 cf 90 b0 	ldm	sp++,r4-r5,r7,pc,r12=1
80006e82:	48 8c       	lddpc	r12,80006ea0 <StartTimer+0x8c>
		}
	}
	else
	{
		result = FALSE;
		LOG_ERR("Timer is already running\n");
80006e84:	e0 a0 86 c6 	rcall	80017c10 <puts>
80006e88:	30 0c       	mov	r12,0
80006e8a:	2f ed       	sub	sp,-8
	}

	return(result);
}
80006e8c:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc
80006e90:	48 5c       	lddpc	r12,80006ea4 <StartTimer+0x90>
			TmrStartTimer (tmr->handle, time/TIMER_TICK, t_mode, &tmr->flag);
		}
		else
		{
			result = FALSE;
			LOG_ERR("No timer slots available\n");
80006e92:	e0 a0 86 bf 	rcall	80017c10 <puts>
80006e96:	30 0c       	mov	r12,0
80006e98:	cf 9b       	rjmp	80006e8a <StartTimer+0x76>
80006e9a:	d7 03       	nop
80006e9c:	00 00       	add	r0,r0
80006e9e:	41 24       	lddsp	r4,sp[0x48]
80006ea0:	80 06       	ld.sh	r6,r0[0x0]
80006ea2:	a0 68       	st.h	r0[0xc],r8
80006ea4:	80 06       	ld.sh	r6,r0[0x0]
80006ea6:	a0 4c       	st.h	r0[0x8],r12

80006ea8 <TmrInit>:
80006ea8:	eb cd 40 80 	pushm	r7,lr
80006eac:	30 0a       	mov	r10,0
80006eae:	e0 6b 04 20 	mov	r11,1056
		.lovrs = 0,
		.covfs = 0
	};
	
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&tc_irq, AMG_PLAYER_TC_IRQ, AMG_PLAYER_TC_IRQ_PRIORITY);
80006eb2:	fe cc ff 9e 	sub	r12,pc,-98
80006eb6:	e0 a0 0c 63 	rcall	8000877c <INTC_register_interrupt>
	
	TmrTableInit();                                 // init the timer blocks
80006eba:	30 07       	mov	r7,0
80006ebc:	cc ce       	rcall	80006c54 <TmrTableInit>
	MasterTick = 0;                                 // Starting time now
80006ebe:	49 18       	lddpc	r8,80006f00 <TmrInit+0x58>
80006ec0:	91 07       	st.w	r8[0x0],r7
	TimerTick = TIMER_TICK;                         // init count down timer for 10ms ticks
80006ec2:	49 18       	lddpc	r8,80006f04 <TmrInit+0x5c>
80006ec4:	30 a9       	mov	r9,10
80006ec6:	b0 89       	st.b	r8[0x0],r9
	TimerTickDone = FALSE;
80006ec8:	49 08       	lddpc	r8,80006f08 <TmrInit+0x60>

	// Initialize the timer/counter.
	tc_init_waveform(AMG_PLAYER_TC, &waveform_opt);
80006eca:	49 1b       	lddpc	r11,80006f0c <TmrInit+0x64>
	INTC_register_interrupt(&tc_irq, AMG_PLAYER_TC_IRQ, AMG_PLAYER_TC_IRQ_PRIORITY);
	
	TmrTableInit();                                 // init the timer blocks
	MasterTick = 0;                                 // Starting time now
	TimerTick = TIMER_TICK;                         // init count down timer for 10ms ticks
	TimerTickDone = FALSE;
80006ecc:	b0 87       	st.b	r8[0x0],r7

	// Initialize the timer/counter.
	tc_init_waveform(AMG_PLAYER_TC, &waveform_opt);
80006ece:	fc 7c 20 00 	mov	r12,-188416
80006ed2:	fe b0 df 53 	rcall	80002d78 <tc_init_waveform>
	 * Set the compare triggers.
	 * We configure it to count every 1 milliseconds.
	 * We want: (1 / (fPBA / 8)) * RC = 1 ms, hence RC = (fPBA / 8) / 1000
	 * to get an interrupt every 10 ms.
	 */
	tc_write_rc(AMG_PLAYER_TC, AMG_PLAYER_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 1000));
80006ed6:	0e 9b       	mov	r11,r7
80006ed8:	e0 6a 07 d0 	mov	r10,2000
80006edc:	fc 7c 20 00 	mov	r12,-188416
80006ee0:	fe b0 df ad 	rcall	80002e3a <tc_write_rc>
	// configure the timer interrupt
	tc_configure_interrupts(AMG_PLAYER_TC, AMG_PLAYER_TC_CHANNEL, &tc_interrupt);
80006ee4:	0e 9b       	mov	r11,r7
80006ee6:	48 ba       	lddpc	r10,80006f10 <TmrInit+0x68>
80006ee8:	fc 7c 20 00 	mov	r12,-188416
80006eec:	fe b0 df c3 	rcall	80002e72 <tc_configure_interrupts>
	// Start the timer/counter.
	tc_start(AMG_PLAYER_TC, AMG_PLAYER_TC_CHANNEL);	
80006ef0:	0e 9b       	mov	r11,r7
80006ef2:	fc 7c 20 00 	mov	r12,-188416
80006ef6:	fe b0 df 90 	rcall	80002e16 <tc_start>
}
80006efa:	e3 cd 80 80 	ldm	sp++,r7,pc
80006efe:	d7 03       	nop
80006f00:	00 00       	add	r0,r0
80006f02:	2b b8       	sub	r8,-69
80006f04:	00 00       	add	r0,r0
80006f06:	2b b5       	sub	r5,-69
80006f08:	00 00       	add	r0,r0
80006f0a:	2b bc       	sub	r12,-69
80006f0c:	80 06       	ld.sh	r6,r0[0x0]
80006f0e:	a0 28       	st.h	r0[0x4],r8
80006f10:	80 06       	ld.sh	r6,r0[0x0]
80006f12:	a0 84       	st.b	r0[0x0],r4

80006f14 <tc_irq>:
80006f14:	d4 01       	pushm	lr
80006f16:	48 c8       	lddpc	r8,80006f44 <tc_irq+0x30>
80006f18:	70 09       	ld.w	r9,r8[0x0]
80006f1a:	2f f9       	sub	r9,-1
80006f1c:	91 09       	st.w	r8[0x0],r9
80006f1e:	48 b8       	lddpc	r8,80006f48 <tc_irq+0x34>
80006f20:	11 89       	ld.ub	r9,r8[0x0]
80006f22:	20 19       	sub	r9,1
80006f24:	b0 89       	st.b	r8[0x0],r9
80006f26:	11 89       	ld.ub	r9,r8[0x0]
80006f28:	58 09       	cp.w	r9,0
80006f2a:	c0 61       	brne	80006f36 <tc_irq+0x22>
80006f2c:	30 a9       	mov	r9,10
80006f2e:	b0 89       	st.b	r8[0x0],r9
	MasterTick++;
	TimerTick--;
	if (TimerTick == 0)
	{
		TimerTick = TIMER_TICK;                     // re-initialize ticker
		TimerTickDone = TRUE;
80006f30:	30 19       	mov	r9,1
80006f32:	48 78       	lddpc	r8,80006f4c <tc_irq+0x38>
80006f34:	b0 89       	st.b	r8[0x0],r9
	}

	// clear the interrupt flag
	tc_read_sr(AMG_PLAYER_TC, AMG_PLAYER_TC_CHANNEL);
80006f36:	30 0b       	mov	r11,0
80006f38:	fc 7c 20 00 	mov	r12,-188416
80006f3c:	fe b0 df 76 	rcall	80002e28 <tc_read_sr>
}
80006f40:	d4 02       	popm	lr
80006f42:	d6 03       	rete
80006f44:	00 00       	add	r0,r0
80006f46:	2b b8       	sub	r8,-69
80006f48:	00 00       	add	r0,r0
80006f4a:	2b b5       	sub	r5,-69
80006f4c:	00 00       	add	r0,r0
80006f4e:	2b bc       	sub	r12,-69

80006f50 <MnsTraceInit>:
/*                                                                          */
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void MnsTraceInit(void)
{
80006f50:	e0 6a 80 00 	mov	r10,32768
80006f54:	49 0b       	lddpc	r11,80006f94 <MnsTraceInit+0x44>

    serviceTabPtr = T_Services;

    while (SRV_TERMINATION != serviceTabPtr->Service)
    {
        SetTraceFilter(serviceTabPtr->Service, serviceTabPtr->DefaultFilter);
80006f56:	76 3c       	ld.w	r12,r11[0xc]
    {
        serviceTabPtr = T_Services;                             /* go to start of services list */

        while (SRV_TERMINATION != serviceTabPtr->Service)       /* scan the services list */
        {
            if (serviceTabPtr->Service == service)              /* service found ? */
80006f58:	e0 4a 80 00 	cp.w	r10,32768
80006f5c:	c1 30       	breq	80006f82 <MnsTraceInit+0x32>
            {
                *(serviceTabPtr->ServiceFilter) = filter;       /* write filter mask */
80006f5e:	48 e8       	lddpc	r8,80006f94 <MnsTraceInit+0x44>
80006f60:	c0 38       	rjmp	80006f66 <MnsTraceInit+0x16>
    {
        serviceTabPtr = T_Services;                             /* go to start of services list */

        while (SRV_TERMINATION != serviceTabPtr->Service)       /* scan the services list */
        {
            if (serviceTabPtr->Service == service)              /* service found ? */
80006f62:	12 3a       	cp.w	r10,r9
80006f64:	c1 00       	breq	80006f84 <MnsTraceInit+0x34>
                *(serviceTabPtr->ServiceFilter) = filter;       /* write filter mask */
                return(MNS_TRUE);
            }
            else
            {
                serviceTabPtr++;                                /* go to next list entry */
80006f66:	2e c8       	sub	r8,-20

    if (0xFFFF != service)                                      /* SpecialFilter */
    {
        serviceTabPtr = T_Services;                             /* go to start of services list */

        while (SRV_TERMINATION != serviceTabPtr->Service)       /* scan the services list */
80006f68:	70 09       	ld.w	r9,r8[0x0]
80006f6a:	e0 49 ff ff 	cp.w	r9,65535
80006f6e:	cf a1       	brne	80006f62 <MnsTraceInit+0x12>
    serviceTabPtr = T_Services;

    while (SRV_TERMINATION != serviceTabPtr->Service)
    {
        SetTraceFilter(serviceTabPtr->Service, serviceTabPtr->DefaultFilter);
        serviceTabPtr++;
80006f70:	2e cb       	sub	r11,-20
{
    pTServices  serviceTabPtr;

    serviceTabPtr = T_Services;

    while (SRV_TERMINATION != serviceTabPtr->Service)
80006f72:	76 0a       	ld.w	r10,r11[0x0]
80006f74:	e0 4a ff ff 	cp.w	r10,65535
80006f78:	ce f1       	brne	80006f56 <MnsTraceInit+0x6>
        }
        return(MNS_FALSE);                                          /* service not found */
    }
    else
    {
        SpecialFilter = filter;
80006f7a:	30 09       	mov	r9,0
80006f7c:	48 78       	lddpc	r8,80006f98 <MnsTraceInit+0x48>
80006f7e:	91 09       	st.w	r8[0x0],r9
    {
        SetTraceFilter(serviceTabPtr->Service, serviceTabPtr->DefaultFilter);
        serviceTabPtr++;
    }
    SetTraceFilter(SRV_TERMINATION, 0);                     /* filter all special items out*/
}
80006f80:	5e fc       	retal	r12
    {
        serviceTabPtr = T_Services;                             /* go to start of services list */

        while (SRV_TERMINATION != serviceTabPtr->Service)       /* scan the services list */
        {
            if (serviceTabPtr->Service == service)              /* service found ? */
80006f82:	48 58       	lddpc	r8,80006f94 <MnsTraceInit+0x44>
            {
                *(serviceTabPtr->ServiceFilter) = filter;       /* write filter mask */
80006f84:	70 28       	ld.w	r8,r8[0x8]
80006f86:	91 0c       	st.w	r8[0x0],r12
    serviceTabPtr = T_Services;

    while (SRV_TERMINATION != serviceTabPtr->Service)
    {
        SetTraceFilter(serviceTabPtr->Service, serviceTabPtr->DefaultFilter);
        serviceTabPtr++;
80006f88:	2e cb       	sub	r11,-20
{
    pTServices  serviceTabPtr;

    serviceTabPtr = T_Services;

    while (SRV_TERMINATION != serviceTabPtr->Service)
80006f8a:	76 0a       	ld.w	r10,r11[0x0]
80006f8c:	e0 4a ff ff 	cp.w	r10,65535
80006f90:	ce 31       	brne	80006f56 <MnsTraceInit+0x6>
80006f92:	cf 4b       	rjmp	80006f7a <MnsTraceInit+0x2a>
80006f94:	80 06       	ld.sh	r6,r0[0x0]
80006f96:	b0 f4       	st.b	r8[0x7],r4
80006f98:	00 00       	add	r0,r0
80006f9a:	41 b8       	lddsp	r8,sp[0x6c]

80006f9c <MnsTraceSpecialFilter>:
byte MnsTraceSpecialFilter(int service, int event, int num_parm, int *params)
{
    (void) service;
    (void) event;
    if (!(SpecialFilter & FILT_INIC_WATCHDOG)
        && (6 == num_parm)
80006f9c:	58 6a       	cp.w	r10,6
80006f9e:	5f 08       	sreq	r8
/*--------------------------------------------------------------------------*/
byte MnsTraceSpecialFilter(int service, int event, int num_parm, int *params)
{
    (void) service;
    (void) event;
    if (!(SpecialFilter & FILT_INIC_WATCHDOG)
80006fa0:	48 ea       	lddpc	r10,80006fd8 <MnsTraceSpecialFilter+0x3c>
80006fa2:	74 0a       	ld.w	r10,r10[0x0]
80006fa4:	14 9b       	mov	r11,r10
80006fa6:	ec 1b 00 01 	eorl	r11,0x1
80006faa:	10 6b       	and	r11,r8
80006fac:	c0 80       	breq	80006fbc <MnsTraceSpecialFilter+0x20>
        && (6 == num_parm)
        && (FBLOCK_INIC          == params[1])
80006fae:	72 1c       	ld.w	r12,r9[0x4]
80006fb0:	58 0c       	cp.w	r12,0
80006fb2:	c0 51       	brne	80006fbc <MnsTraceSpecialFilter+0x20>
        && (FUNCID_INIC_WATCHDOG == params[3]))
80006fb4:	72 3b       	ld.w	r11,r9[0xc]
80006fb6:	e0 4b 03 09 	cp.w	r11,777
80006fba:	5e 0c       	reteq	r12
    {
        return(MNS_FALSE);
    }

    if (  !(SpecialFilter & FILT_INIC_TIMER)
80006fbc:	ec 1a 00 02 	eorl	r10,0x2
80006fc0:	f1 ea 02 18 	and	r8,r8,r10>>0x1
80006fc4:	c0 90       	breq	80006fd6 <MnsTraceSpecialFilter+0x3a>
        && (6 == num_parm)
        && (FBLOCK_INIC       == params[1])
80006fc6:	72 18       	ld.w	r8,r9[0x4]
80006fc8:	58 08       	cp.w	r8,0
80006fca:	c0 61       	brne	80006fd6 <MnsTraceSpecialFilter+0x3a>
80006fcc:	72 38       	ld.w	r8,r9[0xc]
80006fce:	e0 48 02 02 	cp.w	r8,514
80006fd2:	5f 1c       	srne	r12
80006fd4:	5e fc       	retal	r12
80006fd6:	5e ff       	retal	1
80006fd8:	00 00       	add	r0,r0
80006fda:	41 b8       	lddsp	r8,sp[0x6c]

80006fdc <MnsTraceParser>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void MnsTraceParser( int service, int event, unsigned long timestamp,
                        int num_parm, int *params )
{
80006fdc:	d4 31       	pushm	r0-r7,lr
80006fde:	fa cd 01 4c 	sub	sp,sp,332
80006fe2:	10 95       	mov	r5,r8
    unsigned char printLine;
    unsigned char printError;
    unsigned char exitFlag;


    *lineout      = '\0';
80006fe4:	30 08       	mov	r8,0
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void MnsTraceParser( int service, int event, unsigned long timestamp,
                        int num_parm, int *params )
{
80006fe6:	12 97       	mov	r7,r9
80006fe8:	14 92       	mov	r2,r10
80006fea:	18 96       	mov	r6,r12
80006fec:	16 94       	mov	r4,r11
    unsigned char printLine;
    unsigned char printError;
    unsigned char exitFlag;


    *lineout      = '\0';
80006fee:	fb 68 00 20 	st.b	sp[32],r8
    serviceTabPtr = T_Services;

    /*--------------------------------------------------------------------------*/
    /* check for special filters*/
    /*--------------------------------------------------------------------------*/
    if (MNS_FALSE == MnsTraceSpecialFilter(service, event, num_parm, params))
80006ff2:	0a 99       	mov	r9,r5
80006ff4:	0e 9a       	mov	r10,r7
80006ff6:	cd 3f       	rcall	80006f9c <MnsTraceSpecialFilter>
80006ff8:	58 06       	cp.w	r6,0
    }

    /*--------------------------------------------------------------------------*/
    /* search for service*/
    /*--------------------------------------------------------------------------*/
    if (MNS_P_NONE == service)
80006ffa:	c1 90       	breq	8000702c <MnsTraceParser+0x50>
80006ffc:	58 0c       	cp.w	r12,0
        ADD_TIMESTAMP();
        ADD_ERROR("ERROR %s", "Service not defined!");
        exitFlag  = MNS_TRUE;                                                   /* abort parsing*/
    }

    if (!exitFlag)
80006ffe:	c1 30       	breq	80007024 <MnsTraceParser+0x48>
80007000:	fe f3 08 bc 	ld.w	r3,pc[2236]
80007004:	66 08       	ld.w	r8,r3[0x0]
    {
        while (!found && (SRV_TERMINATION != serviceTabPtr->Service))       /* scan the services list*/
80007006:	e0 48 ff ff 	cp.w	r8,65535
8000700a:	c3 20       	breq	8000706e <MnsTraceParser+0x92>
8000700c:	10 36       	cp.w	r6,r8
        {
            if (serviceTabPtr->Service == service)                          /* service found?*/
8000700e:	c0 d1       	brne	80007028 <MnsTraceParser+0x4c>
80007010:	e8 c8 00 01 	sub	r8,r4,1
    /* search for event*/
    /*--------------------------------------------------------------------------*/
    if (!exitFlag)
    {
        found = MNS_FALSE;
        if (*serviceTabPtr->ServiceFilter & (0x00000001 << (event-1)))      /*  event enabled ? */
80007014:	30 19       	mov	r9,1
80007016:	f2 08 09 49 	lsl	r9,r9,r8
8000701a:	66 28       	ld.w	r8,r3[0x8]
8000701c:	70 08       	ld.w	r8,r8[0x0]
8000701e:	f3 e8 00 08 	and	r8,r9,r8
80007022:	c4 01       	brne	800070a2 <MnsTraceParser+0xc6>
80007024:	2a dd       	sub	sp,-332
    {
        PrintTraceLine(lineout);
    }


}
80007026:	d8 32       	popm	r0-r7,pc
80007028:	2e c3       	sub	r3,-20
            if (serviceTabPtr->Service == service)                          /* service found?*/
            {
                found = MNS_TRUE;
            }
            else
                serviceTabPtr++;
8000702a:	ce db       	rjmp	80007004 <MnsTraceParser+0x28>
8000702c:	1a d2       	st.w	--sp,r2
    /*--------------------------------------------------------------------------*/
    /* search for service*/
    /*--------------------------------------------------------------------------*/
    if (MNS_P_NONE == service)
    {
        ADD_TIMESTAMP();
8000702e:	fe fb 08 92 	ld.w	r11,pc[2194]
80007032:	fa c7 ff 14 	sub	r7,sp,-236
80007036:	0e 9c       	mov	r12,r7
80007038:	e0 a0 87 1e 	rcall	80017e74 <sprintf>
8000703c:	fa c6 ff dc 	sub	r6,sp,-36
80007040:	0e 9b       	mov	r11,r7
80007042:	0c 9c       	mov	r12,r6
80007044:	e0 a0 87 76 	rcall	80017f30 <strcat>
80007048:	fe f8 08 7c 	ld.w	r8,pc[2172]
        ADD_ERROR("ERROR %s", "Service not defined!");
8000704c:	fe fb 08 7c 	ld.w	r11,pc[2172]
80007050:	1a d8       	st.w	--sp,r8
80007052:	0e 9c       	mov	r12,r7
80007054:	e0 a0 87 10 	rcall	80017e74 <sprintf>
80007058:	0e 9b       	mov	r11,r7
8000705a:	0c 9c       	mov	r12,r6
8000705c:	e0 a0 87 6a 	rcall	80017f30 <strcat>
80007060:	2f ed       	sub	sp,-8
80007062:	fa cc ff e0 	sub	r12,sp,-32
        }
    }

    if (printError)
    {
        PrintErrorLine(lineout);
80007066:	e0 a0 05 2b 	rcall	80007abc <PrintErrorLine>
8000706a:	2a dd       	sub	sp,-332
    {
        PrintTraceLine(lineout);
    }


}
8000706c:	d8 32       	popm	r0-r7,pc
8000706e:	1a d2       	st.w	--sp,r2
            else
                serviceTabPtr++;
        }
        if (!found)
        {
            ADD_TIMESTAMP();
80007070:	fe fb 08 50 	ld.w	r11,pc[2128]
80007074:	fa c7 ff 14 	sub	r7,sp,-236
80007078:	0e 9c       	mov	r12,r7
8000707a:	e0 a0 86 fd 	rcall	80017e74 <sprintf>
8000707e:	fa c5 ff dc 	sub	r5,sp,-36
80007082:	0e 9b       	mov	r11,r7
80007084:	0a 9c       	mov	r12,r5
80007086:	e0 a0 87 55 	rcall	80017f30 <strcat>
8000708a:	fe fb 08 42 	ld.w	r11,pc[2114]
            ADD_ERROR("ERROR Unknown service: 0x%04x", service);
8000708e:	1a d6       	st.w	--sp,r6
80007090:	0e 9c       	mov	r12,r7
80007092:	e0 a0 86 f1 	rcall	80017e74 <sprintf>
80007096:	0e 9b       	mov	r11,r7
80007098:	0a 9c       	mov	r12,r5
8000709a:	e0 a0 87 4b 	rcall	80017f30 <strcat>
8000709e:	2f ed       	sub	sp,-8
800070a0:	ce 1b       	rjmp	80007062 <MnsTraceParser+0x86>
800070a2:	1a d2       	st.w	--sp,r2
    if (!exitFlag)
    {
        found = MNS_FALSE;
        if (*serviceTabPtr->ServiceFilter & (0x00000001 << (event-1)))      /*  event enabled ? */
        {
            ADD_TIMESTAMP();
800070a4:	fe fb 08 1c 	ld.w	r11,pc[2076]
800070a8:	fa c2 ff 14 	sub	r2,sp,-236
800070ac:	04 9c       	mov	r12,r2
800070ae:	e0 a0 86 e3 	rcall	80017e74 <sprintf>
800070b2:	fa c0 ff dc 	sub	r0,sp,-36
800070b6:	04 9b       	mov	r11,r2
800070b8:	00 9c       	mov	r12,r0
800070ba:	e0 a0 87 3b 	rcall	80017f30 <strcat>
800070be:	66 4b       	ld.w	r11,r3[0x10]
            ADD_STRING("%s",    serviceTabPtr->ServiceName);               /* service name*/
800070c0:	04 9c       	mov	r12,r2
800070c2:	e0 a0 87 48 	rcall	80017f52 <strcpy>
800070c6:	04 9b       	mov	r11,r2
800070c8:	00 9c       	mov	r12,r0
800070ca:	e0 a0 87 33 	rcall	80017f30 <strcat>
800070ce:	fe f8 08 02 	ld.w	r8,pc[2050]
800070d2:	2f fd       	sub	sp,-4
800070d4:	70 09       	ld.w	r9,r8[0x0]
            eventTabPtr = T_Events;
            while (!found && (EV_TERMINATION != eventTabPtr->Event))    /* scan the event list */
800070d6:	e0 49 ff ff 	cp.w	r9,65535
800070da:	c0 80       	breq	800070ea <MnsTraceParser+0x10e>
800070dc:	12 34       	cp.w	r4,r9
            {
                if (eventTabPtr->Event == event)                        /*  event found */
800070de:	c1 70       	breq	8000710c <MnsTraceParser+0x130>
800070e0:	2f 48       	sub	r8,-12
                    found = MNS_TRUE;
                    parmListPtr = eventTabPtr->ParmList;                /* get parameter list */
                }
                else
                {
                    eventTabPtr++;
800070e2:	70 09       	ld.w	r9,r8[0x0]
        if (*serviceTabPtr->ServiceFilter & (0x00000001 << (event-1)))      /*  event enabled ? */
        {
            ADD_TIMESTAMP();
            ADD_STRING("%s",    serviceTabPtr->ServiceName);               /* service name*/
            eventTabPtr = T_Events;
            while (!found && (EV_TERMINATION != eventTabPtr->Event))    /* scan the event list */
800070e4:	e0 49 ff ff 	cp.w	r9,65535
800070e8:	cf a1       	brne	800070dc <MnsTraceParser+0x100>
800070ea:	1a d4       	st.w	--sp,r4
        /*-------------------------------------------------------------------------- */
        if (!exitFlag)
        {
            if (!found)
            {
                ADD_STRING("unknown event: 0x%04X", event);                     /* event not found in list */
800070ec:	fe fb 07 e8 	ld.w	r11,pc[2024]
800070f0:	04 9c       	mov	r12,r2
800070f2:	e0 a0 86 c1 	rcall	80017e74 <sprintf>
800070f6:	04 9b       	mov	r11,r2
800070f8:	00 9c       	mov	r12,r0
800070fa:	e0 a0 87 1b 	rcall	80017f30 <strcat>
800070fe:	2f fd       	sub	sp,-4
80007100:	fa cc ff e0 	sub	r12,sp,-32
    {
        PrintErrorLine(lineout);
    }
    else if (printLine)
    {
        PrintTraceLine(lineout);
80007104:	e0 a0 04 e0 	rcall	80007ac4 <PrintTraceLine>
80007108:	2a dd       	sub	sp,-332
    }


}
8000710a:	d8 32       	popm	r0-r7,pc
8000710c:	70 2b       	ld.w	r11,r8[0x8]
            {
                ADD_STRING("unknown event: 0x%04X", event);                     /* event not found in list */
            }
            else
            {
                ADD_STRING("%s", eventTabPtr->FormatString);
8000710e:	70 14       	ld.w	r4,r8[0x4]
            while (!found && (EV_TERMINATION != eventTabPtr->Event))    /* scan the event list */
            {
                if (eventTabPtr->Event == event)                        /*  event found */
                {
                    found = MNS_TRUE;
                    parmListPtr = eventTabPtr->ParmList;                /* get parameter list */
80007110:	04 9c       	mov	r12,r2
            {
                ADD_STRING("unknown event: 0x%04X", event);                     /* event not found in list */
            }
            else
            {
                ADD_STRING("%s", eventTabPtr->FormatString);
80007112:	e0 a0 87 20 	rcall	80017f52 <strcpy>
80007116:	04 9b       	mov	r11,r2
80007118:	00 9c       	mov	r12,r0
8000711a:	e0 a0 87 0b 	rcall	80017f30 <strcat>
8000711e:	58 07       	cp.w	r7,0
                if (num_parm != 0)
80007120:	cf 00       	breq	80007100 <MnsTraceParser+0x124>
80007122:	fe 9a ff ef 	brle	80007100 <MnsTraceParser+0x124>
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
80007126:	30 09       	mov	r9,0
80007128:	50 63       	stdsp	sp[0x18],r3
8000712a:	50 29       	stdsp	sp[0x8],r9
8000712c:	50 49       	stdsp	sp[0x10],r9
8000712e:	50 59       	stdsp	sp[0x14],r9
80007130:	50 39       	stdsp	sp[0xc],r9
80007132:	50 17       	stdsp	sp[0x4],r7
80007134:	2f c4       	sub	r4,-4
80007136:	12 91       	mov	r1,r9
80007138:	6a 07       	ld.w	r7,r5[0x0]
                    {
                        parm = *params;
8000713a:	e8 f8 ff fc 	ld.w	r8,r4[-4]
                        switch (parmListPtr->ItemType)
8000713e:	58 f8       	cp.w	r8,15
80007140:	e0 80 00 de 	breq	800072fc <MnsTraceParser+0x320>
80007144:	58 f8       	cp.w	r8,15
80007146:	e0 89 00 30 	brgt	800071a6 <MnsTraceParser+0x1ca>
8000714a:	58 88       	cp.w	r8,8
8000714c:	e0 80 02 b2 	breq	800076b0 <MnsTraceParser+0x6d4>
80007150:	e0 89 00 70 	brgt	80007230 <MnsTraceParser+0x254>
80007154:	58 48       	cp.w	r8,4
80007156:	e0 80 02 92 	breq	8000767a <MnsTraceParser+0x69e>
8000715a:	e0 8a 01 44 	brle	800073e2 <MnsTraceParser+0x406>
8000715e:	58 68       	cp.w	r8,6
80007160:	e0 80 01 6c 	breq	80007438 <MnsTraceParser+0x45c>
80007164:	58 78       	cp.w	r8,7
80007166:	e0 81 00 a0 	brne	800072a6 <MnsTraceParser+0x2ca>
8000716a:	fe f8 07 6e 	ld.w	r8,pc[1902]
                                break;

                            /*------------------------------------------------*/
                            case TY_P_EVENT:
                                ADD_STRING(parmListPtr->FormatString, parm);
                                break;
8000716e:	50 48       	stdsp	sp[0x10],r8
80007170:	10 9a       	mov	r10,r8
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to the entry */
        }
        list++;
    }
    while (!found && STR_TERMINATION != num);       /* found or end of list ? */
80007172:	30 09       	mov	r9,0
80007174:	94 88       	ld.uh	r8,r10[0x0]
    ret = NULL;
    found = MNS_FALSE;

    do
    {
        num = list->fbNum;                          /* read fblock number from list */
80007176:	10 37       	cp.w	r7,r8
        if (num == fblock)                          /* item found ?                 */
80007178:	c0 c0       	breq	80007190 <MnsTraceParser+0x1b4>
8000717a:	e0 48 ff ff 	cp.w	r8,65535
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to the entry */
        }
        list++;
    }
    while (!found && STR_TERMINATION != num);       /* found or end of list ? */
8000717e:	5f 18       	srne	r8
80007180:	f2 08 18 00 	cp.b	r8,r9
80007184:	e0 80 03 54 	breq	8000782c <MnsTraceParser+0x850>
80007188:	2f 4a       	sub	r10,-12
        if (num == fblock)                          /* item found ?                 */
        {
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to the entry */
        }
        list++;
8000718a:	94 88       	ld.uh	r8,r10[0x0]
    ret = NULL;
    found = MNS_FALSE;

    do
    {
        num = list->fbNum;                          /* read fblock number from list */
8000718c:	10 37       	cp.w	r7,r8
        if (num == fblock)                          /* item found ?                 */
8000718e:	cf 61       	brne	8000717a <MnsTraceParser+0x19e>
80007190:	50 4a       	stdsp	sp[0x10],r10
80007192:	58 0a       	cp.w	r10,0
                                ADD_STRING(parmListPtr->FormatString, parm);
                                break;

                            /*------------------------------------------------*/
                            case TY_P_FBLOCK:
                                if (NULL != (pFblock = GetFBlock(FBlockList, parm)))
80007194:	e0 80 03 4e 	breq	80007830 <MnsTraceParser+0x854>
80007198:	74 18       	ld.w	r8,r10[0x4]

                            /*------------------------------------------------*/
                            case TY_P_STATEMACHINE:
                                if (NULL != (pStateM = GetStateM(StateMList, parm)))
                                {
                                    ADD_STRING(parmListPtr->FormatString, pStateM->name);
8000719a:	2f f1       	sub	r1,-1
8000719c:	1a d8       	st.w	--sp,r8
8000719e:	2f c5       	sub	r5,-4
800071a0:	04 9c       	mov	r12,r2
800071a2:	68 0b       	ld.w	r11,r4[0x0]
800071a4:	c2 d9       	rjmp	800073fe <MnsTraceParser+0x422>
800071a6:	59 58       	cp.w	r8,21
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
800071a8:	e0 80 02 a5 	breq	800076f2 <MnsTraceParser+0x716>
800071ac:	e0 89 00 67 	brgt	8000727a <MnsTraceParser+0x29e>
800071b0:	59 28       	cp.w	r8,18
800071b2:	e0 80 02 27 	breq	80007600 <MnsTraceParser+0x624>
800071b6:	e0 8a 00 e7 	brle	80007384 <MnsTraceParser+0x3a8>
800071ba:	59 38       	cp.w	r8,19
800071bc:	e0 80 01 4f 	breq	8000745a <MnsTraceParser+0x47e>
800071c0:	59 48       	cp.w	r8,20
800071c2:	c7 21       	brne	800072a6 <MnsTraceParser+0x2ca>
800071c4:	58 07       	cp.w	r7,0
                                {
                                    int tmp = 0;
                                    int pos = 0;
                                    bool first = MNS_TRUE;

                                    while(parm)
800071c6:	e0 80 01 2e 	breq	80007422 <MnsTraceParser+0x446>
800071ca:	30 08       	mov	r8,0
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown service 0x%04X].", parm);
800071cc:	50 71       	stdsp	sp[0x1c],r1
                                    int pos = 0;
                                    bool first = MNS_TRUE;

                                    while(parm)
                                    {
                                        tmp = (1 << pos) & parm;
800071ce:	30 19       	mov	r9,1
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown service 0x%04X].", parm);
800071d0:	0a 91       	mov	r1,r5
                                    int pos = 0;
                                    bool first = MNS_TRUE;

                                    while(parm)
                                    {
                                        tmp = (1 << pos) & parm;
800071d2:	10 93       	mov	r3,r8
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800071d4:	10 95       	mov	r5,r8
                                    int pos = 0;
                                    bool first = MNS_TRUE;

                                    while(parm)
                                    {
                                        tmp = (1 << pos) & parm;
800071d6:	30 18       	mov	r8,1
800071d8:	f0 05 09 46 	lsl	r6,r8,r5
800071dc:	0e 66       	and	r6,r7
800071de:	c2 40       	breq	80007226 <MnsTraceParser+0x24a>
                                        if(tmp)
800071e0:	0c 87       	andn	r7,r6
                                        {
                                            parm &= ~tmp;
800071e2:	58 09       	cp.w	r9,0
                                            if (!first)
800071e4:	e0 80 01 30 	breq	80007444 <MnsTraceParser+0x468>
800071e8:	fe f8 06 f4 	ld.w	r8,pc[1780]
                                            {
                                                ADD_STR(", ");
800071ec:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800071ee:	12 36       	cp.w	r6,r9
        if (myNum == item)                          /* item found ?               */
800071f0:	c0 c0       	breq	80007208 <MnsTraceParser+0x22c>
800071f2:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800071f6:	5f 19       	srne	r9
800071f8:	e6 09 18 00 	cp.b	r9,r3
800071fc:	e0 80 02 b5 	breq	80007766 <MnsTraceParser+0x78a>
80007200:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
80007202:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007204:	12 36       	cp.w	r6,r9
        if (myNum == item)                          /* item found ?               */
80007206:	cf 61       	brne	800071f2 <MnsTraceParser+0x216>
80007208:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
8000720a:	58 08       	cp.w	r8,0
                                            }
                                            else
                                            {
                                                first = MNS_FALSE;
                                            }
                                            if (NULL != (pParmStr = GetName(MNS_ServiceList, tmp)))
8000720c:	e0 80 02 ad 	breq	80007766 <MnsTraceParser+0x78a>
80007210:	1a d8       	st.w	--sp,r8
                                            {
                                                ADD_STRING(parmListPtr->FormatString, pParmStr);
80007212:	04 9c       	mov	r12,r2
80007214:	68 0b       	ld.w	r11,r4[0x0]
80007216:	e0 a0 86 2f 	rcall	80017e74 <sprintf>
                                            }
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
8000721a:	04 9b       	mov	r11,r2
8000721c:	00 9c       	mov	r12,r0
8000721e:	e0 a0 86 89 	rcall	80017f30 <strcat>
80007222:	30 09       	mov	r9,0
80007224:	2f fd       	sub	sp,-4
80007226:	58 07       	cp.w	r7,0
                                {
                                    int tmp = 0;
                                    int pos = 0;
                                    bool first = MNS_TRUE;

                                    while(parm)
80007228:	e0 80 00 fb 	breq	8000741e <MnsTraceParser+0x442>
8000722c:	2f f5       	sub	r5,-1
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
                                            }
                                        }
                                        pos++;
8000722e:	cd 4b       	rjmp	800071d6 <MnsTraceParser+0x1fa>
80007230:	58 b8       	cp.w	r8,11
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
80007232:	e0 80 01 93 	breq	80007558 <MnsTraceParser+0x57c>
80007236:	e0 8a 00 3f 	brle	800072b4 <MnsTraceParser+0x2d8>
8000723a:	58 c8       	cp.w	r8,12
8000723c:	e0 80 01 2a 	breq	80007490 <MnsTraceParser+0x4b4>
80007240:	58 d8       	cp.w	r8,13
80007242:	c3 21       	brne	800072a6 <MnsTraceParser+0x2ca>
80007244:	fe f8 06 98 	ld.w	r8,pc[1688]
                                        ADD_STRING("[unknown state 0x%02X].", parm);
                                    }
                                }
                                else
                                {
                                    ADD_STRING("[state 0x%02X].", parm);
80007248:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000724a:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
8000724c:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
8000724e:	c0 c0       	breq	80007266 <MnsTraceParser+0x28a>
80007250:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007254:	5f 19       	srne	r9
80007256:	f4 09 18 00 	cp.b	r9,r10
8000725a:	e0 80 02 f1 	breq	8000783c <MnsTraceParser+0x860>
8000725e:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
80007260:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007262:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
80007264:	cf 61       	brne	80007250 <MnsTraceParser+0x274>
80007266:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
80007268:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_SERVICE:
                                if (NULL != (pParmStr = GetName(MNS_ServiceList, parm)))
8000726a:	e0 80 02 e9 	breq	8000783c <MnsTraceParser+0x860>
8000726e:	1a d8       	st.w	--sp,r8

                            /*------------------------------------------------*/
                            case TY_P_PMHS_FLAG:
                                if (NULL != (pParmStr = GetName(MNS_PMHS_FlagList, parm)))
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
80007270:	2f f1       	sub	r1,-1
80007272:	2f c5       	sub	r5,-4
80007274:	68 0b       	ld.w	r11,r4[0x0]
80007276:	04 9c       	mov	r12,r2
80007278:	cc 38       	rjmp	800073fe <MnsTraceParser+0x422>
8000727a:	59 88       	cp.w	r8,24
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
8000727c:	e0 80 01 5c 	breq	80007534 <MnsTraceParser+0x558>
80007280:	e0 8a 00 0d 	brle	8000729a <MnsTraceParser+0x2be>
80007284:	59 98       	cp.w	r8,25
80007286:	e0 80 01 87 	breq	80007594 <MnsTraceParser+0x5b8>
8000728a:	e0 48 ff ff 	cp.w	r8,65535
8000728e:	c0 c1       	brne	800072a6 <MnsTraceParser+0x2ca>
80007290:	40 58       	lddsp	r8,sp[0x14]
                }
            }
        }
    }

    if (printError)
80007292:	58 08       	cp.w	r8,0
80007294:	fe 90 ff 36 	breq	80007100 <MnsTraceParser+0x124>
80007298:	ce 5a       	rjmp	80007062 <MnsTraceParser+0x86>
8000729a:	59 68       	cp.w	r8,22
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
8000729c:	e0 80 01 31 	breq	800074fe <MnsTraceParser+0x522>
800072a0:	59 78       	cp.w	r8,23
800072a2:	e0 80 01 13 	breq	800074c8 <MnsTraceParser+0x4ec>
800072a6:	1a d7       	st.w	--sp,r7
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
800072a8:	2f f1       	sub	r1,-1
800072aa:	2f c5       	sub	r5,-4
800072ac:	fe fb 06 34 	ld.w	r11,pc[1588]
800072b0:	04 9c       	mov	r12,r2
800072b2:	ca 68       	rjmp	800073fe <MnsTraceParser+0x422>
800072b4:	58 98       	cp.w	r8,9
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
800072b6:	e0 80 01 c0 	breq	80007636 <MnsTraceParser+0x65a>
800072ba:	58 a8       	cp.w	r8,10
800072bc:	cf 51       	brne	800072a6 <MnsTraceParser+0x2ca>
800072be:	1a d7       	st.w	--sp,r7
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_ASSERT:
                                ADD_ERROR(parmListPtr->FormatString, parm);
800072c0:	04 9c       	mov	r12,r2
800072c2:	68 0b       	ld.w	r11,r4[0x0]
800072c4:	e0 a0 85 d8 	rcall	80017e74 <sprintf>
800072c8:	04 9b       	mov	r11,r2
800072ca:	00 9c       	mov	r12,r0
800072cc:	e0 a0 86 32 	rcall	80017f30 <strcat>
800072d0:	2f fd       	sub	sp,-4
800072d2:	40 19       	lddsp	r9,sp[0x4]
800072d4:	2f f1       	sub	r1,-1
800072d6:	2f c5       	sub	r5,-4
800072d8:	02 39       	cp.w	r9,r1
800072da:	f9 b8 09 01 	movgt	r8,1
800072de:	f9 b8 0a 00 	movle	r8,0
800072e2:	30 19       	mov	r9,1
800072e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800072e8:	50 59       	stdsp	sp[0x14],r9
800072ea:	2f 84       	sub	r4,-8
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
800072ec:	58 08       	cp.w	r8,0
            else
            {
                ADD_STRING("%s", eventTabPtr->FormatString);
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
800072ee:	cd 10       	breq	80007290 <MnsTraceParser+0x2b4>
800072f0:	6a 07       	ld.w	r7,r5[0x0]
                    {
                        parm = *params;
800072f2:	e8 f8 ff fc 	ld.w	r8,r4[-4]
                        switch (parmListPtr->ItemType)
800072f6:	58 f8       	cp.w	r8,15
800072f8:	fe 91 ff 26 	brne	80007144 <MnsTraceParser+0x168>
800072fc:	ee c8 00 01 	sub	r8,r7,1
                            /*------------------------------------------------*/
                            case TY_P_STEP:



                                if ((parm > 0x00) && (parm < 0xA0))
80007300:	e0 48 00 9e 	cp.w	r8,158
80007304:	e0 88 02 3a 	brls	80007778 <MnsTraceParser+0x79c>
80007308:	ee c8 00 a1 	sub	r8,r7,161
                                {
                                    ADD_STRING(".Step.%d", parm);
                                }
                                else if ((parm > 0xA0) && (parm < 0xB0))
8000730c:	58 e8       	cp.w	r8,14
8000730e:	e0 88 02 58 	brls	800077be <MnsTraceParser+0x7e2>
80007312:	ee c8 00 b1 	sub	r8,r7,177
                                {
                                    ADD_STRING(".Alpha.%d", parm & 0xF);
                                }
                                else if ((parm > 0xB0) && (parm < 0xC0))
80007316:	58 e8       	cp.w	r8,14
80007318:	e0 88 02 99 	brls	8000784a <MnsTraceParser+0x86e>
8000731c:	e0 47 00 d0 	cp.w	r7,208
                                {
                                    ADD_STRING(".Beta.%d", parm & 0xF);
                                }
                                else if (parm == 0xD0)
80007320:	e0 80 02 b3 	breq	80007886 <MnsTraceParser+0x8aa>
80007324:	ee c8 00 d1 	sub	r8,r7,209
                                {
                                    ADD_STR("Distrib");
                                }
                                else if ((parm > 0xD0) && (parm < 0xE0))
80007328:	58 e8       	cp.w	r8,14
8000732a:	e0 88 02 a1 	brls	8000786c <MnsTraceParser+0x890>
8000732e:	e0 47 00 e0 	cp.w	r7,224
                                {
                                    ADD_STRING(".RC.%d", parm & 0xF);
                                }
                                else if (parm == 0xE0)
80007332:	e0 80 02 b7 	breq	800078a0 <MnsTraceParser+0x8c4>
80007336:	ee c8 00 e1 	sub	r8,r7,225
                                {
                                    ADD_STR("SR");
                                }
                                else if ((parm > 0xE0) && (parm < 0xF0))
8000733a:	58 e8       	cp.w	r8,14
8000733c:	e0 8b 02 94 	brhi	80007864 <MnsTraceParser+0x888>
80007340:	ef d7 c0 04 	bfextu	r7,r7,0x0,0x4
                                {
                                    ADD_STRING(".SR.RC.%d", parm & 0xF);
80007344:	fe fb 05 a0 	ld.w	r11,pc[1440]
80007348:	1a d7       	st.w	--sp,r7
8000734a:	04 9c       	mov	r12,r2
                                }
                                else
                                {
                                    ADD_STRING(".[unknown code = 0x%02X]", parm);
8000734c:	e0 a0 85 94 	rcall	80017e74 <sprintf>
80007350:	04 9b       	mov	r11,r2
80007352:	00 9c       	mov	r12,r0
80007354:	e0 a0 85 ee 	rcall	80017f30 <strcat>
80007358:	2f fd       	sub	sp,-4
8000735a:	00 9c       	mov	r12,r0
                                }
                                ADD_STR("    ");
8000735c:	e0 a0 86 04 	rcall	80017f64 <strlen>
80007360:	30 5a       	mov	r10,5
80007362:	e0 0c 00 0c 	add	r12,r0,r12
80007366:	fe fb 05 82 	ld.w	r11,pc[1410]
8000736a:	e0 a0 82 fb 	rcall	80017960 <memcpy>
8000736e:	2f f1       	sub	r1,-1
80007370:	40 19       	lddsp	r9,sp[0x4]
80007372:	2f c5       	sub	r5,-4
80007374:	02 39       	cp.w	r9,r1
80007376:	f9 b8 09 01 	movgt	r8,1
8000737a:	f9 b8 0a 00 	movle	r8,0
8000737e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007382:	cb 4b       	rjmp	800072ea <MnsTraceParser+0x30e>
                                break;
80007384:	59 08       	cp.w	r8,16
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
80007386:	e0 80 01 22 	breq	800075ca <MnsTraceParser+0x5ee>
8000738a:	59 18       	cp.w	r8,17
8000738c:	c8 d1       	brne	800072a6 <MnsTraceParser+0x2ca>
8000738e:	fe f8 05 5e 	ld.w	r8,pc[1374]
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
                                            }
                                        }
                                        pos++;
80007392:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007394:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007396:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
80007398:	c0 c0       	breq	800073b0 <MnsTraceParser+0x3d4>
8000739a:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000739e:	5f 19       	srne	r9
800073a0:	f4 09 18 00 	cp.b	r9,r10
800073a4:	e0 80 01 42 	breq	80007628 <MnsTraceParser+0x64c>
800073a8:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
800073aa:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800073ac:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
800073ae:	cf 61       	brne	8000739a <MnsTraceParser+0x3be>
800073b0:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
800073b2:	58 08       	cp.w	r8,0
                                }
                                break;

                                /*------------------------------------------------*/
                            case TY_P_L2_FLAG:
                                if (NULL != (pParmStr = GetName(MNS_L2_FlagList, parm)))
800073b4:	e0 80 01 3a 	breq	80007628 <MnsTraceParser+0x64c>
800073b8:	1a d8       	st.w	--sp,r8

                            /*------------------------------------------------*/
                            case TY_P_TM_OP:
                                if (NULL != (pParmStr = GetName(MNS_TM_OP, parm)))
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
800073ba:	2f f1       	sub	r1,-1
800073bc:	2f c5       	sub	r5,-4
800073be:	68 0b       	ld.w	r11,r4[0x0]
800073c0:	04 9c       	mov	r12,r2
800073c2:	e0 a0 85 59 	rcall	80017e74 <sprintf>
800073c6:	04 9b       	mov	r11,r2
800073c8:	00 9c       	mov	r12,r0
800073ca:	e0 a0 85 b3 	rcall	80017f30 <strcat>
800073ce:	2f fd       	sub	sp,-4
800073d0:	40 19       	lddsp	r9,sp[0x4]
800073d2:	12 31       	cp.w	r1,r9
800073d4:	f9 b8 05 01 	movlt	r8,1
800073d8:	f9 b8 04 00 	movge	r8,0
800073dc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073e0:	c8 5b       	rjmp	800072ea <MnsTraceParser+0x30e>
800073e2:	58 28       	cp.w	r8,2
                if (num_parm != 0)
                {
                    for (i = 0; (i < num_parm) && !exitFlag; ++i, ++params)
                    {
                        parm = *params;
                        switch (parmListPtr->ItemType)
800073e4:	c2 a0       	breq	80007438 <MnsTraceParser+0x45c>
800073e6:	58 38       	cp.w	r8,3
800073e8:	fe 91 ff 5f 	brne	800072a6 <MnsTraceParser+0x2ca>
800073ec:	2f c5       	sub	r5,-4
                                ADD_STRING(parmListPtr->FormatString, parm);
                                break;

                            /*------------------------------------------------*/
                            case TY_P_ADDRESS:
                                if (    (FBLOCK_INIC     == *(params+1))
800073ee:	6a 08       	ld.w	r8,r5[0x0]
800073f0:	58 18       	cp.w	r8,1
800073f2:	e0 88 01 c7 	brls	80007780 <MnsTraceParser+0x7a4>
800073f6:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING("%s", "Local.");
                                }
                                else
                                {
                                    ADD_STRING(parmListPtr->FormatString, parm);
800073f8:	2f f1       	sub	r1,-1
800073fa:	68 0b       	ld.w	r11,r4[0x0]
800073fc:	04 9c       	mov	r12,r2
800073fe:	e0 a0 85 3b 	rcall	80017e74 <sprintf>
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
80007402:	04 9b       	mov	r11,r2
80007404:	00 9c       	mov	r12,r0
80007406:	e0 a0 85 95 	rcall	80017f30 <strcat>
8000740a:	2f fd       	sub	sp,-4
8000740c:	40 19       	lddsp	r9,sp[0x4]
8000740e:	02 39       	cp.w	r9,r1
80007410:	f9 b8 09 01 	movgt	r8,1
80007414:	f9 b8 0a 00 	movle	r8,0
80007418:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000741c:	c6 7b       	rjmp	800072ea <MnsTraceParser+0x30e>
8000741e:	02 95       	mov	r5,r1
80007420:	40 71       	lddsp	r1,sp[0x1c]
80007422:	2f f1       	sub	r1,-1
                                {
                                    int tmp = 0;
                                    int pos = 0;
                                    bool first = MNS_TRUE;

                                    while(parm)
80007424:	40 19       	lddsp	r9,sp[0x4]
80007426:	2f c5       	sub	r5,-4
80007428:	02 39       	cp.w	r9,r1
8000742a:	f9 b8 09 01 	movgt	r8,1
8000742e:	f9 b8 0a 00 	movle	r8,0
80007432:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007436:	c5 ab       	rjmp	800072ea <MnsTraceParser+0x30e>
80007438:	1a d7       	st.w	--sp,r7
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_EVENT:
                                ADD_STRING(parmListPtr->FormatString, parm);
8000743a:	2f f1       	sub	r1,-1
8000743c:	2f c5       	sub	r5,-4
8000743e:	68 0b       	ld.w	r11,r4[0x0]
80007440:	04 9c       	mov	r12,r2
80007442:	cd eb       	rjmp	800073fe <MnsTraceParser+0x422>
80007444:	00 9c       	mov	r12,r0
                                        if(tmp)
                                        {
                                            parm &= ~tmp;
                                            if (!first)
                                            {
                                                ADD_STR(", ");
80007446:	e0 a0 85 8f 	rcall	80017f64 <strlen>
8000744a:	30 3a       	mov	r10,3
8000744c:	e0 0c 00 0c 	add	r12,r0,r12
80007450:	fe fb 04 a0 	ld.w	r11,pc[1184]
80007454:	e0 a0 82 86 	rcall	80017960 <memcpy>
80007458:	cc 8a       	rjmp	800071e8 <MnsTraceParser+0x20c>
8000745a:	fe f8 04 9a 	ld.w	r8,pc[1178]
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown flag 0x%04X].", parm);
8000745e:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007460:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007462:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
80007464:	c0 b0       	breq	8000747a <MnsTraceParser+0x49e>
80007466:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000746a:	5f 19       	srne	r9
8000746c:	f4 09 18 00 	cp.b	r9,r10
80007470:	c0 90       	breq	80007482 <MnsTraceParser+0x4a6>
80007472:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
80007474:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007476:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
80007478:	cf 71       	brne	80007466 <MnsTraceParser+0x48a>
8000747a:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
8000747c:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_PMHS_FLAG:
                                if (NULL != (pParmStr = GetName(MNS_PMHS_FlagList, parm)))
8000747e:	fe 91 fe f8 	brne	8000726e <MnsTraceParser+0x292>
80007482:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown flag 0x%04X].", parm);
80007484:	2f f1       	sub	r1,-1
80007486:	2f c5       	sub	r5,-4
80007488:	fe fb 04 70 	ld.w	r11,pc[1136]
8000748c:	04 9c       	mov	r12,r2
8000748e:	cb 8b       	rjmp	800073fe <MnsTraceParser+0x422>
80007490:	40 38       	lddsp	r8,sp[0xc]
                                ADD_STR("    ");
                                break;

                            /*------------------------------------------------*/
                            case TY_P_STATE:
                                if ((NULL != pStateM) && (NULL != pStateM->sList))
80007492:	58 08       	cp.w	r8,0
80007494:	e0 80 01 8e 	breq	800077b0 <MnsTraceParser+0x7d4>
80007498:	70 28       	ld.w	r8,r8[0x8]
8000749a:	58 08       	cp.w	r8,0
8000749c:	e0 80 01 8a 	breq	800077b0 <MnsTraceParser+0x7d4>
800074a0:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myID));   /* found or end of list ? */
800074a2:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myID = list->id;                           /* read item number from list */
800074a4:	12 37       	cp.w	r7,r9
        if (myID == item)                          /* item found ?               */
800074a6:	c0 c0       	breq	800074be <MnsTraceParser+0x4e2>
800074a8:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myID));   /* found or end of list ? */
800074ac:	5f 19       	srne	r9
800074ae:	f4 09 18 00 	cp.b	r9,r10
800074b2:	e0 80 01 d2 	breq	80007856 <MnsTraceParser+0x87a>
800074b6:	2f 88       	sub	r8,-8
        if (myID == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
800074b8:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myID = list->id;                           /* read item number from list */
800074ba:	12 37       	cp.w	r7,r9
        if (myID == item)                          /* item found ?               */
800074bc:	cf 61       	brne	800074a8 <MnsTraceParser+0x4cc>
800074be:	58 08       	cp.w	r8,0

                            /*------------------------------------------------*/
                            case TY_P_STATE:
                                if ((NULL != pStateM) && (NULL != pStateM->sList))
                                {
                                    if (NULL != (pState = GetState(pStateM->sList, parm)))
800074c0:	e0 80 01 cb 	breq	80007856 <MnsTraceParser+0x87a>
800074c4:	70 18       	ld.w	r8,r8[0x4]
                                    {
                                        ADD_STRING(parmListPtr->FormatString, pState->name);
800074c6:	c7 9b       	rjmp	800073b8 <MnsTraceParser+0x3dc>
800074c8:	fe f8 04 34 	ld.w	r8,pc[1076]
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown operation 0x%04X].", parm);
800074cc:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800074ce:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800074d0:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
800074d2:	c0 b0       	breq	800074e8 <MnsTraceParser+0x50c>
800074d4:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800074d8:	5f 19       	srne	r9
800074da:	f4 09 18 00 	cp.b	r9,r10
800074de:	c0 90       	breq	800074f0 <MnsTraceParser+0x514>
800074e0:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
800074e2:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800074e4:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
800074e6:	cf 71       	brne	800074d4 <MnsTraceParser+0x4f8>
800074e8:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
800074ea:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_TM_EV:
                                if (NULL != (pParmStr = GetName(MNS_TM_EV, parm)))
800074ec:	fe 91 fe c1 	brne	8000726e <MnsTraceParser+0x292>
800074f0:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown event 0x%04X].", parm);
800074f2:	2f f1       	sub	r1,-1
800074f4:	2f c5       	sub	r5,-4
800074f6:	fe fb 04 0a 	ld.w	r11,pc[1034]
800074fa:	04 9c       	mov	r12,r2
800074fc:	c8 1b       	rjmp	800073fe <MnsTraceParser+0x422>
800074fe:	fe f8 04 06 	ld.w	r8,pc[1030]
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown cause 0x%01X].", parm);
80007502:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007504:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007506:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
80007508:	c0 b0       	breq	8000751e <MnsTraceParser+0x542>
8000750a:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000750e:	5f 19       	srne	r9
80007510:	f4 09 18 00 	cp.b	r9,r10
80007514:	c0 90       	breq	80007526 <MnsTraceParser+0x54a>
80007516:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
80007518:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
8000751a:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
8000751c:	cf 71       	brne	8000750a <MnsTraceParser+0x52e>
8000751e:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
80007520:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_TM_OP:
                                if (NULL != (pParmStr = GetName(MNS_TM_OP, parm)))
80007522:	fe 91 ff 4b 	brne	800073b8 <MnsTraceParser+0x3dc>
80007526:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown operation 0x%04X].", parm);
80007528:	2f f1       	sub	r1,-1
8000752a:	2f c5       	sub	r5,-4
8000752c:	fe fb 03 dc 	ld.w	r11,pc[988]
80007530:	04 9c       	mov	r12,r2
80007532:	c6 6b       	rjmp	800073fe <MnsTraceParser+0x422>
80007534:	58 17       	cp.w	r7,1
                                break;

                                /*------------------------------------------------*/
                                case TY_P_TM_FLAGS:

                                switch(parm)
80007536:	e0 80 01 5e 	breq	800077f2 <MnsTraceParser+0x816>
8000753a:	e0 8a 01 6b 	brle	80007810 <MnsTraceParser+0x834>
8000753e:	58 27       	cp.w	r7,2
80007540:	e0 80 01 55 	breq	800077ea <MnsTraceParser+0x80e>
80007544:	58 37       	cp.w	r7,3
80007546:	e0 80 01 42 	breq	800077ca <MnsTraceParser+0x7ee>
8000754a:	1a d7       	st.w	--sp,r7
                                    case 3:
                                        ADD_STR("Busy & Schedule");
                                        break;

                                    default:
                                        ADD_STRING("0x%04X", parm);
8000754c:	2f f1       	sub	r1,-1
8000754e:	2f c5       	sub	r5,-4
80007550:	fe fb 03 bc 	ld.w	r11,pc[956]
80007554:	04 9c       	mov	r12,r2
80007556:	c5 4b       	rjmp	800073fe <MnsTraceParser+0x422>
80007558:	fe f8 03 b8 	ld.w	r8,pc[952]
                                    ADD_STRING("[unknown OpType 0x%01X].", parm);
                                }
                                }
                                else
                                {
                                    ADD_STRING("[OpType 0x%01X].", parm);
8000755c:	50 38       	stdsp	sp[0xc],r8
8000755e:	10 9a       	mov	r10,r8
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myID));   /* found or end of list ? */
80007560:	30 09       	mov	r9,0
80007562:	94 88       	ld.uh	r8,r10[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myID = list->id;                          /* read item number from list */
80007564:	10 37       	cp.w	r7,r8
        if (myID == item)                          /* item found ?               */
80007566:	c0 c0       	breq	8000757e <MnsTraceParser+0x5a2>
80007568:	e0 48 ff ff 	cp.w	r8,65535
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myID));   /* found or end of list ? */
8000756c:	5f 18       	srne	r8
8000756e:	f2 08 18 00 	cp.b	r8,r9
80007572:	e0 80 01 9d 	breq	800078ac <MnsTraceParser+0x8d0>
80007576:	2f 4a       	sub	r10,-12
        if (myID == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
80007578:	94 88       	ld.uh	r8,r10[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myID = list->id;                          /* read item number from list */
8000757a:	10 37       	cp.w	r7,r8
        if (myID == item)                          /* item found ?               */
8000757c:	cf 61       	brne	80007568 <MnsTraceParser+0x58c>
8000757e:	50 3a       	stdsp	sp[0xc],r10
80007580:	58 0a       	cp.w	r10,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_STATEMACHINE:
                                if (NULL != (pStateM = GetStateM(StateMList, parm)))
80007582:	fe 91 fe 0b 	brne	80007198 <MnsTraceParser+0x1bc>
80007586:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pStateM->name);
                                }
                                else
                                {
                                    ADD_STRING("[unknown state machine 0x%02X].", parm);
80007588:	2f f1       	sub	r1,-1
8000758a:	2f c5       	sub	r5,-4
8000758c:	fe fb 03 88 	ld.w	r11,pc[904]
80007590:	04 9c       	mov	r12,r2
80007592:	c3 6b       	rjmp	800073fe <MnsTraceParser+0x422>
80007594:	fe f8 03 84 	ld.w	r8,pc[900]
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown chip 0x%04X].", parm);
80007598:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000759a:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
8000759c:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
8000759e:	c0 b0       	breq	800075b4 <MnsTraceParser+0x5d8>
800075a0:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800075a4:	5f 19       	srne	r9
800075a6:	f4 09 18 00 	cp.b	r9,r10
800075aa:	c0 90       	breq	800075bc <MnsTraceParser+0x5e0>
800075ac:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
800075ae:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800075b0:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
800075b2:	cf 71       	brne	800075a0 <MnsTraceParser+0x5c4>
800075b4:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
800075b6:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_TRANSCAUSE:
                                if (NULL != (pParmStr = GetName(MNS_TC_List, parm)))
800075b8:	fe 91 fe 5b 	brne	8000726e <MnsTraceParser+0x292>
800075bc:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown cause 0x%01X].", parm);
800075be:	2f f1       	sub	r1,-1
800075c0:	2f c5       	sub	r5,-4
800075c2:	fe fb 03 5a 	ld.w	r11,pc[858]
800075c6:	04 9c       	mov	r12,r2
800075c8:	c1 bb       	rjmp	800073fe <MnsTraceParser+0x422>
800075ca:	fe f8 03 56 	ld.w	r8,pc[854]
                                {
                                    ADD_STRING(parmListPtr->FormatString, pStateM->name);
                                }
                                else
                                {
                                    ADD_STRING("[unknown state machine 0x%02X].", parm);
800075ce:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800075d0:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800075d2:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
800075d4:	c0 b0       	breq	800075ea <MnsTraceParser+0x60e>
800075d6:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800075da:	5f 19       	srne	r9
800075dc:	f4 09 18 00 	cp.b	r9,r10
800075e0:	c0 90       	breq	800075f2 <MnsTraceParser+0x616>
800075e2:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
800075e4:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800075e6:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
800075e8:	cf 71       	brne	800075d6 <MnsTraceParser+0x5fa>
800075ea:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
800075ec:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_CHIP:
                                if (NULL != (pParmStr = GetName(MNS_ChipList, parm)))
800075ee:	fe 91 fe 40 	brne	8000726e <MnsTraceParser+0x292>
800075f2:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown chip 0x%04X].", parm);
800075f4:	2f f1       	sub	r1,-1
800075f6:	2f c5       	sub	r5,-4
800075f8:	fe fb 03 2c 	ld.w	r11,pc[812]
800075fc:	04 9c       	mov	r12,r2
800075fe:	c0 0b       	rjmp	800073fe <MnsTraceParser+0x422>
80007600:	fe f8 03 28 	ld.w	r8,pc[808]
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown flag 0x%04X].", parm);
80007604:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007606:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007608:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
8000760a:	c0 b0       	breq	80007620 <MnsTraceParser+0x644>
8000760c:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007610:	5f 19       	srne	r9
80007612:	f4 09 18 00 	cp.b	r9,r10
80007616:	c0 90       	breq	80007628 <MnsTraceParser+0x64c>
80007618:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
8000761a:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
8000761c:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
8000761e:	cf 71       	brne	8000760c <MnsTraceParser+0x630>
80007620:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
80007622:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_MHP_FLAG:
                                if (NULL != (pParmStr = GetName(MNS_MHP_FlagList, parm)))
80007624:	fe 91 fe 25 	brne	8000726e <MnsTraceParser+0x292>
80007628:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown flag 0x%04X].", parm);
8000762a:	2f f1       	sub	r1,-1
8000762c:	2f c5       	sub	r5,-4
8000762e:	fe fb 02 ca 	ld.w	r11,pc[714]
80007632:	04 9c       	mov	r12,r2
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
80007634:	ce 5a       	rjmp	800073fe <MnsTraceParser+0x422>
80007636:	40 28       	lddsp	r8,sp[0x8]
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_OPTYPE:
                                if (NULL != pFkt)
80007638:	58 08       	cp.w	r8,0
8000763a:	e0 80 01 2c 	breq	80007892 <MnsTraceParser+0x8b6>
8000763e:	11 aa       	ld.ub	r10,r8[0x2]
                                {
                                    if (NULL != (pParmStr = GetName(OpTypeList, parm+(pFkt->type))))
80007640:	30 0b       	mov	r11,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007642:	fe f8 02 ea 	ld.w	r8,pc[746]

                            /*------------------------------------------------*/
                            case TY_P_OPTYPE:
                                if (NULL != pFkt)
                                {
                                    if (NULL != (pParmStr = GetName(OpTypeList, parm+(pFkt->type))))
80007646:	ee 0a 00 0a 	add	r10,r7,r10
8000764a:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
8000764c:	12 3a       	cp.w	r10,r9
        if (myNum == item)                          /* item found ?               */
8000764e:	c0 b0       	breq	80007664 <MnsTraceParser+0x688>
80007650:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007654:	5f 19       	srne	r9
80007656:	f6 09 18 00 	cp.b	r9,r11
8000765a:	c0 90       	breq	8000766c <MnsTraceParser+0x690>
8000765c:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
8000765e:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007660:	12 3a       	cp.w	r10,r9
        if (myNum == item)                          /* item found ?               */
80007662:	cf 71       	brne	80007650 <MnsTraceParser+0x674>
80007664:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
80007666:	58 08       	cp.w	r8,0

                            /*------------------------------------------------*/
                            case TY_P_OPTYPE:
                                if (NULL != pFkt)
                                {
                                    if (NULL != (pParmStr = GetName(OpTypeList, parm+(pFkt->type))))
80007668:	fe 91 fe 03 	brne	8000726e <MnsTraceParser+0x292>
8000766c:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown OpType 0x%01X].", parm);
8000766e:	2f f1       	sub	r1,-1
80007670:	2f c5       	sub	r5,-4
80007672:	fe fb 02 be 	ld.w	r11,pc[702]
80007676:	04 9c       	mov	r12,r2
80007678:	cc 3a       	rjmp	800073fe <MnsTraceParser+0x422>
8000767a:	40 69       	lddsp	r9,sp[0x18]
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_FUNC:
                                if (NULL != (pParmStr = GetName(serviceTabPtr->FuncList, parm)))
8000767c:	30 0a       	mov	r10,0
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000767e:	72 18       	ld.w	r8,r9[0x4]
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_FUNC:
                                if (NULL != (pParmStr = GetName(serviceTabPtr->FuncList, parm)))
80007680:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007682:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
80007684:	c0 c0       	breq	8000769c <MnsTraceParser+0x6c0>
80007686:	e0 49 ff ff 	cp.w	r9,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
8000768a:	5f 19       	srne	r9
8000768c:	f4 09 18 00 	cp.b	r9,r10
80007690:	e0 80 00 c7 	breq	8000781e <MnsTraceParser+0x842>
80007694:	2f 88       	sub	r8,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
80007696:	90 89       	ld.uh	r9,r8[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007698:	12 37       	cp.w	r7,r9
        if (myNum == item)                          /* item found ?               */
8000769a:	cf 61       	brne	80007686 <MnsTraceParser+0x6aa>
8000769c:	70 18       	ld.w	r8,r8[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
8000769e:	58 08       	cp.w	r8,0
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_FUNC:
                                if (NULL != (pParmStr = GetName(serviceTabPtr->FuncList, parm)))
800076a0:	e0 80 00 bf 	breq	8000781e <MnsTraceParser+0x842>
800076a4:	1a d8       	st.w	--sp,r8
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
800076a6:	2f f1       	sub	r1,-1
800076a8:	2f c5       	sub	r5,-4
800076aa:	68 0b       	ld.w	r11,r4[0x0]
800076ac:	04 9c       	mov	r12,r2
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
800076ae:	ca 8a       	rjmp	800073fe <MnsTraceParser+0x422>
800076b0:	40 48       	lddsp	r8,sp[0x10]
                                }
                                break;

                            /*------------------------------------------------*/
                            case TY_P_FKTID:
                                if (NULL != pFblock)
800076b2:	58 08       	cp.w	r8,0
800076b4:	e0 80 00 e2 	breq	80007878 <MnsTraceParser+0x89c>
800076b8:	70 29       	ld.w	r9,r8[0x8]
                                {
                                    if (NULL != (pFkt = GetFktName(pFblock->fktList, parm)))
800076ba:	50 29       	stdsp	sp[0x8],r9
800076bc:	30 09       	mov	r9,0
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800076be:	40 2a       	lddsp	r10,sp[0x8]
800076c0:	94 88       	ld.uh	r8,r10[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800076c2:	10 37       	cp.w	r7,r8
        if (myNum == item)                          /* item found ?               */
800076c4:	c0 c0       	breq	800076dc <MnsTraceParser+0x700>
800076c6:	e0 48 ff ff 	cp.w	r8,65535
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800076ca:	5f 18       	srne	r8
800076cc:	f2 08 18 00 	cp.b	r8,r9
800076d0:	e0 80 00 f2 	breq	800078b4 <MnsTraceParser+0x8d8>
800076d4:	2f 8a       	sub	r10,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = list;                           /* return pointer to entry */
        }
        list++;
800076d6:	94 88       	ld.uh	r8,r10[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
800076d8:	10 37       	cp.w	r7,r8
        if (myNum == item)                          /* item found ?               */
800076da:	cf 61       	brne	800076c6 <MnsTraceParser+0x6ea>
800076dc:	50 2a       	stdsp	sp[0x8],r10
800076de:	58 0a       	cp.w	r10,0

                            /*------------------------------------------------*/
                            case TY_P_FKTID:
                                if (NULL != pFblock)
                                {
                                    if (NULL != (pFkt = GetFktName(pFblock->fktList, parm)))
800076e0:	fe 91 fd 5c 	brne	80007198 <MnsTraceParser+0x1bc>
800076e4:	1a d7       	st.w	--sp,r7
                                    {
                                        ADD_STRING(parmListPtr->FormatString, pFkt->name);
                                    }
                                    else
                                    {
                                        ADD_STRING("[unknown FktID 0x%03X].", parm);
800076e6:	2f f1       	sub	r1,-1
800076e8:	2f c5       	sub	r5,-4
800076ea:	fe fb 02 4a 	ld.w	r11,pc[586]
800076ee:	04 9c       	mov	r12,r2
800076f0:	c8 7a       	rjmp	800073fe <MnsTraceParser+0x422>
800076f2:	58 07       	cp.w	r7,0
                            case TY_P_CFGMASK:
                                {
                                    int tmp = 0;
                                    int pos = 0;

                                    while(parm)
800076f4:	fe 90 fe 97 	breq	80007422 <MnsTraceParser+0x446>
800076f8:	30 03       	mov	r3,0
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
                                            }
                                        }
                                        pos++;
800076fa:	06 98       	mov	r8,r3
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
800076fc:	c0 58       	rjmp	80007706 <MnsTraceParser+0x72a>
800076fe:	58 07       	cp.w	r7,0
                            case TY_P_CFGMASK:
                                {
                                    int tmp = 0;
                                    int pos = 0;

                                    while(parm)
80007700:	fe 90 fe 91 	breq	80007422 <MnsTraceParser+0x446>
80007704:	2f f3       	sub	r3,-1
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
                                            }
                                        }
                                        pos++;
80007706:	30 19       	mov	r9,1
                                    int tmp = 0;
                                    int pos = 0;

                                    while(parm)
                                    {
                                        tmp = (1 << pos) & parm;
80007708:	f2 03 09 46 	lsl	r6,r9,r3
8000770c:	0e 66       	and	r6,r7
8000770e:	cf 80       	breq	800076fe <MnsTraceParser+0x722>
                                        if(tmp)
80007710:	50 08       	stdsp	sp[0x0],r8
                                        {
                                            parm &= ~tmp;
                                            ADD_STR(", ");
80007712:	0c 87       	andn	r7,r6
                                    while(parm)
                                    {
                                        tmp = (1 << pos) & parm;
                                        if(tmp)
                                        {
                                            parm &= ~tmp;
80007714:	00 9c       	mov	r12,r0
                                            ADD_STR(", ");
80007716:	e0 a0 84 27 	rcall	80017f64 <strlen>
8000771a:	30 3a       	mov	r10,3
8000771c:	e0 0c 00 0c 	add	r12,r0,r12
80007720:	4f 4b       	lddpc	r11,800078f0 <MnsTraceParser+0x914>
80007722:	e0 a0 81 1f 	rcall	80017960 <memcpy>
80007726:	fe f9 02 12 	ld.w	r9,pc[530]
8000772a:	40 08       	lddsp	r8,sp[0x0]
8000772c:	92 8a       	ld.uh	r10,r9[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
8000772e:	14 36       	cp.w	r6,r10
        if (myNum == item)                          /* item found ?               */
80007730:	c0 b0       	breq	80007746 <MnsTraceParser+0x76a>
80007732:	e0 4a ff ff 	cp.w	r10,65535
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
    }
    while (!found && (STR_TERMINATION != myNum));   /* found or end of list ? */
80007736:	5f 1a       	srne	r10
80007738:	f0 0a 18 00 	cp.b	r10,r8
8000773c:	c1 a0       	breq	80007770 <MnsTraceParser+0x794>
8000773e:	2f 89       	sub	r9,-8
        if (myNum == item)                          /* item found ?               */
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
        }
        list++;
80007740:	92 8a       	ld.uh	r10,r9[0x0]
    ret     = NULL;
    found   = MNS_FALSE;

    do
    {
        myNum = list->num;                          /* read item number from list */
80007742:	14 36       	cp.w	r6,r10
        if (myNum == item)                          /* item found ?               */
80007744:	cf 71       	brne	80007732 <MnsTraceParser+0x756>
80007746:	72 19       	ld.w	r9,r9[0x4]
        {
            found = MNS_TRUE;
            ret   = (char *)list->str;              /* return pointer to the string */
80007748:	58 09       	cp.w	r9,0
                                        tmp = (1 << pos) & parm;
                                        if(tmp)
                                        {
                                            parm &= ~tmp;
                                            ADD_STR(", ");
                                            if (NULL != (pParmStr = GetName(MNS_ConfigList, tmp)))
8000774a:	c1 30       	breq	80007770 <MnsTraceParser+0x794>
8000774c:	1a d9       	st.w	--sp,r9
                                            {
                                                ADD_STRING(parmListPtr->FormatString, pParmStr);
8000774e:	04 9c       	mov	r12,r2
80007750:	68 0b       	ld.w	r11,r4[0x0]
80007752:	50 18       	stdsp	sp[0x4],r8
                                            }
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
80007754:	e0 a0 83 90 	rcall	80017e74 <sprintf>
80007758:	04 9b       	mov	r11,r2
8000775a:	00 9c       	mov	r12,r0
8000775c:	e0 a0 83 ea 	rcall	80017f30 <strcat>
80007760:	2f fd       	sub	sp,-4
80007762:	40 08       	lddsp	r8,sp[0x0]
80007764:	cc db       	rjmp	800076fe <MnsTraceParser+0x722>
80007766:	1a d6       	st.w	--sp,r6
                                            {
                                                ADD_STRING(parmListPtr->FormatString, pParmStr);
                                            }
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
80007768:	4e 9b       	lddpc	r11,8000790c <MnsTraceParser+0x930>
8000776a:	04 9c       	mov	r12,r2
8000776c:	fe 9f fd 55 	bral	80007216 <MnsTraceParser+0x23a>
80007770:	1a d6       	st.w	--sp,r6
                                            {
                                                ADD_STRING(parmListPtr->FormatString, pParmStr);
                                            }
                                            else
                                            {
                                                ADD_STRING("0x%04X", tmp);
80007772:	4e 7b       	lddpc	r11,8000790c <MnsTraceParser+0x930>
80007774:	04 9c       	mov	r12,r2
80007776:	ce eb       	rjmp	80007752 <MnsTraceParser+0x776>
80007778:	1a d7       	st.w	--sp,r7



                                if ((parm > 0x00) && (parm < 0xA0))
                                {
                                    ADD_STRING(".Step.%d", parm);
8000777a:	4f 1b       	lddpc	r11,8000793c <MnsTraceParser+0x960>
8000777c:	fe 9f fd e7 	bral	8000734a <MnsTraceParser+0x36e>
80007780:	4f 08       	lddpc	r8,80007940 <MnsTraceParser+0x964>
                            /*------------------------------------------------*/
                            case TY_P_ADDRESS:
                                if (    (FBLOCK_INIC     == *(params+1))
                                     || (FBLOCK_NETBLOCK == *(params+1)) )
                                {
                                    ADD_STRING("%s", "Local.");
80007782:	11 e9       	ld.ub	r9,r8[0x6]
80007784:	a4 e9       	st.b	r2[0x6],r9
80007786:	70 09       	ld.w	r9,r8[0x0]
80007788:	2f f1       	sub	r1,-1
8000778a:	85 09       	st.w	r2[0x0],r9
8000778c:	04 9b       	mov	r11,r2
8000778e:	11 c9       	ld.ub	r9,r8[0x4]
80007790:	a4 c9       	st.b	r2[0x4],r9
80007792:	11 d8       	ld.ub	r8,r8[0x5]
80007794:	a4 d8       	st.b	r2[0x5],r8
80007796:	00 9c       	mov	r12,r0
                                case TY_P_TM_FLAGS:

                                switch(parm)
                                {
                                    case 0:
                                        ADD_STR("-");
80007798:	e0 a0 83 cc 	rcall	80017f30 <strcat>
8000779c:	40 19       	lddsp	r9,sp[0x4]
8000779e:	02 39       	cp.w	r9,r1
800077a0:	f9 b8 09 01 	movgt	r8,1
800077a4:	f9 b8 0a 00 	movle	r8,0
800077a8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077ac:	fe 9f fd 9f 	bral	800072ea <MnsTraceParser+0x30e>
                                        break;
800077b0:	1a d7       	st.w	--sp,r7
                                        ADD_STRING("[unknown state 0x%02X].", parm);
                                    }
                                }
                                else
                                {
                                    ADD_STRING("[state 0x%02X].", parm);
800077b2:	2f f1       	sub	r1,-1
800077b4:	2f c5       	sub	r5,-4
800077b6:	4e 4b       	lddpc	r11,80007944 <MnsTraceParser+0x968>
800077b8:	04 9c       	mov	r12,r2
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
800077ba:	fe 9f fe 22 	bral	800073fe <MnsTraceParser+0x422>
800077be:	ef d7 c0 04 	bfextu	r7,r7,0x0,0x4
                                {
                                    ADD_STRING(".Step.%d", parm);
                                }
                                else if ((parm > 0xA0) && (parm < 0xB0))
                                {
                                    ADD_STRING(".Alpha.%d", parm & 0xF);
800077c2:	4e 2b       	lddpc	r11,80007948 <MnsTraceParser+0x96c>
800077c4:	1a d7       	st.w	--sp,r7
800077c6:	fe 9f fd c2 	bral	8000734a <MnsTraceParser+0x36e>
800077ca:	4e 1b       	lddpc	r11,8000794c <MnsTraceParser+0x970>
                                    case 2:
                                        ADD_STR("Schedule");
                                        break;

                                    case 3:
                                        ADD_STR("Busy & Schedule");
800077cc:	00 9c       	mov	r12,r0
800077ce:	e0 a0 83 b1 	rcall	80017f30 <strcat>
800077d2:	2f f1       	sub	r1,-1
800077d4:	40 19       	lddsp	r9,sp[0x4]
800077d6:	2f c5       	sub	r5,-4
800077d8:	12 31       	cp.w	r1,r9
800077da:	f9 b8 05 01 	movlt	r8,1
800077de:	f9 b8 04 00 	movge	r8,0
800077e2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077e6:	fe 9f fd 82 	bral	800072ea <MnsTraceParser+0x30e>
                                        break;
800077ea:	2f f1       	sub	r1,-1
                                    case 1:
                                        ADD_STR("Busy");
                                        break;

                                    case 2:
                                        ADD_STR("Schedule");
800077ec:	2f c5       	sub	r5,-4
800077ee:	4d 9b       	lddpc	r11,80007950 <MnsTraceParser+0x974>
800077f0:	cd 3b       	rjmp	80007796 <MnsTraceParser+0x7ba>
800077f2:	4d 9b       	lddpc	r11,80007954 <MnsTraceParser+0x978>
                                    case 0:
                                        ADD_STR("-");
                                        break;

                                    case 1:
                                        ADD_STR("Busy");
800077f4:	00 9c       	mov	r12,r0
800077f6:	e0 a0 83 9d 	rcall	80017f30 <strcat>
800077fa:	2f f1       	sub	r1,-1
800077fc:	0e 98       	mov	r8,r7
800077fe:	40 19       	lddsp	r9,sp[0x4]
80007800:	2f c5       	sub	r5,-4
80007802:	12 31       	cp.w	r1,r9
80007804:	f9 b8 04 00 	movge	r8,0
80007808:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000780c:	fe 9f fd 6f 	bral	800072ea <MnsTraceParser+0x30e>
                                        break;
80007810:	58 07       	cp.w	r7,0
                                break;

                                /*------------------------------------------------*/
                                case TY_P_TM_FLAGS:

                                switch(parm)
80007812:	fe 91 fe 9c 	brne	8000754a <MnsTraceParser+0x56e>
80007816:	2f f1       	sub	r1,-1
                                {
                                    case 0:
                                        ADD_STR("-");
80007818:	2f c5       	sub	r5,-4
8000781a:	4d 0b       	lddpc	r11,80007958 <MnsTraceParser+0x97c>
8000781c:	cb db       	rjmp	80007796 <MnsTraceParser+0x7ba>
8000781e:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown function 0x%04X].", parm);
80007820:	2f f1       	sub	r1,-1
80007822:	2f c5       	sub	r5,-4
80007824:	4c eb       	lddpc	r11,8000795c <MnsTraceParser+0x980>
80007826:	04 9c       	mov	r12,r2
                                exitFlag = MNS_TRUE;                       /* finish loop */
                                break;

                            /*------------------------------------------------*/
                            default:
                                ADD_STRING("TYPE_MISMATCH %d", parm);
80007828:	fe 9f fd eb 	bral	800073fe <MnsTraceParser+0x422>
8000782c:	30 08       	mov	r8,0

                            /*------------------------------------------------*/
                            case TY_P_FBLOCK:
                                if (NULL != (pFblock = GetFBlock(FBlockList, parm)))
                                {
                                    ADD_STRING(parmListPtr->FormatString, pFblock->name);
8000782e:	50 48       	stdsp	sp[0x10],r8
80007830:	1a d7       	st.w	--sp,r7
                                }
                                else
                                {
                                    ADD_STRING("[unknown FBlock 0x%02X].", parm);
80007832:	2f f1       	sub	r1,-1
80007834:	2f c5       	sub	r5,-4
80007836:	4c bb       	lddpc	r11,80007960 <MnsTraceParser+0x984>
80007838:	fe 9f fd c4 	bral	800073c0 <MnsTraceParser+0x3e4>
8000783c:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(parmListPtr->FormatString, pParmStr);
                                }
                                else
                                {
                                    ADD_STRING("[unknown service 0x%04X].", parm);
8000783e:	2f f1       	sub	r1,-1
80007840:	2f c5       	sub	r5,-4
80007842:	4c 9b       	lddpc	r11,80007964 <MnsTraceParser+0x988>
80007844:	04 9c       	mov	r12,r2
80007846:	fe 9f fd dc 	bral	800073fe <MnsTraceParser+0x422>
8000784a:	ef d7 c0 04 	bfextu	r7,r7,0x0,0x4
                                {
                                    ADD_STRING(".Alpha.%d", parm & 0xF);
                                }
                                else if ((parm > 0xB0) && (parm < 0xC0))
                                {
                                    ADD_STRING(".Beta.%d", parm & 0xF);
8000784e:	4c 7b       	lddpc	r11,80007968 <MnsTraceParser+0x98c>
80007850:	1a d7       	st.w	--sp,r7
80007852:	fe 9f fd 7c 	bral	8000734a <MnsTraceParser+0x36e>
80007856:	1a d7       	st.w	--sp,r7
                                    {
                                        ADD_STRING(parmListPtr->FormatString, pState->name);
                                    }
                                    else
                                    {
                                        ADD_STRING("[unknown state 0x%02X].", parm);
80007858:	2f f1       	sub	r1,-1
8000785a:	2f c5       	sub	r5,-4
8000785c:	4c 4b       	lddpc	r11,8000796c <MnsTraceParser+0x990>
8000785e:	04 9c       	mov	r12,r2
80007860:	fe 9f fd cf 	bral	800073fe <MnsTraceParser+0x422>
80007864:	1a d7       	st.w	--sp,r7
                                {
                                    ADD_STRING(".SR.RC.%d", parm & 0xF);
                                }
                                else
                                {
                                    ADD_STRING(".[unknown code = 0x%02X]", parm);
80007866:	4c 3b       	lddpc	r11,80007970 <MnsTraceParser+0x994>
80007868:	fe 9f fd 71 	bral	8000734a <MnsTraceParser+0x36e>
8000786c:	ef d7 c0 04 	bfextu	r7,r7,0x0,0x4
                                {
                                    ADD_STR("Distrib");
                                }
                                else if ((parm > 0xD0) && (parm < 0xE0))
                                {
                                    ADD_STRING(".RC.%d", parm & 0xF);
80007870:	4c 1b       	lddpc	r11,80007974 <MnsTraceParser+0x998>
80007872:	1a d7       	st.w	--sp,r7
80007874:	fe 9f fd 6b 	bral	8000734a <MnsTraceParser+0x36e>
80007878:	1a d7       	st.w	--sp,r7
                                        ADD_STRING("[unknown FktID 0x%03X].", parm);
                                    }
                                }
                                else
                                {
                                    ADD_STRING("[FktID 0x%03X].", parm);
8000787a:	2f f1       	sub	r1,-1
8000787c:	2f c5       	sub	r5,-4
8000787e:	4b fb       	lddpc	r11,80007978 <MnsTraceParser+0x99c>
80007880:	04 9c       	mov	r12,r2
80007882:	fe 9f fd be 	bral	800073fe <MnsTraceParser+0x422>
80007886:	4b eb       	lddpc	r11,8000797c <MnsTraceParser+0x9a0>
                                {
                                    ADD_STRING(".Beta.%d", parm & 0xF);
                                }
                                else if (parm == 0xD0)
                                {
                                    ADD_STR("Distrib");
80007888:	00 9c       	mov	r12,r0
8000788a:	e0 a0 83 53 	rcall	80017f30 <strcat>
8000788e:	fe 9f fd 66 	bral	8000735a <MnsTraceParser+0x37e>
80007892:	1a d7       	st.w	--sp,r7
                                    ADD_STRING("[unknown OpType 0x%01X].", parm);
                                }
                                }
                                else
                                {
                                    ADD_STRING("[OpType 0x%01X].", parm);
80007894:	2f f1       	sub	r1,-1
80007896:	2f c5       	sub	r5,-4
80007898:	4b ab       	lddpc	r11,80007980 <MnsTraceParser+0x9a4>
8000789a:	04 9c       	mov	r12,r2
8000789c:	fe 9f fd b1 	bral	800073fe <MnsTraceParser+0x422>
800078a0:	4b 9b       	lddpc	r11,80007984 <MnsTraceParser+0x9a8>
                                {
                                    ADD_STRING(".RC.%d", parm & 0xF);
                                }
                                else if (parm == 0xE0)
                                {
                                    ADD_STR("SR");
800078a2:	00 9c       	mov	r12,r0
800078a4:	e0 a0 83 46 	rcall	80017f30 <strcat>
800078a8:	fe 9f fd 59 	bral	8000735a <MnsTraceParser+0x37e>
800078ac:	30 08       	mov	r8,0

                            /*------------------------------------------------*/
                            case TY_P_STATEMACHINE:
                                if (NULL != (pStateM = GetStateM(StateMList, parm)))
                                {
                                    ADD_STRING(parmListPtr->FormatString, pStateM->name);
800078ae:	50 38       	stdsp	sp[0xc],r8
800078b0:	fe 9f fe 6b 	bral	80007586 <MnsTraceParser+0x5aa>
800078b4:	30 08       	mov	r8,0
                            case TY_P_FKTID:
                                if (NULL != pFblock)
                                {
                                    if (NULL != (pFkt = GetFktName(pFblock->fktList, parm)))
                                    {
                                        ADD_STRING(parmListPtr->FormatString, pFkt->name);
800078b6:	50 28       	stdsp	sp[0x8],r8
800078b8:	c1 6b       	rjmp	800076e4 <MnsTraceParser+0x708>
800078ba:	d7 03       	nop
800078bc:	80 06       	ld.sh	r6,r0[0x0]
800078be:	b0 f4       	st.b	r8[0x7],r4
800078c0:	80 06       	ld.sh	r6,r0[0x0]
800078c2:	ba 3c       	st.h	sp[0x6],r12
800078c4:	80 06       	ld.sh	r6,r0[0x0]
800078c6:	ba 50       	st.h	sp[0xa],r0
800078c8:	80 06       	ld.sh	r6,r0[0x0]
800078ca:	ba 44       	st.h	sp[0x8],r4
800078cc:	80 06       	ld.sh	r6,r0[0x0]
800078ce:	bc a8       	st.b	lr[0x2],r8
800078d0:	80 06       	ld.sh	r6,r0[0x0]
800078d2:	a2 e0       	st.b	r1[0x6],r0
800078d4:	80 06       	ld.sh	r6,r0[0x0]
800078d6:	ba 68       	st.h	sp[0xc],r8
800078d8:	80 06       	ld.sh	r6,r0[0x0]
800078da:	a9 28       	st.d	r4++,r8
800078dc:	80 06       	ld.sh	r6,r0[0x0]
800078de:	b9 14       	ld.d	r4,--r12
800078e0:	80 06       	ld.sh	r6,r0[0x0]
800078e2:	bc 94       	st.b	lr[0x1],r4
800078e4:	80 06       	ld.sh	r6,r0[0x0]
800078e6:	bc 04       	st.h	lr[0x0],r4
800078e8:	80 06       	ld.sh	r6,r0[0x0]
800078ea:	bc 2c       	st.h	lr[0x4],r12
800078ec:	80 06       	ld.sh	r6,r0[0x0]
800078ee:	b9 cc       	cbr	r12,0x18
800078f0:	80 06       	ld.sh	r6,r0[0x0]
800078f2:	bc 78       	st.h	lr[0xe],r8
800078f4:	80 06       	ld.sh	r6,r0[0x0]
800078f6:	ac b4       	st.b	r6[0x3],r4
800078f8:	80 06       	ld.sh	r6,r0[0x0]
800078fa:	bc 7c       	st.h	lr[0xe],r12
800078fc:	80 06       	ld.sh	r6,r0[0x0]
800078fe:	a1 50       	asr	r0,0x1
80007900:	80 06       	ld.sh	r6,r0[0x0]
80007902:	bb 84       	lsr	r4,0x1a
80007904:	80 06       	ld.sh	r6,r0[0x0]
80007906:	b9 84       	lsr	r4,0x18
80007908:	80 06       	ld.sh	r6,r0[0x0]
8000790a:	bb 68       	lsl	r8,0x1a
8000790c:	80 06       	ld.sh	r6,r0[0x0]
8000790e:	bb c4       	cbr	r4,0x1a
80007910:	80 06       	ld.sh	r6,r0[0x0]
80007912:	ab e8       	*unknown*
80007914:	80 06       	ld.sh	r6,r0[0x0]
80007916:	bb 18       	ld.d	r8,--sp
80007918:	80 06       	ld.sh	r6,r0[0x0]
8000791a:	b9 ec       	*unknown*
8000791c:	80 06       	ld.sh	r6,r0[0x0]
8000791e:	bb 50       	asr	r0,0x1b
80007920:	80 06       	ld.sh	r6,r0[0x0]
80007922:	b6 14       	st.h	r11[0x2],r4
80007924:	80 06       	ld.sh	r6,r0[0x0]
80007926:	bb 38       	mul	r8,sp
80007928:	80 06       	ld.sh	r6,r0[0x0]
8000792a:	b3 7c       	lsl	r12,0x13
8000792c:	80 06       	ld.sh	r6,r0[0x0]
8000792e:	b0 44       	st.h	r8[0x8],r4
80007930:	80 06       	ld.sh	r6,r0[0x0]
80007932:	ba e8       	st.b	sp[0x6],r8
80007934:	80 06       	ld.sh	r6,r0[0x0]
80007936:	ba c0       	st.b	sp[0x4],r0
80007938:	80 06       	ld.sh	r6,r0[0x0]
8000793a:	ab 90       	lsr	r0,0xb
8000793c:	80 06       	ld.sh	r6,r0[0x0]
8000793e:	bb cc       	cbr	r12,0x1a
80007940:	80 06       	ld.sh	r6,r0[0x0]
80007942:	ba 80       	st.b	sp[0x0],r0
80007944:	80 06       	ld.sh	r6,r0[0x0]
80007946:	bc 4c       	st.h	lr[0x8],r12
80007948:	80 06       	ld.sh	r6,r0[0x0]
8000794a:	bb d8       	cbr	r8,0x1b
8000794c:	80 06       	ld.sh	r6,r0[0x0]
8000794e:	bb b4       	sbr	r4,0x1b
80007950:	80 06       	ld.sh	r6,r0[0x0]
80007952:	bb a8       	sbr	r8,0x1a
80007954:	80 06       	ld.sh	r6,r0[0x0]
80007956:	bb a0       	sbr	r0,0x1a
80007958:	80 06       	ld.sh	r6,r0[0x0]
8000795a:	bb 9c       	lsr	r12,0x1b
8000795c:	80 06       	ld.sh	r6,r0[0x0]
8000795e:	ba 88       	st.b	sp[0x0],r8
80007960:	80 06       	ld.sh	r6,r0[0x0]
80007962:	ba a4       	st.b	sp[0x2],r4
80007964:	80 06       	ld.sh	r6,r0[0x0]
80007966:	bc 5c       	st.h	lr[0xa],r12
80007968:	80 06       	ld.sh	r6,r0[0x0]
8000796a:	bb e4       	*unknown*
8000796c:	80 06       	ld.sh	r6,r0[0x0]
8000796e:	bc 34       	st.h	lr[0x6],r4
80007970:	80 06       	ld.sh	r6,r0[0x0]
80007972:	bc 10       	st.h	lr[0x2],r0
80007974:	80 06       	ld.sh	r6,r0[0x0]
80007976:	bb f8       	*unknown*
80007978:	80 06       	ld.sh	r6,r0[0x0]
8000797a:	ba d8       	st.b	sp[0x5],r8
8000797c:	80 06       	ld.sh	r6,r0[0x0]
8000797e:	bb f0       	*unknown*
80007980:	80 06       	ld.sh	r6,r0[0x0]
80007982:	bb 04       	ld.d	r4,sp
80007984:	80 06       	ld.sh	r6,r0[0x0]
80007986:	bc 00       	st.h	lr[0x0],r0

80007988 <prepare_mns_config>:
	cfg_ptr->general.on_error_fptr              = mns_on_error;
	cfg_ptr->general.on_buf_freed_fptr          = NULL;
	cfg_ptr->general.get_tick_count_fptr        = TmrGetMasterTick_Word;
	cfg_ptr->general.next_min_timeout_fptr      = mns_next_min_timeout;

	cfg_ptr->general.watchdogmode.overwrite     = MNS_TRUE;
80007988:	30 19       	mov	r9,1
	cfg_ptr->wads.rx_filter_fptr            = data_rx_filter;
	#ifdef DATA_TX_USER_PAYLOAD
	cfg_ptr->msg.free_data_tx_payload_fptr  = data_free_tx_payload_buf;
	#endif
	cfg_ptr->wads.rx_direct                 = MNS_FALSE;
	cfg_ptr->wads.rx_burst                  = 1;
8000798a:	f9 69 00 7c 	st.b	r12[124],r9
	cfg_ptr->general.on_error_fptr              = mns_on_error;
	cfg_ptr->general.on_buf_freed_fptr          = NULL;
	cfg_ptr->general.get_tick_count_fptr        = TmrGetMasterTick_Word;
	cfg_ptr->general.next_min_timeout_fptr      = mns_next_min_timeout;

	cfg_ptr->general.watchdogmode.overwrite     = MNS_TRUE;
8000798e:	f9 69 00 20 	st.b	r12[32],r9
	cfg_ptr->general.watchdogmode.reset         = MNS_FALSE;
	cfg_ptr->general.watchdogmode.timeout       = MNS_TM_WD_DISABLE;
	cfg_ptr->general.watchdogmode.auto_shutdown_delay = 0xFFFF;

	cfg_ptr->general.burst                      = 1;
80007992:	f9 69 00 28 	st.b	r12[40],r9
	#endif
	#ifndef PMS_RX_OPT4
	cfg_ptr->msg.rx_direct                  = MNS_FALSE;
	#endif
	cfg_ptr->msg.retry_config_adjusted_fptr = msg_retry_config_adjusted;
	cfg_ptr->msg.rx_burst                   = 1;
80007996:	f9 69 00 6c 	st.b	r12[108],r9
	cfg_ptr->general.get_tick_count_fptr        = TmrGetMasterTick_Word;
	cfg_ptr->general.next_min_timeout_fptr      = mns_next_min_timeout;

	cfg_ptr->general.watchdogmode.overwrite     = MNS_TRUE;
	cfg_ptr->general.watchdogmode.reset         = MNS_FALSE;
	cfg_ptr->general.watchdogmode.timeout       = MNS_TM_WD_DISABLE;
8000799a:	3f f9       	mov	r9,-1
	cfg_ptr->general.watchdogmode.auto_shutdown_delay = 0xFFFF;
8000799c:	f9 59 00 24 	st.h	r12[36],r9
	cfg_ptr->general.get_tick_count_fptr        = TmrGetMasterTick_Word;
	cfg_ptr->general.next_min_timeout_fptr      = mns_next_min_timeout;

	cfg_ptr->general.watchdogmode.overwrite     = MNS_TRUE;
	cfg_ptr->general.watchdogmode.reset         = MNS_FALSE;
	cfg_ptr->general.watchdogmode.timeout       = MNS_TM_WD_DISABLE;
800079a0:	f9 59 00 22 	st.h	r12[34],r9
  * @see   InitNetServices
  */
void prepare_mns_config(TNetServicesConfig *cfg_ptr)
{
	/* general system callbacks */
	cfg_ptr->general.most_service_request_fptr  = mns_service_request;
800079a4:	fe c9 ff 10 	sub	r9,pc,-240
	cfg_ptr->general.on_init_complete_fptr      = mns_on_init_complete;
800079a8:	99 09       	st.w	r12[0x0],r9
800079aa:	fe c9 f8 aa 	sub	r9,pc,-1878
	cfg_ptr->general.on_stop_netservices_fptr   = NULL;
	cfg_ptr->general.on_error_fptr              = mns_on_error;
800079ae:	99 19       	st.w	r12[0x4],r9
	cfg_ptr->general.on_buf_freed_fptr          = NULL;
	cfg_ptr->general.get_tick_count_fptr        = TmrGetMasterTick_Word;
800079b0:	fe c9 fc 54 	sub	r9,pc,-940
	cfg_ptr->general.next_min_timeout_fptr      = mns_next_min_timeout;
800079b4:	99 49       	st.w	r12[0x10],r9
800079b6:	fe c9 0d 6e 	sub	r9,pc,3438
	cfg_ptr->general.watchdogmode.auto_shutdown_delay = 0xFFFF;

	cfg_ptr->general.burst                      = 1;

	/* LLD interface callbacks and configuration */
	cfg_ptr->lld.start_interfaces_fptr          = lld_start_interfaces;
800079ba:	99 69       	st.w	r12[0x18],r9
	cfg_ptr->lld.reset_fptr                     = lld_reset;
800079bc:	fe c9 f8 c8 	sub	r9,pc,-1848
	cfg_ptr->lld.on_buf_freed_fptr              = lld_on_buf_freed;
800079c0:	99 79       	st.w	r12[0x1c],r9
800079c2:	fe c9 0f 5e 	sub	r9,pc,3934
	cfg_ptr->lld.i2c_tx_fptr                    = lld_i2c_transmit;     // using I2C for control / packet(if any)
800079c6:	99 b9       	st.w	r12[0x2c],r9
	cfg_ptr->lld.data_tx_fptr                   = NULL;
	cfg_ptr->lld.data_interface_id              = PMS_IFACE_I2C;

	/* application (control) message service wrapper callbacks */
	#ifdef AMS_MIN
	cfg_ptr->msg.tx_status_fptr             = msg_tx_status;
800079c8:	fe c9 0d c8 	sub	r9,pc,3528
800079cc:	99 d9       	st.w	r12[0x34],r9
	cfg_ptr->msg.tx_filter_fptr             = msg_tx_filter;
800079ce:	fe c9 0e 82 	sub	r9,pc,3714
800079d2:	99 e9       	st.w	r12[0x38],r9
	cfg_ptr->msg.rx_complete_fptr           = msg_rx_complete;
800079d4:	fe c9 0e 60 	sub	r9,pc,3680
800079d8:	99 f9       	st.w	r12[0x3c],r9
	#endif
	#ifdef MSG_TX_USER_PAYLOAD
	cfg_ptr->msg.free_tx_payload_buf_fptr   = msg_free_tx_payload_buf;
	#endif
	#ifdef NS_AMS_MSV2
	cfg_ptr->msg.tx_buffer_flushed_fptr     = msg_tx_buffer_flushed;
800079da:	fe c9 ff 3a 	sub	r9,pc,-198
800079de:	f9 49 00 50 	st.w	r12[80],r9
	cfg_ptr->msg.tx_msg_flushed_fptr        = msg_tx_msg_flushed;
800079e2:	fe c9 ff 38 	sub	r9,pc,-200
	#endif
	#ifndef PMS_RX_OPT4
	cfg_ptr->msg.rx_direct                  = MNS_FALSE;
	#endif
	cfg_ptr->msg.retry_config_adjusted_fptr = msg_retry_config_adjusted;
800079e6:	f9 49 00 54 	st.w	r12[84],r9
800079ea:	fe c9 ff 3e 	sub	r9,pc,-194
	cfg_ptr->msg.rx_burst                   = 1;
	#endif

	/* pms configuration */
	cfg_ptr->pms.rx_burst                       = 4;
800079ee:	f9 49 00 58 	st.w	r12[88],r9


	/* asynchronous (packet) data service wrapper callbacks */
	#ifdef ADS_MIN
	cfg_ptr->wads.tx_status_fptr            = data_tx_status;
800079f2:	fe c9 fc aa 	sub	r9,pc,-854
800079f6:	f9 49 00 60 	st.w	r12[96],r9
void prepare_mns_config(TNetServicesConfig *cfg_ptr)
{
	/* general system callbacks */
	cfg_ptr->general.most_service_request_fptr  = mns_service_request;
	cfg_ptr->general.on_init_complete_fptr      = mns_on_init_complete;
	cfg_ptr->general.on_stop_netservices_fptr   = NULL;
800079fa:	fe c9 ff 1e 	sub	r9,pc,-226


	/* asynchronous (packet) data service wrapper callbacks */
	#ifdef ADS_MIN
	cfg_ptr->wads.tx_status_fptr            = data_tx_status;
	cfg_ptr->wads.rx_complete_fptr          = data_rx_complete;
800079fe:	f9 49 00 64 	st.w	r12[100],r9
	/* general system callbacks */
	cfg_ptr->general.most_service_request_fptr  = mns_service_request;
	cfg_ptr->general.on_init_complete_fptr      = mns_on_init_complete;
	cfg_ptr->general.on_stop_netservices_fptr   = NULL;
	cfg_ptr->general.on_error_fptr              = mns_on_error;
	cfg_ptr->general.on_buf_freed_fptr          = NULL;
80007a02:	fe c9 ff 36 	sub	r9,pc,-202
	cfg_ptr->general.get_tick_count_fptr        = TmrGetMasterTick_Word;
	cfg_ptr->general.next_min_timeout_fptr      = mns_next_min_timeout;

	cfg_ptr->general.watchdogmode.overwrite     = MNS_TRUE;
	cfg_ptr->general.watchdogmode.reset         = MNS_FALSE;
80007a06:	f9 49 00 68 	st.w	r12[104],r9
	/* LLD interface callbacks and configuration */
	cfg_ptr->lld.start_interfaces_fptr          = lld_start_interfaces;
	cfg_ptr->lld.reset_fptr                     = lld_reset;
	cfg_ptr->lld.on_buf_freed_fptr              = lld_on_buf_freed;
	cfg_ptr->lld.i2c_tx_fptr                    = lld_i2c_transmit;     // using I2C for control / packet(if any)
	cfg_ptr->lld.ctrl_tx_fptr                   = NULL;
80007a0a:	30 49       	mov	r9,4
	cfg_ptr->lld.data_tx_fptr                   = NULL;
80007a0c:	f9 69 00 4c 	st.b	r12[76],r9
	cfg_ptr->lld.data_interface_id              = PMS_IFACE_I2C;
80007a10:	fe c9 ff 60 	sub	r9,pc,-160
	#ifdef NS_AMS_MSV2
	cfg_ptr->msg.tx_buffer_flushed_fptr     = msg_tx_buffer_flushed;
	cfg_ptr->msg.tx_msg_flushed_fptr        = msg_tx_msg_flushed;
	#endif
	#ifndef PMS_RX_OPT4
	cfg_ptr->msg.rx_direct                  = MNS_FALSE;
80007a14:	f9 49 00 70 	st.w	r12[112],r9
	cfg_ptr->wads.rx_complete_fptr          = data_rx_complete;
	cfg_ptr->wads.rx_filter_fptr            = data_rx_filter;
	#ifdef DATA_TX_USER_PAYLOAD
	cfg_ptr->msg.free_data_tx_payload_fptr  = data_free_tx_payload_buf;
	#endif
	cfg_ptr->wads.rx_direct                 = MNS_FALSE;
80007a18:	fe c9 ff 66 	sub	r9,pc,-154

	/* asynchronous (packet) data service wrapper callbacks */
	#ifdef ADS_MIN
	cfg_ptr->wads.tx_status_fptr            = data_tx_status;
	cfg_ptr->wads.rx_complete_fptr          = data_rx_complete;
	cfg_ptr->wads.rx_filter_fptr            = data_rx_filter;
80007a1c:	30 08       	mov	r8,0
80007a1e:	f9 49 00 74 	st.w	r12[116],r9
	cfg_ptr->wads.rx_burst                  = 1;
	#endif

	/* virtual MOST supervisor service callbacks */
	#ifdef VMSV_MIN
	cfg_ptr->vmsv.msval_state_changed_fptr      = msval_state_changed;
80007a22:	99 28       	st.w	r12[0x8],r8
80007a24:	99 58       	st.w	r12[0x14],r8
80007a26:	f9 68 00 21 	st.b	r12[33],r8
	/* diag results callbacks */
	#ifdef MSV_DIAG_RESULT_MSG
	cfg_ptr->vmsv.rbd_store_rbd_result_fptr     = msval_store_rbd_result;
	cfg_ptr->vmsv.diag_id.length = sizeof(diag_id);
	cfg_ptr->vmsv.diag_id.stream = diag_id;
	cfg_ptr->vmsv.sso_restore_ssoresult_fptr = NULL;
80007a2a:	f9 48 00 40 	st.w	r12[64],r8
	#endif

	/* virtual MOST supervisor service callbacks */
	#ifdef VMSV_MIN
	cfg_ptr->vmsv.msval_state_changed_fptr      = msval_state_changed;
	cfg_ptr->vmsv.msval_error_fptr              = msval_error;
80007a2e:	f9 48 00 44 	st.w	r12[68],r8
	cfg_ptr->vmsv.msval_event_fptr              = msval_event;
80007a32:	f9 68 00 49 	st.b	r12[73],r8
80007a36:	f9 68 00 6d 	st.b	r12[109],r8
	cfg_ptr->vmsv.msval_diag_result_fptr        = msval_diag_result;
80007a3a:	f9 68 00 7d 	st.b	r12[125],r8
	cfg_ptr->vmsv.pmistate_changed_fptr         = pmistate_changed;
80007a3e:	fe c9 ff 8a 	sub	r9,pc,-118
80007a42:	f9 49 00 78 	st.w	r12[120],r9
	#endif

	/* diag results callbacks */
	#ifdef MSV_DIAG_RESULT_MSG
	cfg_ptr->vmsv.rbd_store_rbd_result_fptr     = msval_store_rbd_result;
80007a46:	fe c9 f9 ea 	sub	r9,pc,-1558
	cfg_ptr->vmsv.diag_id.length = sizeof(diag_id);
80007a4a:	f9 49 00 80 	st.w	r12[128],r9
80007a4e:	f9 48 00 a4 	st.w	r12[164],r8
	cfg_ptr->vmsv.diag_id.stream = diag_id;
80007a52:	fe c8 fd 9e 	sub	r8,pc,-610
	#endif


	/* Socket Connection Manager service callbacks */
	#ifdef SCM_MIN
	cfg_ptr->scm.on_error_fptr                  = scm_error;
80007a56:	f9 48 00 84 	st.w	r12[132],r8
80007a5a:	fe c8 fe 82 	sub	r8,pc,-382
	#endif
}
80007a5e:	f9 48 00 88 	st.w	r12[136],r8
80007a62:	fe c8 fa b2 	sub	r8,pc,-1358
80007a66:	f9 48 00 8c 	st.w	r12[140],r8
80007a6a:	fe c8 ff 36 	sub	r8,pc,-202
80007a6e:	f9 48 00 90 	st.w	r12[144],r8
80007a72:	fe c8 fb 4e 	sub	r8,pc,-1202
80007a76:	f9 48 00 94 	st.w	r12[148],r8
80007a7a:	30 88       	mov	r8,8
80007a7c:	f9 68 00 9c 	st.b	r12[156],r8
80007a80:	48 48       	lddpc	r8,80007a90 <prepare_mns_config+0x108>
80007a82:	f9 48 00 98 	st.w	r12[152],r8
80007a86:	fe c8 fb e6 	sub	r8,pc,-1050
80007a8a:	f9 48 00 a8 	st.w	r12[168],r8
80007a8e:	5e fc       	retal	r12
80007a90:	00 00       	add	r0,r0
80007a92:	00 a0       	st.w	r0++,r0

80007a94 <mns_service_request>:
80007a94:	30 19       	mov	r9,1
80007a96:	48 28       	lddpc	r8,80007a9c <mns_service_request+0x8>
80007a98:	b0 89       	st.b	r8[0x0],r9
80007a9a:	5e fc       	retal	r12
80007a9c:	00 00       	add	r0,r0
80007a9e:	4a 96       	lddpc	r6,80007b40 <pmistate_changed+0xc>

80007aa0 <msg_tx_status>:
80007aa0:	32 08       	mov	r8,32
80007aa2:	f8 08 18 00 	cp.b	r8,r12
80007aa6:	5f 0c       	sreq	r12
80007aa8:	5e fc       	retal	r12

80007aaa <msg_tx_filter>:
80007aaa:	5e fd       	retal	0

80007aac <msg_rx_complete>:
80007aac:	30 4c       	mov	r12,4
80007aae:	5e fc       	retal	r12

80007ab0 <data_tx_status>:
80007ab0:	5e fc       	retal	r12

80007ab2 <data_rx_complete>:
80007ab2:	5e ff       	retal	1

80007ab4 <data_rx_filter>:
80007ab4:	5e fd       	retal	0

80007ab6 <mns_take>:
80007ab6:	5e fc       	retal	r12

80007ab8 <mns_give>:
80007ab8:	5e fc       	retal	r12
80007aba:	d7 03       	nop

80007abc <PrintErrorLine>:
80007abc:	d4 01       	pushm	lr
80007abe:	e0 a0 80 a9 	rcall	80017c10 <puts>
80007ac2:	d8 02       	popm	pc

80007ac4 <PrintTraceLine>:
80007ac4:	d4 01       	pushm	lr
80007ac6:	e0 a0 80 a5 	rcall	80017c10 <puts>
/*                                                                          */
/*--------------------------------------------------------------------------*/
void PrintTraceLine(const char *str)
{
	LOG_NOR("%s\n", str);
}
80007aca:	d8 02       	popm	pc

80007acc <msg_retry_config_adjusted>:
80007acc:	d4 01       	pushm	lr
80007ace:	48 3c       	lddpc	r12,80007ad8 <msg_retry_config_adjusted+0xc>
*
* The parameter config_ptr denotes the current retry configuration.
*/
static void msg_retry_config_adjusted(TMsgRetryConfig *config_ptr)
{
	LOG_NOR("msg_retry_config_adjusted()\n");
80007ad0:	e0 a0 80 a0 	rcall	80017c10 <puts>
}
80007ad4:	d8 02       	popm	pc
80007ad6:	d7 03       	nop
80007ad8:	80 06       	ld.sh	r6,r0[0x0]
80007ada:	ea c4 d4 01 	sub	r4,r5,-11263

80007adc <msg_tx_msg_flushed>:
80007adc:	d4 01       	pushm	lr
80007ade:	48 3c       	lddpc	r12,80007ae8 <msg_tx_msg_flushed+0xc>
{
	// This callback function is called, if a message is filtered by the
	// Configuration State Based Message Filter or if it is flushed from
	// a TX FIFO prior to a NS reinit.

	LOG_NOR("msg_tx_msg_flushed()\n");
80007ae0:	e0 a0 80 98 	rcall	80017c10 <puts>

	return;
}
80007ae4:	d8 02       	popm	pc
80007ae6:	d7 03       	nop
80007ae8:	80 06       	ld.sh	r6,r0[0x0]
80007aea:	ea e0 d4 21 	ld.d	r0,r5[-11231]

80007aec <mns_trace>:
80007aec:	d4 21       	pushm	r4-r7,lr
80007aee:	20 7d       	sub	sp,28
* @param service identifier of the service
* @param event   identifier of the event
* @param pcnt    number of parameters following
*/
void mns_trace(int service, int event, int pcnt, ...)
{
80007af0:	18 97       	mov	r7,r12
80007af2:	14 96       	mov	r6,r10
*
* @param service identifier of the service
* @param event   identifier of the event
* @param pcnt    number of parameters following
*/
void mns_trace(int service, int event, int pcnt, ...)
80007af4:	fa c4 ff d0 	sub	r4,sp,-48
	va_list ap;
	int     cnt = 0;
	int     params[NST_MAX_PCNT];

	va_start(ap, pcnt);
	for (;cnt < pcnt; cnt++)
80007af8:	58 0a       	cp.w	r10,0
80007afa:	e0 8a 00 1a 	brle	80007b2e <mns_trace+0x42>
*
* @param service identifier of the service
* @param event   identifier of the event
* @param pcnt    number of parameters following
*/
void mns_trace(int service, int event, int pcnt, ...)
80007afe:	a3 6a       	lsl	r10,0x2
80007b00:	30 08       	mov	r8,0
80007b02:	fa c5 ff fc 	sub	r5,sp,-4
	int     params[NST_MAX_PCNT];

	va_start(ap, pcnt);
	for (;cnt < pcnt; cnt++)
	{
		params[cnt] = va_arg(ap, int);
80007b06:	e8 08 03 09 	ld.w	r9,r4[r8]
80007b0a:	ea 08 09 09 	st.w	r5[r8],r9
80007b0e:	2f c8       	sub	r8,-4
	va_list ap;
	int     cnt = 0;
	int     params[NST_MAX_PCNT];

	va_start(ap, pcnt);
	for (;cnt < pcnt; cnt++)
80007b10:	14 38       	cp.w	r8,r10
80007b12:	cf a1       	brne	80007b06 <mns_trace+0x1a>
	{
		params[cnt] = va_arg(ap, int);
	}
	va_end(ap);

	MnsTraceParser(service, event, TmrGetMasterTick_Word(), pcnt, params);
80007b14:	50 0b       	stdsp	sp[0x0],r11
80007b16:	fe b0 f8 99 	rcall	80006c48 <TmrGetMasterTick_Word>
80007b1a:	0a 98       	mov	r8,r5
80007b1c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80007b20:	0c 99       	mov	r9,r6
80007b22:	40 0b       	lddsp	r11,sp[0x0]
80007b24:	0e 9c       	mov	r12,r7
80007b26:	fe b0 fa 5b 	rcall	80006fdc <MnsTraceParser>
}
80007b2a:	2f 9d       	sub	sp,-28
80007b2c:	d8 22       	popm	r4-r7,pc
80007b2e:	fa c5 ff fc 	sub	r5,sp,-4
80007b32:	cf 1b       	rjmp	80007b14 <mns_trace+0x28>

80007b34 <pmistate_changed>:
80007b34:	eb cd 40 c0 	pushm	r6-r7,lr
80007b38:	18 97       	mov	r7,r12
80007b3a:	16 96       	mov	r6,r11
/*! The MOST NetServices call this function to deliver the Power Management
* Interface state.
*/
static void pmistate_changed(byte state, byte events)
{
	LOG_NOR("PMI State: ");
80007b3c:	49 cc       	lddpc	r12,80007bac <pmistate_changed+0x78>
80007b3e:	e0 a0 7f d3 	rcall	80017ae4 <printf>
	switch (state)
80007b42:	30 18       	mov	r8,1
80007b44:	f0 07 18 00 	cp.b	r7,r8
80007b48:	c2 e0       	breq	80007ba4 <pmistate_changed+0x70>
80007b4a:	c2 03       	brcs	80007b8a <pmistate_changed+0x56>
80007b4c:	30 28       	mov	r8,2
80007b4e:	f0 07 18 00 	cp.b	r7,r8
80007b52:	c0 41       	brne	80007b5a <pmistate_changed+0x26>
			break;
		case PMI_STATE_CRITICAL:
			LOG_NOR("PMI_STATE_CRITICAL\n");
			break;
		case PMI_STATE_OFF:
			LOG_NOR("PMI_STATE_OFF\n");
80007b54:	49 7c       	lddpc	r12,80007bb0 <pmistate_changed+0x7c>
80007b56:	e0 a0 80 5d 	rcall	80017c10 <puts>
			break;
	}
	LOG_NOR("PMI Events: PMI_REQPWROFF is ");
80007b5a:	49 7c       	lddpc	r12,80007bb4 <pmistate_changed+0x80>
80007b5c:	e0 a0 7f c4 	rcall	80017ae4 <printf>
	if (events & 0x01)
80007b60:	ed b6 00 00 	bld	r6,0x0
80007b64:	c1 71       	brne	80007b92 <pmistate_changed+0x5e>
	{
		LOG_NOR("True, ready to power down\n");
80007b66:	49 5c       	lddpc	r12,80007bb8 <pmistate_changed+0x84>
80007b68:	e0 a0 80 54 	rcall	80017c10 <puts>
//		{
//			PwrShutDown();  // let power manager shut down our node
//		}
//		else
//		{
			LOG_NOR("DIP Sw6 is on - can't shut down\n");
80007b6c:	49 4c       	lddpc	r12,80007bbc <pmistate_changed+0x88>
80007b6e:	e0 a0 80 51 	rcall	80017c10 <puts>
	}
	else
	{
		LOG_NOR("False, staying powered up");
	}
	LOG_NOR(" - PMI_STP, Switch to Power is  ");
80007b72:	49 4c       	lddpc	r12,80007bc0 <pmistate_changed+0x8c>
	if (events & 0x02)
80007b74:	e2 16 00 02 	andl	r6,0x2,COH
	}
	else
	{
		LOG_NOR("False, staying powered up");
	}
	LOG_NOR(" - PMI_STP, Switch to Power is  ");
80007b78:	e0 a0 7f b6 	rcall	80017ae4 <printf>
	if (events & 0x02)
80007b7c:	58 06       	cp.w	r6,0
80007b7e:	c0 e1       	brne	80007b9a <pmistate_changed+0x66>
	{
		LOG_NOR("True\n");
	}
	else
	{
		LOG_NOR("False\n");
80007b80:	49 1c       	lddpc	r12,80007bc4 <pmistate_changed+0x90>
80007b82:	e0 a0 80 47 	rcall	80017c10 <puts>
80007b86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
{
	LOG_NOR("PMI State: ");
	switch (state)
	{
		case PMI_STATE_NORMAL:
			LOG_NOR("PMI_STATE_NORMAL\n");
80007b8a:	49 0c       	lddpc	r12,80007bc8 <pmistate_changed+0x94>
80007b8c:	e0 a0 80 42 	rcall	80017c10 <puts>
			break;
80007b90:	ce 5b       	rjmp	80007b5a <pmistate_changed+0x26>
			LOG_NOR("DIP Sw6 is on - can't shut down\n");
//		}
	}
	else
	{
		LOG_NOR("False, staying powered up");
80007b92:	48 fc       	lddpc	r12,80007bcc <pmistate_changed+0x98>
80007b94:	e0 a0 7f a8 	rcall	80017ae4 <printf>
80007b98:	ce db       	rjmp	80007b72 <pmistate_changed+0x3e>
	}
	LOG_NOR(" - PMI_STP, Switch to Power is  ");
	if (events & 0x02)
	{
		LOG_NOR("True\n");
80007b9a:	48 ec       	lddpc	r12,80007bd0 <pmistate_changed+0x9c>
80007b9c:	e0 a0 80 3a 	rcall	80017c10 <puts>
80007ba0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	{
		case PMI_STATE_NORMAL:
			LOG_NOR("PMI_STATE_NORMAL\n");
			break;
		case PMI_STATE_CRITICAL:
			LOG_NOR("PMI_STATE_CRITICAL\n");
80007ba4:	48 cc       	lddpc	r12,80007bd4 <pmistate_changed+0xa0>
80007ba6:	e0 a0 80 35 	rcall	80017c10 <puts>
			break;
80007baa:	cd 8b       	rjmp	80007b5a <pmistate_changed+0x26>
80007bac:	80 06       	ld.sh	r6,r0[0x0]
80007bae:	ea f8 80 06 	ld.w	r8,r5[-32762]
80007bb2:	eb 2c 80 06 	ld.sb	r12,r5[-32762]
80007bb6:	eb 3c 80 06 	ld.ub	r12,r5[-32762]
80007bba:	eb 5c 80 06 	st.h	r5[-32762],r12
80007bbe:	eb 78 80 06 	stcond	r5[-32762],r8
80007bc2:	eb b4       	*unknown*
80007bc4:	80 06       	ld.sh	r6,r0[0x0]
80007bc6:	eb e0 80 06 	sthh.w	r6[r0],r5:b,r0:b
80007bca:	eb 04 80 06 	ld.sh	r4,r5[-32762]
80007bce:	eb 98       	*unknown*
80007bd0:	80 06       	ld.sh	r6,r0[0x0]
80007bd2:	eb d8 80 06 	ldswp.w	r8,r5[24]
80007bd6:	eb 18 d4 01 	ld.uh	r8,r5[-11263]

80007bd8 <msval_event>:
80007bd8:	d4 01       	pushm	lr
80007bda:	31 28       	mov	r8,18
80007bdc:	f0 0c 18 00 	cp.b	r12,r8
* @param event is the code identifing the event
* @param info_ptr contains additional information or NULL
*/
static void msval_event(byte event, byte *info_ptr)
{
	switch (event)
80007be0:	c5 00       	breq	80007c80 <msval_event+0xa8>
80007be2:	e0 88 00 16 	brls	80007c0e <msval_event+0x36>
80007be6:	32 18       	mov	r8,33
80007be8:	f0 0c 18 00 	cp.b	r12,r8
80007bec:	c3 e0       	breq	80007c68 <msval_event+0x90>
80007bee:	e0 8b 00 21 	brhi	80007c30 <msval_event+0x58>
80007bf2:	31 38       	mov	r8,19
80007bf4:	f0 0c 18 00 	cp.b	r12,r8
80007bf8:	c3 40       	breq	80007c60 <msval_event+0x88>
80007bfa:	32 08       	mov	r8,32
80007bfc:	f0 0c 18 00 	cp.b	r12,r8
80007c00:	c2 c0       	breq	80007c58 <msval_event+0x80>
			break;
		case MSVAL_E_NET_ACTIVITY:
			LOG_NOR("msval_event(MSVAL_E_NET_ACTIVITY)\n");
			break;
		default:
			LOG_NOR("Unknown msval_event, event code is: %02X\n", event);
80007c02:	1a dc       	st.w	--sp,r12
80007c04:	4a 1c       	lddpc	r12,80007c88 <msval_event+0xb0>
80007c06:	e0 a0 7f 6f 	rcall	80017ae4 <printf>
80007c0a:	2f fd       	sub	sp,-4
80007c0c:	d8 02       	popm	pc
* @param event is the code identifing the event
* @param info_ptr contains additional information or NULL
*/
static void msval_event(byte event, byte *info_ptr)
{
	switch (event)
80007c0e:	30 18       	mov	r8,1
80007c10:	f0 0c 18 00 	cp.b	r12,r8
80007c14:	c3 20       	breq	80007c78 <msval_event+0xa0>
80007c16:	c1 93       	brcs	80007c48 <msval_event+0x70>
80007c18:	31 08       	mov	r8,16
80007c1a:	f0 0c 18 00 	cp.b	r12,r8
80007c1e:	c1 90       	breq	80007c50 <msval_event+0x78>
80007c20:	31 18       	mov	r8,17
80007c22:	f0 0c 18 00 	cp.b	r12,r8
80007c26:	ce e1       	brne	80007c02 <msval_event+0x2a>
			break;
		case MSVAL_E_MPR:
			LOG_NOR("msval_event(MSVAL_E_MPR)\n");
			break;
		case MSVAL_E_MPRDEL_INC:
			LOG_NOR("msval_event(MSVAL_E_MPRDEL_INC)\n");
80007c28:	49 9c       	lddpc	r12,80007c8c <msval_event+0xb4>
80007c2a:	e0 a0 7f f3 	rcall	80017c10 <puts>
			break;
80007c2e:	d8 02       	popm	pc
* @param event is the code identifing the event
* @param info_ptr contains additional information or NULL
*/
static void msval_event(byte event, byte *info_ptr)
{
	switch (event)
80007c30:	36 08       	mov	r8,96
80007c32:	f0 0c 18 00 	cp.b	r12,r8
80007c36:	c1 d0       	breq	80007c70 <msval_event+0x98>
80007c38:	38 08       	mov	r8,-128
80007c3a:	f0 0c 18 00 	cp.b	r12,r8
80007c3e:	ce 21       	brne	80007c02 <msval_event+0x2a>
			break;
		case MSVAL_E_NPR:
			LOG_NOR("msval_event(MSVAL_E_NPR)\n");
			break;
		case MSVAL_E_NET_ACTIVITY:
			LOG_NOR("msval_event(MSVAL_E_NET_ACTIVITY)\n");
80007c40:	49 4c       	lddpc	r12,80007c90 <msval_event+0xb8>
80007c42:	e0 a0 7f e7 	rcall	80017c10 <puts>
			break;
80007c46:	d8 02       	popm	pc
static void msval_event(byte event, byte *info_ptr)
{
	switch (event)
	{
		case MSVAL_E_UNLOCK:
			LOG_NOR("msval_event(MSVAL_E_UNLOCK)\n");
80007c48:	49 3c       	lddpc	r12,80007c94 <msval_event+0xbc>
80007c4a:	e0 a0 7f e3 	rcall	80017c10 <puts>
			break;
80007c4e:	d8 02       	popm	pc
		case MSVAL_E_LOCKSTABLE:
			LOG_NOR("msval_event(MSVAL_E_LOCKSTABLE)\n");
			break;
		case MSVAL_E_MPR:
			LOG_NOR("msval_event(MSVAL_E_MPR)\n");
80007c50:	49 2c       	lddpc	r12,80007c98 <msval_event+0xc0>
80007c52:	e0 a0 7f df 	rcall	80017c10 <puts>
			break;
80007c56:	d8 02       	popm	pc
			break;
		case MSVAL_E_MPRDEL_EQUAL:
			LOG_NOR("msval_event(MSVAL_E_MPRDEL_EQUAL)\n");
			break;
		case MSVAL_E_NETON:
			LOG_NOR("msval_event(MSVAL_E_NETON)\n");
80007c58:	49 1c       	lddpc	r12,80007c9c <msval_event+0xc4>
80007c5a:	e0 a0 7f db 	rcall	80017c10 <puts>
			break;
80007c5e:	d8 02       	popm	pc
			break;
		case MSVAL_E_MPRDEL_DEC:
			LOG_NOR("msval_event(MSVAL_E_MPRDEL_DEC)\n");
			break;
		case MSVAL_E_MPRDEL_EQUAL:
			LOG_NOR("msval_event(MSVAL_E_MPRDEL_EQUAL)\n");
80007c60:	49 0c       	lddpc	r12,80007ca0 <msval_event+0xc8>
80007c62:	e0 a0 7f d7 	rcall	80017c10 <puts>
			break;
80007c66:	d8 02       	popm	pc
		case MSVAL_E_NETON:
			LOG_NOR("msval_event(MSVAL_E_NETON)\n");
			break;
		case MSVAL_E_SHUTDOWN:
			LOG_NOR("msval_event(MSVAL_E_SHUTDOWN)\n");
80007c68:	48 fc       	lddpc	r12,80007ca4 <msval_event+0xcc>
80007c6a:	e0 a0 7f d3 	rcall	80017c10 <puts>
			break;
80007c6e:	d8 02       	popm	pc
		case MSVAL_E_NPR:
			LOG_NOR("msval_event(MSVAL_E_NPR)\n");
80007c70:	48 ec       	lddpc	r12,80007ca8 <msval_event+0xd0>
80007c72:	e0 a0 7f cf 	rcall	80017c10 <puts>
			break;
80007c76:	d8 02       	popm	pc
	{
		case MSVAL_E_UNLOCK:
			LOG_NOR("msval_event(MSVAL_E_UNLOCK)\n");
			break;
		case MSVAL_E_LOCKSTABLE:
			LOG_NOR("msval_event(MSVAL_E_LOCKSTABLE)\n");
80007c78:	48 dc       	lddpc	r12,80007cac <msval_event+0xd4>
80007c7a:	e0 a0 7f cb 	rcall	80017c10 <puts>
			break;
80007c7e:	d8 02       	popm	pc
			break;
		case MSVAL_E_MPRDEL_INC:
			LOG_NOR("msval_event(MSVAL_E_MPRDEL_INC)\n");
			break;
		case MSVAL_E_MPRDEL_DEC:
			LOG_NOR("msval_event(MSVAL_E_MPRDEL_DEC)\n");
80007c80:	48 cc       	lddpc	r12,80007cb0 <msval_event+0xd8>
80007c82:	e0 a0 7f c7 	rcall	80017c10 <puts>
			break;
80007c86:	d8 02       	popm	pc
80007c88:	80 06       	ld.sh	r6,r0[0x0]
80007c8a:	ed 20 80 06 	ld.sb	r0,r6[-32762]
80007c8e:	ec 40 80 06 	cp.w	r0,819206
80007c92:	ec fc 80 06 	ld.w	r12,r6[-32762]
80007c96:	eb e8 80 06 	sthh.w	r6[r0],r5:b,r8:b
80007c9a:	ec 24 80 06 	sub	r4,819206
80007c9e:	ec a4       	*unknown*
80007ca0:	80 06       	ld.sh	r6,r0[0x0]
80007ca2:	ec 80 80 06 	breq	80197cae <_data_lma+0x126d06>
80007ca6:	ec c0 80 06 	sub	r0,r6,-32762
80007caa:	ec e0 80 06 	ld.d	r0,r6[-32762]
80007cae:	ec 04       	*unknown*
80007cb0:	80 06       	ld.sh	r6,r0[0x0]
80007cb2:	ec 60 eb cd 	mov	r0,846797

80007cb4 <msval_error>:
80007cb4:	eb cd 40 80 	pushm	r7,lr
80007cb8:	18 97       	mov	r7,r12
80007cba:	49 ac       	lddpc	r12,80007d20 <msval_error+0x6c>
* @param error is the code identifing the error
* @param info_ptr is not used (always NULL)
*/
static void msval_error(byte error, byte *info_ptr)
{
	LOG_ERR("NetServices msval_error: ");
80007cbc:	e0 a0 7f 14 	rcall	80017ae4 <printf>
	switch (error)
80007cc0:	59 37       	cp.w	r7,19
80007cc2:	e0 88 00 09 	brls	80007cd4 <msval_error+0x20>
			break;
		case MSVAL_ERR_SHUTDOWN_BUSY:
			LOG_ERR("MSVAL_ERR_SHUTDOWN_BUSY\n");
			break;
		default:
			LOG_ERR("Err code unknown = %02X\n", error);
80007cc6:	1a d7       	st.w	--sp,r7
80007cc8:	49 7c       	lddpc	r12,80007d24 <msval_error+0x70>
80007cca:	e0 a0 7f 0d 	rcall	80017ae4 <printf>
80007cce:	2f fd       	sub	sp,-4
80007cd0:	e3 cd 80 80 	ldm	sp++,r7,pc
* @param info_ptr is not used (always NULL)
*/
static void msval_error(byte error, byte *info_ptr)
{
	LOG_ERR("NetServices msval_error: ");
	switch (error)
80007cd4:	49 58       	lddpc	r8,80007d28 <msval_error+0x74>
80007cd6:	f0 07 03 2f 	ld.w	pc,r8[r7<<0x2]
			break;
		case MSVAL_ERR_SHUTDOWN_FAILED:
			LOG_ERR("MSVAL_ERR_SHUTDOWN_FAILED\n");
			break;
		case MSVAL_ERR_SHUTDOWN_BUSY:
			LOG_ERR("MSVAL_ERR_SHUTDOWN_BUSY\n");
80007cda:	49 5c       	lddpc	r12,80007d2c <msval_error+0x78>
80007cdc:	e0 a0 7f 9a 	rcall	80017c10 <puts>
			break;
80007ce0:	e3 cd 80 80 	ldm	sp++,r7,pc
{
	LOG_ERR("NetServices msval_error: ");
	switch (error)
	{
		case MSVAL_ERR_UNLOCK_SHORT:
			LOG_ERR("MSVAL_ERR_UNLOCK_SHORT\n");
80007ce4:	49 3c       	lddpc	r12,80007d30 <msval_error+0x7c>
80007ce6:	e0 a0 7f 95 	rcall	80017c10 <puts>
			break;
80007cea:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_ERR_UNLOCK_CRITICAL:
			LOG_ERR("MSVAL_ERR_UNLOCK_CRITICAL\n");
80007cee:	49 2c       	lddpc	r12,80007d34 <msval_error+0x80>
80007cf0:	e0 a0 7f 90 	rcall	80017c10 <puts>
			break;
80007cf4:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_ERR_INIT_ERROR:
			LOG_ERR("MSVAL_ERR_INIT_ERROR\n");
80007cf8:	49 0c       	lddpc	r12,80007d38 <msval_error+0x84>
80007cfa:	e0 a0 7f 8b 	rcall	80017c10 <puts>
			break;
80007cfe:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_ERR_STARTUP_FAILED:
			LOG_ERR("MSVAL_ERR_STARTUP_FAILED\n");
80007d02:	48 fc       	lddpc	r12,80007d3c <msval_error+0x88>
80007d04:	e0 a0 7f 86 	rcall	80017c10 <puts>
			break;
80007d08:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_ERR_STARTUP_BUSY:
			LOG_ERR("MSVAL_ERR_STARTUP_BUSY\n");
80007d0c:	48 dc       	lddpc	r12,80007d40 <msval_error+0x8c>
80007d0e:	e0 a0 7f 81 	rcall	80017c10 <puts>
			break;
80007d12:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_ERR_SHUTDOWN_FAILED:
			LOG_ERR("MSVAL_ERR_SHUTDOWN_FAILED\n");
80007d16:	48 cc       	lddpc	r12,80007d44 <msval_error+0x90>
80007d18:	e0 a0 7f 7c 	rcall	80017c10 <puts>
			break;
80007d1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d20:	80 06       	ld.sh	r6,r0[0x0]
80007d22:	ed 4c 80 06 	st.w	r6[-32762],r12
80007d26:	ee 1c 80 06 	eorh	r12,0x8006
80007d2a:	ea 74 80 06 	mov	r4,753670
80007d2e:	ee 04       	*unknown*
80007d30:	80 06       	ld.sh	r6,r0[0x0]
80007d32:	ed 68 80 06 	st.b	r6[-32762],r8
80007d36:	ed 80       	*unknown*
80007d38:	80 06       	ld.sh	r6,r0[0x0]
80007d3a:	ed 9c       	*unknown*
80007d3c:	80 06       	ld.sh	r6,r0[0x0]
80007d3e:	ed b4       	*unknown*
80007d40:	80 06       	ld.sh	r6,r0[0x0]
80007d42:	ed d0 80 06 	ldswp.w	r0,r6[24]
80007d46:	ed e8 d4 01 	sthh.w	r1[0x100],r6:b,r8:t

80007d48 <msg_tx_buffer_flushed>:
80007d48:	d4 01       	pushm	lr
80007d4a:	5c 7c       	castu.h	r12
80007d4c:	1a dc       	st.w	--sp,r12
80007d4e:	48 3c       	lddpc	r12,80007d58 <msg_tx_buffer_flushed+0x10>
*
* @param  num is the number of deleted messages
*/
static void msg_tx_buffer_flushed(word num)
{
	LOG_NOR("msg_tx_buffer_flushed(%d)\n", num);
80007d50:	e0 a0 7e ca 	rcall	80017ae4 <printf>
80007d54:	2f fd       	sub	sp,-4

	return;
}
80007d56:	d8 02       	popm	pc
80007d58:	80 06       	ld.sh	r6,r0[0x0]
80007d5a:	ee 38 d4 01 	sub	r8,1037313

80007d5c <mns_on_error>:
80007d5c:	d4 01       	pushm	lr
80007d5e:	fe 78 c2 81 	mov	r8,-15743
*
* @param result contains the code identifing the error cause
*/
static void mns_on_error(TMnsResult result)
{
	switch(result)
80007d62:	f0 0c 19 00 	cp.h	r12,r8
80007d66:	c6 30       	breq	80007e2c <mns_on_error+0xd0>
80007d68:	e0 88 00 18 	brls	80007d98 <mns_on_error+0x3c>
80007d6c:	fe 78 c3 01 	mov	r8,-15615
80007d70:	f0 0c 19 00 	cp.h	r12,r8
80007d74:	c6 80       	breq	80007e44 <mns_on_error+0xe8>
80007d76:	e0 88 00 2b 	brls	80007dcc <mns_on_error+0x70>
80007d7a:	fe 78 c3 03 	mov	r8,-15613
80007d7e:	f0 0c 19 00 	cp.h	r12,r8
80007d82:	c4 d0       	breq	80007e1c <mns_on_error+0xc0>
80007d84:	c4 43       	brcs	80007e0c <mns_on_error+0xb0>
80007d86:	fe 78 c4 01 	mov	r8,-15359
80007d8a:	f0 0c 19 00 	cp.h	r12,r8
80007d8e:	c3 81       	brne	80007dfe <mns_on_error+0xa2>
		case NSR_EI_SYNC:
		LOG_ERR("mns_on_error(NSR_EI_SYNC)\n");
		break;

		case NSR_E_INVALID_SEG_MODE_CONFIG:
		LOG_ERR("mns_on_error(NSR_E_INVALID_SEG_MODE_CONFIG)\n");
80007d90:	4b 5c       	lddpc	r12,80007e64 <mns_on_error+0x108>
80007d92:	e0 a0 7f 3f 	rcall	80017c10 <puts>
		break;
80007d96:	d8 02       	popm	pc
*
* @param result contains the code identifing the error cause
*/
static void mns_on_error(TMnsResult result)
{
	switch(result)
80007d98:	fe 78 84 00 	mov	r8,-31744
80007d9c:	f0 0c 19 00 	cp.h	r12,r8
80007da0:	c4 20       	breq	80007e24 <mns_on_error+0xc8>
80007da2:	e0 88 00 24 	brls	80007dea <mns_on_error+0x8e>
80007da6:	fe 78 c1 01 	mov	r8,-16127
80007daa:	f0 0c 19 00 	cp.h	r12,r8
80007dae:	c4 70       	breq	80007e3c <mns_on_error+0xe0>
80007db0:	fe 78 c2 11 	mov	r8,-15855
80007db4:	f0 0c 19 00 	cp.h	r12,r8
80007db8:	c3 e0       	breq	80007e34 <mns_on_error+0xd8>
80007dba:	fe 78 c0 02 	mov	r8,-16382
80007dbe:	f0 0c 19 00 	cp.h	r12,r8
80007dc2:	c1 e1       	brne	80007dfe <mns_on_error+0xa2>
		case NSR_E_INIC_VERSION:
		LOG_ERR("mns_on_error(NSR_E_INIC_VERSION)\n");
		break;

		case NSR_E_INVALID_RETRY_CONFIG:
		LOG_ERR("mns_on_error(NSR_E_INVALID_RETRY_CONFIG)\n");
80007dc4:	4a 9c       	lddpc	r12,80007e68 <mns_on_error+0x10c>
80007dc6:	e0 a0 7f 25 	rcall	80017c10 <puts>
		break;
80007dca:	d8 02       	popm	pc
*
* @param result contains the code identifing the error cause
*/
static void mns_on_error(TMnsResult result)
{
	switch(result)
80007dcc:	fe 78 c2 83 	mov	r8,-15741
80007dd0:	f0 0c 19 00 	cp.h	r12,r8
80007dd4:	c3 c0       	breq	80007e4c <mns_on_error+0xf0>
80007dd6:	c1 f3       	brcs	80007e14 <mns_on_error+0xb8>
80007dd8:	fe 78 c2 84 	mov	r8,-15740
80007ddc:	f0 0c 19 00 	cp.h	r12,r8
80007de0:	c0 f1       	brne	80007dfe <mns_on_error+0xa2>
		case NSR_E_BIST_PCODE:
		LOG_ERR("mns_on_error(NSR_E_BIST_PCODE)\n");
		break;

		case NSR_E_BIST_DATA_MEMORY:
		LOG_ERR("mns_on_error(NSR_E_BIST_DATA_MEMORY)\n");
80007de2:	4a 3c       	lddpc	r12,80007e6c <mns_on_error+0x110>
80007de4:	e0 a0 7f 16 	rcall	80017c10 <puts>
		break;
80007de8:	d8 02       	popm	pc
*
* @param result contains the code identifing the error cause
*/
static void mns_on_error(TMnsResult result)
{
	switch(result)
80007dea:	fe 78 82 00 	mov	r8,-32256
80007dee:	f0 0c 19 00 	cp.h	r12,r8
80007df2:	c3 50       	breq	80007e5c <mns_on_error+0x100>
80007df4:	fe 78 83 00 	mov	r8,-32000
80007df8:	f0 0c 19 00 	cp.h	r12,r8
80007dfc:	c2 c0       	breq	80007e54 <mns_on_error+0xf8>
		LOG_ERR("mns_on_error(NSR_E_INVALID_SEG_MODE_CONFIG)\n");
		break;

		default:
		/* unknown error code */
		LOG_ERR("mns_on_error, unknown error code: %04X\n", result);
80007dfe:	5c 7c       	castu.h	r12
80007e00:	1a dc       	st.w	--sp,r12
80007e02:	49 cc       	lddpc	r12,80007e70 <mns_on_error+0x114>
80007e04:	e0 a0 7e 70 	rcall	80017ae4 <printf>
80007e08:	2f fd       	sub	sp,-4
80007e0a:	d8 02       	popm	pc
		case NSR_EI_RESET:
		LOG_ERR("mns_on_error(NSR_EI_RESET)\n");
		break;

		case NSR_EI_SYNC_FAILED:
		LOG_ERR("mns_on_error(NSR_EI_SYNC_FAILED)\n");
80007e0c:	49 ac       	lddpc	r12,80007e74 <mns_on_error+0x118>
80007e0e:	e0 a0 7f 01 	rcall	80017c10 <puts>
		break;
80007e12:	d8 02       	popm	pc
		case NSR_E_BIST_MEMORY:
		LOG_ERR("mns_on_error(NSR_E_BIST_MEMORY)\n");
		break;

		case NSR_E_BIST_CONF_STRING:
		LOG_ERR("mns_on_error(NSR_E_BIST_CONF_STRING)\n");
80007e14:	49 9c       	lddpc	r12,80007e78 <mns_on_error+0x11c>
80007e16:	e0 a0 7e fd 	rcall	80017c10 <puts>
		break;
80007e1a:	d8 02       	popm	pc
		case NSR_EI_SYNC_FAILED:
		LOG_ERR("mns_on_error(NSR_EI_SYNC_FAILED)\n");
		break;

		case NSR_EI_SYNC:
		LOG_ERR("mns_on_error(NSR_EI_SYNC)\n");
80007e1c:	49 8c       	lddpc	r12,80007e7c <mns_on_error+0x120>
80007e1e:	e0 a0 7e f9 	rcall	80017c10 <puts>
		break;
80007e22:	d8 02       	popm	pc
		case NSR_E_REATTACH:
		LOG_ERR("mns_on_error(NSR_E_REATTACH)\n");
		break;

		case NSR_E_NO_COMM:
		LOG_ERR("mns_on_error(NSR_E_RESET_INIC)\n");
80007e24:	49 7c       	lddpc	r12,80007e80 <mns_on_error+0x124>
80007e26:	e0 a0 7e f5 	rcall	80017c10 <puts>
		break;
80007e2a:	d8 02       	popm	pc
		case NSR_E_BIST_MEM_CONTENT:
		LOG_ERR("mns_on_error(NSR_E_BIST_MEM_CONTENT)\n");
		break;

		case NSR_E_BIST_MEMORY:
		LOG_ERR("mns_on_error(NSR_E_BIST_MEMORY)\n");
80007e2c:	49 6c       	lddpc	r12,80007e84 <mns_on_error+0x128>
80007e2e:	e0 a0 7e f1 	rcall	80017c10 <puts>
		break;
80007e32:	d8 02       	popm	pc
		case NSR_E_INVALID_REMOTE_ACCESS_CONFIG:
		LOG_ERR("mns_on_error(NSR_E_INVALID_REMOTE_ACCESS_CONFIG)\n");
		break;

		case NSR_E_BIST_MEM_CONTENT:
		LOG_ERR("mns_on_error(NSR_E_BIST_MEM_CONTENT)\n");
80007e34:	49 5c       	lddpc	r12,80007e88 <mns_on_error+0x12c>
80007e36:	e0 a0 7e ed 	rcall	80017c10 <puts>
		break;
80007e3a:	d8 02       	popm	pc
		case NSR_E_INVALID_RETRY_CONFIG:
		LOG_ERR("mns_on_error(NSR_E_INVALID_RETRY_CONFIG)\n");
		break;

		case NSR_E_INVALID_REMOTE_ACCESS_CONFIG:
		LOG_ERR("mns_on_error(NSR_E_INVALID_REMOTE_ACCESS_CONFIG)\n");
80007e3c:	49 4c       	lddpc	r12,80007e8c <mns_on_error+0x130>
80007e3e:	e0 a0 7e e9 	rcall	80017c10 <puts>
		break;
80007e42:	d8 02       	popm	pc
		case NSR_E_BIST_DATA_MEMORY:
		LOG_ERR("mns_on_error(NSR_E_BIST_DATA_MEMORY)\n");
		break;

		case NSR_EI_RESET:
		LOG_ERR("mns_on_error(NSR_EI_RESET)\n");
80007e44:	49 3c       	lddpc	r12,80007e90 <mns_on_error+0x134>
80007e46:	e0 a0 7e e5 	rcall	80017c10 <puts>
		break;
80007e4a:	d8 02       	popm	pc
		case NSR_E_BIST_CONF_STRING:
		LOG_ERR("mns_on_error(NSR_E_BIST_CONF_STRING)\n");
		break;

		case NSR_E_BIST_PCODE:
		LOG_ERR("mns_on_error(NSR_E_BIST_PCODE)\n");
80007e4c:	49 2c       	lddpc	r12,80007e94 <mns_on_error+0x138>
80007e4e:	e0 a0 7e e1 	rcall	80017c10 <puts>
		break;
80007e52:	d8 02       	popm	pc
static void mns_on_error(TMnsResult result)
{
	switch(result)
	{
		case NSR_E_REATTACH:
		LOG_ERR("mns_on_error(NSR_E_REATTACH)\n");
80007e54:	49 1c       	lddpc	r12,80007e98 <mns_on_error+0x13c>
80007e56:	e0 a0 7e dd 	rcall	80017c10 <puts>
		break;
80007e5a:	d8 02       	popm	pc
		case NSR_E_NO_COMM:
		LOG_ERR("mns_on_error(NSR_E_RESET_INIC)\n");
		break;

		case NSR_E_INIC_VERSION:
		LOG_ERR("mns_on_error(NSR_E_INIC_VERSION)\n");
80007e5c:	49 0c       	lddpc	r12,80007e9c <mns_on_error+0x140>
80007e5e:	e0 a0 7e d9 	rcall	80017c10 <puts>
		break;
80007e62:	d8 02       	popm	pc
80007e64:	80 06       	ld.sh	r6,r0[0x0]
80007e66:	f0 2c 80 06 	sub	r12,-1015802
80007e6a:	ee b8       	*unknown*
80007e6c:	80 06       	ld.sh	r6,r0[0x0]
80007e6e:	ef a8       	*unknown*
80007e70:	80 06       	ld.sh	r6,r0[0x0]
80007e72:	f0 58 80 06 	cp.w	r8,-950266
80007e76:	ef ec 80 06 	sthh.w	r6[r0],r7:b,r12:b
80007e7a:	ef 60 80 06 	st.b	r7[-32762],r0
80007e7e:	f0 10 80 06 	mcall	r0[-131048]
80007e82:	ee 74 80 06 	mov	r4,1015814
80007e86:	ef 40 80 06 	st.w	r7[-32762],r0
80007e8a:	ef 18 80 06 	ld.uh	r8,r7[-32762]
80007e8e:	ee e4 80 06 	ld.d	r4,r7[-32762]
80007e92:	ef d0 80 06 	ldswp.w	r0,r7[24]
80007e96:	ef 88       	*unknown*
80007e98:	80 06       	ld.sh	r6,r0[0x0]
80007e9a:	ee 54 80 06 	cp.w	r4,1015814
80007e9e:	ee 94 eb cd 	brge	80205638 <_data_lma+0x194690>

80007ea0 <scm_error>:
80007ea0:	eb cd 40 c0 	pushm	r6-r7,lr
80007ea4:	18 97       	mov	r7,r12
80007ea6:	16 96       	mov	r6,r11
/*! The MOST NetServices call this function to delivier
* Socket Connection Manager errors
*/
static void scm_error(TMnsResult code, byte handle)
{
	LOG_ERR("SCM Error: ");
80007ea8:	49 9c       	lddpc	r12,80007f0c <scm_error+0x6c>
80007eaa:	e0 a0 7e 1d 	rcall	80017ae4 <printf>
	switch (code)
80007eae:	fe 78 ac 01 	mov	r8,-21503
80007eb2:	f0 07 19 00 	cp.h	r7,r8
80007eb6:	c2 70       	breq	80007f04 <scm_error+0x64>
80007eb8:	e0 8b 00 14 	brhi	80007ee0 <scm_error+0x40>
80007ebc:	fe 78 ab 01 	mov	r8,-21759
80007ec0:	f0 07 19 00 	cp.h	r7,r8
80007ec4:	c0 71       	brne	80007ed2 <scm_error+0x32>
	{
		case NSR_E_SOURCE_DROP:
			LOG_ERR("SOURCE_DROP\n");
80007ec6:	49 3c       	lddpc	r12,80007f10 <scm_error+0x70>
80007ec8:	e0 a0 7e a4 	rcall	80017c10 <puts>
			SCError_CB(handle);                         // go destroy connections/sockets w/ error
80007ecc:	0c 9c       	mov	r12,r6
80007ece:	fe b0 e3 05 	rcall	800044d8 <SCError_CB>
			break;
		case NSR_E_MOST_DEALLOCATED_ALL:
			LOG_ERR("All Network bandwidth is de-allocated\n");
			break;
	}
	LOG_ERR("SCM handle is: %02X\n", handle);
80007ed2:	1a d6       	st.w	--sp,r6
80007ed4:	49 0c       	lddpc	r12,80007f14 <scm_error+0x74>
80007ed6:	e0 a0 7e 07 	rcall	80017ae4 <printf>
80007eda:	2f fd       	sub	sp,-4
}
80007edc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
* Socket Connection Manager errors
*/
static void scm_error(TMnsResult code, byte handle)
{
	LOG_ERR("SCM Error: ");
	switch (code)
80007ee0:	fe 78 ac 02 	mov	r8,-21502
80007ee4:	f0 07 19 00 	cp.h	r7,r8
80007ee8:	c0 a0       	breq	80007efc <scm_error+0x5c>
80007eea:	fe 78 ac 03 	mov	r8,-21501
80007eee:	f0 07 19 00 	cp.h	r7,r8
80007ef2:	cf 01       	brne	80007ed2 <scm_error+0x32>
			break;
		case NSR_E_MEDIALB_BANDWIDTH:
			LOG_ERR("MediaLB Channel Address / Bandwidth Error\n");
			break;
		case NSR_E_MOST_DEALLOCATED_ALL:
			LOG_ERR("All Network bandwidth is de-allocated\n");
80007ef4:	48 9c       	lddpc	r12,80007f18 <scm_error+0x78>
80007ef6:	e0 a0 7e 8d 	rcall	80017c10 <puts>
80007efa:	ce cb       	rjmp	80007ed2 <scm_error+0x32>
		case NSR_E_SOURCE_DROP:
			LOG_ERR("SOURCE_DROP\n");
			SCError_CB(handle);                         // go destroy connections/sockets w/ error
			break;
		case NSR_E_MOST_BANDWIDTH:
			LOG_ERR("MOST Bandwidth Error\n");
80007efc:	48 8c       	lddpc	r12,80007f1c <scm_error+0x7c>
80007efe:	e0 a0 7e 89 	rcall	80017c10 <puts>
			break;
80007f02:	ce 8b       	rjmp	80007ed2 <scm_error+0x32>
		case NSR_E_MEDIALB_BANDWIDTH:
			LOG_ERR("MediaLB Channel Address / Bandwidth Error\n");
80007f04:	48 7c       	lddpc	r12,80007f20 <scm_error+0x80>
80007f06:	e0 a0 7e 85 	rcall	80017c10 <puts>
			break;
80007f0a:	ce 4b       	rjmp	80007ed2 <scm_error+0x32>
80007f0c:	80 06       	ld.sh	r6,r0[0x0]
80007f0e:	f0 80 80 06 	breq	7fe17f1a <_estack+0x7fe07f1a>
80007f12:	f0 8c 80 06 	brvs	7fe17f1e <_estack+0x7fe07f1e>
80007f16:	f1 04 80 06 	ld.sh	r4,r8[-32762]
80007f1a:	f0 dc 80 06 	satsub.w	r12,r8,-32762
80007f1e:	f0 98 80 06 	brls	7fe37f2a <_estack+0x7fe27f2a>
80007f22:	f0 b0 eb cd 	rcall	7fe456bc <_estack+0x7fe356bc>

80007f24 <msval_store_rbd_result>:
80007f24:	eb cd 40 e0 	pushm	r5-r7,lr
80007f28:	18 97       	mov	r7,r12
80007f2a:	16 96       	mov	r6,r11
80007f2c:	14 95       	mov	r5,r10
80007f2e:	49 ac       	lddpc	r12,80007f94 <msval_store_rbd_result+0x70>

#ifdef MSV_DIAG_RESULT_MSG
void msval_store_rbd_result(byte rbd_status, byte length, byte *diag_id)
{
	int i;
	LOG_ERR("Got RBD result message from network:\n    RBD status: ");
80007f30:	e0 a0 7d da 	rcall	80017ae4 <printf>
	switch(rbd_status)
80007f34:	30 28       	mov	r8,2
80007f36:	f0 07 18 00 	cp.b	r7,r8
80007f3a:	c2 90       	breq	80007f8c <msval_store_rbd_result+0x68>
80007f3c:	3e e8       	mov	r8,-18
80007f3e:	f0 07 18 00 	cp.b	r7,r8
80007f42:	c2 10       	breq	80007f84 <msval_store_rbd_result+0x60>
80007f44:	30 18       	mov	r8,1
80007f46:	f0 07 18 00 	cp.b	r7,r8
80007f4a:	c1 90       	breq	80007f7c <msval_store_rbd_result+0x58>
			break;
		case 0xEE:
			LOG_ERR("Invalid RBD result\n");
			break;
		default:
			LOG_ERR("Unknown rbd_status value\n");
80007f4c:	49 3c       	lddpc	r12,80007f98 <msval_store_rbd_result+0x74>
80007f4e:	e0 a0 7e 61 	rcall	80017c10 <puts>
			break;
	}
	LOG_ERR("Received DiagId stream is ");
80007f52:	49 3c       	lddpc	r12,80007f9c <msval_store_rbd_result+0x78>
80007f54:	e0 a0 7d c8 	rcall	80017ae4 <printf>
	for(i=0; i<length; i++) {
80007f58:	58 06       	cp.w	r6,0
80007f5a:	c0 c0       	breq	80007f72 <msval_store_rbd_result+0x4e>
80007f5c:	30 07       	mov	r7,0
		LOG_ERR("%02X ", diag_id[i]);
80007f5e:	ea 07 07 08 	ld.ub	r8,r5[r7]
80007f62:	49 0c       	lddpc	r12,80007fa0 <msval_store_rbd_result+0x7c>
80007f64:	1a d8       	st.w	--sp,r8
		default:
			LOG_ERR("Unknown rbd_status value\n");
			break;
	}
	LOG_ERR("Received DiagId stream is ");
	for(i=0; i<length; i++) {
80007f66:	2f f7       	sub	r7,-1
		LOG_ERR("%02X ", diag_id[i]);
80007f68:	e0 a0 7d be 	rcall	80017ae4 <printf>
		default:
			LOG_ERR("Unknown rbd_status value\n");
			break;
	}
	LOG_ERR("Received DiagId stream is ");
	for(i=0; i<length; i++) {
80007f6c:	2f fd       	sub	sp,-4
80007f6e:	0c 37       	cp.w	r7,r6
80007f70:	cf 75       	brlt	80007f5e <msval_store_rbd_result+0x3a>
		LOG_ERR("%02X ", diag_id[i]);
	}
	LOG_ERR("\n");
80007f72:	30 ac       	mov	r12,10
80007f74:	e0 a0 7d d0 	rcall	80017b14 <putchar>
}
80007f78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	int i;
	LOG_ERR("Got RBD result message from network:\n    RBD status: ");
	switch(rbd_status)
	{
		case 0x01:
			LOG_ERR("Activity, but no lock\n");
80007f7c:	48 ac       	lddpc	r12,80007fa4 <msval_store_rbd_result+0x80>
80007f7e:	e0 a0 7e 49 	rcall	80017c10 <puts>
			break;
80007f82:	ce 8b       	rjmp	80007f52 <msval_store_rbd_result+0x2e>
		case 0x02:
			LOG_ERR("No activity\n");
			break;
		case 0xEE:
			LOG_ERR("Invalid RBD result\n");
80007f84:	48 9c       	lddpc	r12,80007fa8 <msval_store_rbd_result+0x84>
80007f86:	e0 a0 7e 45 	rcall	80017c10 <puts>
			break;
80007f8a:	ce 4b       	rjmp	80007f52 <msval_store_rbd_result+0x2e>
	{
		case 0x01:
			LOG_ERR("Activity, but no lock\n");
			break;
		case 0x02:
			LOG_ERR("No activity\n");
80007f8c:	48 8c       	lddpc	r12,80007fac <msval_store_rbd_result+0x88>
80007f8e:	e0 a0 7e 41 	rcall	80017c10 <puts>
			break;
80007f92:	ce 0b       	rjmp	80007f52 <msval_store_rbd_result+0x2e>
80007f94:	80 06       	ld.sh	r6,r0[0x0]
80007f96:	f1 1c 80 06 	ld.uh	r12,r8[-32762]
80007f9a:	f1 8c       	*unknown*
80007f9c:	80 06       	ld.sh	r6,r0[0x0]
80007f9e:	f1 a8 80 06 	ldc0.w	cr0,r8[0x2018]
80007fa2:	9e 64       	ld.sh	r4,pc[0xc]
80007fa4:	80 06       	ld.sh	r6,r0[0x0]
80007fa6:	f1 54 80 06 	st.h	r8[-32762],r4
80007faa:	f1 78 80 06 	stcond	r8[-32762],r8
80007fae:	f1 6c d4 21 	st.b	r8[-11231],r12

80007fb0 <msval_diag_result>:
80007fb0:	d4 21       	pushm	r4-r7,lr
80007fb2:	18 97       	mov	r7,r12
80007fb4:	16 95       	mov	r5,r11
80007fb6:	4a 1c       	lddpc	r12,80008038 <msval_diag_result+0x88>
80007fb8:	e0 a0 7d 96 	rcall	80017ae4 <printf>

static void msval_diag_result(u8_t event, u8_t *info_ptr)
{
	LOG_NOR("RBD Result is ");
	ET_Store_Diag_Result(event, info_ptr);                      // forward on to ET which saves it for tester
	switch (event)                                              // now print results
80007fbc:	30 16       	mov	r6,1
}

static void msval_diag_result(u8_t event, u8_t *info_ptr)
{
	LOG_NOR("RBD Result is ");
	ET_Store_Diag_Result(event, info_ptr);                      // forward on to ET which saves it for tester
80007fbe:	0a 9b       	mov	r11,r5
80007fc0:	0e 9c       	mov	r12,r7
80007fc2:	e0 a0 62 43 	rcall	80014448 <ET_Store_Diag_Result>
	switch (event)                                              // now print results
80007fc6:	ec 07 18 00 	cp.b	r7,r6
80007fca:	c1 80       	breq	80007ffa <msval_diag_result+0x4a>
80007fcc:	c0 f3       	brcs	80007fea <msval_diag_result+0x3a>
80007fce:	30 24       	mov	r4,2
80007fd0:	e8 07 18 00 	cp.b	r7,r4
80007fd4:	c1 a0       	breq	80008008 <msval_diag_result+0x58>
80007fd6:	30 38       	mov	r8,3
80007fd8:	f0 07 18 00 	cp.b	r7,r8
80007fdc:	c0 b0       	breq	80007ff2 <msval_diag_result+0x42>
			break;
		case MSVAL_DIAG_SIGNAL_NO_LOCK:
			LOG_NOR("MSVAL_DIAG_SIGNAL_NO_LOCK\n");
			break;
		default:
			LOG_NOR("Unknown RBD result, result code is: %02X\n", event);
80007fde:	1a d7       	st.w	--sp,r7
80007fe0:	49 7c       	lddpc	r12,8000803c <msval_diag_result+0x8c>
80007fe2:	e0 a0 7d 81 	rcall	80017ae4 <printf>
80007fe6:	2f fd       	sub	sp,-4
80007fe8:	d8 22       	popm	r4-r7,pc
	LOG_NOR("RBD Result is ");
	ET_Store_Diag_Result(event, info_ptr);                      // forward on to ET which saves it for tester
	switch (event)                                              // now print results
	{
		case MSVAL_DIAG_OK:
			LOG_NOR("MSVAL_DIAG_OK\n");
80007fea:	49 6c       	lddpc	r12,80008040 <msval_diag_result+0x90>
80007fec:	e0 a0 7e 12 	rcall	80017c10 <puts>
			break;
80007ff0:	d8 22       	popm	r4-r7,pc
				LOG_NOR("Diag_Poor\n");
				break;
			}
			break;
		case MSVAL_DIAG_SIGNAL_NO_LOCK:
			LOG_NOR("MSVAL_DIAG_SIGNAL_NO_LOCK\n");
80007ff2:	49 5c       	lddpc	r12,80008044 <msval_diag_result+0x94>
80007ff4:	e0 a0 7e 0e 	rcall	80017c10 <puts>
			break;
80007ff8:	d8 22       	popm	r4-r7,pc
	{
		case MSVAL_DIAG_OK:
			LOG_NOR("MSVAL_DIAG_OK\n");
			break;
		case MSVAL_DIAG_POS:
			LOG_NOR("MSVAL_DIAG_POS = %02X\n", info_ptr[1]);
80007ffa:	0b 98       	ld.ub	r8,r5[0x1]
80007ffc:	49 3c       	lddpc	r12,80008048 <msval_diag_result+0x98>
80007ffe:	1a d8       	st.w	--sp,r8
80008000:	e0 a0 7d 72 	rcall	80017ae4 <printf>
			break;
80008004:	2f fd       	sub	sp,-4
80008006:	d8 22       	popm	r4-r7,pc
		case MSVAL_DIAG_FAILED:
			LOG_NOR("MSVAL_DIAG_FAILED: ");
80008008:	49 1c       	lddpc	r12,8000804c <msval_diag_result+0x9c>
8000800a:	e0 a0 7d 6d 	rcall	80017ae4 <printf>
			switch (info_ptr[1])
8000800e:	0b 98       	ld.ub	r8,r5[0x1]
80008010:	ec 08 18 00 	cp.b	r8,r6
80008014:	c0 60       	breq	80008020 <msval_diag_result+0x70>
80008016:	c0 92       	brcc	80008028 <msval_diag_result+0x78>
			{
			case 0x00:
				LOG_NOR("MultiMaster\n");
80008018:	48 ec       	lddpc	r12,80008050 <msval_diag_result+0xa0>
8000801a:	e0 a0 7d fb 	rcall	80017c10 <puts>
				break;
8000801e:	d8 22       	popm	r4-r7,pc
			case 0x01:
				LOG_NOR("AllSlave\n");
80008020:	48 dc       	lddpc	r12,80008054 <msval_diag_result+0xa4>
80008022:	e0 a0 7d f7 	rcall	80017c10 <puts>
				break;
80008026:	d8 22       	popm	r4-r7,pc
		case MSVAL_DIAG_POS:
			LOG_NOR("MSVAL_DIAG_POS = %02X\n", info_ptr[1]);
			break;
		case MSVAL_DIAG_FAILED:
			LOG_NOR("MSVAL_DIAG_FAILED: ");
			switch (info_ptr[1])
80008028:	e8 08 18 00 	cp.b	r8,r4
8000802c:	cd e1       	brne	80007fe8 <msval_diag_result+0x38>
				break;
			case 0x01:
				LOG_NOR("AllSlave\n");
				break;
			case 0x02:
				LOG_NOR("Diag_Poor\n");
8000802e:	48 bc       	lddpc	r12,80008058 <msval_diag_result+0xa8>
80008030:	e0 a0 7d f0 	rcall	80017c10 <puts>
80008034:	d8 22       	popm	r4-r7,pc
80008036:	d7 03       	nop
80008038:	80 06       	ld.sh	r6,r0[0x0]
8000803a:	f1 c4       	*unknown*
8000803c:	80 06       	ld.sh	r6,r0[0x0]
8000803e:	f2 50 80 06 	cp.w	r0,-819194
80008042:	f1 d4 80 06 	ldswp.w	r4,r8[24]
80008046:	f2 34 80 06 	sub	r4,-819194
8000804a:	f1 e4 80 06 	sthh.w	r6[r0],r8:b,r4:b
8000804e:	f1 fc 80 06 	ld.wls	r12,r8[0x18]
80008052:	f2 10 80 06 	pref	r0[-32762]
80008056:	f2 1c 80 06 	pref	r12[-32762]
8000805a:	f2 28 eb cd 	sub	r8,-857139

8000805c <msval_state_changed>:
8000805c:	eb cd 40 80 	pushm	r7,lr
80008060:	18 97       	mov	r7,r12
80008062:	49 ec       	lddpc	r12,800080d8 <msval_state_changed+0x7c>
80008064:	e0 a0 7d 40 	rcall	80017ae4 <printf>
#ifdef VMSV_MIN

static void msval_state_changed(u8_t state)
{
	LOG_NOR("NetServices Supervisor State: ");
	switch (state)
80008068:	30 28       	mov	r8,2
8000806a:	f0 07 18 00 	cp.b	r7,r8
8000806e:	c3 00       	breq	800080ce <msval_state_changed+0x72>
80008070:	e0 88 00 11 	brls	80008092 <msval_state_changed+0x36>
80008074:	30 38       	mov	r8,3
80008076:	f0 07 18 00 	cp.b	r7,r8
8000807a:	c1 c0       	breq	800080b2 <msval_state_changed+0x56>
8000807c:	30 48       	mov	r8,4
8000807e:	f0 07 18 00 	cp.b	r7,r8
80008082:	c1 30       	breq	800080a8 <msval_state_changed+0x4c>
			break;
		case MSVAL_S_RBDRES:
			LOG_NOR("MSVAL_S_RBDRES\n");
			break;
		default:
			LOG_ERR("State code unknown = %02X\n", state);
80008084:	1a d7       	st.w	--sp,r7
80008086:	49 6c       	lddpc	r12,800080dc <msval_state_changed+0x80>
80008088:	e0 a0 7d 2e 	rcall	80017ae4 <printf>
8000808c:	2f fd       	sub	sp,-4
8000808e:	e3 cd 80 80 	ldm	sp++,r7,pc
#ifdef VMSV_MIN

static void msval_state_changed(u8_t state)
{
	LOG_NOR("NetServices Supervisor State: ");
	switch (state)
80008092:	58 07       	cp.w	r7,0
80008094:	c1 60       	breq	800080c0 <msval_state_changed+0x64>
80008096:	30 18       	mov	r8,1
80008098:	f0 07 18 00 	cp.b	r7,r8
8000809c:	cf 41       	brne	80008084 <msval_state_changed+0x28>
		case MSVAL_S_OFF:
			LOG_NOR("MSVAL_S_OFF\n");
			app_go_net_off();
			break;
		case MSVAL_S_INIT:
			LOG_NOR("MSVAL_S_INIT\n");
8000809e:	49 1c       	lddpc	r12,800080e0 <msval_state_changed+0x84>
800080a0:	e0 a0 7d b8 	rcall	80017c10 <puts>
			//PwrStopPowerDownTimer();                      // stay powered up now
			break;
800080a4:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_S_ON:
			LOG_NOR("MSVAL_S_ON\n");
			app_go_net_on();
			break;
		case MSVAL_S_RBDRES:
			LOG_NOR("MSVAL_S_RBDRES\n");
800080a8:	48 fc       	lddpc	r12,800080e4 <msval_state_changed+0x88>
800080aa:	e0 a0 7d b3 	rcall	80017c10 <puts>
			break;
800080ae:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_S_RBD:
			LOG_ERR("MSVAL_S_RBD\n");
			//PwrStopPowerDownTimer();                      // stay powered up in RBD
			break;
		case MSVAL_S_ON:
			LOG_NOR("MSVAL_S_ON\n");
800080b2:	48 ec       	lddpc	r12,800080e8 <msval_state_changed+0x8c>
800080b4:	e0 a0 7d ae 	rcall	80017c10 <puts>
			app_go_net_on();
800080b8:	e0 a0 70 e2 	rcall	8001627c <app_go_net_on>
			break;
800080bc:	e3 cd 80 80 	ldm	sp++,r7,pc
{
	LOG_NOR("NetServices Supervisor State: ");
	switch (state)
	{
		case MSVAL_S_OFF:
			LOG_NOR("MSVAL_S_OFF\n");
800080c0:	48 bc       	lddpc	r12,800080ec <msval_state_changed+0x90>
800080c2:	e0 a0 7d a7 	rcall	80017c10 <puts>
			app_go_net_off();
800080c6:	e0 a0 70 cb 	rcall	8001625c <app_go_net_off>
			break;
800080ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		case MSVAL_S_INIT:
			LOG_NOR("MSVAL_S_INIT\n");
			//PwrStopPowerDownTimer();                      // stay powered up now
			break;
		case MSVAL_S_RBD:
			LOG_ERR("MSVAL_S_RBD\n");
800080ce:	48 9c       	lddpc	r12,800080f0 <msval_state_changed+0x94>
800080d0:	e0 a0 7d a0 	rcall	80017c10 <puts>
			//PwrStopPowerDownTimer();                      // stay powered up in RBD
			break;
800080d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800080d8:	80 06       	ld.sh	r6,r0[0x0]
800080da:	f2 7c 80 06 	mov	r12,-819194
800080de:	f2 e0 80 06 	ld.d	r0,r9[-32762]
800080e2:	f2 a8       	*unknown*
800080e4:	80 06       	ld.sh	r6,r0[0x0]
800080e6:	f2 d0 80 06 	satsub.w	r0,r9,-32762
800080ea:	f2 c4 80 06 	sub	r4,r9,-32762
800080ee:	f2 9c 80 06 	brvs	7fe780fa <_estack+0x7fe680fa>
800080f2:	f2 b8       	*unknown*

800080f4 <mns_next_min_timeout>:
800080f4:	d4 01       	pushm	lr
800080f6:	5c 7c       	castu.h	r12
800080f8:	e0 a0 70 90 	rcall	80016218 <app_start_check_timer>
800080fc:	d8 02       	popm	pc
800080fe:	d7 03       	nop

80008100 <mns_on_init_complete>:
80008100:	d4 01       	pushm	lr
80008102:	e0 a0 70 f1 	rcall	800162e4 <app_on_init_complete>
* @see   InitNetServices, on_error
*/
static void mns_on_init_complete(void)
{
	app_on_init_complete();
}
80008106:	d8 02       	popm	pc

80008108 <SystemCommunicationInit>:
/*--------------------------------------------------------------------------*/
void SystemCommunicationInit(byte ConfigStatusOk)
{
	byte dummy;
	dummy = ConfigStatusOk;
}
80008108:	5e fc       	retal	r12

8000810a <Store_Error_Info2>:
void Store_Error_Info2(byte error)
{
	byte Dummy;

	Dummy = error;
}
8000810a:	5e fc       	retal	r12

8000810c <FBlockIDsChanged>:
		break;

		default:
		break;
	}
}
8000810c:	5e fc       	retal	r12

8000810e <CmdTxFilter>:
	/* Following returning values are possible: */
	/*  == 0x00:  The result message will not be transmitted, the tx buffer is released by NetServices. */
	/*          */
	/*  != 0x00:  The result message will be transmitted in an ordinary way.  */

}
8000810e:	5e ff       	retal	1

80008110 <CmdTxNoResult>:
void CmdTxNoResult(pTMsgRx rx_ptr)
{
	pTMsgRx dummy;

	dummy = rx_ptr;
}
80008110:	5e fc       	retal	r12

80008112 <NbShutDown>:

	return (MNS_FALSE);         /* no suspend result required  */

	/*  return (MNS_TRUE);       */ /* suspending */

}
80008112:	5e fd       	retal	0

80008114 <NbShutDownExecute>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbShutDownExecute(void)
{
	/* save your application signals and wait for light off */
}
80008114:	5e fc       	retal	r12

80008116 <NbShutDownDevice>:
/*--------------------------------------------------------------------------*/
bool NbShutDownDevice(void)
{
	/* perform a device shutdown */
	return (MNS_TRUE);
}
80008116:	5e ff       	retal	1

80008118 <NbNodeAddrStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbNodeAddrStatus(pTMsgRx prbuf)
{
}
80008118:	5e fc       	retal	r12

8000811a <NbNodeAddrError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbNodeAddrError(pTMsgRx prbuf)
{
}
8000811a:	5e fc       	retal	r12

8000811c <NbFBlockIDsStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbFBlockIDsStatus(pTMsgRx prbuf)
{
}
8000811c:	5e fc       	retal	r12

8000811e <NbFBlockIDsError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbFBlockIDsError(pTMsgRx prbuf)
{
}
8000811e:	5e fc       	retal	r12

80008120 <NbDeviceInfoStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbDeviceInfoStatus(pTMsgRx prbuf)
{
}
80008120:	5e fc       	retal	r12

80008122 <NbDeviceInfoError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbDeviceInfoError(pTMsgRx prbuf)
{
}
80008122:	5e fc       	retal	r12

80008124 <NbGroupAddrStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbGroupAddrStatus(pTMsgRx prbuf)
{
}
80008124:	5e fc       	retal	r12

80008126 <NbGroupAddrError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbGroupAddrError(pTMsgRx prbuf)
{
}
80008126:	5e fc       	retal	r12

80008128 <NbShutDownResult>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbShutDownResult(pTMsgRx prbuf)
{
}
80008128:	5e fc       	retal	r12

8000812a <NbShutDownError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbShutDownError(pTMsgRx prbuf)
{
}
8000812a:	5e fc       	retal	r12

8000812c <NbNodePositionStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbNodePositionStatus(pTMsgRx prbuf)
{
}
8000812c:	5e fc       	retal	r12

8000812e <NbNodePositionError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbNodePositionError(pTMsgRx prbuf)
{
}
8000812e:	5e fc       	retal	r12

80008130 <NbRetryParametersStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbRetryParametersStatus(pTMsgRx prbuf)
{
}
80008130:	5e fc       	retal	r12

80008132 <NbRetryParametersError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbRetryParametersError(pTMsgRx prbuf)
{
}
80008132:	5e fc       	retal	r12

80008134 <NbSamplingFrequencyStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbSamplingFrequencyStatus(pTMsgRx prbuf)
{
}
80008134:	5e fc       	retal	r12

80008136 <NbSamplingFrequencyError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbSamplingFrequencyError(pTMsgRx prbuf)
{
}
80008136:	5e fc       	retal	r12

80008138 <NbBoundaryStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbBoundaryStatus(pTMsgRx prbuf)
{
}
80008138:	5e fc       	retal	r12

8000813a <NbBoundaryError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbBoundaryError(pTMsgRx prbuf)
{
}
8000813a:	5e fc       	retal	r12

8000813c <NbVersionStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbVersionStatus(pTMsgRx prbuf)
{
}
8000813c:	5e fc       	retal	r12

8000813e <NbVersionError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbVersionError(pTMsgRx prbuf)
{
}
8000813e:	5e fc       	retal	r12

80008140 <NbShutDownReasonError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbShutDownReasonError(pTMsgRx prbuf)
{
}
80008140:	5e fc       	retal	r12

80008142 <NbFBlockInfoStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbFBlockInfoStatus(pTMsgRx prbuf)
{
}
80008142:	5e fc       	retal	r12

80008144 <NbFBlockInfoError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbFBlockInfoError(pTMsgRx prbuf)
{
}
80008144:	5e fc       	retal	r12

80008146 <NbImplFBlocksStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbImplFBlocksStatus(pTMsgRx prbuf)
{
}
80008146:	5e fc       	retal	r12

80008148 <NbImplFBlocksError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbImplFBlocksError(pTMsgRx prbuf)
{
}
80008148:	5e fc       	retal	r12

8000814a <NbEUI48Status>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbEUI48Status(pTMsgRx prbuf)
{
}
8000814a:	5e fc       	retal	r12

8000814c <NbEUI48Error>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NbEUI48Error(pTMsgRx prbuf)
{
}
8000814c:	5e fc       	retal	r12

8000814e <NmConfigurationStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmConfigurationStatus(pTMsgRx prbuf)
{
}
8000814e:	5e fc       	retal	r12

80008150 <NmConfigurationError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmConfigurationError(pTMsgRx prbuf)
{
}
80008150:	5e fc       	retal	r12

80008152 <NmCentralRegStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmCentralRegStatus(pTMsgRx prbuf)
{
}
80008152:	5e fc       	retal	r12

80008154 <NmCentralRegError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmCentralRegError(pTMsgRx prbuf)
{
}
80008154:	5e fc       	retal	r12

80008156 <NmSaveConfigResult>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmSaveConfigResult(pTMsgRx prbuf)
{
}
80008156:	5e fc       	retal	r12

80008158 <NmSaveConfigError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmSaveConfigError(pTMsgRx prbuf)
{
}
80008158:	5e fc       	retal	r12

8000815a <NmSaveConfigResultAck>:
/* Returns     : nothing                                                        */
/*                                                                              */
/*------------------------------------------------------------------------------*/
void NmSaveConfigResultAck(pTMsgRx prbuf)
{
}
8000815a:	5e fc       	retal	r12

8000815c <NmSaveConfigErrorAck>:
/* Returns     : nothing                                                        */
/*                                                                              */
/*------------------------------------------------------------------------------*/
void NmSaveConfigErrorAck(pTMsgRx prbuf)
{
}
8000815c:	5e fc       	retal	r12

8000815e <NmFktIDsStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmFktIDsStatus(pTMsgRx prbuf)
{
}
8000815e:	5e fc       	retal	r12

80008160 <NmFktIDsError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmFktIDsError(pTMsgRx prbuf)
{
}
80008160:	5e fc       	retal	r12

80008162 <NmSystemAvailStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmSystemAvailStatus(pTMsgRx prbuf)
{
}
80008162:	5e fc       	retal	r12

80008164 <NmSystemAvailError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmSystemAvailError(pTMsgRx prbuf)
{
}
80008164:	5e fc       	retal	r12

80008166 <NmFBlockInfoStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmFBlockInfoStatus(pTMsgRx prbuf)
{
}
80008166:	5e fc       	retal	r12

80008168 <NmFBlockInfoError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmFBlockInfoError(pTMsgRx prbuf)
{
}
80008168:	5e fc       	retal	r12

8000816a <NmVersionStatus>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmVersionStatus(pTMsgRx prbuf)
{
}
8000816a:	5e fc       	retal	r12

8000816c <NmVersionError>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmVersionError(pTMsgRx prbuf)
{
}
8000816c:	5e fc       	retal	r12

8000816e <NmOwnConfigInvalidResultAck>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmOwnConfigInvalidResultAck(pTMsgRx prbuf)
{
}
8000816e:	5e fc       	retal	r12

80008170 <NmOwnConfigInvalidErrorAck>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void NmOwnConfigInvalidErrorAck(pTMsgRx prbuf)
{
}
80008170:	5e fc       	retal	r12

80008172 <ET_SharedRxTxMsgBuf_Query>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
byte ET_SharedRxTxMsgBuf_Query(void)
{
	return(0x00);
}
80008172:	5e fd       	retal	0

80008174 <ET_AutoWakeup_Request>:
/*--------------------------------------------------------------------------*/
void ET_AutoWakeup_Request(byte delay, bool diag, byte duration)
{
	//    PWROFF_UC_ACTIVE();                        // keep Eval board on during wait & restart
//	PwrAutoWakeupReq(delay, diag, duration);
}
80008174:	5e fc       	retal	r12

80008176 <ET_MOSTRemoteReset_Request>:
/* Returns     : -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void ET_MOSTRemoteReset_Request(word src_adr, byte settings)
{
}
80008176:	5e fc       	retal	r12

80008178 <ET_PhysicalLayerTest_Status>:
/* Returns     : -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void ET_PhysicalLayerTest_Status(bool running)
{
}
80008178:	5e fc       	retal	r12
8000817a:	d7 03       	nop

8000817c <ET_FBlockInfo_Query>:
/* Returns     : MNS_TRUE   if the request could be serviced                */
/*               MNS_FALSE  if the request could not be serviced            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
bool ET_FBlockInfo_Query(word id, bool answer_prepared, pTMsgTx Tx_Ptr)
{
8000817c:	d4 01       	pushm	lr
8000817e:	20 4d       	sub	sp,16
	byte integrator_name[] = "SMSC";
80008180:	4a 09       	lddpc	r9,80008200 <ET_FBlockInfo_Query+0x84>
80008182:	fa c8 ff fc 	sub	r8,sp,-4
80008186:	13 ce       	ld.ub	lr,r9[0x4]
80008188:	b0 ce       	st.b	r8[0x4],lr
8000818a:	72 09       	ld.w	r9,r9[0x0]
8000818c:	91 09       	st.w	r8[0x0],r9
/* Returns     : MNS_TRUE   if the request could be serviced                */
/*               MNS_FALSE  if the request could not be serviced            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
bool ET_FBlockInfo_Query(word id, bool answer_prepared, pTMsgTx Tx_Ptr)
{
8000818e:	18 99       	mov	r9,r12
	byte integrator_name[] = "SMSC";
	byte i;
	byte version[3];

	if (MNS_FALSE != answer_prepared)
80008190:	58 0b       	cp.w	r11,0
80008192:	c0 b1       	brne	800081a8 <ET_FBlockInfo_Query+0x2c>
	}
	else
	{
		/* code here to answer ID's that NetServices does not answer */
		answer_prepared = MNS_TRUE;
		switch (id)
80008194:	fe 7c f0 02 	mov	r12,-4094
80008198:	f8 09 19 00 	cp.h	r9,r12
8000819c:	c0 90       	breq	800081ae <ET_FBlockInfo_Query+0x32>
8000819e:	fe 7c f0 05 	mov	r12,-4091
800081a2:	f8 09 19 00 	cp.h	r9,r12
800081a6:	c1 b0       	breq	800081dc <ET_FBlockInfo_Query+0x60>
		}

		return(answer_prepared);
	}

}
800081a8:	16 9c       	mov	r12,r11
800081aa:	2f cd       	sub	sp,-16
800081ac:	d8 02       	popm	pc
			break;

			case FBI_SUPPLIER_VERSION:
			version[0] = 1;
			version[1] = 0;
			version[2] = 0;
800081ae:	fb 6b 00 0e 	st.b	sp[14],r11
			Tx_Ptr->Length = (word)i + (word)3;
			break;

			case FBI_SUPPLIER_VERSION:
			version[0] = 1;
			version[1] = 0;
800081b2:	fb 6b 00 0d 	st.b	sp[13],r11
			}
			Tx_Ptr->Length = (word)i + (word)3;
			break;

			case FBI_SUPPLIER_VERSION:
			version[0] = 1;
800081b6:	30 18       	mov	r8,1
800081b8:	fb 68 00 0c 	st.b	sp[12],r8
			version[1] = 0;
			version[2] = 0;

			Tx_Ptr->Data[2] = FRMT_ISO8859;
800081bc:	74 09       	ld.w	r9,r10[0x0]
800081be:	b2 a8       	st.b	r9[0x2],r8

			i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
800081c0:	fa cc ff f4 	sub	r12,sp,-12
800081c4:	74 0b       	ld.w	r11,r10[0x0]
800081c6:	50 0a       	stdsp	sp[0x0],r10
800081c8:	2f db       	sub	r11,-3
800081ca:	e0 a0 05 4b 	rcall	80008c60 <MsgVersionToISO8859>

			Tx_Ptr->Length  = (word)((word)i + (word)3);
800081ce:	2f dc       	sub	r12,-3
800081d0:	40 0a       	lddsp	r10,sp[0x0]
800081d2:	30 1b       	mov	r11,1
800081d4:	b4 2c       	st.h	r10[0x4],r12
		}

		return(answer_prepared);
	}

}
800081d6:	16 9c       	mov	r12,r11
800081d8:	2f cd       	sub	sp,-16
800081da:	d8 02       	popm	pc
		/* code here to answer ID's that NetServices does not answer */
		answer_prepared = MNS_TRUE;
		switch (id)
		{
			case FBI_SYSTEM_INTEGRATOR:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
800081dc:	74 09       	ld.w	r9,r10[0x0]
800081de:	30 1c       	mov	r12,1
800081e0:	b2 ac       	st.b	r9[0x2],r12
			for(i=(byte)0; i<(byte)(sizeof(integrator_name)); ++i)
			{
				Tx_Ptr->Data[i+3] = (byte)integrator_name[i];
800081e2:	74 09       	ld.w	r9,r10[0x0]
800081e4:	f0 0b 07 0c 	ld.ub	r12,r8[r11]
800081e8:	16 09       	add	r9,r11
800081ea:	b2 bc       	st.b	r9[0x3],r12
800081ec:	2f fb       	sub	r11,-1
		answer_prepared = MNS_TRUE;
		switch (id)
		{
			case FBI_SYSTEM_INTEGRATOR:
			Tx_Ptr->Data[2] = FRMT_ISO8859;
			for(i=(byte)0; i<(byte)(sizeof(integrator_name)); ++i)
800081ee:	58 5b       	cp.w	r11,5
800081f0:	cf 91       	brne	800081e2 <ET_FBlockInfo_Query+0x66>
			{
				Tx_Ptr->Data[i+3] = (byte)integrator_name[i];
			}
			Tx_Ptr->Length = (word)i + (word)3;
800081f2:	30 88       	mov	r8,8
800081f4:	30 1b       	mov	r11,1
800081f6:	b4 28       	st.h	r10[0x4],r8
		}

		return(answer_prepared);
	}

}
800081f8:	16 9c       	mov	r12,r11
800081fa:	2f cd       	sub	sp,-16
800081fc:	d8 02       	popm	pc
800081fe:	d7 03       	nop
80008200:	80 06       	ld.sh	r6,r0[0x0]
80008202:	f2 fc d4 01 	ld.w	r12,r9[-11263]

80008204 <NbFBlockInfoGet>:
80008204:	d4 01       	pushm	lr
80008206:	20 4d       	sub	sp,16
/*               MNS_FALSE  if the request could not be serviced            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
bool NbFBlockInfoGet(word id, bool answer_prepared, pTMsgTx tx_ptr)
{
	byte name[] = "SMSC";
80008208:	4a 09       	lddpc	r9,80008288 <NbFBlockInfoGet+0x84>
8000820a:	fa c8 ff fc 	sub	r8,sp,-4
8000820e:	13 ce       	ld.ub	lr,r9[0x4]
80008210:	b0 ce       	st.b	r8[0x4],lr
80008212:	72 09       	ld.w	r9,r9[0x0]
80008214:	91 09       	st.w	r8[0x0],r9
/* Returns     : MNS_TRUE   if the request could be serviced                */
/*               MNS_FALSE  if the request could not be serviced            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
bool NbFBlockInfoGet(word id, bool answer_prepared, pTMsgTx tx_ptr)
{
80008216:	18 99       	mov	r9,r12
	byte name[] = "SMSC";
	byte i;
	byte version[3];


	if (answer_prepared)
80008218:	58 0b       	cp.w	r11,0
8000821a:	c0 b1       	brne	80008230 <NbFBlockInfoGet+0x2c>
	{
		return(MNS_TRUE);
	}
	else
	{
		switch (id)
8000821c:	fe 7c f0 02 	mov	r12,-4094
80008220:	f8 09 19 00 	cp.h	r9,r12
80008224:	c0 90       	breq	80008236 <NbFBlockInfoGet+0x32>
80008226:	fe 7c f0 05 	mov	r12,-4091
8000822a:	f8 09 19 00 	cp.h	r9,r12
8000822e:	c1 b0       	breq	80008264 <NbFBlockInfoGet+0x60>

		}
		return(answer_prepared);
	}

}
80008230:	16 9c       	mov	r12,r11
80008232:	2f cd       	sub	sp,-16
80008234:	d8 02       	popm	pc
		switch (id)
		{
			case FBI_SUPPLIER_VERSION:
			version[0] = 1;     // out first version of this FBlock
			version[1] = 0;
			version[2] = 0;
80008236:	fb 6b 00 0e 	st.b	sp[14],r11
	{
		switch (id)
		{
			case FBI_SUPPLIER_VERSION:
			version[0] = 1;     // out first version of this FBlock
			version[1] = 0;
8000823a:	fb 6b 00 0d 	st.b	sp[13],r11
	else
	{
		switch (id)
		{
			case FBI_SUPPLIER_VERSION:
			version[0] = 1;     // out first version of this FBlock
8000823e:	30 18       	mov	r8,1
80008240:	fb 68 00 0c 	st.b	sp[12],r8
			version[1] = 0;
			version[2] = 0;

			tx_ptr->Data[2] = FRMT_ISO8859;
80008244:	74 09       	ld.w	r9,r10[0x0]
80008246:	b2 a8       	st.b	r9[0x2],r8

			i = MsgVersionToISO8859(&version[0], &tx_ptr->Data[3]);
80008248:	fa cc ff f4 	sub	r12,sp,-12
8000824c:	74 0b       	ld.w	r11,r10[0x0]
8000824e:	50 0a       	stdsp	sp[0x0],r10
80008250:	2f db       	sub	r11,-3
80008252:	e0 a0 05 07 	rcall	80008c60 <MsgVersionToISO8859>

			tx_ptr->Length  = (word)i + (word)3;
80008256:	2f dc       	sub	r12,-3
80008258:	40 0a       	lddsp	r10,sp[0x0]
8000825a:	30 1b       	mov	r11,1
8000825c:	b4 2c       	st.h	r10[0x4],r12

		}
		return(answer_prepared);
	}

}
8000825e:	16 9c       	mov	r12,r11
80008260:	2f cd       	sub	sp,-16
80008262:	d8 02       	popm	pc

			tx_ptr->Length  = (word)i + (word)3;
			answer_prepared = MNS_TRUE;
			break;
			case FBI_SYSTEM_INTEGRATOR:
			tx_ptr->Data[2] = FRMT_ISO8859;
80008264:	74 09       	ld.w	r9,r10[0x0]
80008266:	30 1c       	mov	r12,1
80008268:	b2 ac       	st.b	r9[0x2],r12
			for(i=(byte)0; i<(byte)(sizeof(name)/sizeof(name[0])); ++i)
			{
				tx_ptr->Data[i+3] = (byte)name[i];
8000826a:	74 09       	ld.w	r9,r10[0x0]
8000826c:	f0 0b 07 0c 	ld.ub	r12,r8[r11]
80008270:	16 09       	add	r9,r11
80008272:	b2 bc       	st.b	r9[0x3],r12
80008274:	2f fb       	sub	r11,-1
			tx_ptr->Length  = (word)i + (word)3;
			answer_prepared = MNS_TRUE;
			break;
			case FBI_SYSTEM_INTEGRATOR:
			tx_ptr->Data[2] = FRMT_ISO8859;
			for(i=(byte)0; i<(byte)(sizeof(name)/sizeof(name[0])); ++i)
80008276:	58 5b       	cp.w	r11,5
80008278:	cf 91       	brne	8000826a <NbFBlockInfoGet+0x66>
			{
				tx_ptr->Data[i+3] = (byte)name[i];
			}
			tx_ptr->Length = (word)i + (word)3;
8000827a:	30 88       	mov	r8,8
8000827c:	30 1b       	mov	r11,1
8000827e:	b4 28       	st.h	r10[0x4],r8

		}
		return(answer_prepared);
	}

}
80008280:	16 9c       	mov	r12,r11
80008282:	2f cd       	sub	sp,-16
80008284:	d8 02       	popm	pc
80008286:	d7 03       	nop
80008288:	80 06       	ld.sh	r6,r0[0x0]
8000828a:	f2 fc d4 01 	ld.w	r12,r9[-11263]

8000828c <ET_Reset_Request>:
8000828c:	d4 01       	pushm	lr
8000828e:	30 1c       	mov	r12,1
	TMsgTx *msg_ptr;

//	PM_SetHold();                                           // Tell MPM to hold power on while we reset INIC and EHC

	/* reset using INIC command to reset both INIC and EHC - requires INIC's RSOUT connected to EHC_Reset */
	msg_ptr = MsgGetTxPtrExt(1);
80008290:	e0 a0 06 06 	rcall	80008e9c <MsgGetTxPtrExt>

	if (msg_ptr)
80008294:	c1 20       	breq	800082b8 <ET_Reset_Request+0x2c>
	{
		msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
		msg_ptr->FBlock_ID = FBLOCK_INIC;
80008296:	30 0a       	mov	r10,0
	/* reset using INIC command to reset both INIC and EHC - requires INIC's RSOUT connected to EHC_Reset */
	msg_ptr = MsgGetTxPtrExt(1);

	if (msg_ptr)
	{
		msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80008298:	30 19       	mov	r9,1
		msg_ptr->FBlock_ID = FBLOCK_INIC;
		msg_ptr->Func_ID   = FUNCID_INIC_RESET;
		msg_ptr->Operation = OP_START;
8000829a:	f9 6a 00 0c 	st.b	r12[12],r10
	msg_ptr = MsgGetTxPtrExt(1);

	if (msg_ptr)
	{
		msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
		msg_ptr->FBlock_ID = FBLOCK_INIC;
8000829e:	f9 6a 00 0a 	st.b	r12[10],r10
	/* reset using INIC command to reset both INIC and EHC - requires INIC's RSOUT connected to EHC_Reset */
	msg_ptr = MsgGetTxPtrExt(1);

	if (msg_ptr)
	{
		msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800082a2:	b8 39       	st.h	r12[0x6],r9
		msg_ptr->FBlock_ID = FBLOCK_INIC;
		msg_ptr->Func_ID   = FUNCID_INIC_RESET;
800082a4:	e0 6a 02 03 	mov	r10,515
800082a8:	b8 4a       	st.h	r12[0x8],r10
		msg_ptr->Operation = OP_START;
		msg_ptr->Data[0]   = 3;
800082aa:	30 3b       	mov	r11,3
800082ac:	78 0a       	ld.w	r10,r12[0x0]
800082ae:	b4 8b       	st.b	r10[0x0],r11
		msg_ptr->Length    = 1;
800082b0:	b8 29       	st.h	r12[0x4],r9

		MsgSend3(msg_ptr);
800082b2:	e0 a0 09 39 	rcall	80009524 <MsgSend3>
800082b6:	d8 02       	popm	pc
	}
	else
	{
		LOG_ERR("No buffer for ET.Reset\n");
800082b8:	48 2c       	lddpc	r12,800082c0 <ET_Reset_Request+0x34>
800082ba:	e0 a0 7c ab 	rcall	80017c10 <puts>
800082be:	d8 02       	popm	pc
800082c0:	80 06       	ld.sh	r6,r0[0x0]
800082c2:	f3 04 d4 01 	ld.sh	r4,r9[-11263]

800082c4 <NbShutDownReasonStatus>:
800082c4:	d4 01       	pushm	lr
800082c6:	48 3c       	lddpc	r12,800082d0 <NbShutDownReasonStatus+0xc>
800082c8:	e0 a0 7c a4 	rcall	80017c10 <puts>
800082cc:	d8 02       	popm	pc
800082ce:	d7 03       	nop
/*--------------------------------------------------------------------------*/
void NbShutDownReasonStatus(pTMsgRx prbuf)
{
	LOG_NOR("ShutDownReason Status message received\n");

}
800082d0:	80 06       	ld.sh	r6,r0[0x0]
800082d2:	f3 1c eb cd 	ld.uh	r12,r9[-5171]

800082d4 <ET_Shutdown_Request>:
800082d4:	eb cd 40 80 	pushm	r7,lr
/*--------------------------------------------------------------------------*/
byte ET_Shutdown_Request(byte type)
{
	byte retval;

	switch (type)
800082d8:	30 18       	mov	r8,1
/*               0x01 - The application is not able to process the request. */
/*               0x02 - The device is not PowerMaster (in case type==0x00). */
/*                                                                          */
/*--------------------------------------------------------------------------*/
byte ET_Shutdown_Request(byte type)
{
800082da:	18 97       	mov	r7,r12
	byte retval;

	switch (type)
800082dc:	f0 0c 18 00 	cp.b	r12,r8
800082e0:	c0 b0       	breq	800082f6 <ET_Shutdown_Request+0x22>
800082e2:	c0 73       	brcs	800082f0 <ET_Shutdown_Request+0x1c>
800082e4:	30 28       	mov	r8,2
800082e6:	f0 0c 18 00 	cp.b	r12,r8
800082ea:	c1 e0       	breq	80008326 <ET_Shutdown_Request+0x52>
800082ec:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800082f0:	30 2c       	mov	r12,2
800082f2:	e3 cd 80 80 	ldm	sp++,r7,pc
			retval = SDN_NOT_POWERMASTER;
			break;
		}
		case ET_SHUTDOWN_SIM_SHUTDOWN_TEMPERATURE:
		{                           // send broadcast - requesting network shutdown
			TMsgTx *msg_ptr = MsgGetTxPtrExt(0x01);  // Only 1 byte of data to send
800082f6:	30 1c       	mov	r12,1
800082f8:	e0 a0 05 d2 	rcall	80008e9c <MsgGetTxPtrExt>
			if (msg_ptr)
800082fc:	cf 80       	breq	800082ec <ET_Shutdown_Request+0x18>
			{
				msg_ptr->Tgt_Adr = MSG_TGT_BROADCAST_BLOCKING;
800082fe:	e0 69 03 c8 	mov	r9,968
80008302:	b8 39       	st.h	r12[0x6],r9
				msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
				msg_ptr->Inst_ID = INST_ANY;
80008304:	30 09       	mov	r9,0
80008306:	f9 69 00 0b 	st.b	r12[11],r9
				msg_ptr->Func_ID = FUNC_SHUTDOWN;
8000830a:	30 69       	mov	r9,6
8000830c:	b8 49       	st.h	r12[0x8],r9
				msg_ptr->Operation = OP_RESULT;
8000830e:	30 c9       	mov	r9,12
		{                           // send broadcast - requesting network shutdown
			TMsgTx *msg_ptr = MsgGetTxPtrExt(0x01);  // Only 1 byte of data to send
			if (msg_ptr)
			{
				msg_ptr->Tgt_Adr = MSG_TGT_BROADCAST_BLOCKING;
				msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
80008310:	f9 67 00 0a 	st.b	r12[10],r7
				msg_ptr->Inst_ID = INST_ANY;
				msg_ptr->Func_ID = FUNC_SHUTDOWN;
				msg_ptr->Operation = OP_RESULT;
80008314:	f9 69 00 0c 	st.b	r12[12],r9
				msg_ptr->Data[0] = 0x03;            // That's TemperatureShutDown
80008318:	78 08       	ld.w	r8,r12[0x0]
8000831a:	30 39       	mov	r9,3
8000831c:	b0 89       	st.b	r8[0x0],r9

				MsgSend(msg_ptr);
8000831e:	e0 a0 0b 2b 	rcall	80009974 <MsgSend>
80008322:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
			}
			break;
		}
		case ET_SHUTDOWN_SIM_DEAD_TEMPERATURE:
		{                           // turn off network and power down
			LOG_ERR("Emergency Power Down Simulation\n");
80008326:	49 2c       	lddpc	r12,8000836c <ET_Shutdown_Request+0x98>
80008328:	e0 a0 7c 74 	rcall	80017c10 <puts>
			//PM_OverrideEphy();          // ignore that we're locked
			//PM_OverrideOphy();          // ignore that we're locked
			MostShutDown();
8000832c:	e0 a0 40 ac 	rcall	80010484 <MostShutDown>
			StopNetServices();          // go to protected mode - should shut down.
80008330:	e0 a0 19 d4 	rcall	8000b6d8 <StopNetServices>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80008334:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80008338:	ec 69 35 00 	mov	r9,800000
8000833c:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80008340:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80008344:	14 38       	cp.w	r8,r10
80008346:	e0 88 00 0b 	brls	8000835c <ET_Shutdown_Request+0x88>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000834a:	12 38       	cp.w	r8,r9
8000834c:	fe 98 ff fa 	brls	80008340 <ET_Shutdown_Request+0x6c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80008350:	12 3a       	cp.w	r10,r9
80008352:	cf 72       	brcc	80008340 <ET_Shutdown_Request+0x6c>
			delay_ms(50);           // waiting for NetServices to stop
			HOLD_DUT_IN_RESET();           // resetting INIC causes it to release PWROFF instantly
80008354:	fe b0 dc 08 	rcall	80003b64 <inic_HoldReset>
80008358:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000835c:	12 38       	cp.w	r8,r9
8000835e:	fe 98 ff f9 	brls	80008350 <ET_Shutdown_Request+0x7c>
80008362:	fe b0 dc 01 	rcall	80003b64 <inic_HoldReset>
80008366:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000836a:	d7 03       	nop
8000836c:	80 06       	ld.sh	r6,r0[0x0]
8000836e:	f3 44 d4 21 	st.w	r9[-11231],r4

80008370 <NbGetDeviceInfo>:
80008370:	d4 21       	pushm	r4-r7,lr
80008372:	76 08       	ld.w	r8,r11[0x0]
80008374:	30 19       	mov	r9,1
80008376:	b0 8c       	st.b	r8[0x0],r12
80008378:	76 08       	ld.w	r8,r11[0x0]
8000837a:	b0 99       	st.b	r8[0x1],r9
8000837c:	16 97       	mov	r7,r11
8000837e:	32 18       	mov	r8,33
80008380:	f0 0c 18 00 	cp.b	r12,r8
80008384:	e0 80 00 9e 	breq	800084c0 <NbGetDeviceInfo+0x150>

	returnvalue = OP_STATUS;
	tx_ptr->Data[0]  = id;           				        // Return the ID sent in
	tx_ptr->Data[1]  = ISO8859;       				        // Format Identifier ISO8859

	switch (id)
80008388:	e0 88 00 13 	brls	800083ae <NbGetDeviceInfo+0x3e>
8000838c:	32 38       	mov	r8,35
8000838e:	f0 0c 18 00 	cp.b	r12,r8
80008392:	c6 10       	breq	80008454 <NbGetDeviceInfo+0xe4>
80008394:	c2 73       	brcs	800083e2 <NbGetDeviceInfo+0x72>
80008396:	32 48       	mov	r8,36
80008398:	f0 0c 18 00 	cp.b	r12,r8
8000839c:	e0 80 00 c7 	breq	8000852a <NbGetDeviceInfo+0x1ba>
800083a0:	3a d8       	mov	r8,-83
800083a2:	f0 0c 18 00 	cp.b	r12,r8
800083a6:	e0 80 00 be 	breq	80008522 <NbGetDeviceInfo+0x1b2>
800083aa:	30 fc       	mov	r12,15
800083ac:	d8 22       	popm	r4-r7,pc
800083ae:	f2 0c 18 00 	cp.b	r12,r9
800083b2:	c7 e0       	breq	800084ae <NbGetDeviceInfo+0x13e>
800083b4:	c0 a2       	brcc	800083c8 <NbGetDeviceInfo+0x58>
800083b6:	76 0c       	ld.w	r12,r11[0x0]
	{
		case 0x00:                                          // Company Name
		{
			strcpy_P((char *)&tx_ptr->Data[2], &CompanyName[0]);
800083b8:	4d fb       	lddpc	r11,80008534 <NbGetDeviceInfo+0x1c4>
800083ba:	2f ec       	sub	r12,-2
800083bc:	e0 a0 7d cb 	rcall	80017f52 <strcpy>
800083c0:	30 78       	mov	r8,7
			tx_ptr->Length   = 7;							//
800083c2:	30 cc       	mov	r12,12
800083c4:	ae 28       	st.h	r7[0x4],r8
800083c6:	d8 22       	popm	r4-r7,pc

			break;
800083c8:	30 28       	mov	r8,2

	returnvalue = OP_STATUS;
	tx_ptr->Data[0]  = id;           				        // Return the ID sent in
	tx_ptr->Data[1]  = ISO8859;       				        // Format Identifier ISO8859

	switch (id)
800083ca:	f0 0c 18 00 	cp.b	r12,r8
800083ce:	ce e1       	brne	800083aa <NbGetDeviceInfo+0x3a>
800083d0:	76 0c       	ld.w	r12,r11[0x0]
			break;
		}

		case 0x02:                                          // Product Version
		{
			strcpy_P((char *)&tx_ptr->Data[2], &ProductVersion[0]);
800083d2:	4d ab       	lddpc	r11,80008538 <NbGetDeviceInfo+0x1c8>
800083d4:	2f ec       	sub	r12,-2
800083d6:	e0 a0 7d be 	rcall	80017f52 <strcpy>
800083da:	30 f8       	mov	r8,15
			tx_ptr->Length  = 15;
800083dc:	30 cc       	mov	r12,12
800083de:	ae 28       	st.h	r7[0x4],r8
800083e0:	d8 22       	popm	r4-r7,pc
			break;
800083e2:	4d 76       	lddpc	r6,8000853c <NbGetDeviceInfo+0x1cc>
			break;
		}

		case 0x22:                                          // NetServices Revision
		{
			MostGetVersionInfo(&MostVersion);                   // get the revision, use print_buff for temp storage
800083e4:	0c 9c       	mov	r12,r6
800083e6:	e0 a0 16 a9 	rcall	8000b138 <MostGetVersionInfo>
800083ea:	35 69       	mov	r9,86
			//sprintf(&tx_ptr->Data[2], "%d.%d.%d", MostVersion.fw_date[0], MostVersion.fw_date[1], MostVersion.fw_date[0]);
			tx_ptr->Data[2]  = 'V';          				// Start of string
800083ec:	6e 08       	ld.w	r8,r7[0x0]
800083ee:	b0 a9       	st.b	r8[0x2],r9
800083f0:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[3]  = hex_upper_nibble(MostVersion.fw_date[0]);  // version numbers are in hex
800083f2:	0d cc       	ld.ub	r12,r6[0x4]
800083f4:	2f d5       	sub	r5,-3
800083f6:	fe b0 db 65 	rcall	80003ac0 <hex_upper_nibble>
800083fa:	aa 8c       	st.b	r5[0x0],r12
800083fc:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[4]  = hex_lower_nibble(MostVersion.fw_date[0]);
800083fe:	0d cc       	ld.ub	r12,r6[0x4]
80008400:	fe b0 db 68 	rcall	80003ad0 <hex_lower_nibble>
80008404:	2f c5       	sub	r5,-4
80008406:	aa 8c       	st.b	r5[0x0],r12
80008408:	6e 08       	ld.w	r8,r7[0x0]
			tx_ptr->Data[5]  = '.';
8000840a:	32 e5       	mov	r5,46
8000840c:	b0 d5       	st.b	r8[0x5],r5
8000840e:	6e 04       	ld.w	r4,r7[0x0]
			tx_ptr->Data[6]  = hex_upper_nibble(MostVersion.fw_date[1]);  //
80008410:	0d dc       	ld.ub	r12,r6[0x5]
80008412:	2f a4       	sub	r4,-6
80008414:	fe b0 db 56 	rcall	80003ac0 <hex_upper_nibble>
80008418:	a8 8c       	st.b	r4[0x0],r12
8000841a:	6e 04       	ld.w	r4,r7[0x0]
			tx_ptr->Data[7]  = hex_lower_nibble(MostVersion.fw_date[1]);
8000841c:	0d dc       	ld.ub	r12,r6[0x5]
8000841e:	fe b0 db 59 	rcall	80003ad0 <hex_lower_nibble>
80008422:	2f 94       	sub	r4,-7
80008424:	a8 8c       	st.b	r4[0x0],r12
80008426:	6e 08       	ld.w	r8,r7[0x0]
			tx_ptr->Data[8]  = '.';
80008428:	f1 65 00 08 	st.b	r8[8],r5
8000842c:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[9]  = hex_upper_nibble(MostVersion.fw_date[2]);  //
8000842e:	0d ec       	ld.ub	r12,r6[0x6]
80008430:	fe b0 db 48 	rcall	80003ac0 <hex_upper_nibble>
80008434:	2f 75       	sub	r5,-9
80008436:	aa 8c       	st.b	r5[0x0],r12
80008438:	0d ec       	ld.ub	r12,r6[0x6]
			tx_ptr->Data[10] = hex_lower_nibble(MostVersion.fw_date[2]);
8000843a:	6e 06       	ld.w	r6,r7[0x0]
			tx_ptr->Data[5]  = '.';
			tx_ptr->Data[6]  = hex_upper_nibble(MostVersion.fw[1]);  // INIC version numbers are in hex
			tx_ptr->Data[7]  = hex_lower_nibble(MostVersion.fw[1]);
			tx_ptr->Data[8]  = '.';
			tx_ptr->Data[9]  = hex_upper_nibble(MostVersion.fw[2]);  // INIC version numbers are in hex
			tx_ptr->Data[10] = hex_lower_nibble(MostVersion.fw[2]);
8000843c:	fe b0 db 4a 	rcall	80003ad0 <hex_lower_nibble>
80008440:	2f 66       	sub	r6,-10
80008442:	ac 8c       	st.b	r6[0x0],r12
80008444:	30 09       	mov	r9,0
			tx_ptr->Data[11]  = 0x00;			    		// string terminator
80008446:	6e 08       	ld.w	r8,r7[0x0]
80008448:	f1 69 00 0b 	st.b	r8[11],r9
8000844c:	30 cc       	mov	r12,12
			tx_ptr->Length  = 12;
8000844e:	30 c8       	mov	r8,12
80008450:	ae 28       	st.h	r7[0x4],r8
80008452:	d8 22       	popm	r4-r7,pc
			break;
80008454:	4b a6       	lddpc	r6,8000853c <NbGetDeviceInfo+0x1cc>
			break;
		}

		case 0x23:                                          // INIC Firmware Version
		{
			MostGetVersionInfo(&MostVersion);               // get all the current version information
80008456:	0c 9c       	mov	r12,r6
80008458:	e0 a0 16 70 	rcall	8000b138 <MostGetVersionInfo>
8000845c:	35 69       	mov	r9,86
			//sprintf(&tx_ptr->Data[2], "%d.%d.%d", MostVersion.fw[0], MostVersion.fw[1], MostVersion.fw[2]);
			tx_ptr->Data[2]  = 'V';          				// Start of string
8000845e:	6e 08       	ld.w	r8,r7[0x0]
80008460:	b0 a9       	st.b	r8[0x2],r9
80008462:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[3]  = hex_upper_nibble(MostVersion.fw[0]);  // INIC version numbers are in hex
80008464:	0d 9c       	ld.ub	r12,r6[0x1]
80008466:	2f d5       	sub	r5,-3
80008468:	fe b0 db 2c 	rcall	80003ac0 <hex_upper_nibble>
8000846c:	aa 8c       	st.b	r5[0x0],r12
8000846e:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[4]  = hex_lower_nibble(MostVersion.fw[0]);
80008470:	0d 9c       	ld.ub	r12,r6[0x1]
80008472:	fe b0 db 2f 	rcall	80003ad0 <hex_lower_nibble>
80008476:	2f c5       	sub	r5,-4
80008478:	aa 8c       	st.b	r5[0x0],r12
8000847a:	6e 08       	ld.w	r8,r7[0x0]
			tx_ptr->Data[5]  = '.';
8000847c:	32 e5       	mov	r5,46
8000847e:	b0 d5       	st.b	r8[0x5],r5
80008480:	6e 04       	ld.w	r4,r7[0x0]
			tx_ptr->Data[6]  = hex_upper_nibble(MostVersion.fw[1]);  // INIC version numbers are in hex
80008482:	0d ac       	ld.ub	r12,r6[0x2]
80008484:	2f a4       	sub	r4,-6
80008486:	fe b0 db 1d 	rcall	80003ac0 <hex_upper_nibble>
8000848a:	a8 8c       	st.b	r4[0x0],r12
8000848c:	6e 04       	ld.w	r4,r7[0x0]
			tx_ptr->Data[7]  = hex_lower_nibble(MostVersion.fw[1]);
8000848e:	0d ac       	ld.ub	r12,r6[0x2]
80008490:	fe b0 db 20 	rcall	80003ad0 <hex_lower_nibble>
80008494:	2f 94       	sub	r4,-7
80008496:	a8 8c       	st.b	r4[0x0],r12
80008498:	6e 08       	ld.w	r8,r7[0x0]
			tx_ptr->Data[8]  = '.';
8000849a:	f1 65 00 08 	st.b	r8[8],r5
8000849e:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[9]  = hex_upper_nibble(MostVersion.fw[2]);  // INIC version numbers are in hex
800084a0:	0d bc       	ld.ub	r12,r6[0x3]
800084a2:	fe b0 db 0f 	rcall	80003ac0 <hex_upper_nibble>
800084a6:	2f 75       	sub	r5,-9
800084a8:	aa 8c       	st.b	r5[0x0],r12
800084aa:	0d bc       	ld.ub	r12,r6[0x3]
			tx_ptr->Data[10] = hex_lower_nibble(MostVersion.fw[2]);
800084ac:	cc 7b       	rjmp	8000843a <NbGetDeviceInfo+0xca>
800084ae:	76 0c       	ld.w	r12,r11[0x0]
			break;
		}

		case 0x01:                                          // Product Name
		{
			strcpy_P((char *)&tx_ptr->Data[2], &ProductName[0]);
800084b0:	4a 4b       	lddpc	r11,80008540 <NbGetDeviceInfo+0x1d0>
800084b2:	2f ec       	sub	r12,-2
800084b4:	e0 a0 7d 4f 	rcall	80017f52 <strcpy>
800084b8:	30 98       	mov	r8,9
			tx_ptr->Length   = 9;							//
800084ba:	30 cc       	mov	r12,12
800084bc:	ae 28       	st.h	r7[0x4],r8
800084be:	d8 22       	popm	r4-r7,pc
			break;
800084c0:	49 f6       	lddpc	r6,8000853c <NbGetDeviceInfo+0x1cc>
			break;
		}

		case 0x21:                                          // NetServices Version
		{
			MostGetVersionInfo(&MostVersion);               // get all the current version information
800084c2:	0c 9c       	mov	r12,r6
800084c4:	e0 a0 16 3a 	rcall	8000b138 <MostGetVersionInfo>
800084c8:	35 69       	mov	r9,86
			//sprintf(&tx_ptr->Data[2], "%d.%d.%d", MostVersion.ns[0], MostVersion.ns[1], MostVersion.ns[2]);

			tx_ptr->Data[2]  = 'V';          				// Start of string
800084ca:	6e 08       	ld.w	r8,r7[0x0]
800084cc:	b0 a9       	st.b	r8[0x2],r9
800084ce:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[3]  = hex_upper_nibble(MostVersion.ns[0]);  // Version numbers are in hex
800084d0:	0d fc       	ld.ub	r12,r6[0x7]
800084d2:	2f d5       	sub	r5,-3
800084d4:	fe b0 da f6 	rcall	80003ac0 <hex_upper_nibble>
800084d8:	aa 8c       	st.b	r5[0x0],r12
800084da:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[4]  = hex_lower_nibble(MostVersion.ns[0]);
800084dc:	0d fc       	ld.ub	r12,r6[0x7]
800084de:	fe b0 da f9 	rcall	80003ad0 <hex_lower_nibble>
800084e2:	2f c5       	sub	r5,-4
800084e4:	aa 8c       	st.b	r5[0x0],r12
800084e6:	6e 08       	ld.w	r8,r7[0x0]
			tx_ptr->Data[5]  = '.';
800084e8:	32 e5       	mov	r5,46
800084ea:	b0 d5       	st.b	r8[0x5],r5
800084ec:	6e 04       	ld.w	r4,r7[0x0]
			tx_ptr->Data[6]  = hex_upper_nibble(MostVersion.ns[1]);  //
800084ee:	ed 3c 00 08 	ld.ub	r12,r6[8]
800084f2:	2f a4       	sub	r4,-6
800084f4:	fe b0 da e6 	rcall	80003ac0 <hex_upper_nibble>
800084f8:	a8 8c       	st.b	r4[0x0],r12
800084fa:	6e 04       	ld.w	r4,r7[0x0]
			tx_ptr->Data[7]  = hex_lower_nibble(MostVersion.ns[1]);
800084fc:	ed 3c 00 08 	ld.ub	r12,r6[8]
80008500:	fe b0 da e8 	rcall	80003ad0 <hex_lower_nibble>
80008504:	2f 94       	sub	r4,-7
80008506:	a8 8c       	st.b	r4[0x0],r12
80008508:	6e 08       	ld.w	r8,r7[0x0]
			tx_ptr->Data[8]  = '.';
8000850a:	f1 65 00 08 	st.b	r8[8],r5
8000850e:	6e 05       	ld.w	r5,r7[0x0]
			tx_ptr->Data[9]  = hex_upper_nibble(MostVersion.ns[2]);  //
80008510:	ed 3c 00 09 	ld.ub	r12,r6[9]
80008514:	fe b0 da d6 	rcall	80003ac0 <hex_upper_nibble>
80008518:	2f 75       	sub	r5,-9
8000851a:	aa 8c       	st.b	r5[0x0],r12
8000851c:	ed 3c 00 09 	ld.ub	r12,r6[9]
			tx_ptr->Data[10] = hex_lower_nibble(MostVersion.ns[2]);
80008520:	c8 db       	rjmp	8000843a <NbGetDeviceInfo+0xca>
80008522:	30 38       	mov	r8,3
					tx_ptr->Data[1] = 0x00; // 'not initialized' - don't know
				}
			}
			tx_ptr->Data[2]  = PM_Version[3];               // Direct WakeInfo byte collected during startup
			*/
			tx_ptr->Length   = 3;
80008524:	30 cc       	mov	r12,12
80008526:	b6 28       	st.h	r11[0x4],r8
80008528:	d8 22       	popm	r4-r7,pc
		returnvalue = OP_ERROR;         /* -> error message will be prepared by the NetServices ! */
		break;                          /*    You just have to return OP_ERROR */
	}

	return(returnvalue);
}
8000852a:	30 38       	mov	r8,3
		{
			/*
			tx_ptr->Data[1]  = PM_Version[1];               // Returning HEX values, not ASCII string
			tx_ptr->Data[2]  = PM_Version[2];
			*/
			tx_ptr->Length   = 3;
8000852c:	30 cc       	mov	r12,12
8000852e:	b6 28       	st.h	r11[0x4],r8
80008530:	d8 22       	popm	r4-r7,pc
			break;
80008532:	d7 03       	nop
80008534:	80 07       	ld.sh	r7,r0[0x0]
80008536:	0a 04       	add	r4,r5
80008538:	80 07       	ld.sh	r7,r0[0x0]
8000853a:	0a 1c       	sub	r12,r5
8000853c:	00 00       	add	r0,r0
8000853e:	41 d0       	lddsp	r0,sp[0x74]
80008540:	80 07       	ld.sh	r7,r0[0x0]
80008542:	08 78       	tst	r8,r4

80008544 <CmdRxFilter>:
80008544:	d4 01       	pushm	lr
80008546:	58 0c       	cp.w	r12,0
80008548:	c0 40       	breq	80008550 <CmdRxFilter+0xc>
8000854a:	e0 a0 60 ab 	rcall	800146a0 <ET_RxFilter>
8000854e:	d8 02       	popm	pc
80008550:	30 3c       	mov	r12,3
80008552:	d8 02       	popm	pc

80008554 <CmdUnknownFBlockShadow>:
	blink_msg_led();   // causes yellow LED to blink each time we get a message

	#ifdef ET_MIN
	byte retval;

	if (NULL != tx_ptr)                 /* call ET_RxFilter only if tx_ptr is available */
80008554:	eb cd 40 80 	pushm	r7,lr
	pTMsgTx dummy1;
	pTMsgRx dummy2;

	dummy1 = tx_ptr;
	dummy2 = rx_ptr;
	LOG_ERR("Received unknow shadow message from node %04X\n", rx_ptr->Src_Adr);
80008558:	96 b8       	ld.uh	r8,r11[0x6]
/* Parameter(s): tx_ptr - pointer to reserved tx message                    */
/* Returns     : information how to handle the tx message                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
byte CmdUnknownFBlockShadow(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
8000855a:	16 97       	mov	r7,r11
	pTMsgTx dummy1;
	pTMsgRx dummy2;

	dummy1 = tx_ptr;
	dummy2 = rx_ptr;
	LOG_ERR("Received unknow shadow message from node %04X\n", rx_ptr->Src_Adr);
8000855c:	1a d8       	st.w	--sp,r8
8000855e:	48 bc       	lddpc	r12,80008588 <CmdUnknownFBlockShadow+0x34>
80008560:	e0 a0 7a c2 	rcall	80017ae4 <printf>
	LOG_ERR("   message to FBlock:InstId [%02X:%02X]\n",rx_ptr->FBlock_ID, rx_ptr->Inst_ID);
80008564:	ef 38 00 0b 	ld.ub	r8,r7[11]
80008568:	1a d8       	st.w	--sp,r8
8000856a:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000856e:	48 8c       	lddpc	r12,8000858c <CmdUnknownFBlockShadow+0x38>
80008570:	1a d8       	st.w	--sp,r8
80008572:	e0 a0 7a b9 	rcall	80017ae4 <printf>
	LOG_ERR("   Function ID is %04X\n", rx_ptr->Func_ID);
80008576:	8e c8       	ld.uh	r8,r7[0x8]
80008578:	48 6c       	lddpc	r12,80008590 <CmdUnknownFBlockShadow+0x3c>
8000857a:	1a d8       	st.w	--sp,r8
8000857c:	e0 a0 7a b4 	rcall	80017ae4 <printf>

	return (OP_NO_REPORT);
}
80008580:	30 0c       	mov	r12,0

	dummy1 = tx_ptr;
	dummy2 = rx_ptr;
	LOG_ERR("Received unknow shadow message from node %04X\n", rx_ptr->Src_Adr);
	LOG_ERR("   message to FBlock:InstId [%02X:%02X]\n",rx_ptr->FBlock_ID, rx_ptr->Inst_ID);
	LOG_ERR("   Function ID is %04X\n", rx_ptr->Func_ID);
80008582:	2f cd       	sub	sp,-16

	return (OP_NO_REPORT);
}
80008584:	e3 cd 80 80 	ldm	sp++,r7,pc
80008588:	80 06       	ld.sh	r6,r0[0x0]
8000858a:	f3 64 80 06 	st.b	r9[-32762],r4
8000858e:	f3 94       	*unknown*
80008590:	80 06       	ld.sh	r6,r0[0x0]
80008592:	f3 c0       	*unknown*

80008594 <flashc_set_bus_freq>:
}


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
80008594:	e0 68 8a 3f 	mov	r8,35391
80008598:	ea 18 01 f7 	orh	r8,0x1f7
8000859c:	10 3c       	cp.w	r12,r8
8000859e:	e0 8b 00 0a 	brhi	800085b2 <flashc_set_bus_freq+0x1e>
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800085a2:	fe 68 00 00 	mov	r8,-131072
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800085a6:	30 0a       	mov	r10,0
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800085a8:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800085aa:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800085ae:	91 09       	st.w	r8[0x0],r9
800085b0:	5e fc       	retal	r12
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800085b2:	fe 68 00 00 	mov	r8,-131072
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800085b6:	30 1a       	mov	r10,1
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800085b8:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800085ba:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800085be:	91 09       	st.w	r8[0x0],r9
800085c0:	5e fc       	retal	r12
800085c2:	d7 03       	nop

800085c4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800085c4:	f8 08 16 05 	lsr	r8,r12,0x5
800085c8:	a9 78       	lsl	r8,0x9
800085ca:	e0 28 e0 00 	sub	r8,57344

	/* Enable the correct function. */
	switch (function) {
800085ce:	58 7b       	cp.w	r11,7
800085d0:	e0 88 00 03 	brls	800085d6 <gpio_enable_module_pin+0x12>
800085d4:	5e ff       	retal	1
800085d6:	4a 29       	lddpc	r9,8000865c <gpio_enable_module_pin+0x98>
800085d8:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
		gpio_port->pmr1c = 1 << (pin & 0x1F);
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;

	case 6: /* G function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800085dc:	30 19       	mov	r9,1
800085de:	f2 0c 09 4c 	lsl	r12,r9,r12
800085e2:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800085e4:	91 9c       	st.w	r8[0x24],r12
		gpio_port->pmr2s = 1 << (pin & 0x1F);
800085e6:	91 dc       	st.w	r8[0x34],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800085e8:	91 2c       	st.w	r8[0x8],r12
800085ea:	5e fd       	retal	0
		gpio_port->pmr1s = 1 << (pin & 0x1F);
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;

	case 7: /* H function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800085ec:	30 19       	mov	r9,1
800085ee:	f2 0c 09 4c 	lsl	r12,r9,r12
800085f2:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800085f4:	91 9c       	st.w	r8[0x24],r12
		gpio_port->pmr2s = 1 << (pin & 0x1F);
800085f6:	91 dc       	st.w	r8[0x34],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800085f8:	91 2c       	st.w	r8[0x8],r12
800085fa:	5e fd       	retal	0
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800085fc:	30 19       	mov	r9,1
800085fe:	f2 0c 09 4c 	lsl	r12,r9,r12
80008602:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80008604:	91 ac       	st.w	r8[0x28],r12
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80008606:	91 ec       	st.w	r8[0x38],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008608:	91 2c       	st.w	r8[0x8],r12
8000860a:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000860c:	30 19       	mov	r9,1
8000860e:	f2 0c 09 4c 	lsl	r12,r9,r12
80008612:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80008614:	91 ac       	st.w	r8[0x28],r12
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80008616:	91 ec       	st.w	r8[0x38],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008618:	91 2c       	st.w	r8[0x8],r12
8000861a:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000861c:	30 19       	mov	r9,1
8000861e:	f2 0c 09 4c 	lsl	r12,r9,r12
80008622:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008624:	91 9c       	st.w	r8[0x24],r12
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80008626:	91 ec       	st.w	r8[0x38],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008628:	91 2c       	st.w	r8[0x8],r12
8000862a:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000862c:	30 19       	mov	r9,1
8000862e:	f2 0c 09 4c 	lsl	r12,r9,r12
80008632:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80008634:	91 9c       	st.w	r8[0x24],r12
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80008636:	91 ec       	st.w	r8[0x38],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008638:	91 2c       	st.w	r8[0x8],r12
8000863a:	5e fd       	retal	0
#endif
		break;

#if (AVR32_GPIO_H_VERSION >= 210)
	case 4: /* E function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000863c:	30 19       	mov	r9,1
8000863e:	f2 0c 09 4c 	lsl	r12,r9,r12
80008642:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80008644:	91 ac       	st.w	r8[0x28],r12
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80008646:	91 dc       	st.w	r8[0x34],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008648:	91 2c       	st.w	r8[0x8],r12
8000864a:	5e fd       	retal	0
		gpio_port->pmr1c = 1 << (pin & 0x1F);
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;

	case 5: /* F function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000864c:	30 19       	mov	r9,1
8000864e:	f2 0c 09 4c 	lsl	r12,r9,r12
80008652:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80008654:	91 ac       	st.w	r8[0x28],r12
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80008656:	91 dc       	st.w	r8[0x34],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80008658:	91 2c       	st.w	r8[0x8],r12
8000865a:	5e fd       	retal	0
8000865c:	80 06       	ld.sh	r6,r0[0x0]
8000865e:	f3 d8       	*unknown*

80008660 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80008660:	d4 21       	pushm	r4-r7,lr
80008662:	18 97       	mov	r7,r12
80008664:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008666:	58 0b       	cp.w	r11,0
80008668:	c0 e0       	breq	80008684 <gpio_enable_module+0x24>
8000866a:	30 06       	mov	r6,0
8000866c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000866e:	6e 1b       	ld.w	r11,r7[0x4]
80008670:	6e 0c       	ld.w	r12,r7[0x0]
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008672:	2f f6       	sub	r6,-1
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
80008674:	2f 87       	sub	r7,-8
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80008676:	ca 7f       	rcall	800085c4 <gpio_enable_module_pin>
80008678:	18 45       	or	r5,r12
8000867a:	0c 34       	cp.w	r4,r6
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000867c:	fe 9b ff f9 	brhi	8000866e <gpio_enable_module+0xe>
80008680:	0a 9c       	mov	r12,r5
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80008682:	d8 22       	popm	r4-r7,pc
80008684:	16 95       	mov	r5,r11
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008686:	cf db       	rjmp	80008680 <gpio_enable_module+0x20>

80008688 <gpio_enable_gpio_pin>:
80008688:	30 18       	mov	r8,1
8000868a:	f0 0c 09 48 	lsl	r8,r8,r12
8000868e:	a5 9c       	lsr	r12,0x5
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008690:	a9 7c       	lsl	r12,0x9
80008692:	e0 2c e0 00 	sub	r12,57344
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80008696:	f9 48 00 48 	st.w	r12[72],r8
	gpio_port->gpers = 1 << (pin & 0x1F);
8000869a:	99 18       	st.w	r12[0x4],r8
}
8000869c:	5e fc       	retal	r12

8000869e <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000869e:	f8 08 16 05 	lsr	r8,r12,0x5
800086a2:	a9 78       	lsl	r8,0x9
800086a4:	e0 28 e0 00 	sub	r8,57344
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800086a8:	71 88       	ld.w	r8,r8[0x60]
800086aa:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800086ae:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800086b2:	5e fc       	retal	r12

800086b4 <gpio_set_gpio_pin>:
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800086b4:	30 18       	mov	r8,1
800086b6:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800086ba:	a5 9c       	lsr	r12,0x5
800086bc:	a9 7c       	lsl	r12,0x9
800086be:	e0 2c e0 00 	sub	r12,57344
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800086c2:	f9 48 00 54 	st.w	r12[84],r8
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800086c6:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800086ca:	99 18       	st.w	r12[0x4],r8
}
800086cc:	5e fc       	retal	r12

800086ce <gpio_clr_gpio_pin>:
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800086ce:	30 18       	mov	r8,1
800086d0:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800086d4:	a5 9c       	lsr	r12,0x5
800086d6:	a9 7c       	lsl	r12,0x9
800086d8:	e0 2c e0 00 	sub	r12,57344
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800086dc:	f9 48 00 58 	st.w	r12[88],r8
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800086e0:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800086e4:	99 18       	st.w	r12[0x4],r8
}
800086e6:	5e fc       	retal	r12

800086e8 <gpio_tgl_gpio_pin>:
void gpio_tgl_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
800086e8:	30 18       	mov	r8,1
800086ea:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_tgl_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800086ee:	a5 9c       	lsr	r12,0x5
800086f0:	a9 7c       	lsl	r12,0x9
800086f2:	e0 2c e0 00 	sub	r12,57344
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
800086f6:	f9 48 00 5c 	st.w	r12[92],r8
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800086fa:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800086fe:	99 18       	st.w	r12[0x4],r8
}
80008700:	5e fc       	retal	r12

80008702 <gpio_enable_pin_interrupt>:
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80008702:	30 1a       	mov	r10,1
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008704:	f8 08 16 05 	lsr	r8,r12,0x5

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80008708:	f4 0c 09 49 	lsl	r9,r10,r12
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000870c:	a9 78       	lsl	r8,0x9
8000870e:	e0 28 e0 00 	sub	r8,57344

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80008712:	f1 49 00 c4 	st.w	r8[196],r9
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80008716:	14 3b       	cp.w	r11,r10
80008718:	c0 c0       	breq	80008730 <gpio_enable_pin_interrupt+0x2e>
8000871a:	c0 82       	brcc	8000872a <gpio_enable_pin_interrupt+0x28>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
8000871c:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80008720:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80008724:	f1 49 00 94 	st.w	r8[148],r9
80008728:	5e fd       	retal	0
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8000872a:	58 2b       	cp.w	r11,2
8000872c:	c0 90       	breq	8000873e <gpio_enable_pin_interrupt+0x3c>
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1s = 1 << (pin & 0x1F);
8000872e:	5e fa       	retal	r10
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80008730:	f1 49 00 a4 	st.w	r8[164],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80008734:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80008738:	f1 49 00 94 	st.w	r8[148],r9
8000873c:	5e fd       	retal	0
		gpio_port->imr0s = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
8000873e:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1s = 1 << (pin & 0x1F);
80008742:	f1 49 00 b4 	st.w	r8[180],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80008746:	f1 49 00 94 	st.w	r8[148],r9
8000874a:	5e fd       	retal	0

8000874c <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000874c:	f8 08 16 05 	lsr	r8,r12,0x5
80008750:	a9 78       	lsl	r8,0x9
80008752:	e0 28 e0 00 	sub	r8,57344
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80008756:	f0 f8 00 d0 	ld.w	r8,r8[208]
8000875a:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000875e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80008762:	5e fc       	retal	r12

80008764 <gpio_clear_pin_interrupt_flag>:
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80008764:	30 18       	mov	r8,1
80008766:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000876a:	a5 9c       	lsr	r12,0x5
8000876c:	a9 7c       	lsl	r12,0x9
8000876e:	e0 2c e0 00 	sub	r12,57344
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80008772:	f9 48 00 d8 	st.w	r12[216],r8
#endif
}
80008776:	5e fc       	retal	r12

80008778 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80008778:	c0 08       	rjmp	80008778 <_unhandled_interrupt>
8000877a:	d7 03       	nop

8000877c <INTC_register_interrupt>:

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000877c:	f3 db c0 05 	bfextu	r9,r11,0x0,0x5
80008780:	49 b8       	lddpc	r8,800087ec <INTC_register_interrupt+0x70>
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80008782:	a5 9b       	lsr	r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80008784:	f0 0b 00 38 	add	r8,r8,r11<<0x3
80008788:	70 18       	ld.w	r8,r8[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000878a:	f0 09 09 2c 	st.w	r8[r9<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000878e:	58 0a       	cp.w	r10,0
80008790:	c1 00       	breq	800087b0 <INTC_register_interrupt+0x34>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	} else if (int_level == AVR32_INTC_INT1) {
80008792:	58 1a       	cp.w	r10,1
80008794:	c1 70       	breq	800087c2 <INTC_register_interrupt+0x46>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
	} else if (int_level == AVR32_INTC_INT2) {
80008796:	58 2a       	cp.w	r10,2
80008798:	c1 f0       	breq	800087d6 <INTC_register_interrupt+0x5a>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000879a:	49 69       	lddpc	r9,800087f0 <INTC_register_interrupt+0x74>
8000879c:	49 68       	lddpc	r8,800087f4 <INTC_register_interrupt+0x78>
8000879e:	f2 08 01 08 	sub	r8,r9,r8
800087a2:	fe 79 00 00 	mov	r9,-65536
800087a6:	ea 18 c0 00 	orh	r8,0xc000
800087aa:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800087ae:	5e fc       	retal	r12
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800087b0:	fe 78 00 00 	mov	r8,-65536
800087b4:	49 09       	lddpc	r9,800087f4 <INTC_register_interrupt+0x78>
800087b6:	49 1a       	lddpc	r10,800087f8 <INTC_register_interrupt+0x7c>
800087b8:	f4 09 01 09 	sub	r9,r10,r9
800087bc:	f0 0b 09 29 	st.w	r8[r11<<0x2],r9
800087c0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800087c2:	48 f9       	lddpc	r9,800087fc <INTC_register_interrupt+0x80>
800087c4:	48 c8       	lddpc	r8,800087f4 <INTC_register_interrupt+0x78>
800087c6:	f2 08 01 08 	sub	r8,r9,r8
800087ca:	fe 79 00 00 	mov	r9,-65536
800087ce:	bf a8       	sbr	r8,0x1e
800087d0:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800087d4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800087d6:	48 b9       	lddpc	r9,80008800 <INTC_register_interrupt+0x84>
800087d8:	48 78       	lddpc	r8,800087f4 <INTC_register_interrupt+0x78>
800087da:	f2 08 01 08 	sub	r8,r9,r8
800087de:	fe 79 00 00 	mov	r9,-65536
800087e2:	bf b8       	sbr	r8,0x1f
800087e4:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800087e8:	5e fc       	retal	r12
800087ea:	d7 03       	nop
800087ec:	80 06       	ld.sh	r6,r0[0x0]
800087ee:	f3 f8 80 01 	ld.wls	r8,r9[0x4]
800087f2:	cd 2e       	rcall	80008596 <flashc_set_bus_freq+0x2>
800087f4:	80 01       	ld.sh	r1,r0[0x0]
800087f6:	cc 00       	breq	80008776 <gpio_clear_pin_interrupt_flag+0x12>
800087f8:	80 01       	ld.sh	r1,r0[0x0]
800087fa:	cd 04       	brge	8000879a <INTC_register_interrupt+0x1e>
800087fc:	80 01       	ld.sh	r1,r0[0x0]
800087fe:	cd 12       	brcc	800087a0 <INTC_register_interrupt+0x24>
80008800:	80 01       	ld.sh	r1,r0[0x0]
80008802:	cd 20       	breq	800087a6 <INTC_register_interrupt+0x2a>

80008804 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80008804:	eb cd 40 e0 	pushm	r5-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80008808:	49 08       	lddpc	r8,80008848 <INTC_init_interrupts+0x44>
8000880a:	e3 b8 00 01 	mtsr	0x4,r8
8000880e:	49 05       	lddpc	r5,8000884c <INTC_init_interrupts+0x48>
80008810:	49 07       	lddpc	r7,80008850 <INTC_init_interrupts+0x4c>
80008812:	10 15       	sub	r5,r8
80008814:	30 0e       	mov	lr,0
80008816:	fe cc 00 9e 	sub	r12,pc,158

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000881a:	fe 76 00 00 	mov	r6,-65536

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000881e:	6e 0a       	ld.w	r10,r7[0x0]
80008820:	58 0a       	cp.w	r10,0
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80008822:	c0 90       	breq	80008834 <INTC_init_interrupts+0x30>
80008824:	30 08       	mov	r8,0
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80008826:	6e 1b       	ld.w	r11,r7[0x4]
80008828:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000882c:	2f f8       	sub	r8,-1
8000882e:	10 3a       	cp.w	r10,r8
80008830:	fe 9b ff fc 	brhi	80008828 <INTC_init_interrupts+0x24>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008834:	ec 0e 09 25 	st.w	r6[lr<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80008838:	2f 87       	sub	r7,-8
8000883a:	2f fe       	sub	lr,-1
8000883c:	e0 4e 00 2f 	cp.w	lr,47
80008840:	ce f1       	brne	8000881e <INTC_init_interrupts+0x1a>
80008842:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008846:	d7 03       	nop
80008848:	80 01       	ld.sh	r1,r0[0x0]
8000884a:	cc 00       	breq	800087ca <INTC_register_interrupt+0x4e>
8000884c:	80 01       	ld.sh	r1,r0[0x0]
8000884e:	cd 04       	brge	800087ee <INTC_register_interrupt+0x72>
80008850:	80 06       	ld.sh	r6,r0[0x0]
80008852:	f3 f8 e0 68 	ld.wqs	r8,r9[0x1a0]

80008854 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80008854:	e0 68 00 83 	mov	r8,131
80008858:	f0 0c 01 0c 	sub	r12,r8,r12
8000885c:	fe 78 00 00 	mov	r8,-65536
80008860:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80008864:	f2 ca ff c0 	sub	r10,r9,-64
80008868:	f0 0a 03 2c 	ld.w	r12,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000886c:	58 0c       	cp.w	r12,0
8000886e:	5e 0c       	reteq	r12
		? _int_handler_table[int_grp]._int_line_handler_table[32
80008870:	48 68       	lddpc	r8,80008888 <_get_interrupt_handler+0x34>
80008872:	f8 0c 12 00 	clz	r12,r12
80008876:	f0 09 00 39 	add	r9,r8,r9<<0x3
8000887a:	f8 0c 11 1f 	rsub	r12,r12,31
8000887e:	72 18       	ld.w	r8,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008880:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80008884:	5e fc       	retal	r12
80008886:	d7 03       	nop
80008888:	80 06       	ld.sh	r6,r0[0x0]
8000888a:	f3 f8 eb cd 	st.wqs	r9[0x734],r8

8000888c <scif_gc_setup>:
  return PASS;
}


long int scif_gc_setup(unsigned int gclk, scif_gcctrl_oscsel_t clk_src, unsigned int diven, unsigned int divfactor)
{
8000888c:	eb cd 40 c0 	pushm	r6-r7,lr
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
80008890:	fe 7e 08 00 	mov	lr,-63488
80008894:	f8 c8 ff e7 	sub	r8,r12,-25
80008898:	fc 08 03 2c 	ld.w	r12,lr[r8<<0x2]
{
  bool restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
8000889c:	a1 99       	lsr	r9,0x1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000889e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
{
  bool restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
800088a2:	20 19       	sub	r9,1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800088a4:	58 0c       	cp.w	r12,0
800088a6:	c1 21       	brne	800088ca <scif_gc_setup+0x3e>
    if(scif_stop_gclk(gclk) < 0)
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
800088a8:	a1 7a       	lsl	r10,0x1
800088aa:	a9 6b       	lsl	r11,0x8
800088ac:	e2 1a 00 02 	andl	r10,0x2,COH
800088b0:	e2 1b 0f 00 	andl	r11,0xf00,COH
800088b4:	b1 69       	lsl	r9,0x10
800088b6:	f5 eb 10 0b 	or	r11,r10,r11
800088ba:	e6 19 00 ff 	andh	r9,0xff,COH
800088be:	f7 e9 10 09 	or	r9,r11,r9
800088c2:	fc 08 09 29 	st.w	lr[r8<<0x2],r9
  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK ;

  return PASS;
}
800088c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
800088ca:	fc 08 03 2c 	ld.w	r12,lr[r8<<0x2]

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800088ce:	1c 96       	mov	r6,lr
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
800088d0:	a1 cc       	cbr	r12,0x0
800088d2:	fc 08 09 2c 	st.w	lr[r8<<0x2],r12
800088d6:	e0 7e 86 a0 	mov	lr,100000
800088da:	c0 38       	rjmp	800088e0 <scif_gc_setup+0x54>

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
  {
    if(--timeout == 0)
800088dc:	58 0e       	cp.w	lr,0
800088de:	c1 e0       	breq	8000891a <scif_gc_setup+0x8e>

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800088e0:	ec 08 03 2c 	ld.w	r12,r6[r8<<0x2]
  {
    if(--timeout == 0)
800088e4:	20 1e       	sub	lr,1

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800088e6:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800088ea:	fe 77 08 00 	mov	r7,-63488
800088ee:	cf 71       	brne	800088dc <scif_gc_setup+0x50>
    if(scif_stop_gclk(gclk) < 0)
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
800088f0:	a1 7a       	lsl	r10,0x1
800088f2:	a9 6b       	lsl	r11,0x8
800088f4:	e2 1a 00 02 	andl	r10,0x2,COH
800088f8:	e2 1b 0f 00 	andl	r11,0xf00,COH
800088fc:	b1 69       	lsl	r9,0x10
800088fe:	16 4a       	or	r10,r11
80008900:	e6 19 00 ff 	andh	r9,0xff,COH
80008904:	f5 e9 10 09 	or	r9,r10,r9
80008908:	ee 08 09 29 	st.w	r7[r8<<0x2],r9
                            |((diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
                            |((clk_src << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK);

  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK ;
8000890c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008910:	a1 a9       	sbr	r9,0x0
80008912:	ee 08 09 29 	st.w	r7[r8<<0x2],r9
80008916:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
  {
    if(--timeout == 0)
8000891a:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1

8000891e <scif_gc_enable>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, do nothing.
  if(!(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK))
8000891e:	2e 7c       	sub	r12,-25
80008920:	fe 78 08 00 	mov	r8,-63488
80008924:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
80008928:	ed b9 00 00 	bld	r9,0x0
8000892c:	c0 60       	breq	80008938 <scif_gc_enable+0x1a>
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK;
8000892e:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
80008932:	a1 a9       	sbr	r9,0x0
80008934:	f0 0c 09 29 	st.w	r8[r12<<0x2],r9

  return PASS;

}
80008938:	5e fd       	retal	0

8000893a <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000893a:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000893c:	f6 08 15 04 	lsl	r8,r11,0x4
80008940:	14 38       	cp.w	r8,r10
80008942:	e0 8b 00 26 	brhi	8000898e <usart_set_async_baudrate+0x54>
80008946:	31 0e       	mov	lr,16
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80008948:	f0 09 16 01 	lsr	r9,r8,0x1
8000894c:	f2 0a 00 39 	add	r9,r9,r10<<0x3
80008950:	f2 08 0d 08 	divu	r8,r9,r8
80008954:	10 99       	mov	r9,r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80008956:	a3 98       	lsr	r8,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80008958:	f0 cb 00 01 	sub	r11,r8,1
8000895c:	e0 4b ff fe 	cp.w	r11,65534
80008960:	e0 8b 00 1b 	brhi	80008996 <usart_set_async_baudrate+0x5c>
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80008964:	78 1a       	ld.w	r10,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80008966:	e8 6b 00 00 	mov	r11,524288
8000896a:	e4 1a ff f7 	andh	r10,0xfff7
8000896e:	e0 1a fe cf 	andl	r10,0xfecf
80008972:	59 0e       	cp.w	lr,16
80008974:	f6 0e 17 10 	movne	lr,r11
80008978:	f9 be 00 00 	moveq	lr,0
8000897c:	fd ea 10 0a 	or	r10,lr,r10
80008980:	99 1a       	st.w	r12[0x4],r10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80008982:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
80008986:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000898a:	99 88       	st.w	r12[0x20],r8
8000898c:	d8 0a       	popm	pc,r12=0
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000898e:	f6 08 15 03 	lsl	r8,r11,0x3
80008992:	30 8e       	mov	lr,8
80008994:	cd ab       	rjmp	80008948 <usart_set_async_baudrate+0xe>
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80008996:	da 0a       	popm	pc,r12=1

80008998 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80008998:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000899a:	ed b8 00 01 	bld	r8,0x1
8000899e:	c0 51       	brne	800089a8 <usart_write_char+0x10>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800089a0:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800089a4:	99 7b       	st.w	r12[0x1c],r11
800089a6:	5e fd       	retal	0
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800089a8:	30 2c       	mov	r12,2
800089aa:	5e fc       	retal	r12

800089ac <usart_getchar>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800089ac:	78 58       	ld.w	r8,r12[0x14]
800089ae:	e2 18 00 e0 	andl	r8,0xe0,COH
800089b2:	c0 20       	breq	800089b6 <usart_getchar+0xa>
800089b4:	5e fe       	retal	-1
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800089b6:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800089b8:	ed b8 00 00 	bld	r8,0x0
800089bc:	cf 81       	brne	800089ac <usart_getchar>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800089be:	78 6c       	ld.w	r12,r12[0x18]
800089c0:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9

  if (ret == USART_RX_ERROR)
    return USART_FAILURE;

  return c;
}
800089c4:	5e fc       	retal	r12

800089c6 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800089c6:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800089ca:	ed b8 00 10 	bld	r8,0x10
800089ce:	c0 c1       	brne	800089e6 <usart_reset+0x20>
  usart->idr = 0xFFFFFFFF;
800089d0:	3f f8       	mov	r8,-1
800089d2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800089d4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800089d6:	30 08       	mov	r8,0
800089d8:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800089da:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800089dc:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800089de:	ea 68 61 0c 	mov	r8,680204
800089e2:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800089e4:	5e fc       	retal	r12
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800089e6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800089e8:	3f f8       	mov	r8,-1
800089ea:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800089ec:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800089ee:	d5 03       	csrf	0x10
800089f0:	cf 3b       	rjmp	800089d6 <usart_reset+0x10>
800089f2:	d7 03       	nop

800089f4 <usart_init_rs232>:
              AVR32_USART_CR_RTSDIS_MASK;
}


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800089f4:	d4 21       	pushm	r4-r7,lr
800089f6:	16 97       	mov	r7,r11
800089f8:	14 94       	mov	r4,r10
800089fa:	18 96       	mov	r6,r12
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800089fc:	ce 5f       	rcall	800089c6 <usart_reset>
800089fe:	58 07       	cp.w	r7,0

  // Check input values.
  if (!opt || // Null pointer.
80008a00:	c2 00       	breq	80008a40 <usart_init_rs232+0x4c>
80008a02:	0f c8       	ld.ub	r8,r7[0x4]
      opt->charlength < 5 || opt->charlength > 9 ||
80008a04:	30 49       	mov	r9,4
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008a06:	f2 08 18 00 	cp.b	r8,r9
80008a0a:	e0 88 00 1b 	brls	80008a40 <usart_init_rs232+0x4c>
80008a0e:	30 95       	mov	r5,9
80008a10:	ea 08 18 00 	cp.b	r8,r5
80008a14:	e0 8b 00 16 	brhi	80008a40 <usart_init_rs232+0x4c>
80008a18:	0f d9       	ld.ub	r9,r7[0x5]
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80008a1a:	30 78       	mov	r8,7
80008a1c:	f0 09 18 00 	cp.b	r9,r8
80008a20:	e0 8b 00 10 	brhi	80008a40 <usart_init_rs232+0x4c>
80008a24:	8e 39       	ld.sh	r9,r7[0x6]
      opt->stopbits > 2 + 255 ||
80008a26:	e0 68 01 01 	mov	r8,257
80008a2a:	f0 09 19 00 	cp.h	r9,r8
80008a2e:	e0 8b 00 09 	brhi	80008a40 <usart_init_rs232+0x4c>
80008a32:	ef 39 00 08 	ld.ub	r9,r7[8]
      opt->channelmode > 3 ||
80008a36:	30 38       	mov	r8,3
80008a38:	f0 09 18 00 	cp.b	r9,r8
80008a3c:	e0 88 00 03 	brls	80008a42 <usart_init_rs232+0x4e>
80008a40:	da 2a       	popm	r4-r7,pc,r12=1
  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80008a42:	08 9a       	mov	r10,r4
  if (!opt || // Null pointer.
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80008a44:	6e 0b       	ld.w	r11,r7[0x0]
80008a46:	0c 9c       	mov	r12,r6
80008a48:	c7 9f       	rcall	8000893a <usart_set_async_baudrate>
80008a4a:	58 1c       	cp.w	r12,1
80008a4c:	cf a0       	breq	80008a40 <usart_init_rs232+0x4c>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008a4e:	0f c8       	ld.ub	r8,r7[0x4]
80008a50:	ea 08 18 00 	cp.b	r8,r5
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80008a54:	c2 90       	breq	80008aa6 <usart_init_rs232+0xb2>
80008a56:	6c 19       	ld.w	r9,r6[0x4]
80008a58:	20 58       	sub	r8,5
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80008a5a:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80008a5e:	8d 18       	st.w	r6[0x4],r8
80008a60:	6c 19       	ld.w	r9,r6[0x4]
80008a62:	ef 3a 00 08 	ld.ub	r10,r7[8]
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80008a66:	0f d8       	ld.ub	r8,r7[0x5]
80008a68:	a9 78       	lsl	r8,0x9
80008a6a:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80008a6e:	12 48       	or	r8,r9
80008a70:	8d 18       	st.w	r6[0x4],r8
80008a72:	30 29       	mov	r9,2
80008a74:	8e 38       	ld.sh	r8,r7[0x6]
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80008a76:	f2 08 19 00 	cp.h	r8,r9
80008a7a:	e0 88 00 10 	brls	80008a9a <usart_init_rs232+0xa6>
80008a7e:	6c 18       	ld.w	r8,r6[0x4]
80008a80:	ad b8       	sbr	r8,0xd
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80008a82:	8d 18       	st.w	r6[0x4],r8
80008a84:	8e b8       	ld.uh	r8,r7[0x6]
80008a86:	20 28       	sub	r8,2
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80008a88:	8d a8       	st.w	r6[0x28],r8
80008a8a:	6c 18       	ld.w	r8,r6[0x4]
80008a8c:	e0 18 ff f0 	andl	r8,0xfff0
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80008a90:	8d 18       	st.w	r6[0x4],r8
80008a92:	30 0c       	mov	r12,0
80008a94:	35 08       	mov	r8,80
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80008a96:	8d 08       	st.w	r6[0x0],r8
80008a98:	d8 22       	popm	r4-r7,pc
80008a9a:	6c 19       	ld.w	r9,r6[0x4]
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80008a9c:	5c 78       	castu.h	r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80008a9e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80008aa2:	8d 18       	st.w	r6[0x4],r8
80008aa4:	cf 3b       	rjmp	80008a8a <usart_init_rs232+0x96>
80008aa6:	6c 18       	ld.w	r8,r6[0x4]
80008aa8:	b1 b8       	sbr	r8,0x11
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80008aaa:	8d 18       	st.w	r6[0x4],r8
80008aac:	cd ab       	rjmp	80008a60 <usart_init_rs232+0x6c>
80008aae:	d7 03       	nop

80008ab0 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80008ab0:	48 cd       	lddpc	sp,80008ae0 <udata_clear_loop_end+0x2>

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
80008ab2:	48 d0       	lddpc	r0,80008ae4 <udata_clear_loop_end+0x6>
  mtsr    AVR32_EVBA, r0
80008ab4:	e3 b0 00 01 	mtsr	0x4,r0

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80008ab8:	d5 53       	csrf	0x15

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
80008aba:	48 c0       	lddpc	r0,80008ae8 <udata_clear_loop_end+0xa>
  lda.w   r1, _edata
80008abc:	48 c1       	lddpc	r1,80008aec <udata_clear_loop_end+0xe>
  cp      r0, r1
80008abe:	02 30       	cp.w	r0,r1
  brhs    idata_load_loop_end
80008ac0:	c0 62       	brcc	80008acc <idata_load_loop_end>
  lda.w   r2, _data_lma
80008ac2:	48 c2       	lddpc	r2,80008af0 <udata_clear_loop_end+0x12>

80008ac4 <idata_load_loop>:
idata_load_loop:
  ld.d    r4, r2++
80008ac4:	a5 05       	ld.d	r4,r2++
  st.d    r0++, r4
80008ac6:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80008ac8:	02 30       	cp.w	r0,r1
  brlo    idata_load_loop
80008aca:	cf d3       	brcs	80008ac4 <idata_load_loop>

80008acc <idata_load_loop_end>:
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80008acc:	48 a0       	lddpc	r0,80008af4 <udata_clear_loop_end+0x16>
  lda.w   r1, _end
80008ace:	48 b1       	lddpc	r1,80008af8 <udata_clear_loop_end+0x1a>
  cp      r0, r1
80008ad0:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80008ad2:	c0 62       	brcc	80008ade <udata_clear_loop_end>
  mov     r2, 0
80008ad4:	30 02       	mov	r2,0
  mov     r3, 0
80008ad6:	30 03       	mov	r3,0

80008ad8 <udata_clear_loop>:
udata_clear_loop:
  st.d    r0++, r2
80008ad8:	a1 22       	st.d	r0++,r2
  cp      r0, r1
80008ada:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80008adc:	cf e3       	brcs	80008ad8 <udata_clear_loop>

80008ade <udata_clear_loop_end>:
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80008ade:	48 8f       	lddpc	pc,80008afc <udata_clear_loop_end+0x1e>
80008ae0:	00 01       	add	r1,r0
80008ae2:	00 00       	add	r0,r0
80008ae4:	80 01       	ld.sh	r1,r0[0x0]
80008ae6:	cc 00       	breq	80008a66 <usart_init_rs232+0x72>
80008ae8:	00 00       	add	r0,r0
80008aea:	00 08       	add	r8,r0
80008aec:	00 00       	add	r0,r0
80008aee:	05 b0       	ld.ub	r0,r2[0x3]
80008af0:	80 07       	ld.sh	r7,r0[0x0]
80008af2:	0f a8       	ld.ub	r8,r7[0x2]
80008af4:	00 00       	add	r0,r0
80008af6:	05 b0       	ld.ub	r0,r2[0x3]
80008af8:	00 00       	add	r0,r0
80008afa:	4f 78       	lddpc	r8,80008cd4 <MsgNIStateNetInit+0x28>
80008afc:	80 01       	ld.sh	r1,r0[0x0]
80008afe:	63 e0       	ld.w	r0,r1[0x78]

80008b00 <osc_priv_enable_osc0>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80008b00:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80008b04:	d3 03       	ssrf	0x10
void osc_priv_enable_osc0(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL;
80008b06:	fe 79 08 00 	mov	r9,-63488
80008b0a:	32 4a       	mov	r10,36
80008b0c:	ea 1a aa 00 	orh	r10,0xaa00
80008b10:	93 6a       	st.w	r9[0x18],r10
	AVR32_SCIF.oscctrl[0] =
80008b12:	e0 7a 0c 07 	mov	r10,68615
80008b16:	93 9a       	st.w	r9[0x24],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80008b18:	ed b8 00 10 	bld	r8,0x10
80008b1c:	c0 20       	breq	80008b20 <osc_priv_enable_osc0+0x20>
      cpu_irq_enable();
80008b1e:	d5 03       	csrf	0x10
			(OSC0_STARTUP_VALUE << AVR32_SCIF_OSCCTRL_STARTUP)
			| (OSC0_GAIN_VALUE << AVR32_SCIF_OSCCTRL_GAIN)
			| (OSC0_MODE_VALUE << AVR32_SCIF_OSCCTRL_MODE)
			| (1U << AVR32_SCIF_OSCCTRL_OSCEN);
	cpu_irq_restore(flags);
}
80008b20:	5e fc       	retal	r12

80008b22 <sysclk_set_source>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80008b22:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80008b26:	d3 03       	ssrf	0x10
	irqflags_t flags;

	Assert(src <= SYSCLK_SRC_RC120M);

	flags = cpu_irq_save();
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_MCCTRL;
80008b28:	fe 79 04 00 	mov	r9,-64512
80008b2c:	fc 1a aa 00 	movh	r10,0xaa00
80008b30:	f3 4a 00 58 	st.w	r9[88],r10
	AVR32_PM.mcctrl = src;
80008b34:	93 0c       	st.w	r9[0x0],r12
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80008b36:	ed b8 00 10 	bld	r8,0x10
80008b3a:	c0 20       	breq	80008b3e <sysclk_set_source+0x1c>
      cpu_irq_enable();
80008b3c:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80008b3e:	5e fc       	retal	r12

80008b40 <sysclk_priv_enable_module>:
 * \param bus_id Bus index, given by the \c AVR32_PM_CLK_GRP_xxx definitions.
 * \param module_index Index of the module to be enabled. This is the
 * bit number in the corresponding xxxMASK register.
 */
void sysclk_priv_enable_module(unsigned int bus_id, unsigned int module_index)
{
80008b40:	d4 01       	pushm	lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80008b42:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80008b46:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
	AVR32_PM.unlock = 0xaa000020 + (4 * bus_id);
80008b48:	fe 7a 04 00 	mov	r10,-64512
	uint32_t   mask;

	flags = cpu_irq_save();

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80008b4c:	a3 6c       	lsl	r12,0x2
	mask |= 1U << module_index;
	AVR32_PM.unlock = 0xaa000020 + (4 * bus_id);
80008b4e:	32 0e       	mov	lr,32
80008b50:	ea 1e aa 00 	orh	lr,0xaa00
80008b54:	f8 0e 00 0e 	add	lr,r12,lr
	uint32_t   mask;

	flags = cpu_irq_save();

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80008b58:	e0 2c fb e0 	sub	r12,64480
80008b5c:	78 09       	ld.w	r9,r12[0x0]
	mask |= 1U << module_index;
	AVR32_PM.unlock = 0xaa000020 + (4 * bus_id);
80008b5e:	f5 4e 00 58 	st.w	r10[88],lr

	flags = cpu_irq_save();

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
80008b62:	30 1a       	mov	r10,1
80008b64:	f4 0b 09 4b 	lsl	r11,r10,r11
80008b68:	12 4b       	or	r11,r9
	AVR32_PM.unlock = 0xaa000020 + (4 * bus_id);
	*(&AVR32_PM.cpumask + bus_id) = mask;
80008b6a:	99 0b       	st.w	r12[0x0],r11
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80008b6c:	ed b8 00 10 	bld	r8,0x10
80008b70:	c0 20       	breq	80008b74 <sysclk_priv_enable_module+0x34>
      cpu_irq_enable();
80008b72:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80008b74:	d8 02       	popm	pc
80008b76:	d7 03       	nop

80008b78 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE


void sysclk_init(void)
{
80008b78:	d4 01       	pushm	lr
static inline void osc_enable(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		osc_priv_enable_osc0();
80008b7a:	cc 3f       	rcall	80008b00 <osc_priv_enable_osc0>
80008b7c:	fe 79 08 00 	mov	r9,-63488
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC0RDY));
80008b80:	72 58       	ld.w	r8,r9[0x14]
80008b82:	ed b8 00 00 	bld	r8,0x0
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80008b86:	cf d1       	brne	80008b80 <sysclk_init+0x8>
80008b88:	e0 6c 24 00 	mov	r12,9216
#ifdef BOARD_OSC0_HZ
	case SYSCLK_SRC_OSC0:
		osc_enable(OSC_ID_OSC0);
		osc_wait_ready(OSC_ID_OSC0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(BOARD_OSC0_HZ);
80008b8c:	ea 1c 00 f4 	orh	r12,0xf4
80008b90:	fe b0 fd 02 	rcall	80008594 <flashc_set_bus_freq>
80008b94:	30 1c       	mov	r12,1
		sysclk_set_source(SYSCLK_SRC_OSC0);
80008b96:	cc 6f       	rcall	80008b22 <sysclk_set_source>
80008b98:	d8 02       	popm	pc
80008b9a:	d7 03       	nop

80008b9c <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008b9c:	eb cd 40 f8 	pushm	r3-r7,lr
80008ba0:	16 97       	mov	r7,r11
80008ba2:	14 95       	mov	r5,r10
	int nChars = 0;

	if (file != 0) {
80008ba4:	58 0c       	cp.w	r12,0
80008ba6:	c1 51       	brne	80008bd0 <_read+0x34>
		return -1;
	}

	for (; len > 0; --len) {
80008ba8:	58 0a       	cp.w	r10,0
80008baa:	e0 8a 00 11 	brle	80008bcc <_read+0x30>
80008bae:	18 96       	mov	r6,r12
80008bb0:	48 93       	lddpc	r3,80008bd4 <_read+0x38>
80008bb2:	48 a4       	lddpc	r4,80008bd8 <_read+0x3c>
		ptr_get(stdio_base, ptr);
80008bb4:	ee 06 00 0b 	add	r11,r7,r6
80008bb8:	68 08       	ld.w	r8,r4[0x0]
80008bba:	66 0c       	ld.w	r12,r3[0x0]
80008bbc:	5d 18       	icall	r8
		ptr++;
		nChars++;
80008bbe:	2f f6       	sub	r6,-1

int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
80008bc0:	ea 06 01 08 	sub	r8,r5,r6

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
80008bc4:	58 08       	cp.w	r8,0
80008bc6:	fe 99 ff f7 	brgt	80008bb4 <_read+0x18>
80008bca:	0a 9c       	mov	r12,r5
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
80008bcc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
80008bd0:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1
80008bd4:	00 00       	add	r0,r0
80008bd6:	42 20       	lddsp	r0,sp[0x88]
80008bd8:	00 00       	add	r0,r0
80008bda:	42 18       	lddsp	r8,sp[0x84]

80008bdc <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
80008bdc:	eb cd 40 f8 	pushm	r3-r7,lr
80008be0:	16 97       	mov	r7,r11
80008be2:	14 95       	mov	r5,r10
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
80008be4:	20 1c       	sub	r12,1
80008be6:	58 2c       	cp.w	r12,2
80008be8:	e0 8b 00 11 	brhi	80008c0a <_write+0x2e>
		return -1;
	}

	for (; len != 0; --len) {
80008bec:	58 0a       	cp.w	r10,0
80008bee:	c1 20       	breq	80008c12 <_write+0x36>
80008bf0:	30 06       	mov	r6,0
80008bf2:	48 a3       	lddpc	r3,80008c18 <_write+0x3c>
80008bf4:	48 a4       	lddpc	r4,80008c1c <_write+0x40>
80008bf6:	c0 38       	rjmp	80008bfc <_write+0x20>
80008bf8:	0c 35       	cp.w	r5,r6
80008bfa:	c0 90       	breq	80008c0c <_write+0x30>
		if (ptr_put(stdio_base, *ptr++) < 0) {
80008bfc:	ee 06 07 0b 	ld.ub	r11,r7[r6]
80008c00:	66 0c       	ld.w	r12,r3[0x0]
			return -1;
		}
		++nChars;
80008c02:	2f f6       	sub	r6,-1
	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
80008c04:	68 08       	ld.w	r8,r4[0x0]
80008c06:	5d 18       	icall	r8
80008c08:	cf 84       	brge	80008bf8 <_write+0x1c>

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
80008c0a:	3f f6       	mov	r6,-1
			return -1;
		}
		++nChars;
	}
	return nChars;
}
80008c0c:	0c 9c       	mov	r12,r6
80008c0e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
80008c12:	14 96       	mov	r6,r10
80008c14:	cf cb       	rjmp	80008c0c <_write+0x30>
80008c16:	d7 03       	nop
80008c18:	00 00       	add	r0,r0
80008c1a:	42 20       	lddsp	r0,sp[0x88]
80008c1c:	00 00       	add	r0,r0
80008c1e:	42 1c       	lddsp	r12,sp[0x84]

80008c20 <MsgBcdToStr>:
    T_API_ENTRY(AMS_43);

    num = 0;

    digit1 = (bcd >> 4) & 0x0F;
    digit2 = bcd &0x0F;
80008c20:	f5 db c0 04 	bfextu	r10,r11,0x0,0x4

    /* allow only digits in the range of 0..9 */
    digit1 = (digit1 <= 9) ? digit1 : 0;
80008c24:	30 98       	mov	r8,9

    T_API_ENTRY(AMS_43);

    num = 0;

    digit1 = (bcd >> 4) & 0x0F;
80008c26:	f7 db c0 88 	bfextu	r11,r11,0x4,0x8
    digit2 = bcd &0x0F;

    /* allow only digits in the range of 0..9 */
    digit1 = (digit1 <= 9) ? digit1 : 0;
    digit2 = (digit2 <= 9) ? digit2 : 0;
80008c2a:	f0 0a 18 00 	cp.b	r10,r8
80008c2e:	f9 ba 0b 30 	movhi	r10,48
80008c32:	f7 ba 08 d0 	subls	r10,-48
  *                         after encoding the respective data field.
  * \param[in]  bcd         The BCD coded number
  * \return                 the number of copied bytes
  */
byte MsgBcdToStr(byte** tgt_ptr_ptr, byte bcd)
{
80008c36:	18 99       	mov	r9,r12

    digit1 = (bcd >> 4) & 0x0F;
    digit2 = bcd &0x0F;

    /* allow only digits in the range of 0..9 */
    digit1 = (digit1 <= 9) ? digit1 : 0;
80008c38:	f6 08 18 00 	cp.b	r8,r11
80008c3c:	f9 bb 03 00 	movlo	r11,0
    digit2 = (digit2 <= 9) ? digit2 : 0;

    /* no leading zero */
    if (0 != digit1)
80008c40:	58 0b       	cp.w	r11,0
80008c42:	c0 90       	breq	80008c54 <MsgBcdToStr+0x34>
    {
        *((*tgt_ptr_ptr)++) = digit1 + (byte)0x30;
80008c44:	78 08       	ld.w	r8,r12[0x0]
80008c46:	2d 0b       	sub	r11,-48
80008c48:	10 cb       	st.b	r8++,r11
80008c4a:	99 08       	st.w	r12[0x0],r8
        ++num;
    }

    *((*tgt_ptr_ptr)++) = digit2 + (byte)0x30;
80008c4c:	10 ca       	st.b	r8++,r10
    digit2 = (digit2 <= 9) ? digit2 : 0;

    /* no leading zero */
    if (0 != digit1)
    {
        *((*tgt_ptr_ptr)++) = digit1 + (byte)0x30;
80008c4e:	30 2c       	mov	r12,2
        ++num;
    }

    *((*tgt_ptr_ptr)++) = digit2 + (byte)0x30;
80008c50:	93 08       	st.w	r9[0x0],r8
    ++num;

    T_API_EXIT(AMS_43);

    return(num);
}
80008c52:	5e fc       	retal	r12
    /* allow only digits in the range of 0..9 */
    digit1 = (digit1 <= 9) ? digit1 : 0;
    digit2 = (digit2 <= 9) ? digit2 : 0;

    /* no leading zero */
    if (0 != digit1)
80008c54:	78 08       	ld.w	r8,r12[0x0]
80008c56:	30 1c       	mov	r12,1
    {
        *((*tgt_ptr_ptr)++) = digit1 + (byte)0x30;
        ++num;
    }

    *((*tgt_ptr_ptr)++) = digit2 + (byte)0x30;
80008c58:	10 ca       	st.b	r8++,r10
80008c5a:	93 08       	st.w	r9[0x0],r8
    ++num;

    T_API_EXIT(AMS_43);

    return(num);
}
80008c5c:	5e fc       	retal	r12
80008c5e:	d7 03       	nop

80008c60 <MsgVersionToISO8859>:
  * \param[out] version     Pointer to an array containing the version number
  * \param[in]  string      Pointer to the result string
  * \return     The length of the result string
  */
byte MsgVersionToISO8859(byte* version, byte *string)
{
80008c60:	eb cd 40 f8 	pushm	r3-r7,lr
80008c64:	20 1d       	sub	sp,4
80008c66:	fa c7 ff fc 	sub	r7,sp,-4

    T_API_ENTRY(AMS_44);

    num = 0;

    num = MsgBcdToStr(&string, *version++);     /* first number */
80008c6a:	f8 c6 ff ff 	sub	r6,r12,-1
  * \param[out] version     Pointer to an array containing the version number
  * \param[in]  string      Pointer to the result string
  * \return     The length of the result string
  */
byte MsgVersionToISO8859(byte* version, byte *string)
{
80008c6e:	0e db       	st.w	--r7,r11

    T_API_ENTRY(AMS_44);

    num = 0;

    num = MsgBcdToStr(&string, *version++);     /* first number */
80008c70:	19 8b       	ld.ub	r11,r12[0x0]
80008c72:	1a 9c       	mov	r12,sp
80008c74:	cd 6f       	rcall	80008c20 <MsgBcdToStr>
80008c76:	40 08       	lddsp	r8,sp[0x0]
    *string++ = (byte)('.');
80008c78:	18 93       	mov	r3,r12

    T_API_ENTRY(AMS_44);

    num = 0;

    num = MsgBcdToStr(&string, *version++);     /* first number */
80008c7a:	32 e5       	mov	r5,46
    *string++ = (byte)('.');
80008c7c:	1a 9c       	mov	r12,sp
    num++;

    num += MsgBcdToStr(&string, *version++);    /* second number */
80008c7e:	10 c5       	st.b	r8++,r5
    T_API_ENTRY(AMS_44);

    num = 0;

    num = MsgBcdToStr(&string, *version++);     /* first number */
    *string++ = (byte)('.');
80008c80:	50 08       	stdsp	sp[0x0],r8
80008c82:	0d 8b       	ld.ub	r11,r6[0x0]
    num++;

    num += MsgBcdToStr(&string, *version++);    /* second number */
80008c84:	cc ef       	rcall	80008c20 <MsgBcdToStr>
80008c86:	40 08       	lddsp	r8,sp[0x0]
80008c88:	18 94       	mov	r4,r12
    *string++ = (byte)('.');
80008c8a:	10 c5       	st.b	r8++,r5

    num = MsgBcdToStr(&string, *version++);     /* first number */
    *string++ = (byte)('.');
    num++;

    num += MsgBcdToStr(&string, *version++);    /* second number */
80008c8c:	1a 9c       	mov	r12,sp
    *string++ = (byte)('.');
80008c8e:	50 08       	stdsp	sp[0x0],r8
    num++;

    num += MsgBcdToStr(&string, *version++);    /* third number */
80008c90:	0d 9b       	ld.ub	r11,r6[0x1]
    num = MsgBcdToStr(&string, *version++);     /* first number */
    *string++ = (byte)('.');
    num++;

    num += MsgBcdToStr(&string, *version++);    /* second number */
    *string++ = (byte)('.');
80008c92:	cc 7f       	rcall	80008c20 <MsgBcdToStr>
    num++;

    num += MsgBcdToStr(&string, *version++);    /* third number */
80008c94:	e6 04 00 04 	add	r4,r3,r4
80008c98:	30 09       	mov	r9,0
    *string++ = (byte)('.');
    num++;

    num += MsgBcdToStr(&string, *version++);    /* second number */
    *string++ = (byte)('.');
    num++;
80008c9a:	2f d4       	sub	r4,-3
80008c9c:	40 08       	lddsp	r8,sp[0x0]

    num += MsgBcdToStr(&string, *version++);    /* third number */
    *string = (byte)('\0');
80008c9e:	e8 0c 00 0c 	add	r12,r4,r12
80008ca2:	b0 89       	st.b	r8[0x0],r9

    num += MsgBcdToStr(&string, *version++);    /* second number */
    *string++ = (byte)('.');
    num++;

    num += MsgBcdToStr(&string, *version++);    /* third number */
80008ca4:	5c 5c       	castu.b	r12
80008ca6:	2f fd       	sub	sp,-4
    *string = (byte)('\0');
80008ca8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

80008cac <MsgNIStateNetInit>:
    num++;

    T_API_EXIT(AMS_44);

    return(num);
}
80008cac:	eb cd 40 e0 	pushm	r5-r7,lr
80008cb0:	48 b7       	lddpc	r7,80008cdc <MsgNIStateNetInit+0x30>
80008cb2:	30 05       	mov	r5,0
80008cb4:	ef 08 00 12 	ld.sh	r8,r7[18]
{
    HMBMBUF handle;

    T_LIB_ENTRY(AMS_53);

    while ((word)0 != MbmQueueLength(&(msg.rx_queue)))
80008cb8:	ea 08 19 00 	cp.h	r8,r5
80008cbc:	c0 d0       	breq	80008cd6 <MsgNIStateNetInit+0x2a>
    {
        handle = MbmDequeue(&(msg.rx_queue));
80008cbe:	ee c6 ff f8 	sub	r6,r7,-8
80008cc2:	0c 9c       	mov	r12,r6
80008cc4:	e0 a0 0a 1a 	rcall	8000a0f8 <MbmDequeue>
        MbmFree(handle);
80008cc8:	e0 a0 21 48 	rcall	8000cf58 <MbmFree>
{
    HMBMBUF handle;

    T_LIB_ENTRY(AMS_53);

    while ((word)0 != MbmQueueLength(&(msg.rx_queue)))
80008ccc:	ef 08 00 12 	ld.sh	r8,r7[18]
80008cd0:	ea 08 19 00 	cp.h	r8,r5
80008cd4:	cf 71       	brne	80008cc2 <MsgNIStateNetInit+0x16>
80008cd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008cda:	d7 03       	nop
80008cdc:	00 00       	add	r0,r0
80008cde:	2d 8c       	sub	r12,-40

80008ce0 <MsgRxError>:
80008ce0:	eb cd 40 c0 	pushm	r6-r7,lr
80008ce4:	18 96       	mov	r6,r12
80008ce6:	16 97       	mov	r7,r11
#ifdef AMS_12
void MsgRxError(byte error, TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(AMS_12);

    ASSERT(msg_ptr);
80008ce8:	58 0b       	cp.w	r11,0
80008cea:	c0 b0       	breq	80008d00 <MsgRxError+0x20>

    if (NULL != msg.cfg_ptr->rx_error_fptr)
80008cec:	48 a8       	lddpc	r8,80008d14 <MsgRxError+0x34>
80008cee:	70 98       	ld.w	r8,r8[0x24]
80008cf0:	70 38       	ld.w	r8,r8[0xc]
80008cf2:	58 08       	cp.w	r8,0
80008cf4:	c0 40       	breq	80008cfc <MsgRxError+0x1c>
    {
        msg.cfg_ptr->rx_error_fptr(error, msg_ptr);
80008cf6:	0e 9b       	mov	r11,r7
80008cf8:	0c 9c       	mov	r12,r6
80008cfa:	5d 18       	icall	r8
80008cfc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef AMS_12
void MsgRxError(byte error, TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(AMS_12);

    ASSERT(msg_ptr);
80008d00:	e0 68 03 a0 	mov	r8,928
80008d04:	30 1a       	mov	r10,1
80008d06:	1a d8       	st.w	--sp,r8
80008d08:	31 0b       	mov	r11,16
80008d0a:	30 8c       	mov	r12,8
80008d0c:	fe b0 f6 f0 	rcall	80007aec <mns_trace>
80008d10:	2f fd       	sub	sp,-4
80008d12:	ce db       	rjmp	80008cec <MsgRxError+0xc>
80008d14:	00 00       	add	r0,r0
80008d16:	2d 8c       	sub	r12,-40

80008d18 <MsgHandleRetryError>:
80008d18:	eb cd 40 80 	pushm	r7,lr
}
#endif

#ifdef AMS_49
void MsgHandleRetryError(TMsgRx *msg_ptr)
{
80008d1c:	18 97       	mov	r7,r12
    T_LIB_ENTRY(AMS_49);
    ASSERT(msg_ptr);
80008d1e:	58 0c       	cp.w	r12,0
80008d20:	c2 80       	breq	80008d70 <MsgHandleRetryError+0x58>

    if (FUNC_RETRYPARAMETERS == msg_ptr->Func_ID)
80008d22:	8e 49       	ld.sh	r9,r7[0x8]
80008d24:	30 78       	mov	r8,7
80008d26:	f0 09 19 00 	cp.h	r9,r8
80008d2a:	c1 00       	breq	80008d4a <MsgHandleRetryError+0x32>
    }
    else
    {
        /* not possible - the INIC.RetryOptions are not */
        /* changed by the MOST NetServices              */
        FAILED_ASSERT();
80008d2c:	e0 68 07 1b 	mov	r8,1819
80008d30:	30 1a       	mov	r10,1
80008d32:	1a d8       	st.w	--sp,r8
80008d34:	31 0b       	mov	r11,16
80008d36:	30 8c       	mov	r12,8
80008d38:	fe b0 f6 da 	rcall	80007aec <mns_trace>
80008d3c:	2f fd       	sub	sp,-4
    }

    MnsReportError(NSR_E_INVALID_RETRY_CONFIG);
80008d3e:	e0 6c c0 02 	mov	r12,49154
80008d42:	e0 a0 13 6b 	rcall	8000b418 <MnsReportError>

    T_LIB_EXIT(AMS_49);
}
80008d46:	e3 cd 80 80 	ldm	sp++,r7,pc
    T_LIB_ENTRY(AMS_49);
    ASSERT(msg_ptr);

    if (FUNC_RETRYPARAMETERS == msg_ptr->Func_ID)
    {
        TAKE_MSG();
80008d4a:	30 bc       	mov	r12,11
80008d4c:	fe b0 f6 b5 	rcall	80007ab6 <mns_take>
        msg.retry_cfg.busy           = MNS_FALSE;
80008d50:	30 09       	mov	r9,0
80008d52:	48 d8       	lddpc	r8,80008d84 <MsgHandleRetryError+0x6c>
80008d54:	f1 69 00 2d 	st.b	r8[45],r9
        msg.retry_cfg.total_attempts = msg.retry_cfg.shadow.total_attempts;
80008d58:	f1 39 00 2f 	ld.ub	r9,r8[47]
80008d5c:	f1 69 00 2c 	st.b	r8[44],r9
        msg.retry_cfg.time           = msg.retry_cfg.shadow.time;
80008d60:	f1 39 00 2e 	ld.ub	r9,r8[46]
        GIVE_MSG();
80008d64:	30 bc       	mov	r12,11
    if (FUNC_RETRYPARAMETERS == msg_ptr->Func_ID)
    {
        TAKE_MSG();
        msg.retry_cfg.busy           = MNS_FALSE;
        msg.retry_cfg.total_attempts = msg.retry_cfg.shadow.total_attempts;
        msg.retry_cfg.time           = msg.retry_cfg.shadow.time;
80008d66:	f1 69 00 2b 	st.b	r8[43],r9
        GIVE_MSG();
80008d6a:	fe b0 f6 a7 	rcall	80007ab8 <mns_give>
80008d6e:	ce 8b       	rjmp	80008d3e <MsgHandleRetryError+0x26>

#ifdef AMS_49
void MsgHandleRetryError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(AMS_49);
    ASSERT(msg_ptr);
80008d70:	e0 68 07 0d 	mov	r8,1805
80008d74:	30 1a       	mov	r10,1
80008d76:	1a d8       	st.w	--sp,r8
80008d78:	31 0b       	mov	r11,16
80008d7a:	30 8c       	mov	r12,8
80008d7c:	fe b0 f6 b8 	rcall	80007aec <mns_trace>
80008d80:	2f fd       	sub	sp,-4
80008d82:	cd 0b       	rjmp	80008d22 <MsgHandleRetryError+0xa>
80008d84:	00 00       	add	r0,r0
80008d86:	2d 8c       	sub	r12,-40

80008d88 <MsgHandleAbilityToSegmentError>:
80008d88:	d4 01       	pushm	lr
80008d8a:	e0 6c c4 01 	mov	r12,50177
80008d8e:	e0 a0 13 45 	rcall	8000b418 <MnsReportError>
80008d92:	d8 02       	popm	pc

80008d94 <MsgGetSegMode>:
80008d94:	eb cd 40 80 	pushm	r7,lr

    T_API_ENTRY(AMS_31);

    result = INIC_SHADOW_INVALID_BYTE;

    if (EHCISTATE_IS_ATTACHED())
80008d98:	e0 a0 10 ac 	rcall	8000aef0 <MnsGetEHCIState>
80008d9c:	30 28       	mov	r8,2
80008d9e:	f0 0c 18 00 	cp.b	r12,r8
80008da2:	c0 60       	breq	80008dae <MsgGetSegMode+0x1a>
80008da4:	e0 67 00 ee 	mov	r7,238
    }

    T_API_EXIT(AMS_31);

    return(result);
}
80008da8:	0e 9c       	mov	r12,r7
80008daa:	e3 cd 80 80 	ldm	sp++,r7,pc

    result = INIC_SHADOW_INVALID_BYTE;

    if (EHCISTATE_IS_ATTACHED())
    {
        TAKE_MSG();
80008dae:	30 bc       	mov	r12,11
80008db0:	fe b0 f6 83 	rcall	80007ab6 <mns_take>
        if (msg.seg.ats.value == msg.seg.ats.shadow)
80008db4:	48 a8       	lddpc	r8,80008ddc <MsgGetSegMode+0x48>
80008db6:	f1 3a 00 28 	ld.ub	r10,r8[40]
80008dba:	f1 39 00 29 	ld.ub	r9,r8[41]
80008dbe:	f2 0a 18 00 	cp.b	r10,r9
80008dc2:	c0 90       	breq	80008dd4 <MsgGetSegMode+0x40>
80008dc4:	e0 67 00 ee 	mov	r7,238
        {
            result = msg.seg.mode;
        }
        GIVE_MSG();
80008dc8:	30 bc       	mov	r12,11
80008dca:	fe b0 f6 77 	rcall	80007ab8 <mns_give>
    }

    T_API_EXIT(AMS_31);

    return(result);
}
80008dce:	0e 9c       	mov	r12,r7
80008dd0:	e3 cd 80 80 	ldm	sp++,r7,pc
    if (EHCISTATE_IS_ATTACHED())
    {
        TAKE_MSG();
        if (msg.seg.ats.value == msg.seg.ats.shadow)
        {
            result = msg.seg.mode;
80008dd4:	f1 37 00 2a 	ld.ub	r7,r8[42]
80008dd8:	cf 8b       	rjmp	80008dc8 <MsgGetSegMode+0x34>
80008dda:	d7 03       	nop
80008ddc:	00 00       	add	r0,r0
80008dde:	2d 8c       	sub	r12,-40

80008de0 <MsgHandleMidLevelRetriesStatus>:
80008de0:	eb cd 40 80 	pushm	r7,lr
80008de4:	18 97       	mov	r7,r12
80008de6:	58 0c       	cp.w	r12,0
80008de8:	c1 80       	breq	80008e18 <MsgHandleMidLevelRetriesStatus+0x38>
80008dea:	30 bc       	mov	r12,11
{
    T_LIB_ENTRY(AMS_37);

    ASSERT(msg_ptr);

    TAKE_MSG();
80008dec:	fe b0 f6 65 	rcall	80007ab6 <mns_take>
    msg.mid_level_retries = msg_ptr->Data[2];
80008df0:	6e 08       	ld.w	r8,r7[0x0]
80008df2:	11 a9       	ld.ub	r9,r8[0x2]
80008df4:	48 e8       	lddpc	r8,80008e2c <MsgHandleMidLevelRetriesStatus+0x4c>
    GIVE_MSG();
80008df6:	30 bc       	mov	r12,11
    T_LIB_ENTRY(AMS_37);

    ASSERT(msg_ptr);

    TAKE_MSG();
    msg.mid_level_retries = msg_ptr->Data[2];
80008df8:	f1 69 00 30 	st.b	r8[48],r9
    GIVE_MSG();
80008dfc:	fe b0 f6 5e 	rcall	80007ab8 <mns_give>

    if (!EHCISTATE_IS_ATTACHED())
80008e00:	e0 a0 10 78 	rcall	8000aef0 <MnsGetEHCIState>
80008e04:	30 28       	mov	r8,2
80008e06:	f0 0c 18 00 	cp.b	r12,r8
80008e0a:	c0 50       	breq	80008e14 <MsgHandleMidLevelRetriesStatus+0x34>
    {
        MnsNtfCheck(NTF_MIDLEVELRETRY);
80008e0c:	e8 6c 00 00 	mov	r12,524288
80008e10:	e0 a0 10 2e 	rcall	8000ae6c <MnsNtfCheck>
80008e14:	e3 cd 80 80 	ldm	sp++,r7,pc
#ifdef AMS_37
void MsgHandleMidLevelRetriesStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(AMS_37);

    ASSERT(msg_ptr);
80008e18:	e0 68 05 9c 	mov	r8,1436
80008e1c:	30 1a       	mov	r10,1
80008e1e:	1a d8       	st.w	--sp,r8
80008e20:	31 0b       	mov	r11,16
80008e22:	30 8c       	mov	r12,8
80008e24:	fe b0 f6 64 	rcall	80007aec <mns_trace>
80008e28:	2f fd       	sub	sp,-4
80008e2a:	ce 0b       	rjmp	80008dea <MsgHandleMidLevelRetriesStatus+0xa>
80008e2c:	00 00       	add	r0,r0
80008e2e:	2d 8c       	sub	r12,-40

80008e30 <MsgDiscardRx>:
80008e30:	eb cd 40 e0 	pushm	r5-r7,lr
80008e34:	49 06       	lddpc	r6,80008e74 <MsgDiscardRx+0x44>
80008e36:	2f 86       	sub	r6,-8
80008e38:	0c 9c       	mov	r12,r6
80008e3a:	e0 a0 09 23 	rcall	8000a080 <MbmDequeueLast>
80008e3e:	18 97       	mov	r7,r12
80008e40:	c0 e0       	breq	80008e5c <MsgDiscardRx+0x2c>
80008e42:	e0 a0 23 11 	rcall	8000d464 <PmsDiscardRx>
    handle = MbmDequeueLast(&(msg.rx_queue));
    ASSERT(handle);

    if (handle)
    {
        if(MNS_FALSE != PmsDiscardRx(handle))
80008e46:	18 95       	mov	r5,r12
80008e48:	c0 30       	breq	80008e4e <MsgDiscardRx+0x1e>
80008e4a:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
        {
            result = MNS_TRUE;
        }
        else
        {
            MbmEnqueue(&(msg.rx_queue), handle);
80008e4e:	0c 9c       	mov	r12,r6
80008e50:	0e 9b       	mov	r11,r7
80008e52:	e0 a0 0a 35 	rcall	8000a2bc <MbmEnqueue>
80008e56:	0a 9c       	mov	r12,r5


    T_LIB_EXIT(AMS_42);

    return(result);
}
80008e58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    T_LIB_ENTRY(AMS_42);

    result = MNS_FALSE;

    handle = MbmDequeueLast(&(msg.rx_queue));
    ASSERT(handle);
80008e5c:	e0 68 06 0c 	mov	r8,1548
80008e60:	30 8c       	mov	r12,8
80008e62:	1a d8       	st.w	--sp,r8
80008e64:	30 1a       	mov	r10,1
80008e66:	31 0b       	mov	r11,16
80008e68:	fe b0 f6 42 	rcall	80007aec <mns_trace>
80008e6c:	0e 9c       	mov	r12,r7
80008e6e:	2f fd       	sub	sp,-4
80008e70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008e74:	00 00       	add	r0,r0
80008e76:	2d 8c       	sub	r12,-40

80008e78 <MsgGetRxInPtrExt>:
80008e78:	eb cd 40 80 	pushm	r7,lr
80008e7c:	30 4b       	mov	r11,4
80008e7e:	18 97       	mov	r7,r12
80008e80:	5c 7c       	castu.h	r12
80008e82:	e0 a0 1f b3 	rcall	8000cde8 <PmsGetBuf>
80008e86:	c0 90       	breq	80008e98 <MsgGetRxInPtrExt+0x20>
    handle = PmsGetBuf(size, MBM_TYPE_CTRL_RX);
    if (handle)
    {
        msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
        ASSERT(msg_ptr);
        msg_ptr->Src_Adr = MSG_SRC_EHC;
80008e88:	30 08       	mov	r8,0
        msg_ptr->Rcv_Type = MSG_RCV_TYPE_LOGICAL;
        msg_ptr->Length  = size;
80008e8a:	f9 57 00 18 	st.h	r12[24],r7
    if (handle)
    {
        msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
        ASSERT(msg_ptr);
        msg_ptr->Src_Adr = MSG_SRC_EHC;
        msg_ptr->Rcv_Type = MSG_RCV_TYPE_LOGICAL;
80008e8e:	f9 68 00 21 	st.b	r12[33],r8
    handle = PmsGetBuf(size, MBM_TYPE_CTRL_RX);
    if (handle)
    {
        msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
        ASSERT(msg_ptr);
        msg_ptr->Src_Adr = MSG_SRC_EHC;
80008e92:	f9 58 00 1a 	st.h	r12[26],r8
    msg_ptr = NULL;

    handle = PmsGetBuf(size, MBM_TYPE_CTRL_RX);
    if (handle)
    {
        msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
80008e96:	2e cc       	sub	r12,-20
        #endif
    }

    T_API_EXIT(AMS_14);
    return(msg_ptr);
}
80008e98:	e3 cd 80 80 	ldm	sp++,r7,pc

80008e9c <MsgGetTxPtrExt>:
80008e9c:	eb cd 40 80 	pushm	r7,lr
    T_API_ENTRY(AMS_4);

    handle  = NULL;
    msg_ptr = NULL;

    handle = PmsGetBuf(size, MBM_TYPE_CTRL_TX);
80008ea0:	30 5b       	mov	r11,5
  * \return     Possible return values:
  *             - Pointer to a free message buffer.
  *             - \c NULL if there is no free buffer.
  */
TMsgTx * MsgGetTxPtrExt(word size)
{
80008ea2:	18 97       	mov	r7,r12
    T_API_ENTRY(AMS_4);

    handle  = NULL;
    msg_ptr = NULL;

    handle = PmsGetBuf(size, MBM_TYPE_CTRL_TX);
80008ea4:	5c 7c       	castu.h	r12
80008ea6:	e0 a0 1f a1 	rcall	8000cde8 <PmsGetBuf>
80008eaa:	18 98       	mov	r8,r12
    if (handle)
80008eac:	c0 90       	breq	80008ebe <MsgGetTxPtrExt+0x22>
    {
        msg_ptr = MBM_GET_CTRL_TX_PTR(handle);
        ASSERT(msg_ptr);
        msg_ptr->Length = size;
80008eae:	f1 57 00 18 	st.h	r8[24],r7
    msg_ptr = NULL;

    handle = PmsGetBuf(size, MBM_TYPE_CTRL_TX);
    if (handle)
    {
        msg_ptr = MBM_GET_CTRL_TX_PTR(handle);
80008eb2:	2e cc       	sub	r12,-20
        #ifdef CTRL_FILTER_ID
        msg_ptr->Filter_ID = 0x00;
        #endif
        if (!size)
        {
            msg_ptr->Data = NULL;
80008eb4:	58 07       	cp.w	r7,0
80008eb6:	f1 f7 0a 05 	st.weq	r8[0x14],r7
        }
    }

    T_API_EXIT(AMS_4);
    return(msg_ptr);
}
80008eba:	e3 cd 80 80 	ldm	sp++,r7,pc
80008ebe:	e3 cd 80 80 	ldm	sp++,r7,pc
80008ec2:	d7 03       	nop

80008ec4 <MsgFreeRxMsg>:
80008ec4:	eb cd 40 c0 	pushm	r6-r7,lr
  *             message buffer after allocating the buffer by using
  *             MsgGetRxInPtr() or MsgGetRxInPtrExt().
  * \param[in]  msg_ptr     Pointer to the message.
  */
void MsgFreeRxMsg(TMsgRx *msg_ptr)
{
80008ec8:	18 96       	mov	r6,r12
    byte cnt;

    T_API_ENTRY(AMS_13);

    ASSERT(msg_ptr);
80008eca:	58 0c       	cp.w	r12,0
80008ecc:	c1 e0       	breq	80008f08 <MsgFreeRxMsg+0x44>

    if (msg_ptr)
    {
        TAKE_MSG();
80008ece:	30 bc       	mov	r12,11
80008ed0:	fe b0 f5 f3 	rcall	80007ab6 <mns_take>
        if (0 != (msg_ptr->UsageCnt & ~MSG_RX_F_NOT_FINISHED)) /* do not decrement, if only the flag is set, */
80008ed4:	ed 37 00 0e 	ld.ub	r7,r6[14]
80008ed8:	0e 98       	mov	r8,r7
80008eda:	a7 d8       	cbr	r8,0x7
80008edc:	c0 50       	breq	80008ee6 <MsgFreeRxMsg+0x22>
        {                                                                   /* but the usage cnt is already zero          */
            msg_ptr->UsageCnt--;
80008ede:	20 17       	sub	r7,1
80008ee0:	5c 57       	castu.b	r7
80008ee2:	ed 67 00 0e 	st.b	r6[14],r7
        }

        cnt = msg_ptr->UsageCnt;
        GIVE_MSG();
80008ee6:	30 bc       	mov	r12,11
80008ee8:	fe b0 f5 e8 	rcall	80007ab8 <mns_give>

        if (!cnt)
80008eec:	58 07       	cp.w	r7,0
80008eee:	c0 30       	breq	80008ef4 <MsgFreeRxMsg+0x30>
80008ef0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        {
            /*lint -e{413} see ASSERT */
            HMBMBUF handle = MbmGetHandleByMsgPtr(msg_ptr);
80008ef4:	0c 9c       	mov	r12,r6
80008ef6:	e0 a0 07 59 	rcall	80009da8 <MbmGetHandleByMsgPtr>
80008efa:	18 97       	mov	r7,r12
            ASSERT(handle);
80008efc:	c1 10       	breq	80008f1e <MsgFreeRxMsg+0x5a>
            MbmFree(handle);
80008efe:	0e 9c       	mov	r12,r7
80008f00:	e0 a0 20 2c 	rcall	8000cf58 <MbmFree>
80008f04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
{
    byte cnt;

    T_API_ENTRY(AMS_13);

    ASSERT(msg_ptr);
80008f08:	e0 68 03 80 	mov	r8,896
80008f0c:	30 1a       	mov	r10,1
80008f0e:	1a d8       	st.w	--sp,r8
80008f10:	31 0b       	mov	r11,16
80008f12:	30 8c       	mov	r12,8
80008f14:	fe b0 f5 ec 	rcall	80007aec <mns_trace>
80008f18:	2f fd       	sub	sp,-4
80008f1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

        if (!cnt)
        {
            /*lint -e{413} see ASSERT */
            HMBMBUF handle = MbmGetHandleByMsgPtr(msg_ptr);
            ASSERT(handle);
80008f1e:	e0 68 03 91 	mov	r8,913
80008f22:	30 1a       	mov	r10,1
80008f24:	1a d8       	st.w	--sp,r8
80008f26:	31 0b       	mov	r11,16
80008f28:	30 8c       	mov	r12,8
80008f2a:	fe b0 f5 e1 	rcall	80007aec <mns_trace>
80008f2e:	2f fd       	sub	sp,-4
80008f30:	ce 7b       	rjmp	80008efe <MsgFreeRxMsg+0x3a>
80008f32:	d7 03       	nop

80008f34 <MsgTxUnused>:
80008f34:	eb cd 40 80 	pushm	r7,lr
80008f38:	58 0c       	cp.w	r12,0
80008f3a:	c0 a0       	breq	80008f4e <MsgTxUnused+0x1a>
80008f3c:	e0 a0 07 36 	rcall	80009da8 <MbmGetHandleByMsgPtr>
80008f40:	18 97       	mov	r7,r12
80008f42:	c1 10       	breq	80008f64 <MsgTxUnused+0x30>
80008f44:	0e 9c       	mov	r12,r7
80008f46:	e0 a0 20 09 	rcall	8000cf58 <MbmFree>
    ASSERT(msg_ptr);
    if (msg_ptr)
    {   /*lint -e{413} See ASSERT  */
        handle = MbmGetHandleByMsgPtr(msg_ptr);
        ASSERT(handle);
        MbmFree(handle);
80008f4a:	e3 cd 80 80 	ldm	sp++,r7,pc

    T_API_ENTRY(AMS_9);

    handle = NULL;

    ASSERT(msg_ptr);
80008f4e:	e0 68 02 c1 	mov	r8,705
80008f52:	30 1a       	mov	r10,1
80008f54:	1a d8       	st.w	--sp,r8
80008f56:	31 0b       	mov	r11,16
80008f58:	30 8c       	mov	r12,8
80008f5a:	fe b0 f5 c9 	rcall	80007aec <mns_trace>
80008f5e:	2f fd       	sub	sp,-4
80008f60:	e3 cd 80 80 	ldm	sp++,r7,pc
    if (msg_ptr)
    {   /*lint -e{413} See ASSERT  */
        handle = MbmGetHandleByMsgPtr(msg_ptr);
        ASSERT(handle);
80008f64:	e0 68 02 c5 	mov	r8,709
80008f68:	30 1a       	mov	r10,1
80008f6a:	1a d8       	st.w	--sp,r8
80008f6c:	31 0b       	mov	r11,16
80008f6e:	30 8c       	mov	r12,8
80008f70:	fe b0 f5 be 	rcall	80007aec <mns_trace>
80008f74:	2f fd       	sub	sp,-4
80008f76:	ce 7b       	rjmp	80008f44 <MsgTxUnused+0x10>

80008f78 <MsgSetPendingEvent>:
80008f78:	d4 01       	pushm	lr
80008f7a:	30 89       	mov	r9,8
80008f7c:	5c 7c       	castu.h	r12
80008f7e:	48 3a       	lddpc	r10,80008f88 <MsgSetPendingEvent+0x10>
80008f80:	30 ab       	mov	r11,10
80008f82:	e0 a0 11 fd 	rcall	8000b37c <MnsSetPendingEventFlag>

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_AMS_PE,
                           &msg.pending_events, MNS_P_SRV_AMS);
    T_MOD_EXIT(AMS_2);
}
80008f86:	d8 02       	popm	pc
80008f88:	00 00       	add	r0,r0
80008f8a:	2d 8c       	sub	r12,-40

80008f8c <MsgHandleRetryParamsStatus>:
80008f8c:	eb cd 40 c0 	pushm	r6-r7,lr
}
#endif

#ifdef AMS_48
void MsgHandleRetryParamsStatus(TMsgRx *msg_ptr)
{
80008f90:	18 97       	mov	r7,r12
    bool shadow_changed;

    T_LIB_ENTRY(AMS_48);

    ASSERT(msg_ptr);
80008f92:	58 0c       	cp.w	r12,0
80008f94:	c3 70       	breq	80009002 <MsgHandleRetryParamsStatus+0x76>

    TAKE_MSG();
80008f96:	30 bc       	mov	r12,11
80008f98:	fe b0 f5 8f 	rcall	80007ab6 <mns_take>
    shadow_changed = MNS_FALSE;

    /* check if the shadow values have changed */
    shadow_changed = (msg.retry_cfg.shadow.time != msg_ptr->Data[0]) ? MNS_TRUE : MNS_FALSE;
80008f9c:	6e 0a       	ld.w	r10,r7[0x0]
    shadow_changed = ((MNS_FALSE != shadow_changed) || (msg.retry_cfg.shadow.total_attempts != msg_ptr->Data[1])) ? MNS_TRUE : MNS_FALSE;
80008f9e:	49 f8       	lddpc	r8,80009018 <MsgHandleRetryParamsStatus+0x8c>

    TAKE_MSG();
    shadow_changed = MNS_FALSE;

    /* check if the shadow values have changed */
    shadow_changed = (msg.retry_cfg.shadow.time != msg_ptr->Data[0]) ? MNS_TRUE : MNS_FALSE;
80008fa0:	15 89       	ld.ub	r9,r10[0x0]
    shadow_changed = ((MNS_FALSE != shadow_changed) || (msg.retry_cfg.shadow.total_attempts != msg_ptr->Data[1])) ? MNS_TRUE : MNS_FALSE;
80008fa2:	f1 3b 00 2e 	ld.ub	r11,r8[46]
80008fa6:	f2 0b 18 00 	cp.b	r11,r9
80008faa:	c2 50       	breq	80008ff4 <MsgHandleRetryParamsStatus+0x68>
80008fac:	30 16       	mov	r6,1

    msg.retry_cfg.shadow.time           = msg_ptr->Data[0];
80008fae:	f1 69 00 2e 	st.b	r8[46],r9
    msg.retry_cfg.shadow.total_attempts = msg_ptr->Data[1];
80008fb2:	6e 09       	ld.w	r9,r7[0x0]
80008fb4:	13 99       	ld.ub	r9,r9[0x1]
80008fb6:	f1 69 00 2f 	st.b	r8[47],r9
    msg.retry_cfg.busy                  = MNS_FALSE;
80008fba:	30 09       	mov	r9,0
    GIVE_MSG();
80008fbc:	30 bc       	mov	r12,11
    shadow_changed = (msg.retry_cfg.shadow.time != msg_ptr->Data[0]) ? MNS_TRUE : MNS_FALSE;
    shadow_changed = ((MNS_FALSE != shadow_changed) || (msg.retry_cfg.shadow.total_attempts != msg_ptr->Data[1])) ? MNS_TRUE : MNS_FALSE;

    msg.retry_cfg.shadow.time           = msg_ptr->Data[0];
    msg.retry_cfg.shadow.total_attempts = msg_ptr->Data[1];
    msg.retry_cfg.busy                  = MNS_FALSE;
80008fbe:	f1 69 00 2d 	st.b	r8[45],r9
    GIVE_MSG();
80008fc2:	fe b0 f5 7b 	rcall	80007ab8 <mns_give>

    if (EHCISTATE_IS_ATTACHED())
80008fc6:	e0 a0 0f 95 	rcall	8000aef0 <MnsGetEHCIState>
80008fca:	30 28       	mov	r8,2
80008fcc:	f0 0c 18 00 	cp.b	r12,r8
80008fd0:	c0 70       	breq	80008fde <MsgHandleRetryParamsStatus+0x52>
            MsgSetPendingEvent(AMS_P_SHADOW_CHANGE);
        }
    }
    else
    {
        MnsNtfCheck(NTF_RETRY_PARAMS);
80008fd2:	e0 6c 10 00 	mov	r12,4096
80008fd6:	e0 a0 0f 4b 	rcall	8000ae6c <MnsNtfCheck>
80008fda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    msg.retry_cfg.busy                  = MNS_FALSE;
    GIVE_MSG();

    if (EHCISTATE_IS_ATTACHED())
    {
        if ((MNS_FALSE != shadow_changed) && msg.cfg_ptr->retry_config_adjusted_fptr)
80008fde:	58 06       	cp.w	r6,0
80008fe0:	cf d0       	breq	80008fda <MsgHandleRetryParamsStatus+0x4e>
80008fe2:	48 e8       	lddpc	r8,80009018 <MsgHandleRetryParamsStatus+0x8c>
80008fe4:	70 98       	ld.w	r8,r8[0x24]
80008fe6:	70 68       	ld.w	r8,r8[0x18]
80008fe8:	58 08       	cp.w	r8,0
80008fea:	cf 80       	breq	80008fda <MsgHandleRetryParamsStatus+0x4e>
        {
            /* fire callback asynchronously */
            MsgSetPendingEvent(AMS_P_SHADOW_CHANGE);
80008fec:	32 0c       	mov	r12,32
80008fee:	cc 5f       	rcall	80008f78 <MsgSetPendingEvent>
80008ff0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008ff4:	15 9a       	ld.ub	r10,r10[0x1]
    TAKE_MSG();
    shadow_changed = MNS_FALSE;

    /* check if the shadow values have changed */
    shadow_changed = (msg.retry_cfg.shadow.time != msg_ptr->Data[0]) ? MNS_TRUE : MNS_FALSE;
    shadow_changed = ((MNS_FALSE != shadow_changed) || (msg.retry_cfg.shadow.total_attempts != msg_ptr->Data[1])) ? MNS_TRUE : MNS_FALSE;
80008ff6:	f1 3b 00 2f 	ld.ub	r11,r8[47]
80008ffa:	f4 0b 18 00 	cp.b	r11,r10
80008ffe:	5f 16       	srne	r6
80009000:	cd 7b       	rjmp	80008fae <MsgHandleRetryParamsStatus+0x22>
80009002:	e0 68 06 ea 	mov	r8,1770
{
    bool shadow_changed;

    T_LIB_ENTRY(AMS_48);

    ASSERT(msg_ptr);
80009006:	30 1a       	mov	r10,1
80009008:	1a d8       	st.w	--sp,r8
8000900a:	31 0b       	mov	r11,16
8000900c:	30 8c       	mov	r12,8
8000900e:	fe b0 f5 6f 	rcall	80007aec <mns_trace>
80009012:	2f fd       	sub	sp,-4
80009014:	cc 1b       	rjmp	80008f96 <MsgHandleRetryParamsStatus+0xa>
80009016:	d7 03       	nop
80009018:	00 00       	add	r0,r0
8000901a:	2d 8c       	sub	r12,-40

8000901c <MsgNIStateNetOn>:
8000901c:	eb cd 40 e0 	pushm	r5-r7,lr
80009020:	49 27       	lddpc	r7,80009068 <MsgNIStateNetOn+0x4c>
80009022:	ae cc       	st.b	r7[0x4],r12
80009024:	58 0c       	cp.w	r12,0
80009026:	c1 51       	brne	80009050 <MsgNIStateNetOn+0x34>
80009028:	ef 09 00 12 	ld.sh	r9,r7[18]
8000902c:	f8 09 19 00 	cp.h	r9,r12
80009030:	c1 a0       	breq	80009064 <MsgNIStateNetOn+0x48>
80009032:	18 95       	mov	r5,r12
    }
    else
    {
        while (MbmQueueLength(&(msg.rx_queue)))
        {
            HMBMBUF handle = MbmDequeue(&(msg.rx_queue));
80009034:	ee c6 ff f8 	sub	r6,r7,-8
80009038:	0c 9c       	mov	r12,r6
8000903a:	e0 a0 08 5f 	rcall	8000a0f8 <MbmDequeue>
            MbmFree(handle);
8000903e:	e0 a0 1f 8d 	rcall	8000cf58 <MbmFree>
            MsgSetPendingEvent(AMS_P_RX);
        }
    }
    else
    {
        while (MbmQueueLength(&(msg.rx_queue)))
80009042:	ef 08 00 12 	ld.sh	r8,r7[18]
80009046:	ea 08 19 00 	cp.h	r8,r5
8000904a:	cf 71       	brne	80009038 <MsgNIStateNetOn+0x1c>
8000904c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    msg.net_on = on;

    if (MNS_FALSE != on)
    {
        if (MbmQueueLength(&(msg.rx_queue)))
80009050:	ef 09 00 12 	ld.sh	r9,r7[18]
80009054:	30 08       	mov	r8,0
80009056:	f0 09 19 00 	cp.h	r9,r8
8000905a:	cf 90       	breq	8000904c <MsgNIStateNetOn+0x30>
        {
            MsgSetPendingEvent(AMS_P_RX);
8000905c:	30 2c       	mov	r12,2
8000905e:	c8 df       	rcall	80008f78 <MsgSetPendingEvent>
80009060:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009064:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009068:	00 00       	add	r0,r0
8000906a:	2d 8c       	sub	r12,-40

8000906c <MsgRxOutTrigger>:
8000906c:	d4 31       	pushm	r0-r7,lr
8000906e:	20 1d       	sub	sp,4
80009070:	fe f4 02 18 	ld.w	r4,pc[536]
80009074:	18 97       	mov	r7,r12
80009076:	68 98       	ld.w	r8,r4[0x24]
80009078:	30 09       	mov	r9,0
8000907a:	f1 3a 00 1d 	ld.ub	r10,r8[29]
    handle   = NULL;

    /* if msg.cfg_ptr->rx_direct is MNS_TRUE, there shouldn't be anything in the
       queue, except messages received before MNS_NET_ON and BUSY operations */
    #ifndef PMS_RX_OPT4
    rx_burst = msg.cfg_ptr->rx_direct ? (byte)0xFF : msg.cfg_ptr->rx_burst;
8000907e:	f2 0a 18 00 	cp.b	r10,r9
80009082:	c6 c0       	breq	8000915a <MsgRxOutTrigger+0xee>
80009084:	e0 66 00 ff 	mov	r6,255
    #else
    rx_burst = msg.cfg_ptr->rx_burst;
    #endif

    if(MNS_FALSE == msg.net_on)
80009088:	09 c8       	ld.ub	r8,r4[0x4]
8000908a:	30 03       	mov	r3,0
8000908c:	e6 08 18 00 	cp.b	r8,r3
80009090:	c5 b0       	breq	80009146 <MsgRxOutTrigger+0xda>
    {
        T_MOD_EXIT(AMS_11);
        return;
    }

    if (!msg_ptr)
80009092:	58 07       	cp.w	r7,0
80009094:	e0 80 00 da 	breq	80009248 <MsgRxOutTrigger+0x1dc>
        msg_ptr = handle ? MBM_GET_CTRL_RX_PTR(handle) : NULL;
    }
    else
    {
        /*lint -e{413} See ASSERT  */
        handle = MbmGetHandleByMsgPtr(msg_ptr);
80009098:	0e 9c       	mov	r12,r7
8000909a:	e0 a0 06 87 	rcall	80009da8 <MbmGetHandleByMsgPtr>
8000909e:	18 95       	mov	r5,r12
    }

    ASSERT((rx_burst > (byte)1) || (msg_ptr && handle));
800090a0:	30 18       	mov	r8,1
800090a2:	f0 06 18 00 	cp.b	r6,r8
800090a6:	e0 88 00 79 	brls	80009198 <MsgRxOutTrigger+0x12c>
                    break;
            }
        }
        else
        {
            MbmEnqueueFirst(&(msg.rx_queue), handle);
800090aa:	e8 c2 ff f8 	sub	r2,r4,-8
        handle = MbmGetHandleByMsgPtr(msg_ptr);
    }

    ASSERT((rx_burst > (byte)1) || (msg_ptr && handle));

    while (msg_ptr && handle && rx_burst)
800090ae:	30 03       	mov	r3,0
            bool free_msg = MNS_FALSE;

            TAKE_MSG();
            msg_ptr->UsageCnt++;                                                /* counts retained messages */
            GIVE_MSG();
            if (msg.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
800090b0:	30 21       	mov	r1,2
            {
                MsgSetPendingEvent(AMS_P_RX);
            }
            else
            {
                handle = MbmDequeue(&(msg.rx_queue));
800090b2:	04 90       	mov	r0,r2
        handle = MbmGetHandleByMsgPtr(msg_ptr);
    }

    ASSERT((rx_burst > (byte)1) || (msg_ptr && handle));

    while (msg_ptr && handle && rx_burst)
800090b4:	58 05       	cp.w	r5,0
800090b6:	5f 19       	srne	r9
800090b8:	58 07       	cp.w	r7,0
800090ba:	5f 18       	srne	r8
800090bc:	f3 e8 00 08 	and	r8,r9,r8
800090c0:	e6 08 18 00 	cp.b	r8,r3
800090c4:	c4 10       	breq	80009146 <MsgRxOutTrigger+0xda>
800090c6:	58 06       	cp.w	r6,0
800090c8:	c3 f0       	breq	80009146 <MsgRxOutTrigger+0xda>
    {
        if (   (MSG_RX_F_NOT_FINISHED - 1)
             > (msg_ptr->UsageCnt & (MSG_RX_F_NOT_FINISHED - 1)) )              /* avoid overflow of msg_ptr->UsageCnt */
800090ca:	ef 38 00 0e 	ld.ub	r8,r7[14]
800090ce:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800090d2:	e0 48 00 7f 	cp.w	r8,127
800090d6:	c3 20       	breq	8000913a <MsgRxOutTrigger+0xce>
        {
            byte result   = MSG_RX_FREE;
            bool free_msg = MNS_FALSE;

            TAKE_MSG();
800090d8:	30 bc       	mov	r12,11
800090da:	fe b0 f4 ee 	rcall	80007ab6 <mns_take>
            msg_ptr->UsageCnt++;                                                /* counts retained messages */
800090de:	ef 38 00 0e 	ld.ub	r8,r7[14]
800090e2:	2f f8       	sub	r8,-1
            GIVE_MSG();
800090e4:	30 bc       	mov	r12,11
        {
            byte result   = MSG_RX_FREE;
            bool free_msg = MNS_FALSE;

            TAKE_MSG();
            msg_ptr->UsageCnt++;                                                /* counts retained messages */
800090e6:	ef 68 00 0e 	st.b	r7[14],r8
            GIVE_MSG();
800090ea:	fe b0 f4 e7 	rcall	80007ab8 <mns_give>
            if (msg.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
800090ee:	68 98       	ld.w	r8,r4[0x24]
800090f0:	70 28       	ld.w	r8,r8[0x8]
800090f2:	58 08       	cp.w	r8,0
800090f4:	c0 60       	breq	80009100 <MsgRxOutTrigger+0x94>
800090f6:	e0 a0 0e fd 	rcall	8000aef0 <MnsGetEHCIState>
800090fa:	e2 0c 18 00 	cp.b	r12,r1
800090fe:	c3 10       	breq	80009160 <MsgRxOutTrigger+0xf4>
                default:
                    FAILED_ASSERT();

                /*lint -e(616) default case is meant that way */
                case MSG_RX_FREE:
                    TAKE_MSG();
80009100:	30 bc       	mov	r12,11
80009102:	fe b0 f4 da 	rcall	80007ab6 <mns_take>
                    msg_ptr->UsageCnt &= ~MSG_RX_F_NOT_FINISHED;
80009106:	ef 38 00 0e 	ld.ub	r8,r7[14]
                    GIVE_MSG();
8000910a:	30 bc       	mov	r12,11
                    FAILED_ASSERT();

                /*lint -e(616) default case is meant that way */
                case MSG_RX_FREE:
                    TAKE_MSG();
                    msg_ptr->UsageCnt &= ~MSG_RX_F_NOT_FINISHED;
8000910c:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80009110:	ef 68 00 0e 	st.b	r7[14],r8
                        if (msg_ptr->UsageCnt == 0)                         /* Was only the "not finished flag" set, but no user registrated ? */
                        {
                            free_msg = MNS_TRUE;
                        }
                    }
                    GIVE_MSG();
80009114:	fe b0 f4 d2 	rcall	80007ab8 <mns_give>
                    if (MNS_FALSE != free_msg)
                    {
                        MsgFreeRxMsg(msg_ptr);                        /* Message must now be cleared, since all users are checked out */
80009118:	0e 9c       	mov	r12,r7
8000911a:	20 16       	sub	r6,1
8000911c:	cd 4e       	rcall	80008ec4 <MsgFreeRxMsg>
8000911e:	5c 56       	castu.b	r6
80009120:	30 07       	mov	r7,0
80009122:	0e 95       	mov	r5,r7
80009124:	e9 09 00 12 	ld.sh	r9,r4[18]
            rx_burst = 1;
        }

        rx_burst--;

        if (MbmQueueLength(&(msg.rx_queue)))
80009128:	30 08       	mov	r8,0
8000912a:	f0 09 19 00 	cp.h	r9,r8
8000912e:	cc 30       	breq	800090b4 <MsgRxOutTrigger+0x48>
80009130:	58 06       	cp.w	r6,0
        {
            if(!rx_burst)
80009132:	c0 c1       	brne	8000914a <MsgRxOutTrigger+0xde>
80009134:	30 2c       	mov	r12,2
            {
                MsgSetPendingEvent(AMS_P_RX);
80009136:	c2 1f       	rcall	80008f78 <MsgSetPendingEvent>
80009138:	cb eb       	rjmp	800090b4 <MsgRxOutTrigger+0x48>
8000913a:	0a 9b       	mov	r11,r5
8000913c:	04 9c       	mov	r12,r2
                    break;
            }
        }
        else
        {
            MbmEnqueueFirst(&(msg.rx_queue), handle);
8000913e:	30 06       	mov	r6,0
80009140:	e0 a0 08 14 	rcall	8000a168 <MbmEnqueueFirst>
80009144:	cf 0b       	rjmp	80009124 <MsgRxOutTrigger+0xb8>
80009146:	2f fd       	sub	sp,-4
80009148:	d8 32       	popm	r0-r7,pc
            }
        }
    }

    T_MOD_EXIT(AMS_11);
}
8000914a:	00 9c       	mov	r12,r0
8000914c:	e0 a0 07 d6 	rcall	8000a0f8 <MbmDequeue>
            {
                MsgSetPendingEvent(AMS_P_RX);
            }
            else
            {
                handle = MbmDequeue(&(msg.rx_queue));
80009150:	18 95       	mov	r5,r12
80009152:	c7 00       	breq	80009232 <MsgRxOutTrigger+0x1c6>
80009154:	f8 c7 ff ec 	sub	r7,r12,-20
                ASSERT(handle);
                msg_ptr = handle ? MBM_GET_CTRL_RX_PTR(handle) : NULL;
80009158:	ca eb       	rjmp	800090b4 <MsgRxOutTrigger+0x48>
8000915a:	f1 36 00 1c 	ld.ub	r6,r8[28]
    handle   = NULL;

    /* if msg.cfg_ptr->rx_direct is MNS_TRUE, there shouldn't be anything in the
       queue, except messages received before MNS_NET_ON and BUSY operations */
    #ifndef PMS_RX_OPT4
    rx_burst = msg.cfg_ptr->rx_direct ? (byte)0xFF : msg.cfg_ptr->rx_burst;
8000915e:	c9 5b       	rjmp	80009088 <MsgRxOutTrigger+0x1c>
80009160:	4c a9       	lddpc	r9,80009288 <MsgRxOutTrigger+0x21c>
80009162:	0e 9c       	mov	r12,r7
            TAKE_MSG();
            msg_ptr->UsageCnt++;                                                /* counts retained messages */
            GIVE_MSG();
            if (msg.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
            {
                result = msg.cfg_ptr->rx_complete_fptr(msg_ptr);
80009164:	72 98       	ld.w	r8,r9[0x24]
80009166:	70 28       	ld.w	r8,r8[0x8]
80009168:	5d 18       	icall	r8
8000916a:	30 39       	mov	r9,3
8000916c:	18 98       	mov	r8,r12
            }

            switch (result)
8000916e:	f2 0c 18 00 	cp.b	r12,r9
80009172:	e0 8b 00 24 	brhi	800091ba <MsgRxOutTrigger+0x14e>
80009176:	e2 0c 18 00 	cp.b	r12,r1
8000917a:	c3 52       	brcc	800091e4 <MsgRxOutTrigger+0x178>
8000917c:	30 19       	mov	r9,1
8000917e:	f2 0c 18 00 	cp.b	r12,r9
80009182:	c2 10       	breq	800091c4 <MsgRxOutTrigger+0x158>
80009184:	e0 68 03 48 	mov	r8,840
                    msg_ptr = NULL;
                    handle = NULL;
                    break;

                default:
                    FAILED_ASSERT();
80009188:	30 1a       	mov	r10,1
8000918a:	1a d8       	st.w	--sp,r8
8000918c:	31 0b       	mov	r11,16
8000918e:	30 8c       	mov	r12,8
80009190:	fe b0 f4 ae 	rcall	80007aec <mns_trace>
80009194:	2f fd       	sub	sp,-4
80009196:	cb 5b       	rjmp	80009100 <MsgRxOutTrigger+0x94>
80009198:	58 05       	cp.w	r5,0
8000919a:	5f 09       	sreq	r9
    {
        /*lint -e{413} See ASSERT  */
        handle = MbmGetHandleByMsgPtr(msg_ptr);
    }

    ASSERT((rx_burst > (byte)1) || (msg_ptr && handle));
8000919c:	58 07       	cp.w	r7,0
8000919e:	5f 08       	sreq	r8
800091a0:	f3 e8 10 08 	or	r8,r9,r8
800091a4:	c8 30       	breq	800090aa <MsgRxOutTrigger+0x3e>
800091a6:	e0 68 03 11 	mov	r8,785
800091aa:	30 1a       	mov	r10,1
800091ac:	1a d8       	st.w	--sp,r8
800091ae:	31 0b       	mov	r11,16
800091b0:	30 8c       	mov	r12,8
800091b2:	fe b0 f4 9d 	rcall	80007aec <mns_trace>
800091b6:	2f fd       	sub	sp,-4
800091b8:	c7 9b       	rjmp	800090aa <MsgRxOutTrigger+0x3e>
800091ba:	30 49       	mov	r9,4
800091bc:	f2 0c 18 00 	cp.b	r12,r9
            if (msg.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
            {
                result = msg.cfg_ptr->rx_complete_fptr(msg_ptr);
            }

            switch (result)
800091c0:	ce 21       	brne	80009184 <MsgRxOutTrigger+0x118>
800091c2:	c9 fb       	rjmp	80009100 <MsgRxOutTrigger+0x94>
800091c4:	30 bc       	mov	r12,11
800091c6:	fe b0 f4 78 	rcall	80007ab6 <mns_take>
                    /* force another service run */
                    rx_burst = 1;
                    break;

                case MSG_RX_TAKE:
                    TAKE_MSG();
800091ca:	ef 38 00 0e 	ld.ub	r8,r7[14]
                    if (MSG_RX_F_NOT_FINISHED == (msg_ptr->UsageCnt & MSG_RX_F_NOT_FINISHED))
800091ce:	e6 08 18 00 	cp.b	r8,r3
800091d2:	c2 95       	brlt	80009224 <MsgRxOutTrigger+0x1b8>
800091d4:	30 bc       	mov	r12,11
800091d6:	20 16       	sub	r6,1
                        if (msg_ptr->UsageCnt == 0)                         /* Was only the "not finished flag" set, but no user registrated ? */
                        {
                            free_msg = MNS_TRUE;
                        }
                    }
                    GIVE_MSG();
800091d8:	fe b0 f4 70 	rcall	80007ab8 <mns_give>
800091dc:	30 05       	mov	r5,0
800091de:	5c 56       	castu.b	r6
800091e0:	0a 97       	mov	r7,r5
800091e2:	ca 1b       	rjmp	80009124 <MsgRxOutTrigger+0xb8>
800091e4:	50 08       	stdsp	sp[0x0],r8
800091e6:	30 bc       	mov	r12,11

            switch (result)
            {
                case MSG_RX_BUSY:
                case MSG_RX_INC_USAGE_CNT:
                    TAKE_MSG();
800091e8:	fe b0 f4 67 	rcall	80007ab6 <mns_take>
800091ec:	40 08       	lddsp	r8,sp[0x0]
800091ee:	e2 08 18 00 	cp.b	r8,r1
                    if (MSG_RX_BUSY == result)
800091f2:	c1 20       	breq	80009216 <MsgRxOutTrigger+0x1aa>
800091f4:	ef 38 00 0e 	ld.ub	r8,r7[14]
800091f8:	ea 18 ff ff 	orh	r8,0xffff
                    {
                        msg_ptr->UsageCnt--;
                    }
                    msg_ptr->UsageCnt |= MSG_RX_F_NOT_FINISHED;
800091fc:	e8 18 ff 80 	orl	r8,0xff80
80009200:	30 bc       	mov	r12,11
80009202:	ef 68 00 0e 	st.b	r7[14],r8
80009206:	fe b0 f4 59 	rcall	80007ab8 <mns_give>
                    GIVE_MSG();
8000920a:	0a 9b       	mov	r11,r5
8000920c:	04 9c       	mov	r12,r2
                    MbmEnqueueFirst(&(msg.rx_queue), handle);
8000920e:	30 06       	mov	r6,0
80009210:	e0 a0 07 ac 	rcall	8000a168 <MbmEnqueueFirst>
80009214:	c8 8b       	rjmp	80009124 <MsgRxOutTrigger+0xb8>
80009216:	ef 38 00 0e 	ld.ub	r8,r7[14]
                case MSG_RX_BUSY:
                case MSG_RX_INC_USAGE_CNT:
                    TAKE_MSG();
                    if (MSG_RX_BUSY == result)
                    {
                        msg_ptr->UsageCnt--;
8000921a:	20 18       	sub	r8,1
8000921c:	5c 58       	castu.b	r8
8000921e:	ef 68 00 0e 	st.b	r7[14],r8
80009222:	ce bb       	rjmp	800091f8 <MsgRxOutTrigger+0x18c>
80009224:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7

                case MSG_RX_TAKE:
                    TAKE_MSG();
                    if (MSG_RX_F_NOT_FINISHED == (msg_ptr->UsageCnt & MSG_RX_F_NOT_FINISHED))
                    {
                        msg_ptr->UsageCnt &= ~MSG_RX_F_NOT_FINISHED;
80009228:	ef 68 00 0e 	st.b	r7[14],r8
8000922c:	cd 41       	brne	800091d4 <MsgRxOutTrigger+0x168>
8000922e:	30 bc       	mov	r12,11
                        if (msg_ptr->UsageCnt == 0)                         /* Was only the "not finished flag" set, but no user registrated ? */
80009230:	c7 2b       	rjmp	80009114 <MsgRxOutTrigger+0xa8>
                        {
                            free_msg = MNS_TRUE;
                        }
                    }
                    GIVE_MSG();
80009232:	e0 68 03 66 	mov	r8,870
                MsgSetPendingEvent(AMS_P_RX);
            }
            else
            {
                handle = MbmDequeue(&(msg.rx_queue));
                ASSERT(handle);
80009236:	30 1a       	mov	r10,1
80009238:	1a d8       	st.w	--sp,r8
8000923a:	31 0b       	mov	r11,16
8000923c:	30 8c       	mov	r12,8
8000923e:	fe b0 f4 57 	rcall	80007aec <mns_trace>
80009242:	2f fd       	sub	sp,-4
80009244:	0a 97       	mov	r7,r5
80009246:	c3 7b       	rjmp	800090b4 <MsgRxOutTrigger+0x48>
80009248:	49 0c       	lddpc	r12,80009288 <MsgRxOutTrigger+0x21c>
8000924a:	2f 8c       	sub	r12,-8
        return;
    }

    if (!msg_ptr)
    {
        handle = MbmDequeue(&(msg.rx_queue));
8000924c:	e0 a0 07 56 	rcall	8000a0f8 <MbmDequeue>
80009250:	30 18       	mov	r8,1
80009252:	5f 09       	sreq	r9
        ASSERT((rx_burst > (byte)1) || handle);
80009254:	ec 08 18 00 	cp.b	r8,r6
80009258:	e6 08 17 30 	movlo	r8,r3
8000925c:	18 95       	mov	r5,r12
8000925e:	f3 e8 00 08 	and	r8,r9,r8
80009262:	e6 08 18 00 	cp.b	r8,r3
80009266:	c0 71       	brne	80009274 <MsgRxOutTrigger+0x208>
80009268:	58 05       	cp.w	r5,0
8000926a:	fe 90 ff 1b 	breq	800090a0 <MsgRxOutTrigger+0x34>
        msg_ptr = handle ? MBM_GET_CTRL_RX_PTR(handle) : NULL;
8000926e:	ea c7 ff ec 	sub	r7,r5,-20
80009272:	c1 7b       	rjmp	800090a0 <MsgRxOutTrigger+0x34>
80009274:	e0 68 03 08 	mov	r8,776
    }

    if (!msg_ptr)
    {
        handle = MbmDequeue(&(msg.rx_queue));
        ASSERT((rx_burst > (byte)1) || handle);
80009278:	30 1a       	mov	r10,1
8000927a:	1a d8       	st.w	--sp,r8
8000927c:	31 0b       	mov	r11,16
8000927e:	30 8c       	mov	r12,8
80009280:	fe b0 f4 36 	rcall	80007aec <mns_trace>
80009284:	2f fd       	sub	sp,-4
80009286:	cf 1b       	rjmp	80009268 <MsgRxOutTrigger+0x1fc>
80009288:	00 00       	add	r0,r0
8000928a:	2d 8c       	sub	r12,-40

8000928c <MsgRxTrigger>:
8000928c:	eb cd 40 c0 	pushm	r6-r7,lr
80009290:	18 96       	mov	r6,r12
80009292:	58 0c       	cp.w	r12,0
80009294:	c2 c0       	breq	800092ec <MsgRxTrigger+0x60>
80009296:	30 08       	mov	r8,0
80009298:	ed 68 00 0e 	st.b	r6[14],r8
8000929c:	49 e7       	lddpc	r7,80009314 <MsgRxTrigger+0x88>
8000929e:	6e 99       	ld.w	r9,r7[0x24]
800092a0:	f3 39 00 1d 	ld.ub	r9,r9[29]
800092a4:	f0 09 18 00 	cp.b	r9,r8
800092a8:	c0 50       	breq	800092b2 <MsgRxTrigger+0x26>
800092aa:	0f c9       	ld.ub	r9,r7[0x4]
800092ac:	f0 09 18 00 	cp.b	r9,r8
800092b0:	c1 41       	brne	800092d8 <MsgRxTrigger+0x4c>
800092b2:	0c 9c       	mov	r12,r6
    }
    else
    #endif
    {
        /*lint -e{413} See ASSERT  */
        HMBMBUF handle = MbmGetHandleByMsgPtr(msg_ptr);
800092b4:	e0 a0 05 7a 	rcall	80009da8 <MbmGetHandleByMsgPtr>
800092b8:	18 96       	mov	r6,r12
        ASSERT(handle);
800092ba:	c2 30       	breq	80009300 <MsgRxTrigger+0x74>
        MbmEnqueue(&(msg.rx_queue), handle);
800092bc:	0c 9b       	mov	r11,r6
800092be:	ee cc ff f8 	sub	r12,r7,-8
800092c2:	e0 a0 07 fd 	rcall	8000a2bc <MbmEnqueue>
        if(MNS_FALSE != msg.net_on)
800092c6:	0f c9       	ld.ub	r9,r7[0x4]
800092c8:	30 08       	mov	r8,0
800092ca:	f0 09 18 00 	cp.b	r9,r8
800092ce:	c0 30       	breq	800092d4 <MsgRxTrigger+0x48>
        {
            MsgSetPendingEvent(AMS_P_RX);
800092d0:	30 2c       	mov	r12,2
800092d2:	c5 3e       	rcall	80008f78 <MsgSetPendingEvent>
800092d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800092d8:	ef 09 00 12 	ld.sh	r9,r7[18]
    T_RX(msg_ptr->Src_Adr, msg_ptr->FBlock_ID, msg_ptr->Inst_ID,
         msg_ptr->Func_ID, msg_ptr->Operation, msg_ptr->Length);
    msg_ptr->UsageCnt = 0;

    #ifndef PMS_RX_OPT4
    if ((MNS_FALSE != msg.cfg_ptr->rx_direct) && (MNS_FALSE != msg.net_on) && ((word)0 == MbmQueueLength(&(msg.rx_queue))))
800092dc:	30 08       	mov	r8,0
800092de:	f0 09 19 00 	cp.h	r9,r8
800092e2:	ce 81       	brne	800092b2 <MsgRxTrigger+0x26>
800092e4:	0c 9c       	mov	r12,r6
    {
        MsgRxOutTrigger(msg_ptr);
800092e6:	cc 3e       	rcall	8000906c <MsgRxOutTrigger>
800092e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    T_RX(msg_ptr->Src_Adr, msg_ptr->FBlock_ID, msg_ptr->Inst_ID,
         msg_ptr->Func_ID, msg_ptr->Operation, msg_ptr->Length);
    msg_ptr->UsageCnt = 0;

    #ifndef PMS_RX_OPT4
    if ((MNS_FALSE != msg.cfg_ptr->rx_direct) && (MNS_FALSE != msg.net_on) && ((word)0 == MbmQueueLength(&(msg.rx_queue))))
800092ec:	e0 68 02 d2 	mov	r8,722
#ifdef AMS_10
void MsgRxTrigger(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(AMS_10);

    ASSERT(msg_ptr);
800092f0:	30 1a       	mov	r10,1
800092f2:	1a d8       	st.w	--sp,r8
800092f4:	31 0b       	mov	r11,16
800092f6:	30 8c       	mov	r12,8
800092f8:	fe b0 f3 fa 	rcall	80007aec <mns_trace>
800092fc:	2f fd       	sub	sp,-4
800092fe:	cc cb       	rjmp	80009296 <MsgRxTrigger+0xa>
80009300:	e0 68 02 e1 	mov	r8,737
    else
    #endif
    {
        /*lint -e{413} See ASSERT  */
        HMBMBUF handle = MbmGetHandleByMsgPtr(msg_ptr);
        ASSERT(handle);
80009304:	30 1a       	mov	r10,1
80009306:	1a d8       	st.w	--sp,r8
80009308:	31 0b       	mov	r11,16
8000930a:	30 8c       	mov	r12,8
8000930c:	fe b0 f3 f0 	rcall	80007aec <mns_trace>
80009310:	2f fd       	sub	sp,-4
80009312:	cd 5b       	rjmp	800092bc <MsgRxTrigger+0x30>
80009314:	00 00       	add	r0,r0
80009316:	2d 8c       	sub	r12,-40

80009318 <MsgRxInReady>:
80009318:	eb cd 40 80 	pushm	r7,lr
8000931c:	18 97       	mov	r7,r12
8000931e:	58 0c       	cp.w	r12,0
80009320:	c0 50       	breq	8000932a <MsgRxInReady+0x12>
80009322:	0e 9c       	mov	r12,r7
80009324:	cb 4f       	rcall	8000928c <MsgRxTrigger>
80009326:	e3 cd 80 80 	ldm	sp++,r7,pc
8000932a:	e0 68 03 e8 	mov	r8,1000
8000932e:	30 1a       	mov	r10,1
  */
void MsgRxInReady(TMsgRx *msg_ptr)
{
    T_API_ENTRY(AMS_15);

    ASSERT(msg_ptr);
80009330:	1a d8       	st.w	--sp,r8
80009332:	31 0b       	mov	r11,16
80009334:	30 8c       	mov	r12,8
80009336:	fe b0 f3 db 	rcall	80007aec <mns_trace>
8000933a:	0e 9c       	mov	r12,r7
    MsgRxTrigger(msg_ptr);
8000933c:	2f fd       	sub	sp,-4
  */
void MsgRxInReady(TMsgRx *msg_ptr)
{
    T_API_ENTRY(AMS_15);

    ASSERT(msg_ptr);
8000933e:	ca 7f       	rcall	8000928c <MsgRxTrigger>
    MsgRxTrigger(msg_ptr);
80009340:	e3 cd 80 80 	ldm	sp++,r7,pc

80009344 <MsgTxFinal>:

    T_API_EXIT(AMS_15);
}
80009344:	eb cd 40 fc 	pushm	r2-r7,lr
80009348:	18 97       	mov	r7,r12
8000934a:	16 96       	mov	r6,r11
8000934c:	58 0c       	cp.w	r12,0
8000934e:	e0 80 00 d8 	breq	800094fe <MsgTxFinal+0x1ba>
    byte    cb_result;

    T_MOD_ENTRY(AMS_8);

    ASSERT(handle);
    msg_ptr   = MBM_GET_CTRL_TX_PTR(handle);
80009352:	ee c5 ff ec 	sub	r5,r7,-20
    result    = PMS_RELEASE;
    cb_result = MSG_TX_FREE;
    ASSERT(msg_ptr);
80009356:	e0 80 00 ca 	breq	800094ea <MsgTxFinal+0x1a6>

    /*lint -esym(960,14.10) no else condition - internal messages shall not effect sync_guard*/
    if (MSG_TGT_INIC != msg_ptr->Tgt_Adr)
8000935a:	ef 0c 00 1a 	ld.sh	r12,r7[26]
8000935e:	30 14       	mov	r4,1
80009360:	e8 0c 19 00 	cp.h	r12,r4
80009364:	c7 f0       	breq	80009462 <MsgTxFinal+0x11e>
    {
        if (XMIT_SYNC == status)
80009366:	38 38       	mov	r8,-125
80009368:	f0 06 18 00 	cp.b	r6,r8
8000936c:	c6 90       	breq	8000943e <MsgTxFinal+0xfa>
            {
                sync_guard = (byte)0;
                MisResetInic();
            }
        }
        else if((XMIT_SUCCESS_INTERNAL != status) && (XMIT_PROTECTED_MODE != status))
8000936e:	ec c8 ff 86 	sub	r8,r6,-122
80009372:	e8 08 18 00 	cp.b	r8,r4
80009376:	e0 88 00 08 	brls	80009386 <MsgTxFinal+0x42>
        {
            if ((byte)0 != sync_guard)
8000937a:	4e 98       	lddpc	r8,8000951c <MsgTxFinal+0x1d8>
8000937c:	11 89       	ld.ub	r9,r8[0x0]
8000937e:	58 09       	cp.w	r9,0
80009380:	c0 30       	breq	80009386 <MsgTxFinal+0x42>
            {
                sync_guard--;
80009382:	20 19       	sub	r9,1
80009384:	b0 89       	st.b	r8[0x0],r9
    else
    {
        
        #ifdef MCS_MIN
        bool internal = (XMIT_SUCCESS_INTERNAL == status) ? MNS_TRUE : MNS_FALSE;
        byte addr_type = MostCheckOwnAddress(msg_ptr->Tgt_Adr);
80009386:	5c 7c       	castu.h	r12
80009388:	e0 a0 42 86 	rcall	80011894 <MostCheckOwnAddress>

        if (MNS_FALSE != internal)
8000938c:	38 68       	mov	r8,-122
    else
    {
        
        #ifdef MCS_MIN
        bool internal = (XMIT_SUCCESS_INTERNAL == status) ? MNS_TRUE : MNS_FALSE;
        byte addr_type = MostCheckOwnAddress(msg_ptr->Tgt_Adr);
8000938e:	18 93       	mov	r3,r12

        if (MNS_FALSE != internal)
80009390:	f0 06 18 00 	cp.b	r6,r8
80009394:	c2 b1       	brne	800093ea <MsgTxFinal+0xa6>
80009396:	30 14       	mov	r4,1
80009398:	31 06       	mov	r6,16
            }

        }
        #endif
        /*lint -esym(960,14.10) no else condition - no modification for non-internal messages*/
        if (EHCISTATE_IS_ATTACHED())                  /*lint +esym(960,14.10) re-enables rule*/
8000939a:	e0 a0 0d ab 	rcall	8000aef0 <MnsGetEHCIState>
8000939e:	30 28       	mov	r8,2
800093a0:	f0 0c 18 00 	cp.b	r12,r8
800093a4:	c2 c0       	breq	800093fc <MsgTxFinal+0xb8>
                cb_result = msg.cfg_ptr->tx_status_fptr(status, msg_ptr);

                if (((XMIT_SUCCESS == status) || (XMIT_NO_ICM == status)) &&
                    (MSG_TX_FREE != cb_result))
                {
                    FAILED_ASSERT();
800093a6:	30 02       	mov	r2,0
                    cb_result = MSG_TX_FREE;
                }
            }
        }
        #ifdef MCS_MIN
        if ((MNS_FALSE != internal) && (MSG_TX_FREE == cb_result))
800093a8:	58 04       	cp.w	r4,0
800093aa:	c0 40       	breq	800093b2 <MsgTxFinal+0x6e>
800093ac:	58 02       	cp.w	r2,0
800093ae:	e0 80 00 8d 	breq	800094c8 <MsgTxFinal+0x184>
            #endif
        }
        #endif
    }

    switch (cb_result)
800093b2:	30 18       	mov	r8,1
800093b4:	f0 02 18 00 	cp.b	r2,r8
800093b8:	c7 50       	breq	800094a2 <MsgTxFinal+0x15e>
800093ba:	c0 f3       	brcs	800093d8 <MsgTxFinal+0x94>
800093bc:	30 28       	mov	r8,2
800093be:	f0 02 18 00 	cp.b	r2,r8
800093c2:	e0 80 00 81 	breq	800094c4 <MsgTxFinal+0x180>

        case MSG_TX_POSTPONE:
            break;

        default:
            FAILED_ASSERT();
800093c6:	e0 68 02 a6 	mov	r8,678
800093ca:	1a d8       	st.w	--sp,r8
800093cc:	30 1a       	mov	r10,1
800093ce:	31 0b       	mov	r11,16
800093d0:	30 8c       	mov	r12,8
800093d2:	fe b0 f3 8d 	rcall	80007aec <mns_trace>
800093d6:	2f fd       	sub	sp,-4

        /*lint -e(616,825) intended fallthrough, default case is before MSG_TX_FREE */
        case MSG_TX_FREE:
            MbmFree(handle);
800093d8:	0e 9c       	mov	r12,r7
800093da:	e0 a0 1d bf 	rcall	8000cf58 <MbmFree>
800093de:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
    else
    {
        
        #ifdef MCS_MIN
        bool internal = (XMIT_SUCCESS_INTERNAL == status) ? MNS_TRUE : MNS_FALSE;
        byte addr_type = MostCheckOwnAddress(msg_ptr->Tgt_Adr);
800093e2:	30 1c       	mov	r12,1
800093e4:	e0 a0 42 58 	rcall	80011894 <MostCheckOwnAddress>
800093e8:	18 93       	mov	r3,r12

        if (MNS_FALSE != internal)
        {
            status = XMIT_SUCCESS;
        }
        else if ((MOST_CHECK_ADDR_GROUP     == addr_type) ||
800093ea:	e6 c9 00 32 	sub	r9,r3,50
800093ee:	30 18       	mov	r8,1
800093f0:	f0 09 18 00 	cp.b	r9,r8
800093f4:	e0 88 00 59 	brls	800094a6 <MsgTxFinal+0x162>
            {
                internal = MNS_FALSE;
            }
            else
            {
                status |= XMIT_SUCCESS;
800093f8:	30 04       	mov	r4,0
800093fa:	cd 0b       	rjmp	8000939a <MsgTxFinal+0x56>
        }
        #endif
        /*lint -esym(960,14.10) no else condition - no modification for non-internal messages*/
        if (EHCISTATE_IS_ATTACHED())                  /*lint +esym(960,14.10) re-enables rule*/
        {
            if (msg.cfg_ptr->tx_status_fptr)
800093fc:	4c 98       	lddpc	r8,80009520 <MsgTxFinal+0x1dc>
800093fe:	70 98       	ld.w	r8,r8[0x24]
80009400:	70 08       	ld.w	r8,r8[0x0]
80009402:	58 08       	cp.w	r8,0
80009404:	cd 10       	breq	800093a6 <MsgTxFinal+0x62>
            {
                cb_result = msg.cfg_ptr->tx_status_fptr(status, msg_ptr);
80009406:	0a 9b       	mov	r11,r5
80009408:	0c 9c       	mov	r12,r6
8000940a:	5d 18       	icall	r8

                if (((XMIT_SUCCESS == status) || (XMIT_NO_ICM == status)) &&
8000940c:	38 58       	mov	r8,-123
        /*lint -esym(960,14.10) no else condition - no modification for non-internal messages*/
        if (EHCISTATE_IS_ATTACHED())                  /*lint +esym(960,14.10) re-enables rule*/
        {
            if (msg.cfg_ptr->tx_status_fptr)
            {
                cb_result = msg.cfg_ptr->tx_status_fptr(status, msg_ptr);
8000940e:	18 92       	mov	r2,r12

                if (((XMIT_SUCCESS == status) || (XMIT_NO_ICM == status)) &&
80009410:	f0 06 18 00 	cp.b	r6,r8
80009414:	5f 09       	sreq	r9
80009416:	31 08       	mov	r8,16
80009418:	f0 06 18 00 	cp.b	r6,r8
8000941c:	5f 08       	sreq	r8
8000941e:	f3 e8 10 08 	or	r8,r9,r8
80009422:	cc 30       	breq	800093a8 <MsgTxFinal+0x64>
80009424:	58 0c       	cp.w	r12,0
80009426:	cc 10       	breq	800093a8 <MsgTxFinal+0x64>
                    (MSG_TX_FREE != cb_result))
                {
                    FAILED_ASSERT();
80009428:	e0 68 02 78 	mov	r8,632
8000942c:	30 1a       	mov	r10,1
8000942e:	1a d8       	st.w	--sp,r8
80009430:	31 0b       	mov	r11,16
80009432:	30 8c       	mov	r12,8
80009434:	30 02       	mov	r2,0
80009436:	fe b0 f3 5b 	rcall	80007aec <mns_trace>
8000943a:	2f fd       	sub	sp,-4
8000943c:	cb 6b       	rjmp	800093a8 <MsgTxFinal+0x64>
    /*lint -esym(960,14.10) no else condition - internal messages shall not effect sync_guard*/
    if (MSG_TGT_INIC != msg_ptr->Tgt_Adr)
    {
        if (XMIT_SYNC == status)
        {
            sync_guard += (byte)2;
8000943e:	4b 88       	lddpc	r8,8000951c <MsgTxFinal+0x1d8>
80009440:	11 89       	ld.ub	r9,r8[0x0]
80009442:	2f e9       	sub	r9,-2
80009444:	b0 89       	st.b	r8[0x0],r9
    
            if ((byte)5 <= sync_guard)
80009446:	30 4a       	mov	r10,4
80009448:	f4 09 18 00 	cp.b	r9,r10
8000944c:	fe 98 ff 9d 	brls	80009386 <MsgTxFinal+0x42>
            {
                sync_guard = (byte)0;
80009450:	30 09       	mov	r9,0
80009452:	b0 89       	st.b	r8[0x0],r9
                MisResetInic();
80009454:	e0 a0 0a 22 	rcall	8000a898 <MisResetInic>
            }
        }
    }
    /*lint +esym(960,14.10) re-enables rule*/

    if (((MSG_TGT_INIC == msg_ptr->Tgt_Adr)   &&
80009458:	ef 0c 00 1a 	ld.sh	r12,r7[26]
8000945c:	e8 0c 19 00 	cp.h	r12,r4
80009460:	c5 91       	brne	80009512 <MsgTxFinal+0x1ce>
    byte    cb_result;

    T_MOD_ENTRY(AMS_8);

    ASSERT(handle);
    msg_ptr   = MBM_GET_CTRL_TX_PTR(handle);
80009462:	ef 38 00 1e 	ld.ub	r8,r7[30]
80009466:	30 09       	mov	r9,0
80009468:	f2 08 18 00 	cp.b	r8,r9
8000946c:	c1 91       	brne	8000949e <MsgTxFinal+0x15a>
            }
        }
    }
    /*lint +esym(960,14.10) re-enables rule*/

    if (((MSG_TGT_INIC == msg_ptr->Tgt_Adr)   &&
8000946e:	38 39       	mov	r9,-125
80009470:	f2 06 18 00 	cp.b	r6,r9
80009474:	5f 1a       	srne	r10
80009476:	38 59       	mov	r9,-123
80009478:	f2 06 18 00 	cp.b	r6,r9
8000947c:	5f 19       	srne	r9
8000947e:	f5 e9 00 09 	and	r9,r10,r9
80009482:	f0 09 18 00 	cp.b	r9,r8
80009486:	c0 c0       	breq	8000949e <MsgTxFinal+0x15a>
80009488:	38 78       	mov	r8,-121
8000948a:	f0 06 18 00 	cp.b	r6,r8
8000948e:	ca a0       	breq	800093e2 <MsgTxFinal+0x9e>
         (FBLOCK_INIC == msg_ptr->FBlock_ID)) &&
        !((XMIT_NO_ICM == status) || (XMIT_SYNC == status) || (XMIT_PROTECTED_MODE == status)))
    {
        ASSERT(XMIT_SUCCESS == status);
80009490:	31 08       	mov	r8,16
80009492:	f0 06 18 00 	cp.b	r6,r8
80009496:	ca 10       	breq	800093d8 <MsgTxFinal+0x94>
80009498:	e0 68 02 52 	mov	r8,594
8000949c:	c9 7b       	rjmp	800093ca <MsgTxFinal+0x86>
8000949e:	30 1c       	mov	r12,1
800094a0:	c7 3b       	rjmp	80009386 <MsgTxFinal+0x42>
            #endif
        }
        #endif
    }

    switch (cb_result)
800094a2:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
            status = XMIT_SUCCESS;
        }
        else if ((MOST_CHECK_ADDR_GROUP     == addr_type) ||
                 (MOST_CHECK_ADDR_BROADCAST == addr_type))
        {
            if ((XMIT_FRMT == status) || (XMIT_TX_FILTER == status))
800094a6:	38 88       	mov	r8,-120
800094a8:	f0 06 18 00 	cp.b	r6,r8
800094ac:	5f 09       	sreq	r9
800094ae:	38 28       	mov	r8,-126
800094b0:	f0 06 18 00 	cp.b	r6,r8
800094b4:	5f 08       	sreq	r8
800094b6:	f3 e8 10 08 	or	r8,r9,r8
800094ba:	c9 f1       	brne	800093f8 <MsgTxFinal+0xb4>
            {
                internal = MNS_FALSE;
            }
            else
            {
                status |= XMIT_SUCCESS;
800094bc:	a5 a6       	sbr	r6,0x4
800094be:	30 14       	mov	r4,1
800094c0:	5c 56       	castu.b	r6
800094c2:	c6 cb       	rjmp	8000939a <MsgTxFinal+0x56>
            #endif
        }
        #endif
    }

    switch (cb_result)
800094c4:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
                MBM_SET_STATUS_BITS(handle, MBM_STAT_USE_BACKUP);
                handle->msg_backup = handle->msg;   /* copy message union */
            }
            #endif

            (void)MbmChangeType(handle, MBM_TYPE_CTRL_RX);
800094c8:	30 4b       	mov	r11,4
800094ca:	0e 9c       	mov	r12,r7
800094cc:	e0 a0 08 24 	rcall	8000a514 <MbmChangeType>
            rx_msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
            ASSERT(rx_msg_ptr);
            rx_msg_ptr->Src_Adr = MostGetNodeAdr();
800094d0:	e0 a0 42 26 	rcall	8001191c <MostGetNodeAdr>
            rx_msg_ptr->Rcv_Type = (addr_type & MOST_CHECK_ADDR_MASK_RTYP);
800094d4:	e7 d3 c0 02 	bfextu	r3,r3,0x0,0x2
            #endif

            (void)MbmChangeType(handle, MBM_TYPE_CTRL_RX);
            rx_msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
            ASSERT(rx_msg_ptr);
            rx_msg_ptr->Src_Adr = MostGetNodeAdr();
800094d8:	ef 5c 00 1a 	st.h	r7[26],r12
            rx_msg_ptr->Rcv_Type = (addr_type & MOST_CHECK_ADDR_MASK_RTYP);
800094dc:	ef 63 00 21 	st.b	r7[33],r3
            #ifdef MSG_RX_USER_PAYLOAD
            PmsInjectWaitingRx(handle);
            #else
            MsgRxInReady(rx_msg_ptr);
800094e0:	0a 9c       	mov	r12,r5
800094e2:	c1 bf       	rcall	80009318 <MsgRxInReady>
800094e4:	04 9c       	mov	r12,r2
800094e6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800094ea:	e0 68 02 35 	mov	r8,565

    ASSERT(handle);
    msg_ptr   = MBM_GET_CTRL_TX_PTR(handle);
    result    = PMS_RELEASE;
    cb_result = MSG_TX_FREE;
    ASSERT(msg_ptr);
800094ee:	30 1a       	mov	r10,1
800094f0:	1a d8       	st.w	--sp,r8
800094f2:	31 0b       	mov	r11,16
800094f4:	30 8c       	mov	r12,8
800094f6:	fe b0 f2 fb 	rcall	80007aec <mns_trace>
800094fa:	2f fd       	sub	sp,-4
800094fc:	c2 fb       	rjmp	8000935a <MsgTxFinal+0x16>
800094fe:	e0 68 02 31 	mov	r8,561
    byte    result;
    byte    cb_result;

    T_MOD_ENTRY(AMS_8);

    ASSERT(handle);
80009502:	30 1a       	mov	r10,1
80009504:	1a d8       	st.w	--sp,r8
80009506:	31 0b       	mov	r11,16
80009508:	30 8c       	mov	r12,8
8000950a:	fe b0 f2 f1 	rcall	80007aec <mns_trace>
8000950e:	2f fd       	sub	sp,-4
80009510:	c2 1b       	rjmp	80009352 <MsgTxFinal+0xe>
80009512:	5c 7c       	castu.h	r12
    else
    {
        
        #ifdef MCS_MIN
        bool internal = (XMIT_SUCCESS_INTERNAL == status) ? MNS_TRUE : MNS_FALSE;
        byte addr_type = MostCheckOwnAddress(msg_ptr->Tgt_Adr);
80009514:	e0 a0 41 c0 	rcall	80011894 <MostCheckOwnAddress>
80009518:	18 93       	mov	r3,r12
8000951a:	c6 8b       	rjmp	800093ea <MsgTxFinal+0xa6>
8000951c:	00 00       	add	r0,r0
8000951e:	2d 88       	sub	r8,-40
80009520:	00 00       	add	r0,r0
80009522:	2d 8c       	sub	r12,-40

80009524 <MsgSend3>:
80009524:	eb cd 40 c0 	pushm	r6-r7,lr
80009528:	18 97       	mov	r7,r12
8000952a:	58 0c       	cp.w	r12,0
8000952c:	c4 a0       	breq	800095c0 <MsgSend3+0x9c>
8000952e:	0e 9c       	mov	r12,r7
80009530:	e0 a0 04 3c 	rcall	80009da8 <MbmGetHandleByMsgPtr>
80009534:	18 96       	mov	r6,r12
80009536:	c4 f0       	breq	800095d4 <MsgSend3+0xb0>
80009538:	8e a8       	ld.uh	r8,r7[0x4]
8000953a:	1a d8       	st.w	--sp,r8
8000953c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80009540:	1a d8       	st.w	--sp,r8
80009542:	8e c8       	ld.uh	r8,r7[0x8]
80009544:	1a d8       	st.w	--sp,r8
80009546:	ef 38 00 0b 	ld.ub	r8,r7[11]
    ASSERT(msg_ptr);
    /*lint -e{413} See ASSERT  */
    handle = MbmGetHandleByMsgPtr(msg_ptr);
    ASSERT(handle);

    T_TX(msg_ptr->Tgt_Adr,  msg_ptr->FBlock_ID, msg_ptr->Inst_ID,
8000954a:	1a d8       	st.w	--sp,r8
8000954c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80009550:	1a d8       	st.w	--sp,r8
80009552:	8e b8       	ld.uh	r8,r7[0x6]
80009554:	30 6a       	mov	r10,6
80009556:	1a d8       	st.w	--sp,r8
80009558:	30 ab       	mov	r11,10
8000955a:	30 8c       	mov	r12,8
8000955c:	fe b0 f2 c8 	rcall	80007aec <mns_trace>
         msg_ptr->Func_ID, msg_ptr->Operation, msg_ptr->Length);

    #ifdef MCS_MIN
    msg_routing = MostCheckOwnAddress(msg_ptr->Tgt_Adr);
80009560:	8e bc       	ld.uh	r12,r7[0x6]
80009562:	e0 a0 41 99 	rcall	80011894 <MostCheckOwnAddress>

    if ((msg_routing & MOST_CHECK_ADDR_MASK_ROUTING) ==
80009566:	2f ad       	sub	sp,-24
80009568:	e2 1c 00 f0 	andl	r12,0xf0,COH
8000956c:	e0 4c 00 20 	cp.w	r12,32
80009570:	c2 20       	breq	800095b4 <MsgSend3+0x90>
    }
    else
    #endif

    #ifndef MNS_AVOID_ATTACH
    if ( EHCISTATE_IS_PROTECTED()                        &&
80009572:	e0 a0 0c bf 	rcall	8000aef0 <MnsGetEHCIState>
80009576:	c1 21       	brne	8000959a <MsgSend3+0x76>
         !(( MSG_TGT_INIC    == msg_ptr->Tgt_Adr  )      &&
80009578:	8e 38       	ld.sh	r8,r7[0x6]
8000957a:	30 19       	mov	r9,1
8000957c:	f2 08 19 00 	cp.h	r8,r9
80009580:	c0 71       	brne	8000958e <MsgSend3+0x6a>
           ((FBLOCK_INIC     == msg_ptr->FBlock_ID)    ||
80009582:	ef 39 00 0a 	ld.ub	r9,r7[10]
80009586:	f0 09 18 00 	cp.b	r9,r8
8000958a:	e0 88 00 0e 	brls	800095a6 <MsgSend3+0x82>
            (FBLOCK_NETBLOCK == msg_ptr->FBlock_ID))
           ))
    {
        (void)MsgTxFinal(handle, XMIT_PROTECTED_MODE);
8000958e:	0c 9c       	mov	r12,r6
80009590:	e0 6b 00 87 	mov	r11,135
80009594:	cd 8e       	rcall	80009344 <MsgTxFinal>
80009596:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    }
    else
    #endif

    #ifndef MNS_AVOID_ATTACH
    if ( EHCISTATE_IS_PROTECTED()                        &&
8000959a:	e0 a0 0c ab 	rcall	8000aef0 <MnsGetEHCIState>
8000959e:	3f f8       	mov	r8,-1
800095a0:	f0 0c 18 00 	cp.b	r12,r8
800095a4:	ce a0       	breq	80009578 <MsgSend3+0x54>
800095a6:	0c 9c       	mov	r12,r6
    #endif
    {
        #ifdef AAM_MIN
        AamSend2(handle, MsgTxFinal);
        #else
        PmsSend(handle, MsgTxFinal);
800095a8:	fe cb 02 64 	sub	r11,pc,612
800095ac:	e0 a0 1f 46 	rcall	8000d438 <PmsSend>
800095b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    msg_routing = MostCheckOwnAddress(msg_ptr->Tgt_Adr);

    if ((msg_routing & MOST_CHECK_ADDR_MASK_ROUTING) ==
         MOST_CHECK_ADDR_INT_ONLY)
    {
        (void)MsgTxFinal(handle, XMIT_SUCCESS_INTERNAL);
800095b4:	0c 9c       	mov	r12,r6
800095b6:	e0 6b 00 86 	mov	r11,134
800095ba:	cc 5e       	rcall	80009344 <MsgTxFinal>
800095bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800095c0:	e0 68 01 fc 	mov	r8,508
    handle      = NULL;
    #ifdef MCS_MIN
    msg_routing = 0;
    #endif

    ASSERT(msg_ptr);
800095c4:	30 1a       	mov	r10,1
800095c6:	1a d8       	st.w	--sp,r8
800095c8:	31 0b       	mov	r11,16
800095ca:	30 8c       	mov	r12,8
800095cc:	fe b0 f2 90 	rcall	80007aec <mns_trace>
800095d0:	2f fd       	sub	sp,-4
800095d2:	ca eb       	rjmp	8000952e <MsgSend3+0xa>
800095d4:	e0 68 01 ff 	mov	r8,511
    /*lint -e{413} See ASSERT  */
    handle = MbmGetHandleByMsgPtr(msg_ptr);
    ASSERT(handle);
800095d8:	30 1a       	mov	r10,1
800095da:	1a d8       	st.w	--sp,r8
800095dc:	31 0b       	mov	r11,16
800095de:	30 8c       	mov	r12,8
800095e0:	fe b0 f2 86 	rcall	80007aec <mns_trace>
800095e4:	2f fd       	sub	sp,-4
800095e6:	ca 9b       	rjmp	80009538 <MsgSend3+0x14>

800095e8 <MsgSendRetryParams>:
800095e8:	eb cd 40 c0 	pushm	r6-r7,lr
800095ec:	30 2c       	mov	r12,2
800095ee:	fe b0 fc 57 	rcall	80008e9c <MsgGetTxPtrExt>
800095f2:	18 97       	mov	r7,r12
800095f4:	c4 00       	breq	80009674 <MsgSendRetryParams+0x8c>
800095f6:	30 bc       	mov	r12,11
800095f8:	fe b0 f2 5f 	rcall	80007ab6 <mns_take>
800095fc:	4a 66       	lddpc	r6,80009694 <MsgSendRetryParams+0xac>
800095fe:	ed 39 00 2c 	ld.ub	r9,r6[44]
80009602:	ed 38 00 2f 	ld.ub	r8,r6[47]
    msg_ptr = MsgGetTxPtrExt(2);

    if (msg_ptr)
    {
        TAKE_MSG();
        if ((msg.retry_cfg.total_attempts != msg.retry_cfg.shadow.total_attempts)
80009606:	f0 09 18 00 	cp.b	r9,r8
8000960a:	c2 30       	breq	80009650 <MsgSendRetryParams+0x68>
            ||(msg.retry_cfg.time != msg.retry_cfg.shadow.time))    /* check changes once again in case retries are performed */
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;                     /* at least one value will change */
8000960c:	30 18       	mov	r8,1
            msg_ptr->FBlock_ID  = FBLOCK_NETBLOCK;
8000960e:	ef 68 00 0a 	st.b	r7[10],r8
    {
        TAKE_MSG();
        if ((msg.retry_cfg.total_attempts != msg.retry_cfg.shadow.total_attempts)
            ||(msg.retry_cfg.time != msg.retry_cfg.shadow.time))    /* check changes once again in case retries are performed */
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;                     /* at least one value will change */
80009612:	ae 38       	st.h	r7[0x6],r8
            msg_ptr->FBlock_ID  = FBLOCK_NETBLOCK;
            msg_ptr->Func_ID    = FUNC_RETRYPARAMETERS;
80009614:	30 78       	mov	r8,7

            if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
80009616:	e0 6c 40 00 	mov	r12,16384
        if ((msg.retry_cfg.total_attempts != msg.retry_cfg.shadow.total_attempts)
            ||(msg.retry_cfg.time != msg.retry_cfg.shadow.time))    /* check changes once again in case retries are performed */
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;                     /* at least one value will change */
            msg_ptr->FBlock_ID  = FBLOCK_NETBLOCK;
            msg_ptr->Func_ID    = FUNC_RETRYPARAMETERS;
8000961a:	ae 48       	st.h	r7[0x8],r8

            if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
8000961c:	e0 a0 0c 4c 	rcall	8000aeb4 <MostIsSupported>
            {
                msg_ptr->Operation  = OP_SETGET;
80009620:	f9 b8 01 02 	movne	r8,2
80009624:	ef f8 1e 0c 	st.bne	r7[0xc],r8
            }
            else
            {
                msg_ptr->Operation  = OP_SET;
80009628:	ef fc 0e 0c 	st.beq	r7[0xc],r12
            }

            msg_ptr->Data[0]    = msg.retry_cfg.time;
8000962c:	6e 08       	ld.w	r8,r7[0x0]
8000962e:	ed 39 00 2b 	ld.ub	r9,r6[43]
80009632:	b0 89       	st.b	r8[0x0],r9
            msg_ptr->Data[1]    = msg.retry_cfg.total_attempts;
80009634:	6e 08       	ld.w	r8,r7[0x0]
80009636:	ed 39 00 2c 	ld.ub	r9,r6[44]
8000963a:	b0 99       	st.b	r8[0x1],r9
            msg.retry_cfg.busy  = MNS_TRUE;
8000963c:	30 18       	mov	r8,1
        else
        {
            /* no changes - release busy flag */
            msg.retry_cfg.busy = MNS_FALSE;
        }
        GIVE_MSG();
8000963e:	30 bc       	mov	r12,11
                msg_ptr->Operation  = OP_SET;
            }

            msg_ptr->Data[0]    = msg.retry_cfg.time;
            msg_ptr->Data[1]    = msg.retry_cfg.total_attempts;
            msg.retry_cfg.busy  = MNS_TRUE;
80009640:	ed 68 00 2d 	st.b	r6[45],r8
        else
        {
            /* no changes - release busy flag */
            msg.retry_cfg.busy = MNS_FALSE;
        }
        GIVE_MSG();
80009644:	fe b0 f2 3a 	rcall	80007ab8 <mns_give>

        if (MNS_FALSE != send_msg)
        {
            MsgSend3(msg_ptr);
80009648:	0e 9c       	mov	r12,r7
8000964a:	c6 df       	rcall	80009524 <MsgSend3>
8000964c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80009650:	ed 39 00 2b 	ld.ub	r9,r6[43]
    msg_ptr = MsgGetTxPtrExt(2);

    if (msg_ptr)
    {
        TAKE_MSG();
        if ((msg.retry_cfg.total_attempts != msg.retry_cfg.shadow.total_attempts)
80009654:	ed 38 00 2e 	ld.ub	r8,r6[46]
80009658:	f0 09 18 00 	cp.b	r9,r8
8000965c:	cd 81       	brne	8000960c <MsgSendRetryParams+0x24>
8000965e:	30 08       	mov	r8,0
            send_msg            = MNS_TRUE;
        }
        else
        {
            /* no changes - release busy flag */
            msg.retry_cfg.busy = MNS_FALSE;
80009660:	30 bc       	mov	r12,11
        }
        GIVE_MSG();
80009662:	ed 68 00 2d 	st.b	r6[45],r8
            send_msg            = MNS_TRUE;
        }
        else
        {
            /* no changes - release busy flag */
            msg.retry_cfg.busy = MNS_FALSE;
80009666:	fe b0 f2 29 	rcall	80007ab8 <mns_give>
        }
        GIVE_MSG();
8000966a:	0e 9c       	mov	r12,r7
        {
            MsgSend3(msg_ptr);
        }
        else
        {
            MsgTxUnused(msg_ptr);
8000966c:	fe b0 fc 64 	rcall	80008f34 <MsgTxUnused>
80009670:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80009674:	30 ac       	mov	r12,10
        }
    }
    else
    {
        SCHEDULE_RETRY(MSG_RETRY_RETRYPARAMS);
80009676:	fe b0 f2 20 	rcall	80007ab6 <mns_take>
8000967a:	48 79       	lddpc	r9,80009694 <MsgSendRetryParams+0xac>
8000967c:	f3 08 00 20 	ld.sh	r8,r9[32]
80009680:	a5 a8       	sbr	r8,0x4
80009682:	30 ac       	mov	r12,10
80009684:	f3 58 00 20 	st.h	r9[32],r8
80009688:	fe b0 f2 18 	rcall	80007ab8 <mns_give>
8000968c:	30 4c       	mov	r12,4
8000968e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(AMS_46);
    return(result);
}
80009692:	d7 03       	nop
80009694:	00 00       	add	r0,r0
80009696:	2d 8c       	sub	r12,-40

80009698 <MsgRequestRetryParams>:
80009698:	eb cd 40 c0 	pushm	r6-r7,lr
8000969c:	30 0c       	mov	r12,0
8000969e:	fe b0 fb ff 	rcall	80008e9c <MsgGetTxPtrExt>
800096a2:	18 97       	mov	r7,r12
800096a4:	30 bc       	mov	r12,11
800096a6:	fe b0 f2 08 	rcall	80007ab6 <mns_take>
800096aa:	30 18       	mov	r8,1
800096ac:	49 16       	lddpc	r6,800096f0 <MsgRequestRetryParams+0x58>
800096ae:	30 bc       	mov	r12,11

    result = ERR_NO;
    msg_ptr = MsgGetTxPtrExt(0);

    TAKE_MSG();
    msg.retry_cfg.busy = MNS_TRUE;
800096b0:	ed 68 00 2d 	st.b	r6[45],r8
    GIVE_MSG();
800096b4:	fe b0 f2 02 	rcall	80007ab8 <mns_give>

    if (msg_ptr)
800096b8:	58 07       	cp.w	r7,0
800096ba:	c0 d0       	breq	800096d4 <MsgRequestRetryParams+0x3c>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800096bc:	30 18       	mov	r8,1
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Func_ID   = FUNC_RETRYPARAMETERS;
        msg_ptr->Operation = OP_GET;
800096be:	ef 68 00 0c 	st.b	r7[12],r8
    msg.retry_cfg.busy = MNS_TRUE;
    GIVE_MSG();

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800096c2:	ae 38       	st.h	r7[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
800096c4:	ef 68 00 0a 	st.b	r7[10],r8
        msg_ptr->Func_ID   = FUNC_RETRYPARAMETERS;
800096c8:	30 78       	mov	r8,7
        msg_ptr->Operation = OP_GET;

        MsgSend3(msg_ptr);
800096ca:	0e 9c       	mov	r12,r7

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Func_ID   = FUNC_RETRYPARAMETERS;
800096cc:	ae 48       	st.h	r7[0x8],r8
        msg_ptr->Operation = OP_GET;

        MsgSend3(msg_ptr);
800096ce:	c2 bf       	rcall	80009524 <MsgSend3>
800096d0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800096d4:	30 ac       	mov	r12,10
    }
    else
    {
        SCHEDULE_RETRY(MSG_RETRY_REQ_RETRYPARAMS);
800096d6:	fe b0 f1 f0 	rcall	80007ab6 <mns_take>
800096da:	ed 08 00 20 	ld.sh	r8,r6[32]
800096de:	a3 b8       	sbr	r8,0x3
800096e0:	30 ac       	mov	r12,10
800096e2:	ed 58 00 20 	st.h	r6[32],r8
800096e6:	fe b0 f1 e9 	rcall	80007ab8 <mns_give>
800096ea:	30 4c       	mov	r12,4
800096ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(AMS_45);
    return(result);
}
800096f0:	00 00       	add	r0,r0
800096f2:	2d 8c       	sub	r12,-40

800096f4 <MsgHandleRetryOptionsStatus>:
800096f4:	d4 01       	pushm	lr
800096f6:	cd 1f       	rcall	80009698 <MsgRequestRetryParams>
800096f8:	d8 02       	popm	pc
800096fa:	d7 03       	nop

800096fc <MsgForceSegMode>:
800096fc:	eb cd 40 80 	pushm	r7,lr
80009700:	30 1c       	mov	r12,1
80009702:	fe b0 fb cd 	rcall	80008e9c <MsgGetTxPtrExt>
80009706:	18 97       	mov	r7,r12
    T_MOD_ENTRY(AMS_33);

    result  = ERR_NO;
    msg_ptr = MsgGetTxPtrExt(1);

    if (msg_ptr)
80009708:	c1 b0       	breq	8000973e <MsgForceSegMode+0x42>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000970a:	30 18       	mov	r8,1
8000970c:	ae 38       	st.h	r7[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000970e:	30 08       	mov	r8,0
80009710:	ef 68 00 0a 	st.b	r7[10],r8
        msg_ptr->Func_ID   = FUNCID_INIC_ABILITYTOSEGMENT;
80009714:	e0 68 03 06 	mov	r8,774
80009718:	ae 48       	st.h	r7[0x8],r8
        msg_ptr->Operation = OP_SETGET;
8000971a:	30 28       	mov	r8,2
        TAKE_MSG();
8000971c:	30 bc       	mov	r12,11
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_ABILITYTOSEGMENT;
        msg_ptr->Operation = OP_SETGET;
8000971e:	ef 68 00 0c 	st.b	r7[12],r8
        TAKE_MSG();
80009722:	fe b0 f1 ca 	rcall	80007ab6 <mns_take>
        msg_ptr->Data[0]   = msg.seg.ats.value;
80009726:	6e 08       	ld.w	r8,r7[0x0]
80009728:	48 d9       	lddpc	r9,8000975c <MsgForceSegMode+0x60>
8000972a:	f3 39 00 28 	ld.ub	r9,r9[40]
        GIVE_MSG();
8000972e:	30 bc       	mov	r12,11
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_ABILITYTOSEGMENT;
        msg_ptr->Operation = OP_SETGET;
        TAKE_MSG();
        msg_ptr->Data[0]   = msg.seg.ats.value;
80009730:	b0 89       	st.b	r8[0x0],r9
        GIVE_MSG();
80009732:	fe b0 f1 c3 	rcall	80007ab8 <mns_give>

        MsgSend3(msg_ptr);
80009736:	0e 9c       	mov	r12,r7
80009738:	cf 6e       	rcall	80009524 <MsgSend3>
8000973a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000973e:	30 ac       	mov	r12,10
    }
    else
    {
        SCHEDULE_RETRY(MSG_RETRY_SEGMODE);
80009740:	fe b0 f1 bb 	rcall	80007ab6 <mns_take>
80009744:	48 69       	lddpc	r9,8000975c <MsgForceSegMode+0x60>
80009746:	f3 08 00 20 	ld.sh	r8,r9[32]
8000974a:	a1 b8       	sbr	r8,0x1
8000974c:	30 ac       	mov	r12,10
8000974e:	f3 58 00 20 	st.h	r9[32],r8
80009752:	fe b0 f1 b3 	rcall	80007ab8 <mns_give>
80009756:	30 4c       	mov	r12,4
80009758:	e3 cd 80 80 	ldm	sp++,r7,pc
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(AMS_33);
    return(result);
}
8000975c:	00 00       	add	r0,r0
8000975e:	2d 8c       	sub	r12,-40

80009760 <MsgHandleAbilityToSegmentStatus>:
80009760:	eb cd 40 c0 	pushm	r6-r7,lr
80009764:	18 97       	mov	r7,r12
80009766:	58 0c       	cp.w	r12,0
80009768:	c1 e0       	breq	800097a4 <MsgHandleAbilityToSegmentStatus+0x44>
8000976a:	30 bc       	mov	r12,11
8000976c:	fe b0 f1 a5 	rcall	80007ab6 <mns_take>
80009770:	6e 08       	ld.w	r8,r7[0x0]
80009772:	11 87       	ld.ub	r7,r8[0x0]
    T_LIB_ENTRY(AMS_29);

    ASSERT(msg_ptr);

    TAKE_MSG();
    msg.seg.ats.shadow = msg_ptr->Data[0];
80009774:	49 18       	lddpc	r8,800097b8 <MsgHandleAbilityToSegmentStatus+0x58>
    ats_shadow         = msg.seg.ats.shadow;
    ats_value          = msg.seg.ats.value;
    GIVE_MSG();
80009776:	30 bc       	mov	r12,11
    T_LIB_ENTRY(AMS_29);

    ASSERT(msg_ptr);

    TAKE_MSG();
    msg.seg.ats.shadow = msg_ptr->Data[0];
80009778:	f1 67 00 29 	st.b	r8[41],r7
    ats_shadow         = msg.seg.ats.shadow;
    ats_value          = msg.seg.ats.value;
8000977c:	f1 36 00 28 	ld.ub	r6,r8[40]
    GIVE_MSG();
80009780:	fe b0 f1 9c 	rcall	80007ab8 <mns_give>

    if (!EHCISTATE_IS_ATTACHED())
80009784:	e0 a0 0b b6 	rcall	8000aef0 <MnsGetEHCIState>
80009788:	30 28       	mov	r8,2
8000978a:	f0 0c 18 00 	cp.b	r12,r8
8000978e:	c0 50       	breq	80009798 <MsgHandleAbilityToSegmentStatus+0x38>
    {
        MnsNtfCheck(NTF_ABILITY_TO_SEGMENT);
80009790:	e0 6c 20 00 	mov	r12,8192
80009794:	e0 a0 0b 6c 	rcall	8000ae6c <MnsNtfCheck>
    }

    /* Change the INIC.AbilityToSegment property if it differs from value
     * we want to have.
     */
    if (ats_value != ats_shadow)
80009798:	ec 07 18 00 	cp.b	r7,r6
8000979c:	c0 20       	breq	800097a0 <MsgHandleAbilityToSegmentStatus+0x40>
    {
        (void)MsgForceSegMode();
8000979e:	ca ff       	rcall	800096fc <MsgForceSegMode>
800097a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800097a4:	e0 68 04 ea 	mov	r8,1258
    byte ats_shadow;
    byte ats_value;

    T_LIB_ENTRY(AMS_29);

    ASSERT(msg_ptr);
800097a8:	30 1a       	mov	r10,1
800097aa:	1a d8       	st.w	--sp,r8
800097ac:	31 0b       	mov	r11,16
800097ae:	30 8c       	mov	r12,8
800097b0:	fe b0 f1 9e 	rcall	80007aec <mns_trace>
800097b4:	2f fd       	sub	sp,-4
800097b6:	cd ab       	rjmp	8000976a <MsgHandleAbilityToSegmentStatus+0xa>
800097b8:	00 00       	add	r0,r0
800097ba:	2d 8c       	sub	r12,-40

800097bc <MsgForceMidLevelRetries>:
800097bc:	d4 01       	pushm	lr
800097be:	30 3c       	mov	r12,3
800097c0:	fe b0 fb 6e 	rcall	80008e9c <MsgGetTxPtrExt>
800097c4:	c1 60       	breq	800097f0 <MsgForceMidLevelRetries+0x34>
800097c6:	30 1a       	mov	r10,1
800097c8:	b8 3a       	st.h	r12[0x6],r10
800097ca:	30 0a       	mov	r10,0
800097cc:	f9 6a 00 0a 	st.b	r12[10],r10
800097d0:	e0 6a 03 03 	mov	r10,771
800097d4:	30 29       	mov	r9,2
800097d6:	b8 4a       	st.h	r12[0x8],r10
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_MIDLEVELRETRY;
        msg_ptr->Operation = OP_SETGET;
800097d8:	f9 69 00 0c 	st.b	r12[12],r9
        msg_ptr->Data[0]   = TIME_MSG_TX_RETRY;
800097dc:	78 0a       	ld.w	r10,r12[0x0]
800097de:	31 4b       	mov	r11,20
800097e0:	b4 8b       	st.b	r10[0x0],r11
        msg_ptr->Data[1]   = DEF_MID_LEVEL_RETRIES_INT_PROC;
800097e2:	78 0a       	ld.w	r10,r12[0x0]
800097e4:	b4 99       	st.b	r10[0x1],r9
        msg_ptr->Data[2]   = DEF_MID_LEVEL_RETRIES;
800097e6:	30 39       	mov	r9,3
800097e8:	78 08       	ld.w	r8,r12[0x0]
800097ea:	b0 a9       	st.b	r8[0x2],r9

        MsgSend3(msg_ptr);
800097ec:	c9 ce       	rcall	80009524 <MsgSend3>
800097ee:	d8 0a       	popm	pc,r12=0
800097f0:	30 ac       	mov	r12,10
    }
    else
    {
        SCHEDULE_RETRY(AMS_RETRY_MIDLEVEL_RETRIES);
800097f2:	fe b0 f1 62 	rcall	80007ab6 <mns_take>
800097f6:	48 69       	lddpc	r9,8000980c <MsgForceMidLevelRetries+0x50>
800097f8:	f3 08 00 20 	ld.sh	r8,r9[32]
800097fc:	a1 a8       	sbr	r8,0x0
800097fe:	30 ac       	mov	r12,10
80009800:	f3 58 00 20 	st.h	r9[32],r8
80009804:	fe b0 f1 5a 	rcall	80007ab8 <mns_give>
80009808:	30 4c       	mov	r12,4
8000980a:	d8 02       	popm	pc
    }

    T_MOD_EXIT(AMS_34);

    return(result);
}
8000980c:	00 00       	add	r0,r0
8000980e:	2d 8c       	sub	r12,-40

80009810 <MsgRequestSegMode>:
80009810:	d4 01       	pushm	lr
80009812:	30 0c       	mov	r12,0
80009814:	fe b0 fb 44 	rcall	80008e9c <MsgGetTxPtrExt>
80009818:	c0 d0       	breq	80009832 <MsgRequestSegMode+0x22>
8000981a:	30 19       	mov	r9,1
8000981c:	f9 69 00 0c 	st.b	r12[12],r9
80009820:	b8 39       	st.h	r12[0x6],r9
80009822:	30 09       	mov	r9,0
    msg_ptr = MsgGetTxPtrExt(0);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
80009824:	f9 69 00 0a 	st.b	r12[10],r9
        msg_ptr->Func_ID   = FUNCID_INIC_ABILITYTOSEGMENT;
80009828:	e0 69 03 06 	mov	r9,774
8000982c:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_GET;

        MsgSend3(msg_ptr);
8000982e:	c7 be       	rcall	80009524 <MsgSend3>
80009830:	d8 0a       	popm	pc,r12=0
80009832:	30 ac       	mov	r12,10
    }
    else
    {
        SCHEDULE_RETRY(MSG_RETRY_REQ_SEGMODE);
80009834:	fe b0 f1 41 	rcall	80007ab6 <mns_take>
80009838:	48 69       	lddpc	r9,80009850 <MsgRequestSegMode+0x40>
8000983a:	f3 08 00 20 	ld.sh	r8,r9[32]
8000983e:	a3 a8       	sbr	r8,0x2
80009840:	30 ac       	mov	r12,10
80009842:	f3 58 00 20 	st.h	r9[32],r8
80009846:	fe b0 f1 39 	rcall	80007ab8 <mns_give>
8000984a:	30 4c       	mov	r12,4
8000984c:	d8 02       	popm	pc
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(AMS_34);
    return(result);
}
8000984e:	d7 03       	nop
80009850:	00 00       	add	r0,r0
80009852:	2d 8c       	sub	r12,-40

80009854 <MsgSend2>:
80009854:	d4 21       	pushm	r4-r7,lr
80009856:	18 97       	mov	r7,r12
80009858:	58 0c       	cp.w	r12,0
8000985a:	c7 00       	breq	8000993a <MsgSend2+0xe6>
8000985c:	0e 9c       	mov	r12,r7
8000985e:	e0 a0 02 a5 	rcall	80009da8 <MbmGetHandleByMsgPtr>
80009862:	18 96       	mov	r6,r12
    result = MSG_TX_FILTER_DEFAULT;

    ASSERT(msg_ptr);
    /*lint -e{413} See ASSERT  */
    handle = MbmGetHandleByMsgPtr(msg_ptr);
    ASSERT(handle);
80009864:	c7 50       	breq	8000994e <MsgSend2+0xfa>

    #ifdef NS_AMS_MSV2
    result = ConfigStateFilterV2(msg_ptr);        /* Configuration state based message filter */
80009866:	0e 9c       	mov	r12,r7
80009868:	e0 a0 5a 58 	rcall	80014d18 <ConfigStateFilterV2>
    if ( msg.cbTxMsgFlushed_fptr &&
8000986c:	4c 14       	lddpc	r4,80009970 <MsgSend2+0x11c>
8000986e:	30 1a       	mov	r10,1
80009870:	68 d8       	ld.w	r8,r4[0x34]
80009872:	f4 0c 18 00 	cp.b	r12,r10
80009876:	5f 0a       	sreq	r10
80009878:	58 08       	cp.w	r8,0
8000987a:	5f 19       	srne	r9
    /*lint -e{413} See ASSERT  */
    handle = MbmGetHandleByMsgPtr(msg_ptr);
    ASSERT(handle);

    #ifdef NS_AMS_MSV2
    result = ConfigStateFilterV2(msg_ptr);        /* Configuration state based message filter */
8000987c:	18 95       	mov	r5,r12
    if ( msg.cbTxMsgFlushed_fptr &&
8000987e:	f5 e9 00 09 	and	r9,r10,r9
80009882:	c4 c1       	brne	8000991a <MsgSend2+0xc6>
        msg.cbTxMsgFlushed_fptr(msg_ptr);
    }
    #endif

    #ifdef VMSV_MIN
    if (MSG_TX_FILTER_DEFAULT == result)
80009884:	58 0c       	cp.w	r12,0
80009886:	c1 d0       	breq	800098c0 <MsgSend2+0x6c>
         EHCISTATE_IS_ATTACHED())
    {
        result = msg.cfg_ptr->tx_filter_fptr(msg_ptr);
    }

    switch (result)
80009888:	30 18       	mov	r8,1
8000988a:	f0 05 18 00 	cp.b	r5,r8
8000988e:	c4 20       	breq	80009912 <MsgSend2+0xbe>
80009890:	f0 05 18 00 	cp.b	r5,r8
80009894:	c2 53       	brcs	800098de <MsgSend2+0x8a>
80009896:	30 28       	mov	r8,2
80009898:	f0 05 18 00 	cp.b	r5,r8
8000989c:	c4 60       	breq	80009928 <MsgSend2+0xd4>
            MbmEnqueue(&(msg.tx_queue), handle);
            MsgSetPendingEvent(AMS_P_TX);
            break;

        default:
            FAILED_ASSERT();
8000989e:	e0 68 01 d8 	mov	r8,472
800098a2:	30 1a       	mov	r10,1
800098a4:	1a d8       	st.w	--sp,r8
800098a6:	31 0b       	mov	r11,16
800098a8:	30 8c       	mov	r12,8
800098aa:	fe b0 f1 21 	rcall	80007aec <mns_trace>

        /*lint -e(616) default case before MSG_TX_FILTER_DEFAULT */
        case MSG_TX_FILTER_DEFAULT:
            if ((MSG_TGT_INIC == msg_ptr->Tgt_Adr) &&
800098ae:	8e 39       	ld.sh	r9,r7[0x6]
            MbmEnqueue(&(msg.tx_queue), handle);
            MsgSetPendingEvent(AMS_P_TX);
            break;

        default:
            FAILED_ASSERT();
800098b0:	2f fd       	sub	sp,-4

        /*lint -e(616) default case before MSG_TX_FILTER_DEFAULT */
        case MSG_TX_FILTER_DEFAULT:
            if ((MSG_TGT_INIC == msg_ptr->Tgt_Adr) &&
800098b2:	30 18       	mov	r8,1
800098b4:	f0 09 19 00 	cp.h	r9,r8
800098b8:	c1 80       	breq	800098e8 <MsgSend2+0x94>
                FAILED_ASSERT();
                (void)MsgTxFinal(handle, XMIT_NO_ICM);
            }
            else
            {
                MsgSend3(msg_ptr);
800098ba:	0e 9c       	mov	r12,r7
800098bc:	c3 4e       	rcall	80009524 <MsgSend3>
800098be:	d8 22       	popm	r4-r7,pc
800098c0:	0e 9c       	mov	r12,r7
    #endif

    #ifdef VMSV_MIN
    if (MSG_TX_FILTER_DEFAULT == result)
    {
        result = VmsvTxFilter(msg_ptr);
800098c2:	e0 a0 30 97 	rcall	8000f9f0 <VmsvTxFilter>
800098c6:	18 95       	mov	r5,r12
800098c8:	ce 01       	brne	80009888 <MsgSend2+0x34>
    }
    #endif

    if ((MSG_TX_FILTER_DEFAULT == result) &&
800098ca:	68 98       	ld.w	r8,r4[0x24]
         msg.cfg_ptr->tx_filter_fptr      &&
800098cc:	70 18       	ld.w	r8,r8[0x4]
800098ce:	58 08       	cp.w	r8,0
800098d0:	c0 70       	breq	800098de <MsgSend2+0x8a>
800098d2:	e0 a0 0b 0f 	rcall	8000aef0 <MnsGetEHCIState>
         EHCISTATE_IS_ATTACHED())
800098d6:	30 28       	mov	r8,2
    {
        result = VmsvTxFilter(msg_ptr);
    }
    #endif

    if ((MSG_TX_FILTER_DEFAULT == result) &&
800098d8:	f0 0c 18 00 	cp.b	r12,r8
800098dc:	c4 30       	breq	80009962 <MsgSend2+0x10e>
800098de:	8e 39       	ld.sh	r9,r7[0x6]
        default:
            FAILED_ASSERT();

        /*lint -e(616) default case before MSG_TX_FILTER_DEFAULT */
        case MSG_TX_FILTER_DEFAULT:
            if ((MSG_TGT_INIC == msg_ptr->Tgt_Adr) &&
800098e0:	30 18       	mov	r8,1
800098e2:	f0 09 19 00 	cp.h	r9,r8
800098e6:	ce a1       	brne	800098ba <MsgSend2+0x66>
800098e8:	ef 39 00 0a 	ld.ub	r9,r7[10]
                (FBLOCK_INIC == msg_ptr->FBlock_ID))
800098ec:	30 08       	mov	r8,0
800098ee:	f0 09 18 00 	cp.b	r9,r8
800098f2:	ce 41       	brne	800098ba <MsgSend2+0x66>
800098f4:	e0 68 01 df 	mov	r8,479
            {
                FAILED_ASSERT();
800098f8:	30 1a       	mov	r10,1
800098fa:	1a d8       	st.w	--sp,r8
800098fc:	31 0b       	mov	r11,16
800098fe:	30 8c       	mov	r12,8
80009900:	fe b0 f0 f6 	rcall	80007aec <mns_trace>
80009904:	0c 9c       	mov	r12,r6
                (void)MsgTxFinal(handle, XMIT_NO_ICM);
80009906:	e0 6b 00 85 	mov	r11,133
8000990a:	fe b0 fd 1d 	rcall	80009344 <MsgTxFinal>
8000990e:	2f fd       	sub	sp,-4
        default:
            FAILED_ASSERT();

        /*lint -e(616) default case before MSG_TX_FILTER_DEFAULT */
        case MSG_TX_FILTER_DEFAULT:
            if ((MSG_TGT_INIC == msg_ptr->Tgt_Adr) &&
80009910:	d8 22       	popm	r4-r7,pc
80009912:	0c 9c       	mov	r12,r6
    }

    switch (result)
    {
        case MSG_TX_FILTER_CANCEL:
            MbmFree(handle);
80009914:	e0 a0 1b 22 	rcall	8000cf58 <MbmFree>
80009918:	d8 22       	popm	r4-r7,pc
            break;
8000991a:	0e 9c       	mov	r12,r7
    #ifdef NS_AMS_MSV2
    result = ConfigStateFilterV2(msg_ptr);        /* Configuration state based message filter */
    if ( msg.cbTxMsgFlushed_fptr &&
        (MSG_TX_FILTER_CANCEL == result) )
    {
        msg.cbTxMsgFlushed_fptr(msg_ptr);
8000991c:	5d 18       	icall	r8
8000991e:	30 18       	mov	r8,1
         EHCISTATE_IS_ATTACHED())
    {
        result = msg.cfg_ptr->tx_filter_fptr(msg_ptr);
    }

    switch (result)
80009920:	f0 05 18 00 	cp.b	r5,r8
80009924:	cb 61       	brne	80009890 <MsgSend2+0x3c>
80009926:	cf 6b       	rjmp	80009912 <MsgSend2+0xbe>
80009928:	e8 cc ff ec 	sub	r12,r4,-20
        case MSG_TX_FILTER_CANCEL:
            MbmFree(handle);
            break;

        case MSG_TX_FILTER_BUSY:
            MbmEnqueue(&(msg.tx_queue), handle);
8000992c:	0c 9b       	mov	r11,r6
8000992e:	e0 a0 04 c7 	rcall	8000a2bc <MbmEnqueue>
80009932:	30 1c       	mov	r12,1
            MsgSetPendingEvent(AMS_P_TX);
80009934:	fe b0 fb 22 	rcall	80008f78 <MsgSetPendingEvent>
80009938:	d8 22       	popm	r4-r7,pc
            break;
8000993a:	e0 68 01 b0 	mov	r8,432
    T_API_ENTRY(AMS_6);

    handle = NULL;
    result = MSG_TX_FILTER_DEFAULT;

    ASSERT(msg_ptr);
8000993e:	30 1a       	mov	r10,1
80009940:	1a d8       	st.w	--sp,r8
80009942:	31 0b       	mov	r11,16
80009944:	30 8c       	mov	r12,8
80009946:	fe b0 f0 d3 	rcall	80007aec <mns_trace>
8000994a:	2f fd       	sub	sp,-4
8000994c:	c8 8b       	rjmp	8000985c <MsgSend2+0x8>
8000994e:	e0 68 01 b3 	mov	r8,435
    /*lint -e{413} See ASSERT  */
    handle = MbmGetHandleByMsgPtr(msg_ptr);
    ASSERT(handle);
80009952:	30 1a       	mov	r10,1
80009954:	1a d8       	st.w	--sp,r8
80009956:	31 0b       	mov	r11,16
80009958:	30 8c       	mov	r12,8
8000995a:	fe b0 f0 c9 	rcall	80007aec <mns_trace>
8000995e:	2f fd       	sub	sp,-4
80009960:	c8 3b       	rjmp	80009866 <MsgSend2+0x12>
80009962:	68 98       	ld.w	r8,r4[0x24]

    if ((MSG_TX_FILTER_DEFAULT == result) &&
         msg.cfg_ptr->tx_filter_fptr      &&
         EHCISTATE_IS_ATTACHED())
    {
        result = msg.cfg_ptr->tx_filter_fptr(msg_ptr);
80009964:	0e 9c       	mov	r12,r7
80009966:	70 18       	ld.w	r8,r8[0x4]
80009968:	5d 18       	icall	r8
8000996a:	18 95       	mov	r5,r12
8000996c:	c8 eb       	rjmp	80009888 <MsgSend2+0x34>
8000996e:	d7 03       	nop
80009970:	00 00       	add	r0,r0
80009972:	2d 8c       	sub	r12,-40

80009974 <MsgSend>:
80009974:	eb cd 40 80 	pushm	r7,lr
80009978:	18 97       	mov	r7,r12
8000997a:	58 0c       	cp.w	r12,0
8000997c:	c4 40       	breq	80009a04 <MsgSend+0x90>
8000997e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80009982:	33 f8       	mov	r8,63
80009984:	f0 09 18 00 	cp.b	r9,r8
80009988:	e0 8b 00 34 	brhi	800099f0 <MsgSend+0x7c>
8000998c:	ef 39 00 0e 	ld.ub	r9,r7[14]
80009990:	31 f8       	mov	r8,31
80009992:	f0 09 18 00 	cp.b	r9,r8
80009996:	e0 8b 00 23 	brhi	800099dc <MsgSend+0x68>
8000999a:	e0 a0 0a ab 	rcall	8000aef0 <MnsGetEHCIState>
    ASSERT(((byte)64) > msg_ptr->MidLevelRetries);
    #ifdef _OS81110_MCM_LLR
    ASSERT(((byte)32) > msg_ptr->LowLevelRetries);
    #endif

    if(EHCISTATE_IS_ATTACHED() && msg_ptr)
8000999e:	30 28       	mov	r8,2
800099a0:	f0 0c 18 00 	cp.b	r12,r8
800099a4:	c1 80       	breq	800099d4 <MsgSend+0x60>
            MsgSend2(msg_ptr);
        }
    }
    else
    {
        FAILED_ASSERT();
800099a6:	e0 68 01 99 	mov	r8,409
800099aa:	30 1a       	mov	r10,1
800099ac:	1a d8       	st.w	--sp,r8
800099ae:	31 0b       	mov	r11,16
800099b0:	30 8c       	mov	r12,8
800099b2:	fe b0 f0 9d 	rcall	80007aec <mns_trace>
        if (msg.cfg_ptr->tx_status_fptr)
800099b6:	49 98       	lddpc	r8,80009a18 <MsgSend+0xa4>
800099b8:	2f fd       	sub	sp,-4
800099ba:	70 98       	ld.w	r8,r8[0x24]
800099bc:	70 08       	ld.w	r8,r8[0x0]
800099be:	58 08       	cp.w	r8,0
800099c0:	c0 50       	breq	800099ca <MsgSend+0x56>
        {
            (void)msg.cfg_ptr->tx_status_fptr(XMIT_PROTECTED_MODE, msg_ptr);
800099c2:	0e 9b       	mov	r11,r7
800099c4:	e0 6c 00 87 	mov	r12,135
800099c8:	5d 18       	icall	r8
        }
        MsgTxUnused(msg_ptr);
800099ca:	0e 9c       	mov	r12,r7
800099cc:	fe b0 fa b4 	rcall	80008f34 <MsgTxUnused>
800099d0:	e3 cd 80 80 	ldm	sp++,r7,pc
            AddrHSearchStart(msg_ptr);
        }
        else
        #endif
        {
            MsgSend2(msg_ptr);
800099d4:	0e 9c       	mov	r12,r7
800099d6:	c3 ff       	rcall	80009854 <MsgSend2>
800099d8:	e3 cd 80 80 	ldm	sp++,r7,pc
    ASSERT(((byte)64) > msg_ptr->MidLevelRetries);
    #ifdef _OS81110_MCM_LLR
    ASSERT(((byte)32) > msg_ptr->LowLevelRetries);
    #endif

    if(EHCISTATE_IS_ATTACHED() && msg_ptr)
800099dc:	e0 68 01 87 	mov	r8,391
    T_API_ENTRY(AMS_5);

    ASSERT(msg_ptr);
    ASSERT(((byte)64) > msg_ptr->MidLevelRetries);
    #ifdef _OS81110_MCM_LLR
    ASSERT(((byte)32) > msg_ptr->LowLevelRetries);
800099e0:	30 1a       	mov	r10,1
800099e2:	1a d8       	st.w	--sp,r8
800099e4:	31 0b       	mov	r11,16
800099e6:	30 8c       	mov	r12,8
800099e8:	fe b0 f0 82 	rcall	80007aec <mns_trace>
800099ec:	2f fd       	sub	sp,-4
800099ee:	cd 6b       	rjmp	8000999a <MsgSend+0x26>
800099f0:	e0 68 01 85 	mov	r8,389
void AmsMsgSend(TMsgTx *msg_ptr)
{
    T_API_ENTRY(AMS_5);

    ASSERT(msg_ptr);
    ASSERT(((byte)64) > msg_ptr->MidLevelRetries);
800099f4:	30 1a       	mov	r10,1
800099f6:	1a d8       	st.w	--sp,r8
800099f8:	31 0b       	mov	r11,16
800099fa:	30 8c       	mov	r12,8
800099fc:	fe b0 f0 78 	rcall	80007aec <mns_trace>
80009a00:	2f fd       	sub	sp,-4
80009a02:	cc 5b       	rjmp	8000998c <MsgSend+0x18>
80009a04:	e0 68 01 84 	mov	r8,388
  */
void AmsMsgSend(TMsgTx *msg_ptr)
{
    T_API_ENTRY(AMS_5);

    ASSERT(msg_ptr);
80009a08:	30 1a       	mov	r10,1
80009a0a:	1a d8       	st.w	--sp,r8
80009a0c:	31 0b       	mov	r11,16
80009a0e:	30 8c       	mov	r12,8
80009a10:	fe b0 f0 6e 	rcall	80007aec <mns_trace>
80009a14:	2f fd       	sub	sp,-4
80009a16:	cb 4b       	rjmp	8000997e <MsgSend+0xa>
80009a18:	00 00       	add	r0,r0
80009a1a:	2d 8c       	sub	r12,-40

80009a1c <MsgService>:
80009a1c:	eb cd 40 c0 	pushm	r6-r7,lr
80009a20:	20 1d       	sub	sp,4
80009a22:	4f 97       	lddpc	r7,80009c04 <MsgService+0x1e8>
80009a24:	32 08       	mov	r8,32
80009a26:	30 19       	mov	r9,1
80009a28:	ee ca ff fe 	sub	r10,r7,-2
80009a2c:	0e 9b       	mov	r11,r7
80009a2e:	30 ac       	mov	r12,10
static word MsgGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(AMS_3);
    result = MnsGetNextEventFlagToCall(MX_AMS_PE,
80009a30:	e0 a0 0c 06 	rcall	8000b23c <MnsGetNextEventFlagToCall>
    event_to_handle = MsgGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80009a34:	30 48       	mov	r8,4
static word MsgGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(AMS_3);
    result = MnsGetNextEventFlagToCall(MX_AMS_PE,
80009a36:	5c 8c       	casts.h	r12
    event_to_handle = MsgGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80009a38:	f0 0c 19 00 	cp.h	r12,r8
80009a3c:	e0 80 00 83 	breq	80009b42 <MsgService+0x126>
80009a40:	e0 88 00 26 	brls	80009a8c <MsgService+0x70>
80009a44:	31 08       	mov	r8,16
80009a46:	f0 0c 19 00 	cp.h	r12,r8
80009a4a:	c4 30       	breq	80009ad0 <MsgService+0xb4>
80009a4c:	32 08       	mov	r8,32
80009a4e:	f0 0c 19 00 	cp.h	r12,r8
80009a52:	c2 90       	breq	80009aa4 <MsgService+0x88>
80009a54:	30 88       	mov	r8,8
80009a56:	f0 0c 19 00 	cp.h	r12,r8
80009a5a:	c4 60       	breq	80009ae6 <MsgService+0xca>
                msg.cfg_ptr->retry_config_adjusted_fptr(&config);
            }
            break;

        default:
            FAILED_ASSERT();
80009a5c:	e0 68 01 1f 	mov	r8,287
80009a60:	1a d8       	st.w	--sp,r8
80009a62:	30 1a       	mov	r10,1
80009a64:	31 0b       	mov	r11,16
80009a66:	30 8c       	mov	r12,8
80009a68:	fe b0 f0 42 	rcall	80007aec <mns_trace>
80009a6c:	2f fd       	sub	sp,-4
            event_to_handle = AMS_P_NONE;
            break;
    }

    TAKE_EVENTS();
80009a6e:	30 ac       	mov	r12,10
80009a70:	fe b0 f0 23 	rcall	80007ab6 <mns_take>
    request_flag = (AMS_P_NONE != msg.pending_events) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
80009a74:	30 ac       	mov	r12,10
            event_to_handle = AMS_P_NONE;
            break;
    }

    TAKE_EVENTS();
    request_flag = (AMS_P_NONE != msg.pending_events) ? MNS_TRUE : MNS_FALSE;
80009a76:	8e 07       	ld.sh	r7,r7[0x0]
    GIVE_EVENTS();
80009a78:	fe b0 f0 20 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != request_flag)
80009a7c:	58 07       	cp.w	r7,0
80009a7e:	c0 40       	breq	80009a86 <MsgService+0x6a>
    {
        MnsSetPendingService(MNS_P_SRV_AMS);
80009a80:	30 8c       	mov	r12,8
80009a82:	e0 a0 0c 43 	rcall	8000b308 <MnsSetPendingService>
    }

    T_LIB_EXIT(AMS_1);
}
80009a86:	2f fd       	sub	sp,-4
80009a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    event_to_handle = MsgGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80009a8c:	30 18       	mov	r8,1
80009a8e:	f0 0c 19 00 	cp.h	r12,r8
80009a92:	c5 00       	breq	80009b32 <MsgService+0x116>
80009a94:	30 28       	mov	r8,2
80009a96:	f0 0c 19 00 	cp.h	r12,r8
80009a9a:	ce 11       	brne	80009a5c <MsgService+0x40>
                }
            }
            break;

        case AMS_P_RX:
            MsgRxOutTrigger(NULL);
80009a9c:	30 0c       	mov	r12,0
80009a9e:	fe b0 fa e7 	rcall	8000906c <MsgRxOutTrigger>
            break;
80009aa2:	ce 6b       	rjmp	80009a6e <MsgService+0x52>
            MsgEHCIGoSemiProtected();
            break;


        case AMS_P_SHADOW_CHANGE:
            if (msg.cfg_ptr->retry_config_adjusted_fptr)
80009aa4:	6e 98       	ld.w	r8,r7[0x24]
80009aa6:	70 68       	ld.w	r8,r8[0x18]
80009aa8:	58 08       	cp.w	r8,0
80009aaa:	ce 20       	breq	80009a6e <MsgService+0x52>
            {
                TMsgRetryConfig config;

                TAKE_MSG();
80009aac:	30 bc       	mov	r12,11
80009aae:	fe b0 f0 04 	rcall	80007ab6 <mns_take>
                config.time           = msg.retry_cfg.shadow.time;
80009ab2:	ef 38 00 2e 	ld.ub	r8,r7[46]
80009ab6:	ba b8       	st.b	sp[0x3],r8
                config.total_attempts = msg.retry_cfg.shadow.total_attempts;
80009ab8:	ef 38 00 2f 	ld.ub	r8,r7[47]
                GIVE_MSG();
80009abc:	30 bc       	mov	r12,11
            {
                TMsgRetryConfig config;

                TAKE_MSG();
                config.time           = msg.retry_cfg.shadow.time;
                config.total_attempts = msg.retry_cfg.shadow.total_attempts;
80009abe:	ba a8       	st.b	sp[0x2],r8
                GIVE_MSG();
80009ac0:	fe b0 ef fc 	rcall	80007ab8 <mns_give>

                msg.cfg_ptr->retry_config_adjusted_fptr(&config);
80009ac4:	6e 98       	ld.w	r8,r7[0x24]
80009ac6:	fa cc ff fe 	sub	r12,sp,-2
80009aca:	70 68       	ld.w	r8,r8[0x18]
80009acc:	5d 18       	icall	r8
80009ace:	cd 0b       	rjmp	80009a6e <MsgService+0x52>
#ifdef AMS_27
static void MsgEHCIGoSemiProtected(void)
{
    T_MOD_ENTRY(AMS_27);

    (void)MsgForceMidLevelRetries();
80009ad0:	c7 6e       	rcall	800097bc <MsgForceMidLevelRetries>
80009ad2:	30 8c       	mov	r12,8
    if ((MNS_FALSE != MostIsSupported(NSF_MOST_25)) || (MNS_FALSE != MostIsSupported(NSF_MOST_50)))
80009ad4:	e0 a0 09 f0 	rcall	8000aeb4 <MostIsSupported>
80009ad8:	c0 51       	brne	80009ae2 <MsgService+0xc6>
80009ada:	31 0c       	mov	r12,16
80009adc:	e0 a0 09 ec 	rcall	8000aeb4 <MostIsSupported>
80009ae0:	cc 70       	breq	80009a6e <MsgService+0x52>
80009ae2:	c9 7e       	rcall	80009810 <MsgRequestSegMode>
    {
        (void)MsgRequestSegMode();
80009ae4:	cc 5b       	rjmp	80009a6e <MsgService+0x52>
80009ae6:	30 ac       	mov	r12,10
80009ae8:	fe b0 ef e7 	rcall	80007ab6 <mns_take>
    T_MOD_ENTRY(AMS_28);

    retry  = 0;
    result = ERR_NO;

    TAKE_EVENTS();
80009aec:	30 ac       	mov	r12,10
80009aee:	ef 06 00 20 	ld.sh	r6,r7[32]
    retry = msg.retry;
80009af2:	fe b0 ef e3 	rcall	80007ab8 <mns_give>
    GIVE_EVENTS();
80009af6:	5c 76       	castu.h	r6
80009af8:	ed b6 00 00 	bld	r6,0x0

    PROCESS_RETRY    (AMS_RETRY_MIDLEVEL_RETRIES,   MsgForceMidLevelRetries );
80009afc:	c4 50       	breq	80009b86 <MsgService+0x16a>
80009afe:	ed b6 00 01 	bld	r6,0x1
    PROCESS_RETRY    (MSG_RETRY_SEGMODE,            MsgForceSegMode         );
80009b02:	c6 e0       	breq	80009bde <MsgService+0x1c2>
80009b04:	ed b6 00 02 	bld	r6,0x2
    PROCESS_RETRY    (MSG_RETRY_REQ_SEGMODE,        MsgRequestSegMode       );
80009b08:	c5 d0       	breq	80009bc2 <MsgService+0x1a6>
80009b0a:	ed b6 00 03 	bld	r6,0x3
    PROCESS_RETRY    (MSG_RETRY_REQ_RETRYPARAMS,    MsgRequestRetryParams   );
80009b0e:	c4 b0       	breq	80009ba4 <MsgService+0x188>
80009b10:	e2 16 00 10 	andl	r6,0x10,COH
    PROCESS_RETRY    (MSG_RETRY_RETRYPARAMS,        MsgSendRetryParams      );
80009b14:	ca d0       	breq	80009a6e <MsgService+0x52>
80009b16:	30 ac       	mov	r12,10
80009b18:	fe b0 ef cf 	rcall	80007ab6 <mns_take>
80009b1c:	ef 08 00 20 	ld.sh	r8,r7[32]
80009b20:	a5 c8       	cbr	r8,0x4
80009b22:	30 ac       	mov	r12,10
80009b24:	ef 58 00 20 	st.h	r7[32],r8
80009b28:	fe b0 ef c8 	rcall	80007ab8 <mns_give>
80009b2c:	fe b0 fd 5e 	rcall	800095e8 <MsgSendRetryParams>
80009b30:	c9 fb       	rjmp	80009a6e <MsgService+0x52>
80009b32:	ee cc ff ec 	sub	r12,r7,-20
            (void)MsgRetry();
            break;

        case AMS_P_TX:
            {
                HMBMBUF handle = MbmDequeue(&(msg.tx_queue));
80009b36:	e0 a0 02 e1 	rcall	8000a0f8 <MbmDequeue>
80009b3a:	c6 10       	breq	80009bfc <MsgService+0x1e0>
80009b3c:	2e cc       	sub	r12,-20

                ASSERT(handle);
80009b3e:	c8 be       	rcall	80009854 <MsgSend2>
                    TMsgTx *msg_ptr = MBM_GET_CTRL_TX_PTR(handle);

                    ASSERT(msg_ptr);
                    if (msg_ptr)
                    {
                        MsgSend2(msg_ptr);
80009b40:	c9 7b       	rjmp	80009a6e <MsgService+0x52>
80009b42:	30 ac       	mov	r12,10
80009b44:	fe b0 ef b9 	rcall	80007ab6 <mns_take>
#ifdef AMS_26
static void MsgEHCIGoProtected(void)
{
    T_MOD_ENTRY(AMS_26);

    TAKE_EVENTS();
80009b48:	30 06       	mov	r6,0
80009b4a:	30 ac       	mov	r12,10
80009b4c:	ef 56 00 20 	st.h	r7[32],r6
    msg.retry = 0;
    GIVE_EVENTS();
80009b50:	fe b0 ef b4 	rcall	80007ab8 <mns_give>
static void MsgEHCIGoProtected(void)
{
    T_MOD_ENTRY(AMS_26);

    TAKE_EVENTS();
    msg.retry = 0;
80009b54:	30 bc       	mov	r12,11
    GIVE_EVENTS();
80009b56:	fe b0 ef b0 	rcall	80007ab6 <mns_take>

    TAKE_MSG();
80009b5a:	30 18       	mov	r8,1
80009b5c:	ef 68 00 2f 	st.b	r7[47],r8
    msg.mid_level_retries               = DEF_MID_LEVEL_RETRIES;
    msg.retry_cfg.total_attempts        = PMS_DEF_RETRY_1;
80009b60:	ef 68 00 2c 	st.b	r7[44],r8
    msg.retry_cfg.time                  = 0;
    msg.retry_cfg.shadow.total_attempts = PMS_DEF_RETRY_1;
80009b64:	30 38       	mov	r8,3
    msg.retry = 0;
    GIVE_EVENTS();

    TAKE_MSG();
    msg.mid_level_retries               = DEF_MID_LEVEL_RETRIES;
    msg.retry_cfg.total_attempts        = PMS_DEF_RETRY_1;
80009b66:	ef 66 00 2d 	st.b	r7[45],r6
    TAKE_EVENTS();
    msg.retry = 0;
    GIVE_EVENTS();

    TAKE_MSG();
    msg.mid_level_retries               = DEF_MID_LEVEL_RETRIES;
80009b6a:	ef 66 00 2b 	st.b	r7[43],r6
    msg.retry_cfg.total_attempts        = PMS_DEF_RETRY_1;
    msg.retry_cfg.time                  = 0;
    msg.retry_cfg.shadow.total_attempts = PMS_DEF_RETRY_1;
    msg.retry_cfg.shadow.time           = 0;
    msg.retry_cfg.busy                  = MNS_FALSE;
80009b6e:	ef 66 00 2e 	st.b	r7[46],r6
    GIVE_EVENTS();

    TAKE_MSG();
    msg.mid_level_retries               = DEF_MID_LEVEL_RETRIES;
    msg.retry_cfg.total_attempts        = PMS_DEF_RETRY_1;
    msg.retry_cfg.time                  = 0;
80009b72:	ef 68 00 30 	st.b	r7[48],r8
    msg.retry_cfg.shadow.total_attempts = PMS_DEF_RETRY_1;
    msg.retry_cfg.shadow.time           = 0;
80009b76:	30 bc       	mov	r12,11
    TAKE_EVENTS();
    msg.retry = 0;
    GIVE_EVENTS();

    TAKE_MSG();
    msg.mid_level_retries               = DEF_MID_LEVEL_RETRIES;
80009b78:	fe b0 ef a0 	rcall	80007ab8 <mns_give>
    msg.retry_cfg.total_attempts        = PMS_DEF_RETRY_1;
    msg.retry_cfg.time                  = 0;
    msg.retry_cfg.shadow.total_attempts = PMS_DEF_RETRY_1;
    msg.retry_cfg.shadow.time           = 0;
    msg.retry_cfg.busy                  = MNS_FALSE;
    GIVE_MSG();
80009b7c:	30 8b       	mov	r11,8
80009b7e:	30 1c       	mov	r12,1
80009b80:	e0 a0 0e 9e 	rcall	8000b8bc <MnsServiceInitComplete>

    MnsServiceInitComplete(MNS_PHASE_RESET, MNS_P_SRV_AMS);
80009b84:	c7 5b       	rjmp	80009a6e <MsgService+0x52>
80009b86:	30 ac       	mov	r12,10
80009b88:	fe b0 ef 97 	rcall	80007ab6 <mns_take>

    TAKE_EVENTS();
    retry = msg.retry;
    GIVE_EVENTS();

    PROCESS_RETRY    (AMS_RETRY_MIDLEVEL_RETRIES,   MsgForceMidLevelRetries );
80009b8c:	ef 08 00 20 	ld.sh	r8,r7[32]
80009b90:	a1 c8       	cbr	r8,0x0
80009b92:	30 ac       	mov	r12,10
80009b94:	ef 58 00 20 	st.h	r7[32],r8
80009b98:	fe b0 ef 90 	rcall	80007ab8 <mns_give>
80009b9c:	c1 0e       	rcall	800097bc <MsgForceMidLevelRetries>
80009b9e:	fe 91 ff 68 	brne	80009a6e <MsgService+0x52>
80009ba2:	ca eb       	rjmp	80009afe <MsgService+0xe2>
80009ba4:	30 ac       	mov	r12,10
    PROCESS_RETRY    (MSG_RETRY_SEGMODE,            MsgForceSegMode         );
80009ba6:	fe b0 ef 88 	rcall	80007ab6 <mns_take>
80009baa:	ef 08 00 20 	ld.sh	r8,r7[32]
    PROCESS_RETRY    (MSG_RETRY_REQ_SEGMODE,        MsgRequestSegMode       );
    PROCESS_RETRY    (MSG_RETRY_REQ_RETRYPARAMS,    MsgRequestRetryParams   );
80009bae:	a3 d8       	cbr	r8,0x3
80009bb0:	30 ac       	mov	r12,10
80009bb2:	ef 58 00 20 	st.h	r7[32],r8
80009bb6:	fe b0 ef 81 	rcall	80007ab8 <mns_give>
80009bba:	fe b0 fd 6f 	rcall	80009698 <MsgRequestRetryParams>
80009bbe:	ca 90       	breq	80009b10 <MsgService+0xf4>
80009bc0:	c5 7b       	rjmp	80009a6e <MsgService+0x52>
80009bc2:	30 ac       	mov	r12,10
80009bc4:	fe b0 ef 79 	rcall	80007ab6 <mns_take>
    PROCESS_RETRY    (MSG_RETRY_RETRYPARAMS,        MsgSendRetryParams      );
80009bc8:	ef 08 00 20 	ld.sh	r8,r7[32]
    retry = msg.retry;
    GIVE_EVENTS();

    PROCESS_RETRY    (AMS_RETRY_MIDLEVEL_RETRIES,   MsgForceMidLevelRetries );
    PROCESS_RETRY    (MSG_RETRY_SEGMODE,            MsgForceSegMode         );
    PROCESS_RETRY    (MSG_RETRY_REQ_SEGMODE,        MsgRequestSegMode       );
80009bcc:	a3 c8       	cbr	r8,0x2
80009bce:	30 ac       	mov	r12,10
80009bd0:	ef 58 00 20 	st.h	r7[32],r8
80009bd4:	fe b0 ef 72 	rcall	80007ab8 <mns_give>
80009bd8:	c1 ce       	rcall	80009810 <MsgRequestSegMode>
80009bda:	c9 80       	breq	80009b0a <MsgService+0xee>
80009bdc:	c4 9b       	rjmp	80009a6e <MsgService+0x52>
80009bde:	30 ac       	mov	r12,10
80009be0:	fe b0 ef 6b 	rcall	80007ab6 <mns_take>
    PROCESS_RETRY    (MSG_RETRY_REQ_RETRYPARAMS,    MsgRequestRetryParams   );
80009be4:	ef 08 00 20 	ld.sh	r8,r7[32]
    TAKE_EVENTS();
    retry = msg.retry;
    GIVE_EVENTS();

    PROCESS_RETRY    (AMS_RETRY_MIDLEVEL_RETRIES,   MsgForceMidLevelRetries );
    PROCESS_RETRY    (MSG_RETRY_SEGMODE,            MsgForceSegMode         );
80009be8:	a1 d8       	cbr	r8,0x1
80009bea:	30 ac       	mov	r12,10
80009bec:	ef 58 00 20 	st.h	r7[32],r8
80009bf0:	fe b0 ef 64 	rcall	80007ab8 <mns_give>
80009bf4:	fe b0 fd 84 	rcall	800096fc <MsgForceSegMode>
80009bf8:	c8 60       	breq	80009b04 <MsgService+0xe8>
80009bfa:	c3 ab       	rjmp	80009a6e <MsgService+0x52>
80009bfc:	e0 68 00 f5 	mov	r8,245
80009c00:	c3 0b       	rjmp	80009a60 <MsgService+0x44>
    PROCESS_RETRY    (MSG_RETRY_REQ_SEGMODE,        MsgRequestSegMode       );
80009c02:	d7 03       	nop
80009c04:	00 00       	add	r0,r0

        case AMS_P_TX:
            {
                HMBMBUF handle = MbmDequeue(&(msg.tx_queue));

                ASSERT(handle);
80009c06:	2d 8c       	sub	r12,-40

80009c08 <MsgInit>:
80009c08:	eb cd 40 c0 	pushm	r6-r7,lr
80009c0c:	18 97       	mov	r7,r12
80009c0e:	58 0c       	cp.w	r12,0
80009c10:	c4 70       	breq	80009c9e <MsgInit+0x96>
80009c12:	4a 96       	lddpc	r6,80009cb4 <MsgInit+0xac>
80009c14:	30 0a       	mov	r10,0
80009c16:	30 7b       	mov	r11,7
80009c18:	30 8c       	mov	r12,8
80009c1a:	fe b0 ef 69 	rcall	80007aec <mns_trace>
80009c1e:	8d 97       	st.w	r6[0x24],r7
80009c20:	30 08       	mov	r8,0
80009c22:	ef 39 00 1c 	ld.ub	r9,r7[28]
80009c26:	f0 09 18 00 	cp.b	r9,r8
80009c2a:	f9 b8 00 01 	moveq	r8,1
80009c2e:	ef f8 0e 1c 	st.beq	r7[0x1c],r8
80009c32:	6e 58       	ld.w	r8,r7[0x14]
80009c34:	30 ac       	mov	r12,10
80009c36:	8d d8       	st.w	r6[0x34],r8
80009c38:	fe b0 ef 3f 	rcall	80007ab6 <mns_take>
80009c3c:	30 ac       	mov	r12,10
80009c3e:	30 07       	mov	r7,0
80009c40:	ac 07       	st.h	r6[0x0],r7
80009c42:	ac 17       	st.h	r6[0x2],r7
80009c44:	ed 57 00 20 	st.h	r6[32],r7
80009c48:	ac c7       	st.b	r6[0x4],r7
80009c4a:	fe b0 ef 37 	rcall	80007ab8 <mns_give>
    msg.latest_handled_event = AMS_P_NONE;
    msg.retry  = 0;
    msg.net_on = MNS_FALSE;
    GIVE_EVENTS();

    TAKE_MSG();
80009c4e:	30 bc       	mov	r12,11
80009c50:	fe b0 ef 33 	rcall	80007ab6 <mns_take>
    msg.seg.mode        = MSG_SEG_INIC_ONLY;
    #endif

    #ifdef MSG_RX_SEG_EHC_ONLY
    msg.seg.ats.value   = INIC_ATS_CMSEHCSEG;
    msg.seg.mode        = MSG_SEG_EHC_ONLY;
80009c54:	30 38       	mov	r8,3
    #endif

    msg.mid_level_retries   = DEF_MID_LEVEL_RETRIES;
80009c56:	ed 68 00 30 	st.b	r6[48],r8
    msg.seg.mode        = MSG_SEG_INIC_ONLY;
    #endif

    #ifdef MSG_RX_SEG_EHC_ONLY
    msg.seg.ats.value   = INIC_ATS_CMSEHCSEG;
    msg.seg.mode        = MSG_SEG_EHC_ONLY;
80009c5a:	ed 68 00 2a 	st.b	r6[42],r8
    msg.seg.ats.value   = INIC_ATS_NOEHCSEG;
    msg.seg.mode        = MSG_SEG_INIC_ONLY;
    #endif

    #ifdef MSG_RX_SEG_EHC_ONLY
    msg.seg.ats.value   = INIC_ATS_CMSEHCSEG;
80009c5e:	30 28       	mov	r8,2
80009c60:	ed 68 00 28 	st.b	r6[40],r8
    msg.seg.mode        = MSG_SEG_EHC_ONLY;
    #endif

    msg.mid_level_retries   = DEF_MID_LEVEL_RETRIES;
    msg.seg.ats.shadow      = INIC_SHADOW_INVALID_BYTE;
80009c64:	3e e8       	mov	r8,-18
80009c66:	ed 68 00 29 	st.b	r6[41],r8
    msg.retry_cfg.shadow.total_attempts = PMS_DEF_RETRY_1;
80009c6a:	30 18       	mov	r8,1
    msg.retry_cfg.shadow.time           = 0;
    msg.retry_cfg.busy                  = MNS_FALSE;
80009c6c:	ed 67 00 2d 	st.b	r6[45],r7
    msg.seg.mode        = MSG_SEG_EHC_ONLY;
    #endif

    msg.mid_level_retries   = DEF_MID_LEVEL_RETRIES;
    msg.seg.ats.shadow      = INIC_SHADOW_INVALID_BYTE;
    msg.retry_cfg.shadow.total_attempts = PMS_DEF_RETRY_1;
80009c70:	ed 68 00 2f 	st.b	r6[47],r8
    msg.retry_cfg.shadow.time           = 0;
80009c74:	ed 67 00 2e 	st.b	r6[46],r7
    msg.retry_cfg.busy                  = MNS_FALSE;
    GIVE_MSG();
80009c78:	30 bc       	mov	r12,11
80009c7a:	fe b0 ef 1f 	rcall	80007ab8 <mns_give>

    MbmQueueInit(&(msg.tx_queue), MX_AMS_TX_Q);
80009c7e:	ec cc ff ec 	sub	r12,r6,-20
80009c82:	30 cb       	mov	r11,12
80009c84:	e0 a0 03 48 	rcall	8000a314 <MbmQueueInit>
    MbmQueueInit(&(msg.rx_queue), MX_AMS_RX_Q);
80009c88:	ec cc ff f8 	sub	r12,r6,-8
80009c8c:	30 db       	mov	r11,13
80009c8e:	e0 a0 03 43 	rcall	8000a314 <MbmQueueInit>

    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_AMS);
80009c92:	30 8b       	mov	r11,8
80009c94:	30 2c       	mov	r12,2
80009c96:	e0 a0 0e 13 	rcall	8000b8bc <MnsServiceInitComplete>
    T_LIB_EXIT(AMS_0);
}
80009c9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef AMS_0
void MsgInit(struct TMsgConfig *cfg_ptr)
{
    T_LIB_ENTRY(AMS_0);

    ASSERT(cfg_ptr);
80009c9e:	e0 68 00 a9 	mov	r8,169
80009ca2:	30 1a       	mov	r10,1
80009ca4:	1a d8       	st.w	--sp,r8
80009ca6:	31 0b       	mov	r11,16
80009ca8:	30 8c       	mov	r12,8
80009caa:	fe b0 ef 21 	rcall	80007aec <mns_trace>
80009cae:	2f fd       	sub	sp,-4
80009cb0:	cb 1b       	rjmp	80009c12 <MsgInit+0xa>
80009cb2:	d7 03       	nop
80009cb4:	00 00       	add	r0,r0
80009cb6:	2d 8c       	sub	r12,-40

80009cb8 <MbmPullHeaders>:
{
    MbmBuf *mbuf_ptr = handle;

    T_LIB_ENTRY(MBM_17);
    mbuf_ptr->hdr_ptr += mbuf_ptr->hdr_len;
    mbuf_ptr->hdr_len  = (word)0;
80009cb8:	30 09       	mov	r9,0
void MbmPullHeaders(HMBMBUF handle)
{
    MbmBuf *mbuf_ptr = handle;

    T_LIB_ENTRY(MBM_17);
    mbuf_ptr->hdr_ptr += mbuf_ptr->hdr_len;
80009cba:	f9 18 00 32 	ld.uh	r8,r12[50]
    mbuf_ptr->hdr_len  = (word)0;
80009cbe:	f9 59 00 32 	st.h	r12[50],r9
void MbmPullHeaders(HMBMBUF handle)
{
    MbmBuf *mbuf_ptr = handle;

    T_LIB_ENTRY(MBM_17);
    mbuf_ptr->hdr_ptr += mbuf_ptr->hdr_len;
80009cc2:	78 a9       	ld.w	r9,r12[0x28]
80009cc4:	f2 08 00 08 	add	r8,r9,r8
80009cc8:	99 a8       	st.w	r12[0x28],r8
    mbuf_ptr->hdr_len  = (word)0;
    T_LIB_EXIT(MBM_17);
}
80009cca:	5e fc       	retal	r12

80009ccc <MbmGetExtPayloadLen>:
    MbmBuf *mb_ptr = handle;

    T_LIB_ENTRY(MBM_19);
    T_LIB_EXIT(MBM_19);

    return( (mb_ptr->payload_ptr != (mb_ptr->hdr_ptr + mb_ptr->hdr_len)) ?
80009ccc:	78 a9       	ld.w	r9,r12[0x28]
80009cce:	f9 18 00 32 	ld.uh	r8,r12[50]
80009cd2:	f2 08 00 08 	add	r8,r9,r8
80009cd6:	78 b9       	ld.w	r9,r12[0x2c]
80009cd8:	10 39       	cp.w	r9,r8
80009cda:	f9 bc 00 00 	moveq	r12,0
80009cde:	f9 fc 12 1a 	ld.shne	r12,r12[0x34]
             mb_ptr->payload_len : (word)0 );
}
80009ce2:	5e fc       	retal	r12

80009ce4 <_MbmMemAlloc>:
}
#endif

#ifdef MBM_26
static byte *_MbmMemAlloc(word *size)
{
80009ce4:	d4 21       	pushm	r4-r7,lr
    byte *mem_ptr;

    T_MOD_ENTRY(MBM_26);

    if( *size )
80009ce6:	98 0a       	ld.sh	r10,r12[0x0]
80009ce8:	58 0a       	cp.w	r10,0
80009cea:	c0 21       	brne	80009cee <_MbmMemAlloc+0xa>
                /* Remove whole segment */
                MBM_MEM_UNLINK(memInfoArray[last], memInfoArray, i);
                MBM_MEM_LINK(memInfoFree, memInfoArray, i);
                _MBM_USAGE_FRAG_DEC();
            }
            *size = (word)MBM_MEM_BYTES(units);        /* Set real allocated size */
80009cec:	d8 2a       	popm	r4-r7,pc,r12=0
        MbmMemInfoIndex last;
        word            units;

        units = (word)MBM_MEM_UNITS(*size);
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */
80009cee:	4a 4e       	lddpc	lr,80009d7c <_MbmMemAlloc+0x98>
80009cf0:	1d 88       	ld.ub	r8,lr[0x0]

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009cf2:	58 08       	cp.w	r8,0
80009cf4:	cf c0       	breq	80009cec <_MbmMemAlloc+0x8>
    {
        MbmMemInfoIndex i;
        MbmMemInfoIndex last;
        word            units;

        units = (word)MBM_MEM_UNITS(*size);
80009cf6:	ef da c0 10 	bfextu	r7,r10,0x0,0x10
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009cfa:	f0 08 00 19 	add	r9,r8,r8<<0x1
    {
        MbmMemInfoIndex i;
        MbmMemInfoIndex last;
        word            units;

        units = (word)MBM_MEM_UNITS(*size);
80009cfe:	2f d7       	sub	r7,-3
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009d00:	fc 09 00 1a 	add	r10,lr,r9<<0x1
    {
        MbmMemInfoIndex i;
        MbmMemInfoIndex last;
        word            units;

        units = (word)MBM_MEM_UNITS(*size);
80009d04:	a3 87       	lsr	r7,0x2
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009d06:	94 2a       	ld.sh	r10,r10[0x4]
80009d08:	f4 07 19 00 	cp.h	r7,r10
80009d0c:	e0 88 00 36 	brls	80009d78 <_MbmMemAlloc+0x94>
        {
            last = i;
            i    = memInfoArray[i].next;
80009d10:	1c 95       	mov	r5,lr
        units = (word)MBM_MEM_UNITS(*size);
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009d12:	10 96       	mov	r6,r8
        {
            last = i;
            i    = memInfoArray[i].next;
80009d14:	fc 09 07 18 	ld.ub	r8,lr[r9<<0x1]
        units = (word)MBM_MEM_UNITS(*size);
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009d18:	58 08       	cp.w	r8,0
80009d1a:	ce 90       	breq	80009cec <_MbmMemAlloc+0x8>
80009d1c:	f0 08 00 19 	add	r9,r8,r8<<0x1
80009d20:	0e 94       	mov	r4,r7
80009d22:	ea 09 00 1b 	add	r11,r5,r9<<0x1
80009d26:	96 2a       	ld.sh	r10,r11[0x4]
80009d28:	f4 07 19 00 	cp.h	r7,r10
80009d2c:	fe 9b ff f3 	brhi	80009d12 <_MbmMemAlloc+0x2e>
            i    = memInfoArray[i].next;
        }

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];
80009d30:	fc 09 00 19 	add	r9,lr,r9<<0x1

            memInfoArray[i].size  -= units;
80009d34:	0e 1a       	sub	r10,r7
            i    = memInfoArray[i].next;
        }

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];
80009d36:	f2 cb ff fe 	sub	r11,r9,-2

            memInfoArray[i].size  -= units;
80009d3a:	f2 ce ff fc 	sub	lr,r9,-4
            i    = memInfoArray[i].next;
        }

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];
80009d3e:	96 05       	ld.sh	r5,r11[0x0]

            memInfoArray[i].size  -= units;
80009d40:	bc 0a       	st.h	lr[0x0],r10
            memInfoArray[i].start += units;
80009d42:	96 0a       	ld.sh	r10,r11[0x0]
80009d44:	0e 0a       	add	r10,r7
80009d46:	b6 0a       	st.h	r11[0x0],r10

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];

            memInfoArray[i].size  -= units;
80009d48:	0e 94       	mov	r4,r7
            memInfoArray[i].start += units;

            if( !memInfoArray[i].size )
80009d4a:	9c 0b       	ld.sh	r11,lr[0x0]
80009d4c:	30 0a       	mov	r10,0
80009d4e:	f4 0b 19 00 	cp.h	r11,r10
80009d52:	c0 b1       	brne	80009d68 <_MbmMemAlloc+0x84>
            {
                /* Remove whole segment */
                MBM_MEM_UNLINK(memInfoArray[last], memInfoArray, i);
80009d54:	13 8b       	ld.ub	r11,r9[0x0]
80009d56:	48 aa       	lddpc	r10,80009d7c <_MbmMemAlloc+0x98>
80009d58:	ec 06 00 16 	add	r6,r6,r6<<0x1
80009d5c:	f4 06 0b 1b 	st.b	r10[r6<<0x1],r11
                MBM_MEM_LINK(memInfoFree, memInfoArray, i);
80009d60:	48 8a       	lddpc	r10,80009d80 <_MbmMemAlloc+0x9c>
80009d62:	15 8b       	ld.ub	r11,r10[0x0]
80009d64:	b4 88       	st.b	r10[0x0],r8
80009d66:	b2 8b       	st.b	r9[0x0],r11
            i    = memInfoArray[i].next;
        }

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];
80009d68:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
                /* Remove whole segment */
                MBM_MEM_UNLINK(memInfoArray[last], memInfoArray, i);
                MBM_MEM_LINK(memInfoFree, memInfoArray, i);
                _MBM_USAGE_FRAG_DEC();
            }
            *size = (word)MBM_MEM_BYTES(units);        /* Set real allocated size */
80009d6c:	a3 67       	lsl	r7,0x2
            i    = memInfoArray[i].next;
        }

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];
80009d6e:	48 68       	lddpc	r8,80009d84 <_MbmMemAlloc+0xa0>
                /* Remove whole segment */
                MBM_MEM_UNLINK(memInfoArray[last], memInfoArray, i);
                MBM_MEM_LINK(memInfoFree, memInfoArray, i);
                _MBM_USAGE_FRAG_DEC();
            }
            *size = (word)MBM_MEM_BYTES(units);        /* Set real allocated size */
80009d70:	b8 07       	st.h	r12[0x0],r7
            i    = memInfoArray[i].next;
        }

        if( i )
        {
            mem_ptr = &mbmMemArray[MBM_MEM_BYTES(memInfoArray[i].start)];
80009d72:	f0 09 00 2c 	add	r12,r8,r9<<0x2
80009d76:	d8 22       	popm	r4-r7,pc
        units = (word)MBM_MEM_UNITS(*size);
        last  = (MbmMemInfoIndex)0;      /* If first == match, then last == head  */
        i     = memInfoArray[0].next;    /* Get first available segment from head */

        /* If i == 0 it's the Head and no match was found */
        while( i && (memInfoArray[i].size < units) )
80009d78:	30 06       	mov	r6,0
80009d7a:	cd bb       	rjmp	80009d30 <_MbmMemAlloc+0x4c>
80009d7c:	00 00       	add	r0,r0
80009d7e:	34 6c       	mov	r12,70
80009d80:	00 00       	add	r0,r0
80009d82:	35 2c       	mov	r12,82
80009d84:	00 00       	add	r0,r0
80009d86:	42 24       	lddsp	r4,sp[0x88]

80009d88 <MbmIsFromPool>:
{
    bool retval;

    T_LIB_ENTRY(MBM_30);

    if((handle >= &msgBufArray[0]) && (handle <= &msgBufArray[MBM_MSG_NUM-1]))
80009d88:	48 78       	lddpc	r8,80009da4 <MbmIsFromPool+0x1c>
80009d8a:	10 3c       	cp.w	r12,r8
80009d8c:	c0 22       	brcc	80009d90 <MbmIsFromPool+0x8>
80009d8e:	5e fd       	retal	0
    T_LIB_EXIT(MBM_33);
}
#endif

#ifdef MBM_30
bool MbmIsFromPool(HCMBMBUF handle)
80009d90:	f0 c8 f9 a8 	sub	r8,r8,-1624
80009d94:	10 3c       	cp.w	r12,r8
80009d96:	f9 bc 08 01 	movls	r12,1
80009d9a:	f9 bc 0b 00 	movhi	r12,0
80009d9e:	5c 5c       	castu.b	r12
        retval = MNS_FALSE;
    }

    T_LIB_EXIT(MBM_30);
    return (retval);
}
80009da0:	5e fc       	retal	r12
80009da2:	d7 03       	nop
80009da4:	00 00       	add	r0,r0
80009da6:	2d d0       	sub	r0,-35

80009da8 <MbmGetHandleByMsgPtr>:
    /*lint -e{970} suppress 'use of modifier unsigned outside a typedef'*/
    /*lint -e{826} suppress 'Suspicious pointer-to-pointer conversion'*/
    handle = (HMBMBUF)((byte *)(msg) - PMS_OFFSETOF(MbmBuf, msg.dataTx));

    return handle;
}
80009da8:	21 4c       	sub	r12,20
80009daa:	5e fc       	retal	r12

80009dac <_MbmEnqueueBehind>:
}
#endif

#ifdef MBM_33
void _MbmEnqueueBehind(MbmQueue *q_ptr, HMBMBUF hPrev, HMBMBUF hNew)
{
80009dac:	eb cd 40 e0 	pushm	r5-r7,lr
80009db0:	18 96       	mov	r6,r12
80009db2:	16 95       	mov	r5,r11
80009db4:	14 97       	mov	r7,r10
    T_LIB_ENTRY(MBM_33);
    ASSERT((NULL != q_ptr) && (NULL == hNew->q_ptr));
80009db6:	58 0c       	cp.w	r12,0
80009db8:	c0 40       	breq	80009dc0 <_MbmEnqueueBehind+0x14>
80009dba:	74 28       	ld.w	r8,r10[0x8]
80009dbc:	58 08       	cp.w	r8,0
80009dbe:	c0 b0       	breq	80009dd4 <_MbmEnqueueBehind+0x28>
80009dc0:	e0 68 04 27 	mov	r8,1063
80009dc4:	30 1a       	mov	r10,1
80009dc6:	1a d8       	st.w	--sp,r8
80009dc8:	31 0b       	mov	r11,16
80009dca:	e0 6c 80 00 	mov	r12,32768
80009dce:	fe b0 ee 8f 	rcall	80007aec <mns_trace>
80009dd2:	2f fd       	sub	sp,-4
    hNew->q_ptr              = q_ptr;
80009dd4:	8f 26       	st.w	r7[0x8],r6
    q_ptr->length++;
80009dd6:	8c 58       	ld.sh	r8,r6[0xa]
80009dd8:	2f f8       	sub	r8,-1
80009dda:	ac 58       	st.h	r6[0xa],r8
    hNew->next_ptr           = hPrev->next_ptr;
80009ddc:	6a 08       	ld.w	r8,r5[0x0]
    hNew->prev_ptr           = hPrev;
80009dde:	8f 15       	st.w	r7[0x4],r5
{
    T_LIB_ENTRY(MBM_33);
    ASSERT((NULL != q_ptr) && (NULL == hNew->q_ptr));
    hNew->q_ptr              = q_ptr;
    q_ptr->length++;
    hNew->next_ptr           = hPrev->next_ptr;
80009de0:	8f 08       	st.w	r7[0x0],r8
    hNew->prev_ptr           = hPrev;
    hNew->next_ptr->prev_ptr = hNew;
80009de2:	91 17       	st.w	r8[0x4],r7
    hPrev->next_ptr          = hNew;
80009de4:	8b 07       	st.w	r5[0x0],r7
    T_LIB_EXIT(MBM_33);
}
80009de6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009dea:	d7 03       	nop

80009dec <MbmMemFree>:
80009dec:	eb cd 40 fc 	pushm	r2-r7,lr
}
#endif

#ifdef MBM_27
void MbmMemFree(MbmBuf *mb_ptr)
{
80009df0:	18 97       	mov	r7,r12
    T_LIB_ENTRY(MBM_27);

    ASSERT(mb_ptr);
80009df2:	58 0c       	cp.w	r12,0
80009df4:	e0 80 00 8a 	breq	80009f08 <MbmMemFree+0x11c>

    if( mb_ptr->start_ptr && mb_ptr->size )
80009df8:	6e 48       	ld.w	r8,r7[0x10]
80009dfa:	58 08       	cp.w	r8,0
80009dfc:	c0 50       	breq	80009e06 <MbmMemFree+0x1a>
80009dfe:	ef 04 00 30 	ld.sh	r4,r7[48]
80009e02:	58 04       	cp.w	r4,0
80009e04:	c0 31       	brne	80009e0a <MbmMemFree+0x1e>
80009e06:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        word units = (word)MBM_MEM_UNITS(mb_ptr->size);
        word start = (word)MBM_MEM_UNITS(mb_ptr->start_ptr - &mbmMemArray[0]);
80009e0a:	4d 65       	lddpc	r5,80009f60 <MbmMemFree+0x174>
80009e0c:	0a 18       	sub	r8,r5
80009e0e:	f0 c9 ff fa 	sub	r9,r8,-6
80009e12:	f0 c5 ff fd 	sub	r5,r8,-3

    ASSERT(mb_ptr);

    if( mb_ptr->start_ptr && mb_ptr->size )
    {
        word units = (word)MBM_MEM_UNITS(mb_ptr->size);
80009e16:	5c 74       	castu.h	r4
        word start = (word)MBM_MEM_UNITS(mb_ptr->start_ptr - &mbmMemArray[0]);
80009e18:	58 05       	cp.w	r5,0
80009e1a:	f2 05 17 50 	movlt	r5,r9

    ASSERT(mb_ptr);

    if( mb_ptr->start_ptr && mb_ptr->size )
    {
        word units = (word)MBM_MEM_UNITS(mb_ptr->size);
80009e1e:	2f d4       	sub	r4,-3
        word start = (word)MBM_MEM_UNITS(mb_ptr->start_ptr - &mbmMemArray[0]);
        word end   = (word)(start + units);
        MbmMemInfoIndex i;
        MbmMemInfoIndex j = (MbmMemInfoIndex)0;

        WAIT4MX(MX_MBM_CS);
80009e20:	30 0c       	mov	r12,0

        i = memInfoArray[0].next;
80009e22:	4d 16       	lddpc	r6,80009f64 <MbmMemFree+0x178>
        word start = (word)MBM_MEM_UNITS(mb_ptr->start_ptr - &mbmMemArray[0]);
        word end   = (word)(start + units);
        MbmMemInfoIndex i;
        MbmMemInfoIndex j = (MbmMemInfoIndex)0;

        WAIT4MX(MX_MBM_CS);
80009e24:	fe b0 ee 49 	rcall	80007ab6 <mns_take>

    ASSERT(mb_ptr);

    if( mb_ptr->start_ptr && mb_ptr->size )
    {
        word units = (word)MBM_MEM_UNITS(mb_ptr->size);
80009e28:	a3 84       	lsr	r4,0x2
        word start = (word)MBM_MEM_UNITS(mb_ptr->start_ptr - &mbmMemArray[0]);
80009e2a:	eb d5 b0 50 	bfexts	r5,r5,0x2,0x10
        MbmMemInfoIndex i;
        MbmMemInfoIndex j = (MbmMemInfoIndex)0;

        WAIT4MX(MX_MBM_CS);

        i = memInfoArray[0].next;
80009e2e:	0d 82       	ld.ub	r2,r6[0x0]
        /* If i == 0 it's the Head and no match was found */
        while( i && (start > (memInfoArray[i].start + memInfoArray[i].size)) )
80009e30:	58 02       	cp.w	r2,0
80009e32:	c2 90       	breq	80009e84 <MbmMemFree+0x98>
80009e34:	e4 02 00 19 	add	r9,r2,r2<<0x1
80009e38:	ec 09 00 19 	add	r9,r6,r9<<0x1
80009e3c:	04 98       	mov	r8,r2
80009e3e:	92 2b       	ld.sh	r11,r9[0x4]
80009e40:	92 1a       	ld.sh	r10,r9[0x2]
80009e42:	fd db c0 10 	bfextu	lr,r11,0x0,0x10
80009e46:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80009e4a:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80009e4e:	fc 09 00 09 	add	r9,lr,r9
80009e52:	18 39       	cp.w	r9,r12
80009e54:	c4 64       	brge	80009ee0 <MbmMemFree+0xf4>
        {
            j = i; /* Preceding if a new segment shall be added */
            i = memInfoArray[i].next;
80009e56:	0c 93       	mov	r3,r6
80009e58:	c1 08       	rjmp	80009e78 <MbmMemFree+0x8c>

        WAIT4MX(MX_MBM_CS);

        i = memInfoArray[0].next;
        /* If i == 0 it's the Head and no match was found */
        while( i && (start > (memInfoArray[i].start + memInfoArray[i].size)) )
80009e5a:	f0 08 00 19 	add	r9,r8,r8<<0x1
80009e5e:	e6 09 00 19 	add	r9,r3,r9<<0x1
80009e62:	92 2b       	ld.sh	r11,r9[0x4]
80009e64:	92 1a       	ld.sh	r10,r9[0x2]
80009e66:	fd db c0 10 	bfextu	lr,r11,0x0,0x10
80009e6a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80009e6e:	fc 09 00 09 	add	r9,lr,r9
80009e72:	18 39       	cp.w	r9,r12
80009e74:	c3 74       	brge	80009ee2 <MbmMemFree+0xf6>
80009e76:	10 92       	mov	r2,r8
        {
            j = i; /* Preceding if a new segment shall be added */
            i = memInfoArray[i].next;
80009e78:	f0 08 00 18 	add	r8,r8,r8<<0x1
80009e7c:	ec 08 07 18 	ld.ub	r8,r6[r8<<0x1]

        WAIT4MX(MX_MBM_CS);

        i = memInfoArray[0].next;
        /* If i == 0 it's the Head and no match was found */
        while( i && (start > (memInfoArray[i].start + memInfoArray[i].size)) )
80009e80:	58 08       	cp.w	r8,0
80009e82:	ce c1       	brne	80009e5a <MbmMemFree+0x6e>
            memInfoArray[i].start -= units;
        }
        else
        {
            /* TODO: Remove assert when through testing */
            ASSERT(memInfoFree.next);
80009e84:	4b 93       	lddpc	r3,80009f68 <MbmMemFree+0x17c>
80009e86:	07 88       	ld.ub	r8,r3[0x0]
80009e88:	58 08       	cp.w	r8,0
80009e8a:	c1 f0       	breq	80009ec8 <MbmMemFree+0xdc>

            /*
             * Get a new segment and link it in front of where the search ended.
             */
            i = memInfoFree.next;
            MBM_MEM_UNLINK(memInfoFree, memInfoArray, i);
80009e8c:	f0 08 00 19 	add	r9,r8,r8<<0x1

            /*
             * Link this behind 'j', because it is either the head or the
             * segment closest in front of this one
             */
            MBM_MEM_LINK(memInfoArray[j], memInfoArray, i);
80009e90:	e4 02 00 12 	add	r2,r2,r2<<0x1
80009e94:	ec 02 00 12 	add	r2,r6,r2<<0x1

            /*
             * Get a new segment and link it in front of where the search ended.
             */
            i = memInfoFree.next;
            MBM_MEM_UNLINK(memInfoFree, memInfoArray, i);
80009e98:	ec 09 00 16 	add	r6,r6,r9<<0x1
            memInfoArray[i].start = start;
80009e9c:	ac 15       	st.h	r6[0x2],r5
            memInfoArray[i].size  = units;
80009e9e:	ac 24       	st.h	r6[0x4],r4

            /*
             * Get a new segment and link it in front of where the search ended.
             */
            i = memInfoFree.next;
            MBM_MEM_UNLINK(memInfoFree, memInfoArray, i);
80009ea0:	0d 89       	ld.ub	r9,r6[0x0]

            /*
             * Link this behind 'j', because it is either the head or the
             * segment closest in front of this one
             */
            MBM_MEM_LINK(memInfoArray[j], memInfoArray, i);
80009ea2:	05 8a       	ld.ub	r10,r2[0x0]
80009ea4:	ac 8a       	st.b	r6[0x0],r10

            /*
             * Get a new segment and link it in front of where the search ended.
             */
            i = memInfoFree.next;
            MBM_MEM_UNLINK(memInfoFree, memInfoArray, i);
80009ea6:	a6 89       	st.b	r3[0x0],r9

            /*
             * Link this behind 'j', because it is either the head or the
             * segment closest in front of this one
             */
            MBM_MEM_LINK(memInfoArray[j], memInfoArray, i);
80009ea8:	a4 88       	st.b	r2[0x0],r8
            _MBM_USAGE_FRAG_INC();
        }
        _MBM_USAGE_MEM_FREE(units);
        REL_MX(MX_MBM_CS);
80009eaa:	30 0c       	mov	r12,0
80009eac:	fe b0 ee 06 	rcall	80007ab8 <mns_give>

        mb_ptr->start_ptr = mb_ptr->hdr_ptr = mb_ptr->payload_ptr = NULL;
80009eb0:	30 08       	mov	r8,0
        mb_ptr->size      = mb_ptr->hdr_len = mb_ptr->payload_len = (word)0;
80009eb2:	ef 58 00 30 	st.h	r7[48],r8
            _MBM_USAGE_FRAG_INC();
        }
        _MBM_USAGE_MEM_FREE(units);
        REL_MX(MX_MBM_CS);

        mb_ptr->start_ptr = mb_ptr->hdr_ptr = mb_ptr->payload_ptr = NULL;
80009eb6:	8f b8       	st.w	r7[0x2c],r8
80009eb8:	8f a8       	st.w	r7[0x28],r8
80009eba:	8f 48       	st.w	r7[0x10],r8
        mb_ptr->size      = mb_ptr->hdr_len = mb_ptr->payload_len = (word)0;
80009ebc:	ef 58 00 34 	st.h	r7[52],r8
80009ec0:	ef 58 00 32 	st.h	r7[50],r8
80009ec4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
            memInfoArray[i].start -= units;
        }
        else
        {
            /* TODO: Remove assert when through testing */
            ASSERT(memInfoFree.next);
80009ec8:	e0 68 03 d7 	mov	r8,983
80009ecc:	30 1a       	mov	r10,1
80009ece:	1a d8       	st.w	--sp,r8
80009ed0:	31 0b       	mov	r11,16
80009ed2:	e0 6c 80 00 	mov	r12,32768
80009ed6:	fe b0 ee 0b 	rcall	80007aec <mns_trace>
80009eda:	07 88       	ld.ub	r8,r3[0x0]
80009edc:	2f fd       	sub	sp,-4
80009ede:	cd 7b       	rjmp	80009e8c <MbmMemFree+0xa0>

        WAIT4MX(MX_MBM_CS);

        i = memInfoArray[0].next;
        /* If i == 0 it's the Head and no match was found */
        while( i && (start > (memInfoArray[i].start + memInfoArray[i].size)) )
80009ee0:	30 02       	mov	r2,0

    if( mb_ptr->start_ptr && mb_ptr->size )
    {
        word units = (word)MBM_MEM_UNITS(mb_ptr->size);
        word start = (word)MBM_MEM_UNITS(mb_ptr->start_ptr - &mbmMemArray[0]);
        word end   = (word)(start + units);
80009ee2:	ea 04 00 0e 	add	lr,r5,r4
80009ee6:	08 93       	mov	r3,r4
80009ee8:	5c 8e       	casts.h	lr
        {
            j = i; /* Preceding if a new segment shall be added */
            i = memInfoArray[i].next;
        }

        if( i && (start == (memInfoArray[i].start + memInfoArray[i].size)) )
80009eea:	12 3c       	cp.w	r12,r9
80009eec:	c1 90       	breq	80009f1e <MbmMemFree+0x132>
                MBM_MEM_UNLINK(memInfoArray[i], memInfoArray, j);
                MBM_MEM_LINK(memInfoFree, memInfoArray, j);
                _MBM_USAGE_FRAG_DEC();
            }
        }
        else if( i && (end == memInfoArray[i].start) )
80009eee:	f4 0e 19 00 	cp.h	lr,r10
80009ef2:	cc 91       	brne	80009e84 <MbmMemFree+0x98>
        {
            /* Append freed segment to the front of the found one */
            memInfoArray[i].size  += units;
80009ef4:	f0 08 00 18 	add	r8,r8,r8<<0x1
80009ef8:	08 0b       	add	r11,r4
80009efa:	ec 08 00 16 	add	r6,r6,r8<<0x1
            memInfoArray[i].start -= units;
80009efe:	8c 18       	ld.sh	r8,r6[0x2]
            }
        }
        else if( i && (end == memInfoArray[i].start) )
        {
            /* Append freed segment to the front of the found one */
            memInfoArray[i].size  += units;
80009f00:	ac 2b       	st.h	r6[0x4],r11
            memInfoArray[i].start -= units;
80009f02:	08 18       	sub	r8,r4
80009f04:	ac 18       	st.h	r6[0x2],r8
                MBM_MEM_UNLINK(memInfoArray[i], memInfoArray, j);
                MBM_MEM_LINK(memInfoFree, memInfoArray, j);
                _MBM_USAGE_FRAG_DEC();
            }
        }
        else if( i && (end == memInfoArray[i].start) )
80009f06:	cd 2b       	rjmp	80009eaa <MbmMemFree+0xbe>
#ifdef MBM_27
void MbmMemFree(MbmBuf *mb_ptr)
{
    T_LIB_ENTRY(MBM_27);

    ASSERT(mb_ptr);
80009f08:	e0 68 03 aa 	mov	r8,938
80009f0c:	30 1a       	mov	r10,1
80009f0e:	1a d8       	st.w	--sp,r8
80009f10:	31 0b       	mov	r11,16
80009f12:	e0 6c 80 00 	mov	r12,32768
80009f16:	fe b0 ed eb 	rcall	80007aec <mns_trace>
80009f1a:	2f fd       	sub	sp,-4
80009f1c:	c6 eb       	rjmp	80009df8 <MbmMemFree+0xc>
        }

        if( i && (start == (memInfoArray[i].start + memInfoArray[i].size)) )
        {
            /* Append freed segment to the end of the found one */
            memInfoArray[i].size += units;
80009f1e:	f0 08 00 18 	add	r8,r8,r8<<0x1
80009f22:	f6 04 00 0a 	add	r10,r11,r4
80009f26:	ec 08 00 16 	add	r6,r6,r8<<0x1
80009f2a:	5c 8a       	casts.h	r10
80009f2c:	ec c9 ff fc 	sub	r9,r6,-4
80009f30:	b2 0a       	st.h	r9[0x0],r10

            /* Check if the segment has grown to join the next one */
            j = memInfoArray[i].next;
80009f32:	0d 88       	ld.ub	r8,r6[0x0]
            if( j && (end == memInfoArray[j].start) )
80009f34:	58 08       	cp.w	r8,0
80009f36:	cb a0       	breq	80009eaa <MbmMemFree+0xbe>
80009f38:	f0 08 00 1c 	add	r12,r8,r8<<0x1
80009f3c:	48 ab       	lddpc	r11,80009f64 <MbmMemFree+0x178>
80009f3e:	f6 0c 00 1b 	add	r11,r11,r12<<0x1
80009f42:	96 1c       	ld.sh	r12,r11[0x2]
80009f44:	fc 0c 19 00 	cp.h	r12,lr
80009f48:	cb 11       	brne	80009eaa <MbmMemFree+0xbe>
            {
                /* Yes, join the next one and free the info structure */
                memInfoArray[i].size += memInfoArray[j].size;
80009f4a:	96 2c       	ld.sh	r12,r11[0x4]
80009f4c:	f8 0a 00 0a 	add	r10,r12,r10
80009f50:	b2 0a       	st.h	r9[0x0],r10
                MBM_MEM_UNLINK(memInfoArray[i], memInfoArray, j);
80009f52:	17 89       	ld.ub	r9,r11[0x0]
80009f54:	ac 89       	st.b	r6[0x0],r9
                MBM_MEM_LINK(memInfoFree, memInfoArray, j);
80009f56:	48 59       	lddpc	r9,80009f68 <MbmMemFree+0x17c>
80009f58:	13 8a       	ld.ub	r10,r9[0x0]
80009f5a:	b2 88       	st.b	r9[0x0],r8
80009f5c:	b6 8a       	st.b	r11[0x0],r10
80009f5e:	ca 6b       	rjmp	80009eaa <MbmMemFree+0xbe>
80009f60:	00 00       	add	r0,r0
80009f62:	42 24       	lddsp	r4,sp[0x88]
80009f64:	00 00       	add	r0,r0
80009f66:	34 6c       	mov	r12,70
80009f68:	00 00       	add	r0,r0
80009f6a:	35 2c       	mov	r12,82

80009f6c <MbmPush>:
80009f6c:	eb cd 40 80 	pushm	r7,lr
80009f70:	f9 09 00 32 	ld.sh	r9,r12[50]
80009f74:	f1 db c0 10 	bfextu	r8,r11,0x0,0x10

#ifdef MBM_15
byte *MbmPush(HMBMBUF handle, word size)
{
    T_LIB_ENTRY(MBM_15);
    handle->hdr_len += size;
80009f78:	f2 0b 00 0b 	add	r11,r9,r11
80009f7c:	f9 5b 00 32 	st.h	r12[50],r11
}
#endif

#ifdef MBM_15
byte *MbmPush(HMBMBUF handle, word size)
{
80009f80:	18 97       	mov	r7,r12
    T_LIB_ENTRY(MBM_15);
    handle->hdr_len += size;
    handle->hdr_ptr -= size;
80009f82:	78 ac       	ld.w	r12,r12[0x28]
80009f84:	10 1c       	sub	r12,r8
80009f86:	8f ac       	st.w	r7[0x28],r12
    ASSERT(handle->hdr_ptr >= handle->start_ptr);
80009f88:	6e 48       	ld.w	r8,r7[0x10]
80009f8a:	10 3c       	cp.w	r12,r8
80009f8c:	c0 c2       	brcc	80009fa4 <MbmPush+0x38>
80009f8e:	e0 68 02 97 	mov	r8,663
80009f92:	e0 6c 80 00 	mov	r12,32768
80009f96:	1a d8       	st.w	--sp,r8
80009f98:	30 1a       	mov	r10,1
80009f9a:	31 0b       	mov	r11,16
80009f9c:	fe b0 ed a8 	rcall	80007aec <mns_trace>
80009fa0:	6e ac       	ld.w	r12,r7[0x28]
80009fa2:	2f fd       	sub	sp,-4
    T_LIB_EXIT(MBM_15);
    return( handle->hdr_ptr );
}
80009fa4:	e3 cd 80 80 	ldm	sp++,r7,pc

80009fa8 <MbmReserve>:
80009fa8:	eb cd 40 80 	pushm	r7,lr
void MbmReserve(HMBMBUF handle, word size)
{
    MbmBuf *mb_ptr = handle;
    T_LIB_ENTRY(MBM_14);
    mb_ptr->hdr_ptr = mb_ptr->start_ptr + size;
    mb_ptr->hdr_len = (word)0;
80009fac:	30 09       	mov	r9,0
#ifdef MBM_14
void MbmReserve(HMBMBUF handle, word size)
{
    MbmBuf *mb_ptr = handle;
    T_LIB_ENTRY(MBM_14);
    mb_ptr->hdr_ptr = mb_ptr->start_ptr + size;
80009fae:	78 48       	ld.w	r8,r12[0x10]
80009fb0:	5c 7b       	castu.h	r11
    mb_ptr->hdr_len = (word)0;
80009fb2:	f9 59 00 32 	st.h	r12[50],r9
#ifdef MBM_14
void MbmReserve(HMBMBUF handle, word size)
{
    MbmBuf *mb_ptr = handle;
    T_LIB_ENTRY(MBM_14);
    mb_ptr->hdr_ptr = mb_ptr->start_ptr + size;
80009fb6:	f0 0b 00 0b 	add	r11,r8,r11
80009fba:	99 ab       	st.w	r12[0x28],r11

    /**
     * hdr_ptr can be at start_ptr + size, this is a buffer with only reserved
     * space
     */
    ASSERT(mb_ptr->hdr_ptr <= (mb_ptr->start_ptr + mb_ptr->size));
80009fbc:	f9 19 00 30 	ld.uh	r9,r12[48]
}
#endif

#ifdef MBM_14
void MbmReserve(HMBMBUF handle, word size)
{
80009fc0:	18 97       	mov	r7,r12

    /**
     * hdr_ptr can be at start_ptr + size, this is a buffer with only reserved
     * space
     */
    ASSERT(mb_ptr->hdr_ptr <= (mb_ptr->start_ptr + mb_ptr->size));
80009fc2:	12 08       	add	r8,r9
80009fc4:	10 3b       	cp.w	r11,r8
80009fc6:	e0 8b 00 0e 	brhi	80009fe2 <MbmReserve+0x3a>
80009fca:	16 99       	mov	r9,r11
     * If there is no payload space left after reserving, set *Data to the start
     * of the memory array so a valid pointer always will be passed.
     */
    mb_ptr->msg.dataTx.Data = (mb_ptr->hdr_ptr < (mb_ptr->start_ptr + mb_ptr->size))
                              ? mb_ptr->hdr_ptr : &mbmMemArray[0];
    mb_ptr->payload_ptr = mb_ptr->hdr_ptr;
80009fcc:	8f b9       	st.w	r7[0x2c],r9
     * This may very well overwrite a CMD or STATUS, but the structure can not
     * be in use yet, so it doesn't matter.
     * If there is no payload space left after reserving, set *Data to the start
     * of the memory array so a valid pointer always will be passed.
     */
    mb_ptr->msg.dataTx.Data = (mb_ptr->hdr_ptr < (mb_ptr->start_ptr + mb_ptr->size))
80009fce:	48 f9       	lddpc	r9,8000a008 <MbmReserve+0x60>
80009fd0:	10 3b       	cp.w	r11,r8
80009fd2:	f2 0b 17 20 	movhs	r11,r9
                              ? mb_ptr->hdr_ptr : &mbmMemArray[0];
    mb_ptr->payload_ptr = mb_ptr->hdr_ptr;
    mb_ptr->payload_len = (word)0;
80009fd6:	30 08       	mov	r8,0
     * This may very well overwrite a CMD or STATUS, but the structure can not
     * be in use yet, so it doesn't matter.
     * If there is no payload space left after reserving, set *Data to the start
     * of the memory array so a valid pointer always will be passed.
     */
    mb_ptr->msg.dataTx.Data = (mb_ptr->hdr_ptr < (mb_ptr->start_ptr + mb_ptr->size))
80009fd8:	8f 5b       	st.w	r7[0x14],r11
                              ? mb_ptr->hdr_ptr : &mbmMemArray[0];
    mb_ptr->payload_ptr = mb_ptr->hdr_ptr;
    mb_ptr->payload_len = (word)0;
80009fda:	ef 58 00 34 	st.h	r7[52],r8
    mb_ptr->append.segCnt = (byte)0;
    #endif
    #endif

    T_LIB_EXIT(MBM_14);
}
80009fde:	e3 cd 80 80 	ldm	sp++,r7,pc

    /**
     * hdr_ptr can be at start_ptr + size, this is a buffer with only reserved
     * space
     */
    ASSERT(mb_ptr->hdr_ptr <= (mb_ptr->start_ptr + mb_ptr->size));
80009fe2:	e0 68 02 76 	mov	r8,630
80009fe6:	30 1a       	mov	r10,1
80009fe8:	1a d8       	st.w	--sp,r8
80009fea:	31 0b       	mov	r11,16
80009fec:	e0 6c 80 00 	mov	r12,32768
80009ff0:	fe b0 ed 7e 	rcall	80007aec <mns_trace>
80009ff4:	6e a9       	ld.w	r9,r7[0x28]
80009ff6:	ef 18 00 30 	ld.uh	r8,r7[48]
80009ffa:	6e 4a       	ld.w	r10,r7[0x10]
80009ffc:	2f fd       	sub	sp,-4
80009ffe:	f4 08 00 08 	add	r8,r10,r8
8000a002:	12 9b       	mov	r11,r9
8000a004:	ce 4b       	rjmp	80009fcc <MbmReserve+0x24>
8000a006:	d7 03       	nop
8000a008:	00 00       	add	r0,r0
8000a00a:	42 24       	lddsp	r4,sp[0x88]

8000a00c <_MbmUnlink>:
8000a00c:	eb cd 40 80 	pushm	r7,lr
}
#endif

#ifdef MBM_13
void _MbmUnlink(HMBMBUF handle)
{
8000a010:	18 97       	mov	r7,r12
    T_MOD_ENTRY(MBM_13);

    /* Not allowed to unlink an unlinked buffer */
    ASSERT((NULL != handle) && (NULL != handle->q_ptr));
8000a012:	58 0c       	cp.w	r12,0
8000a014:	c1 40       	breq	8000a03c <_MbmUnlink+0x30>
8000a016:	78 28       	ld.w	r8,r12[0x8]
8000a018:	58 08       	cp.w	r8,0
8000a01a:	c1 10       	breq	8000a03c <_MbmUnlink+0x30>

    /* Simply cross-link next and previous */
    handle->prev_ptr->next_ptr = handle->next_ptr;
8000a01c:	6e 18       	ld.w	r8,r7[0x4]
8000a01e:	6e 09       	ld.w	r9,r7[0x0]
8000a020:	91 09       	st.w	r8[0x0],r9
    handle->next_ptr->prev_ptr = handle->prev_ptr;
8000a022:	6e 08       	ld.w	r8,r7[0x0]
8000a024:	6e 19       	ld.w	r9,r7[0x4]
8000a026:	91 19       	st.w	r8[0x4],r9
    handle->q_ptr->length--;
8000a028:	6e 28       	ld.w	r8,r7[0x8]
8000a02a:	90 59       	ld.sh	r9,r8[0xa]
8000a02c:	20 19       	sub	r9,1
8000a02e:	b0 59       	st.h	r8[0xa],r9
    handle->next_ptr = handle->prev_ptr = NULL;
8000a030:	30 08       	mov	r8,0
    handle->q_ptr    = NULL;
8000a032:	8f 28       	st.w	r7[0x8],r8

    /* Simply cross-link next and previous */
    handle->prev_ptr->next_ptr = handle->next_ptr;
    handle->next_ptr->prev_ptr = handle->prev_ptr;
    handle->q_ptr->length--;
    handle->next_ptr = handle->prev_ptr = NULL;
8000a034:	8f 18       	st.w	r7[0x4],r8
8000a036:	8f 08       	st.w	r7[0x0],r8
    handle->q_ptr    = NULL;
    T_MOD_EXIT(MBM_13);
}
8000a038:	e3 cd 80 80 	ldm	sp++,r7,pc
void _MbmUnlink(HMBMBUF handle)
{
    T_MOD_ENTRY(MBM_13);

    /* Not allowed to unlink an unlinked buffer */
    ASSERT((NULL != handle) && (NULL != handle->q_ptr));
8000a03c:	e0 68 02 5e 	mov	r8,606
8000a040:	30 1a       	mov	r10,1
8000a042:	1a d8       	st.w	--sp,r8
8000a044:	31 0b       	mov	r11,16
8000a046:	e0 6c 80 00 	mov	r12,32768
8000a04a:	fe b0 ed 51 	rcall	80007aec <mns_trace>
8000a04e:	2f fd       	sub	sp,-4
8000a050:	ce 6b       	rjmp	8000a01c <_MbmUnlink+0x10>
8000a052:	d7 03       	nop

8000a054 <_MbmPeek>:
8000a054:	eb cd 40 80 	pushm	r7,lr
}                                           /*lint +esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
#endif

#ifdef MBM_12
HMBMBUF _MbmPeek(const MbmQueue *q_ptr)
{
8000a058:	18 97       	mov	r7,r12
    HMBMBUF handle;

    T_LIB_ENTRY(MBM_12);

    ASSERT(q_ptr);
8000a05a:	58 0c       	cp.w	r12,0
8000a05c:	c0 70       	breq	8000a06a <_MbmPeek+0x16>

    /* Make pointer check, safer than checking count (in case someone has
     * linked more than what length can store) */
    if( q_ptr->next_ptr != (struct MbmBuf *)q_ptr )
8000a05e:	6e 0c       	ld.w	r12,r7[0x0]
    {
        handle = NULL;    /* List was empty */
    }
    T_LIB_EXIT(MBM_12);
    return( handle );
}
8000a060:	0e 3c       	cp.w	r12,r7
8000a062:	f9 bc 00 00 	moveq	r12,0
8000a066:	e3 cd 80 80 	ldm	sp++,r7,pc
{
    HMBMBUF handle;

    T_LIB_ENTRY(MBM_12);

    ASSERT(q_ptr);
8000a06a:	e0 68 02 46 	mov	r8,582
8000a06e:	30 1a       	mov	r10,1
8000a070:	1a d8       	st.w	--sp,r8
8000a072:	31 0b       	mov	r11,16
8000a074:	e0 6c 80 00 	mov	r12,32768
8000a078:	fe b0 ed 3a 	rcall	80007aec <mns_trace>
8000a07c:	2f fd       	sub	sp,-4
8000a07e:	cf 0b       	rjmp	8000a05e <_MbmPeek+0xa>

8000a080 <MbmDequeueLast>:
8000a080:	eb cd 40 c0 	pushm	r6-r7,lr
}                                           /*lint +esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
#endif

#ifdef MBM_11
HMBMBUF MbmDequeueLast(MbmQueue *q_ptr)     /*lint -esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
{
8000a084:	18 97       	mov	r7,r12
    HMBMBUF handle;

    T_LIB_ENTRY(MBM_11);
    ASSERT(q_ptr);
8000a086:	58 0c       	cp.w	r12,0
8000a088:	c1 10       	breq	8000a0aa <MbmDequeueLast+0x2a>

    WAIT4MX(q_ptr->mutex_id);
8000a08a:	8e cc       	ld.uh	r12,r7[0x8]
8000a08c:	fe b0 ed 15 	rcall	80007ab6 <mns_take>
    if( q_ptr->prev_ptr != (MbmBuf *)q_ptr )
8000a090:	6e 16       	ld.w	r6,r7[0x4]
8000a092:	0e 36       	cp.w	r6,r7
8000a094:	c0 90       	breq	8000a0a6 <MbmDequeueLast+0x26>
    {
        handle = q_ptr->prev_ptr;
        _MbmUnlink(handle);
8000a096:	0c 9c       	mov	r12,r6
8000a098:	cb af       	rcall	8000a00c <_MbmUnlink>
8000a09a:	8e cc       	ld.uh	r12,r7[0x8]
    }
    else
    {
        handle = NULL;
    }
    REL_MX(q_ptr->mutex_id);
8000a09c:	fe b0 ed 0e 	rcall	80007ab8 <mns_give>
8000a0a0:	0c 9c       	mov	r12,r6
    T_LIB_EXIT(MBM_11);

    return( handle );
}                                           /*lint +esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
8000a0a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a0a6:	30 06       	mov	r6,0

    T_LIB_ENTRY(MBM_11);
    ASSERT(q_ptr);

    WAIT4MX(q_ptr->mutex_id);
    if( q_ptr->prev_ptr != (MbmBuf *)q_ptr )
8000a0a8:	cf 9b       	rjmp	8000a09a <MbmDequeueLast+0x1a>
8000a0aa:	e0 68 02 2c 	mov	r8,556
HMBMBUF MbmDequeueLast(MbmQueue *q_ptr)     /*lint -esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
{
    HMBMBUF handle;

    T_LIB_ENTRY(MBM_11);
    ASSERT(q_ptr);
8000a0ae:	30 1a       	mov	r10,1
8000a0b0:	1a d8       	st.w	--sp,r8
8000a0b2:	31 0b       	mov	r11,16
8000a0b4:	e0 6c 80 00 	mov	r12,32768
8000a0b8:	fe b0 ed 1a 	rcall	80007aec <mns_trace>
8000a0bc:	2f fd       	sub	sp,-4
8000a0be:	ce 6b       	rjmp	8000a08a <MbmDequeueLast+0xa>

8000a0c0 <_MbmDequeue>:
8000a0c0:	eb cd 40 c0 	pushm	r6-r7,lr
8000a0c4:	18 97       	mov	r7,r12
8000a0c6:	58 0c       	cp.w	r12,0
8000a0c8:	c0 d0       	breq	8000a0e2 <_MbmDequeue+0x22>
8000a0ca:	6e 06       	ld.w	r6,r7[0x0]
8000a0cc:	0e 36       	cp.w	r6,r7
8000a0ce:	c0 60       	breq	8000a0da <_MbmDequeue+0x1a>
8000a0d0:	0c 9c       	mov	r12,r6
8000a0d2:	c9 df       	rcall	8000a00c <_MbmUnlink>
     * linked more than length can store) */
    if( q_ptr->next_ptr != (struct MbmBuf *)q_ptr )
    {
        /* Get handle to first buffer */
        handle = q_ptr->next_ptr;
        _MbmUnlink(handle);
8000a0d4:	0c 9c       	mov	r12,r6
    {
        handle = NULL;    /* List was empty */
    }
    T_LIB_EXIT(MBM_9);
    return( handle );
}                                           /*lint +esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
8000a0d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a0da:	30 06       	mov	r6,0

    ASSERT(q_ptr);

    /* Make pointer check, safer than checking count (in case someone has
     * linked more than length can store) */
    if( q_ptr->next_ptr != (struct MbmBuf *)q_ptr )
8000a0dc:	0c 9c       	mov	r12,r6
    {
        handle = NULL;    /* List was empty */
    }
    T_LIB_EXIT(MBM_9);
    return( handle );
}                                           /*lint +esym( 818, q_ptr ) queue may be modified in _MbmUnlink*/
8000a0de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a0e2:	e0 68 02 13 	mov	r8,531
{
    HMBMBUF handle;

    T_LIB_ENTRY(MBM_9);

    ASSERT(q_ptr);
8000a0e6:	30 1a       	mov	r10,1
8000a0e8:	1a d8       	st.w	--sp,r8
8000a0ea:	31 0b       	mov	r11,16
8000a0ec:	e0 6c 80 00 	mov	r12,32768
8000a0f0:	fe b0 ec fe 	rcall	80007aec <mns_trace>
8000a0f4:	2f fd       	sub	sp,-4
8000a0f6:	ce ab       	rjmp	8000a0ca <_MbmDequeue+0xa>

8000a0f8 <MbmDequeue>:
8000a0f8:	eb cd 40 c0 	pushm	r6-r7,lr
8000a0fc:	18 97       	mov	r7,r12
8000a0fe:	58 0c       	cp.w	r12,0
8000a100:	c0 d0       	breq	8000a11a <MbmDequeue+0x22>
8000a102:	8e cc       	ld.uh	r12,r7[0x8]
    HMBMBUF handle;
    T_LIB_ENTRY(MBM_8);

    ASSERT(q_ptr);

    WAIT4MX(q_ptr->mutex_id);
8000a104:	fe b0 ec d9 	rcall	80007ab6 <mns_take>
    handle = _MbmDequeue(q_ptr);
8000a108:	0e 9c       	mov	r12,r7
8000a10a:	cd bf       	rcall	8000a0c0 <_MbmDequeue>
8000a10c:	18 96       	mov	r6,r12
8000a10e:	8e cc       	ld.uh	r12,r7[0x8]
    REL_MX(q_ptr->mutex_id);
8000a110:	fe b0 ec d4 	rcall	80007ab8 <mns_give>
8000a114:	0c 9c       	mov	r12,r6

    T_LIB_EXIT(MBM_8);
    return( handle );
}
8000a116:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a11a:	e0 68 02 01 	mov	r8,513
HMBMBUF MbmDequeue(MbmQueue *q_ptr)
{
    HMBMBUF handle;
    T_LIB_ENTRY(MBM_8);

    ASSERT(q_ptr);
8000a11e:	30 1a       	mov	r10,1
8000a120:	1a d8       	st.w	--sp,r8
8000a122:	31 0b       	mov	r11,16
8000a124:	e0 6c 80 00 	mov	r12,32768
8000a128:	fe b0 ec e2 	rcall	80007aec <mns_trace>
8000a12c:	2f fd       	sub	sp,-4
8000a12e:	ce ab       	rjmp	8000a102 <MbmDequeue+0xa>

8000a130 <_MbmEnqueueFirst>:
8000a130:	eb cd 40 c0 	pushm	r6-r7,lr
8000a134:	18 97       	mov	r7,r12
8000a136:	16 96       	mov	r6,r11
8000a138:	58 0c       	cp.w	r12,0
8000a13a:	c0 c0       	breq	8000a152 <_MbmEnqueueFirst+0x22>
8000a13c:	8d 17       	st.w	r6[0x4],r7
8000a13e:	6e 08       	ld.w	r8,r7[0x0]
8000a140:	8d 08       	st.w	r6[0x0],r8
8000a142:	91 16       	st.w	r8[0x4],r6

    /* Fix node behind handle (previously behind q_ptr) */
    handle->next_ptr->prev_ptr = handle;

    /* Fix q_ptr */
    q_ptr->next_ptr = handle;
8000a144:	8f 06       	st.w	r7[0x0],r6

    handle->q_ptr = q_ptr;
8000a146:	8d 27       	st.w	r6[0x8],r7
    q_ptr->length++;
8000a148:	8e 58       	ld.sh	r8,r7[0xa]
8000a14a:	2f f8       	sub	r8,-1
8000a14c:	ae 58       	st.h	r7[0xa],r8
    T_LIB_EXIT(MBM_7);
}
8000a14e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef MBM_7
void _MbmEnqueueFirst(MbmQueue *q_ptr, HMBMBUF handle)
{
    T_LIB_ENTRY(MBM_7);

    ASSERT(q_ptr);
8000a152:	e0 68 01 e9 	mov	r8,489
8000a156:	30 1a       	mov	r10,1
8000a158:	1a d8       	st.w	--sp,r8
8000a15a:	31 0b       	mov	r11,16
8000a15c:	e0 6c 80 00 	mov	r12,32768
8000a160:	fe b0 ec c6 	rcall	80007aec <mns_trace>
8000a164:	2f fd       	sub	sp,-4
8000a166:	ce bb       	rjmp	8000a13c <_MbmEnqueueFirst+0xc>

8000a168 <MbmEnqueueFirst>:
8000a168:	eb cd 40 c0 	pushm	r6-r7,lr
}
#endif

#ifdef MBM_6
void MbmEnqueueFirst(MbmQueue *q_ptr, HMBMBUF handle)
{
8000a16c:	18 97       	mov	r7,r12
8000a16e:	16 96       	mov	r6,r11
    T_LIB_ENTRY(MBM_6);

    ASSERT(q_ptr);
8000a170:	58 0c       	cp.w	r12,0
8000a172:	c1 b0       	breq	8000a1a8 <MbmEnqueueFirst+0x40>

    WAIT4MX(q_ptr->mutex_id);
8000a174:	8e cc       	ld.uh	r12,r7[0x8]
8000a176:	fe b0 ec a0 	rcall	80007ab6 <mns_take>
    ASSERT((NULL != handle) && (NULL == handle->q_ptr));
8000a17a:	58 06       	cp.w	r6,0
8000a17c:	c0 40       	breq	8000a184 <MbmEnqueueFirst+0x1c>
8000a17e:	6c 28       	ld.w	r8,r6[0x8]
8000a180:	58 08       	cp.w	r8,0
8000a182:	c0 b0       	breq	8000a198 <MbmEnqueueFirst+0x30>
8000a184:	e0 68 01 dc 	mov	r8,476
8000a188:	30 1a       	mov	r10,1
8000a18a:	1a d8       	st.w	--sp,r8
8000a18c:	31 0b       	mov	r11,16
8000a18e:	e0 6c 80 00 	mov	r12,32768
8000a192:	fe b0 ec ad 	rcall	80007aec <mns_trace>
8000a196:	2f fd       	sub	sp,-4
    _MbmEnqueueFirst(q_ptr, handle);
8000a198:	0e 9c       	mov	r12,r7
8000a19a:	0c 9b       	mov	r11,r6
8000a19c:	cc af       	rcall	8000a130 <_MbmEnqueueFirst>
8000a19e:	8e cc       	ld.uh	r12,r7[0x8]
    REL_MX(q_ptr->mutex_id);
8000a1a0:	fe b0 ec 8c 	rcall	80007ab8 <mns_give>
8000a1a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    T_LIB_EXIT(MBM_6);
}
8000a1a8:	e0 68 01 d9 	mov	r8,473
#ifdef MBM_6
void MbmEnqueueFirst(MbmQueue *q_ptr, HMBMBUF handle)
{
    T_LIB_ENTRY(MBM_6);

    ASSERT(q_ptr);
8000a1ac:	30 1a       	mov	r10,1
8000a1ae:	1a d8       	st.w	--sp,r8
8000a1b0:	31 0b       	mov	r11,16
8000a1b2:	e0 6c 80 00 	mov	r12,32768
8000a1b6:	fe b0 ec 9b 	rcall	80007aec <mns_trace>
8000a1ba:	2f fd       	sub	sp,-4
8000a1bc:	cd cb       	rjmp	8000a174 <MbmEnqueueFirst+0xc>
8000a1be:	d7 03       	nop

8000a1c0 <_MbmEnqueue>:
8000a1c0:	eb cd 40 c0 	pushm	r6-r7,lr
8000a1c4:	18 97       	mov	r7,r12
8000a1c6:	16 96       	mov	r6,r11
8000a1c8:	58 0c       	cp.w	r12,0
8000a1ca:	c0 c0       	breq	8000a1e2 <_MbmEnqueue+0x22>
8000a1cc:	6e 18       	ld.w	r8,r7[0x4]
8000a1ce:	8d 07       	st.w	r6[0x0],r7
    T_LIB_ENTRY(MBM_5);

    ASSERT(q_ptr);

    /* Fix handle */
    handle->prev_ptr = q_ptr->prev_ptr;
8000a1d0:	8d 18       	st.w	r6[0x4],r8
    handle->next_ptr = (MbmBuf *)q_ptr;

    /* Fix node in front of handle (previously last) */
    handle->prev_ptr->next_ptr = handle;
8000a1d2:	91 06       	st.w	r8[0x0],r6

    /* Fix q_ptr */
    q_ptr->prev_ptr = handle;
8000a1d4:	8f 16       	st.w	r7[0x4],r6

    handle->q_ptr = q_ptr;
8000a1d6:	8d 27       	st.w	r6[0x8],r7
    q_ptr->length++;
8000a1d8:	8e 58       	ld.sh	r8,r7[0xa]
8000a1da:	2f f8       	sub	r8,-1
8000a1dc:	ae 58       	st.h	r7[0xa],r8
    T_LIB_EXIT(MBM_5);
}
8000a1de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef MBM_5
void _MbmEnqueue(MbmQueue *q_ptr, HMBMBUF handle)
{
    T_LIB_ENTRY(MBM_5);

    ASSERT(q_ptr);
8000a1e2:	e0 68 01 c2 	mov	r8,450
8000a1e6:	30 1a       	mov	r10,1
8000a1e8:	1a d8       	st.w	--sp,r8
8000a1ea:	31 0b       	mov	r11,16
8000a1ec:	e0 6c 80 00 	mov	r12,32768
8000a1f0:	fe b0 ec 7e 	rcall	80007aec <mns_trace>
8000a1f4:	2f fd       	sub	sp,-4
8000a1f6:	ce bb       	rjmp	8000a1cc <_MbmEnqueue+0xc>

8000a1f8 <MbmAllocate>:
8000a1f8:	eb cd 40 f8 	pushm	r3-r7,lr
}
#endif

#ifdef MBM_1
HMBMBUF MbmAllocate(word size, word reserved, word type)
{
8000a1fc:	20 1d       	sub	sp,4
8000a1fe:	ba 0c       	st.h	sp[0x0],r12
8000a200:	14 96       	mov	r6,r10
8000a202:	16 94       	mov	r4,r11
    word      used;            /* Used buffers of possibly reserved kind */
    word     *cnt_ptr;         /* Pointer to allocation counter          */

    T_LIB_ENTRY(MBM_1);

    WAIT4MX(MX_MBM_CS);
8000a204:	30 0c       	mov	r12,0
8000a206:	fe b0 ec 58 	rcall	80007ab6 <mns_take>
    if( type & MBM_TYPE_TX_BIT )
8000a20a:	ed b6 00 00 	bld	r6,0x0
8000a20e:	c1 d1       	brne	8000a248 <MbmAllocate+0x50>
    {
        rsvd    = msgPool.rxRsvd;
8000a210:	4a 38       	lddpc	r8,8000a29c <MbmAllocate+0xa4>
8000a212:	90 3a       	ld.sh	r10,r8[0x6]
        used    = msgPool.rxAlloc;
8000a214:	90 59       	ld.sh	r9,r8[0xa]
8000a216:	f0 c5 ff f8 	sub	r5,r8,-8
        used    = msgPool.txAlloc;
        cnt_ptr = &msgPool.rxAlloc;
    }

    /* How many buffers needs to stay reserved? */
    if( used < rsvd )
8000a21a:	f2 0a 19 00 	cp.h	r10,r9
8000a21e:	e0 8b 00 11 	brhi	8000a240 <MbmAllocate+0x48>
8000a222:	30 09       	mov	r9,0
    {
        rsvd = (word)0;
    }

    /* Check if any unreserved buffer is available */
    if( MBM_QUEUE_LENGTH(msgPool.q_ptr) > rsvd )
8000a224:	70 0c       	ld.w	r12,r8[0x0]
8000a226:	98 58       	ld.sh	r8,r12[0xa]
8000a228:	f2 08 19 00 	cp.h	r8,r9
8000a22c:	e0 8b 00 14 	brhi	8000a254 <MbmAllocate+0x5c>
                T_ALLOC((int)alloc_ptr, (int)msgPool.txAlloc, (int)msgPool.rxAlloc);
            }
            else
            {
                T_MALLOC_FAIL(size);
                _MbmEnqueue(msgPool.q_ptr, alloc_ptr);
8000a230:	30 07       	mov	r7,0
                alloc_ptr = NULL;
            }
        }
    }
    REL_MX(MX_MBM_CS);
8000a232:	30 0c       	mov	r12,0
8000a234:	fe b0 ec 42 	rcall	80007ab8 <mns_give>
    }
    #endif

    T_LIB_EXIT(MBM_1);
    return( alloc_ptr );
}
8000a238:	0e 9c       	mov	r12,r7
8000a23a:	2f fd       	sub	sp,-4
8000a23c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    }

    /* How many buffers needs to stay reserved? */
    if( used < rsvd )
    {
        rsvd -= used;
8000a240:	f4 09 01 09 	sub	r9,r10,r9
8000a244:	5c 89       	casts.h	r9
8000a246:	ce fb       	rjmp	8000a224 <MbmAllocate+0x2c>
        used    = msgPool.rxAlloc;
        cnt_ptr = &msgPool.txAlloc;
    }
    else
    {
        rsvd    = msgPool.txRsvd;
8000a248:	49 58       	lddpc	r8,8000a29c <MbmAllocate+0xa4>
8000a24a:	90 2a       	ld.sh	r10,r8[0x4]
        used    = msgPool.txAlloc;
8000a24c:	90 49       	ld.sh	r9,r8[0x8]
8000a24e:	f0 c5 ff f6 	sub	r5,r8,-10
8000a252:	ce 4b       	rjmp	8000a21a <MbmAllocate+0x22>
    }

    /* Check if any unreserved buffer is available */
    if( MBM_QUEUE_LENGTH(msgPool.q_ptr) > rsvd )
    {
        alloc_ptr = _MbmDequeue(msgPool.q_ptr);
8000a254:	c3 6f       	rcall	8000a0c0 <_MbmDequeue>
8000a256:	18 97       	mov	r7,r12
8000a258:	ce d0       	breq	8000a232 <MbmAllocate+0x3a>
        if( alloc_ptr )
8000a25a:	9a 03       	ld.sh	r3,sp[0x0]
        {
            word needed_size = size;
8000a25c:	1a 9c       	mov	r12,sp

            alloc_ptr->start_ptr = _MbmMemAlloc(&size);
8000a25e:	fe b0 fd 43 	rcall	80009ce4 <_MbmMemAlloc>
8000a262:	8f 4c       	st.w	r7[0x10],r12
8000a264:	5f 1a       	srne	r10

            if( alloc_ptr->start_ptr || !needed_size )
8000a266:	30 08       	mov	r8,0
8000a268:	f0 03 19 00 	cp.h	r3,r8
8000a26c:	5f 09       	sreq	r9
8000a26e:	12 4a       	or	r10,r9
8000a270:	f0 0a 18 00 	cp.b	r10,r8
8000a274:	c0 f0       	breq	8000a292 <MbmAllocate+0x9a>
8000a276:	9a 09       	ld.sh	r9,sp[0x0]
            {
                /*!
                 * hdr_ptr, hdr_len, payload_ptr & payload_len is set in
                 * MbmReserve() (or subfunctions).
                 */
                alloc_ptr->size = size;
8000a278:	08 9b       	mov	r11,r4

                #ifndef PACKET_COMMUNICATION_ONLY
                alloc_ptr->msg.msgRx.UsageCnt = (byte)0;
                #endif

                MbmReserve(alloc_ptr, reserved);
8000a27a:	ef 68 00 22 	st.b	r7[34],r8
                 */
                alloc_ptr->size = size;
                alloc_ptr->type = type;

                #ifndef PACKET_COMMUNICATION_ONLY
                alloc_ptr->msg.msgRx.UsageCnt = (byte)0;
8000a27e:	5c 7b       	castu.h	r11
                #endif

                MbmReserve(alloc_ptr, reserved);
8000a280:	ae 66       	st.h	r7[0xc],r6
                /*!
                 * hdr_ptr, hdr_len, payload_ptr & payload_len is set in
                 * MbmReserve() (or subfunctions).
                 */
                alloc_ptr->size = size;
                alloc_ptr->type = type;
8000a282:	ef 59 00 30 	st.h	r7[48],r9
            {
                /*!
                 * hdr_ptr, hdr_len, payload_ptr & payload_len is set in
                 * MbmReserve() (or subfunctions).
                 */
                alloc_ptr->size = size;
8000a286:	0e 9c       	mov	r12,r7

                #ifndef PACKET_COMMUNICATION_ONLY
                alloc_ptr->msg.msgRx.UsageCnt = (byte)0;
                #endif

                MbmReserve(alloc_ptr, reserved);
8000a288:	c9 0e       	rcall	80009fa8 <MbmReserve>
8000a28a:	8a 08       	ld.sh	r8,r5[0x0]
8000a28c:	2f f8       	sub	r8,-1
                (*cnt_ptr)++;
8000a28e:	aa 08       	st.h	r5[0x0],r8
8000a290:	cd 1b       	rjmp	8000a232 <MbmAllocate+0x3a>
8000a292:	48 38       	lddpc	r8,8000a29c <MbmAllocate+0xa4>
8000a294:	0e 9b       	mov	r11,r7
                T_ALLOC((int)alloc_ptr, (int)msgPool.txAlloc, (int)msgPool.rxAlloc);
            }
            else
            {
                T_MALLOC_FAIL(size);
                _MbmEnqueue(msgPool.q_ptr, alloc_ptr);
8000a296:	70 0c       	ld.w	r12,r8[0x0]
8000a298:	c9 4f       	rcall	8000a1c0 <_MbmEnqueue>
8000a29a:	cc bb       	rjmp	8000a230 <MbmAllocate+0x38>
8000a29c:	00 00       	add	r0,r0
8000a29e:	2d c4       	sub	r4,-36

8000a2a0 <MbmGetBuf>:
8000a2a0:	d4 01       	pushm	lr
8000a2a2:	31 78       	mov	r8,23
8000a2a4:	f0 0c 19 00 	cp.h	r12,r8
8000a2a8:	e0 8b 00 07 	brhi	8000a2b6 <MbmGetBuf+0x16>
8000a2ac:	31 8c       	mov	r12,24
8000a2ae:	30 0a       	mov	r10,0
8000a2b0:	14 9b       	mov	r11,r10
8000a2b2:	ca 3f       	rcall	8000a1f8 <MbmAllocate>
8000a2b4:	d8 02       	popm	pc
8000a2b6:	5c 7c       	castu.h	r12
8000a2b8:	cf bb       	rjmp	8000a2ae <MbmGetBuf+0xe>
8000a2ba:	d7 03       	nop

8000a2bc <MbmEnqueue>:
8000a2bc:	eb cd 40 c0 	pushm	r6-r7,lr
}
#endif

#ifdef MBM_4
void MbmEnqueue(MbmQueue *q_ptr, HMBMBUF handle)
{
8000a2c0:	18 97       	mov	r7,r12
8000a2c2:	16 96       	mov	r6,r11
    T_LIB_ENTRY(MBM_4);

    ASSERT(q_ptr);
8000a2c4:	58 0c       	cp.w	r12,0
8000a2c6:	c1 b0       	breq	8000a2fc <MbmEnqueue+0x40>

    WAIT4MX(q_ptr->mutex_id);
8000a2c8:	8e cc       	ld.uh	r12,r7[0x8]
8000a2ca:	fe b0 eb f6 	rcall	80007ab6 <mns_take>
    ASSERT((NULL != handle) && (NULL == handle->q_ptr));
8000a2ce:	58 06       	cp.w	r6,0
8000a2d0:	c0 40       	breq	8000a2d8 <MbmEnqueue+0x1c>
8000a2d2:	6c 28       	ld.w	r8,r6[0x8]
8000a2d4:	58 08       	cp.w	r8,0
8000a2d6:	c0 b0       	breq	8000a2ec <MbmEnqueue+0x30>
8000a2d8:	e0 68 01 b5 	mov	r8,437
8000a2dc:	30 1a       	mov	r10,1
8000a2de:	1a d8       	st.w	--sp,r8
8000a2e0:	31 0b       	mov	r11,16
8000a2e2:	e0 6c 80 00 	mov	r12,32768
8000a2e6:	fe b0 ec 03 	rcall	80007aec <mns_trace>
8000a2ea:	2f fd       	sub	sp,-4
    _MbmEnqueue(q_ptr, handle);
8000a2ec:	0e 9c       	mov	r12,r7
8000a2ee:	0c 9b       	mov	r11,r6
8000a2f0:	c6 8f       	rcall	8000a1c0 <_MbmEnqueue>
8000a2f2:	8e cc       	ld.uh	r12,r7[0x8]
    REL_MX(q_ptr->mutex_id);
8000a2f4:	fe b0 eb e2 	rcall	80007ab8 <mns_give>
8000a2f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    T_LIB_EXIT(MBM_4);
}
8000a2fc:	e0 68 01 b2 	mov	r8,434
#ifdef MBM_4
void MbmEnqueue(MbmQueue *q_ptr, HMBMBUF handle)
{
    T_LIB_ENTRY(MBM_4);

    ASSERT(q_ptr);
8000a300:	30 1a       	mov	r10,1
8000a302:	1a d8       	st.w	--sp,r8
8000a304:	31 0b       	mov	r11,16
8000a306:	e0 6c 80 00 	mov	r12,32768
8000a30a:	fe b0 eb f1 	rcall	80007aec <mns_trace>
8000a30e:	2f fd       	sub	sp,-4
8000a310:	cd cb       	rjmp	8000a2c8 <MbmEnqueue+0xc>
8000a312:	d7 03       	nop

8000a314 <MbmQueueInit>:
8000a314:	eb cd 40 c0 	pushm	r6-r7,lr
8000a318:	18 97       	mov	r7,r12
8000a31a:	16 96       	mov	r6,r11
8000a31c:	58 0c       	cp.w	r12,0
8000a31e:	c0 80       	breq	8000a32e <MbmQueueInit+0x1a>
8000a320:	30 08       	mov	r8,0
8000a322:	ae 46       	st.h	r7[0x8],r6
    T_LIB_ENTRY(MBM_3);

    ASSERT(q_ptr);

    /* initialize the list with no elements */
    q_ptr->next_ptr = (struct MbmBuf *)q_ptr;
8000a324:	8f 07       	st.w	r7[0x0],r7
    q_ptr->prev_ptr = (struct MbmBuf *)q_ptr;
8000a326:	8f 17       	st.w	r7[0x4],r7
    q_ptr->length   = (word)0;
8000a328:	ae 58       	st.h	r7[0xa],r8
    q_ptr->mutex_id = mutex_id;

    T_LIB_EXIT(MBM_3);
}
8000a32a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef MBM_3
void MbmQueueInit(MbmQueue *q_ptr, word mutex_id)
{
    T_LIB_ENTRY(MBM_3);

    ASSERT(q_ptr);
8000a32e:	e0 68 01 a1 	mov	r8,417
8000a332:	30 1a       	mov	r10,1
8000a334:	1a d8       	st.w	--sp,r8
8000a336:	31 0b       	mov	r11,16
8000a338:	e0 6c 80 00 	mov	r12,32768
8000a33c:	fe b0 eb d8 	rcall	80007aec <mns_trace>
8000a340:	2f fd       	sub	sp,-4
8000a342:	ce fb       	rjmp	8000a320 <MbmQueueInit+0xc>

8000a344 <MbmFree2>:
8000a344:	eb cd 40 c0 	pushm	r6-r7,lr
}
#endif

#ifdef MBM_2
void MbmFree2(HMBMBUF handle)
{
8000a348:	18 97       	mov	r7,r12
    T_API_ENTRY(MBM_2);

    ASSERT((NULL != handle) && (NULL == handle->q_ptr));
8000a34a:	58 0c       	cp.w	r12,0
8000a34c:	c0 40       	breq	8000a354 <MbmFree2+0x10>
8000a34e:	78 28       	ld.w	r8,r12[0x8]
8000a350:	58 08       	cp.w	r8,0
8000a352:	c0 b0       	breq	8000a368 <MbmFree2+0x24>
8000a354:	e0 68 01 7c 	mov	r8,380
8000a358:	30 1a       	mov	r10,1
8000a35a:	1a d8       	st.w	--sp,r8
8000a35c:	31 0b       	mov	r11,16
8000a35e:	e0 6c 80 00 	mov	r12,32768
8000a362:	fe b0 eb c5 	rcall	80007aec <mns_trace>
8000a366:	2f fd       	sub	sp,-4
{
    bool retval;

    T_LIB_ENTRY(MBM_30);

    if((handle >= &msgBufArray[0]) && (handle <= &msgBufArray[MBM_MSG_NUM-1]))
8000a368:	49 68       	lddpc	r8,8000a3c0 <MbmFree2+0x7c>
8000a36a:	10 37       	cp.w	r7,r8
8000a36c:	c2 43       	brcs	8000a3b4 <MbmFree2+0x70>
8000a36e:	f0 c8 f9 a8 	sub	r8,r8,-1624
8000a372:	10 37       	cp.w	r7,r8
8000a374:	e0 8b 00 20 	brhi	8000a3b4 <MbmFree2+0x70>

    ASSERT((NULL != handle) && (NULL == handle->q_ptr));

    if(MNS_FALSE != MbmIsFromPool(handle))
    {
        MbmMemFree(handle);
8000a378:	0e 9c       	mov	r12,r7
8000a37a:	fe b0 fd 39 	rcall	80009dec <MbmMemFree>

        WAIT4MX(MX_MBM_CS);
8000a37e:	30 0c       	mov	r12,0
8000a380:	fe b0 eb 9b 	rcall	80007ab6 <mns_take>
        _MbmEnqueue(msgPool.q_ptr, handle);
8000a384:	49 06       	lddpc	r6,8000a3c4 <MbmFree2+0x80>
8000a386:	0e 9b       	mov	r11,r7
8000a388:	6c 0c       	ld.w	r12,r6[0x0]
8000a38a:	c1 bf       	rcall	8000a1c0 <_MbmEnqueue>
8000a38c:	8e e8       	ld.uh	r8,r7[0xc]
        if( MBM_GET_TYPE(handle) & MBM_TYPE_TX_BIT )
8000a38e:	ed b8 00 00 	bld	r8,0x0
        {
            msgPool.txAlloc--;
8000a392:	ed f8 02 04 	ld.sheq	r8,r6[0x8]
8000a396:	f7 b8 00 01 	subeq	r8,1
8000a39a:	ed f8 0c 04 	st.heq	r6[0x8],r8
8000a39e:	ed f8 12 05 	ld.shne	r8,r6[0xa]
            _MBM_USAGE_UPDATE_TX();
        }
        else
        {
            msgPool.rxAlloc--;
8000a3a2:	f7 b8 01 01 	subne	r8,1
8000a3a6:	ed f8 1c 05 	st.hne	r6[0xa],r8
8000a3aa:	30 0c       	mov	r12,0
            _MBM_USAGE_UPDATE_RX();
        }
        _MBM_USAGE_UPDATE_NUM();
        T_FREE((int)handle, (int)msgPool.txAlloc, (int)msgPool.rxAlloc);
        REL_MX(MX_MBM_CS);
8000a3ac:	fe b0 eb 86 	rcall	80007ab8 <mns_give>
8000a3b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a3b4:	8e 68       	ld.sh	r8,r7[0xc]
    }
    else
    {
        /* Statically allocated message, just clear RSVD bit to mark it available */
        MBM_CLR_STATUS_BITS(handle, MBM_STAT_RSVD);
8000a3b6:	ab c8       	cbr	r8,0xa
8000a3b8:	ae 68       	st.h	r7[0xc],r8
8000a3ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a3be:	d7 03       	nop
8000a3c0:	00 00       	add	r0,r0
8000a3c2:	2d d0       	sub	r0,-35
8000a3c4:	00 00       	add	r0,r0
8000a3c6:	2d c4       	sub	r4,-36

8000a3c8 <MbmInit>:
8000a3c8:	eb cd 40 e0 	pushm	r5-r7,lr
8000a3cc:	30 0a       	mov	r10,0
8000a3ce:	30 7b       	mov	r11,7
8000a3d0:	e0 6c 80 00 	mov	r12,32768
8000a3d4:	fe b0 eb 8c 	rcall	80007aec <mns_trace>
8000a3d8:	30 0c       	mov	r12,0
8000a3da:	fe b0 eb 6e 	rcall	80007ab6 <mns_take>
    T_MOD_ENTRY(MBM_28);
    /*
     * Note that the head is the element with index zero and thus not a valid
     * index, this is used to mark the end of the list.
     */
    memInfoArray[0].next = (MbmMemInfoIndex)1;          /* First free segment */
8000a3de:	30 1b       	mov	r11,1
8000a3e0:	49 d8       	lddpc	r8,8000a454 <MbmInit+0x8c>
    memInfoArray[0].start = (word)0;
8000a3e2:	30 0a       	mov	r10,0
    T_MOD_ENTRY(MBM_28);
    /*
     * Note that the head is the element with index zero and thus not a valid
     * index, this is used to mark the end of the list.
     */
    memInfoArray[0].next = (MbmMemInfoIndex)1;          /* First free segment */
8000a3e4:	b0 8b       	st.b	r8[0x0],r11
    memInfoArray[0].start = (word)0;
8000a3e6:	b0 1a       	st.h	r8[0x2],r10
    memInfoArray[0].size = (word)0;                     /* Head has no size   */
8000a3e8:	b0 2a       	st.h	r8[0x4],r10
    memInfoArray[1].next = (MbmMemInfoIndex)0;          /* Only 1 large seg   */
8000a3ea:	b0 ea       	st.b	r8[0x6],r10
    memInfoArray[1].start = (word)0;
8000a3ec:	b0 4a       	st.h	r8[0x8],r10
    memInfoArray[1].size = MBM_CFG_UNIT_NUM;
8000a3ee:	e0 6b 02 00 	mov	r11,512
8000a3f2:	b0 5b       	st.h	r8[0xa],r11

    /* Create the list of free memory information structures */
    memInfoFree.next = (MbmMemInfoIndex)0;
    memInfoFree.size = (word)0;
8000a3f4:	f0 c9 ff f4 	sub	r9,r8,-12
8000a3f8:	49 8c       	lddpc	r12,8000a458 <MbmInit+0x90>
8000a3fa:	30 28       	mov	r8,2
8000a3fc:	b8 2a       	st.h	r12[0x4],r10
    /**
     * Index 0 is head of segment list. Index 1 is the first free segment (all)
     */
    i = (MbmMemInfoIndex)2;
    while( i < (MbmMemInfoIndex)(MBM_MEM_MAX_SEG + 1) )
8000a3fe:	32 0b       	mov	r11,32
    memInfoArray[1].start = (word)0;
    memInfoArray[1].size = MBM_CFG_UNIT_NUM;

    /* Create the list of free memory information structures */
    memInfoFree.next = (MbmMemInfoIndex)0;
    memInfoFree.size = (word)0;
8000a400:	30 0a       	mov	r10,0
     * Index 0 is head of segment list. Index 1 is the first free segment (all)
     */
    i = (MbmMemInfoIndex)2;
    while( i < (MbmMemInfoIndex)(MBM_MEM_MAX_SEG + 1) )
    {
        MBM_MEM_LINK(memInfoFree, memInfoArray, i);
8000a402:	b2 8a       	st.b	r9[0x0],r10
        i++;
8000a404:	10 9a       	mov	r10,r8
8000a406:	2f a9       	sub	r9,-6
8000a408:	2f f8       	sub	r8,-1
8000a40a:	5c 58       	castu.b	r8
    memInfoFree.size = (word)0;
    /**
     * Index 0 is head of segment list. Index 1 is the first free segment (all)
     */
    i = (MbmMemInfoIndex)2;
    while( i < (MbmMemInfoIndex)(MBM_MEM_MAX_SEG + 1) )
8000a40c:	f6 08 18 00 	cp.b	r8,r11
8000a410:	cf 91       	brne	8000a402 <MbmInit+0x3a>
8000a412:	31 f8       	mov	r8,31

    num      = is_ptr->numDataBufs;
    mbuf_ptr = is_ptr->firstMbmBuf_ptr;

    T_MOD_ENTRY(MBM_20);
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);
8000a414:	49 26       	lddpc	r6,8000a45c <MbmInit+0x94>
    memInfoFree.size = (word)0;
    /**
     * Index 0 is head of segment list. Index 1 is the first free segment (all)
     */
    i = (MbmMemInfoIndex)2;
    while( i < (MbmMemInfoIndex)(MBM_MEM_MAX_SEG + 1) )
8000a416:	b8 88       	st.b	r12[0x0],r8

    num      = is_ptr->numDataBufs;
    mbuf_ptr = is_ptr->firstMbmBuf_ptr;

    T_MOD_ENTRY(MBM_20);
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);
8000a418:	30 0b       	mov	r11,0
8000a41a:	0c 9c       	mov	r12,r6
8000a41c:	c7 cf       	rcall	8000a314 <MbmQueueInit>
8000a41e:	30 a9       	mov	r9,10

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
8000a420:	49 08       	lddpc	r8,8000a460 <MbmInit+0x98>
    mbuf_ptr = is_ptr->firstMbmBuf_ptr;

    T_MOD_ENTRY(MBM_20);
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
8000a422:	49 15       	lddpc	r5,8000a464 <MbmInit+0x9c>
    Library function implementations
================================================================================
*/

#ifdef MBM_0
void MbmInit(void)
8000a424:	91 06       	st.w	r8[0x0],r6
    mbuf_ptr = is_ptr->firstMbmBuf_ptr;

    T_MOD_ENTRY(MBM_20);
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
8000a426:	b0 39       	st.h	r8[0x6],r9
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
    is_ptr->pool_ptr->rxRsvd  = is_ptr->rxRsvd;
8000a428:	b0 29       	st.h	r8[0x4],r9

    T_MOD_ENTRY(MBM_20);
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
8000a42a:	0a 96       	mov	r6,r5
    Library function implementations
================================================================================
*/

#ifdef MBM_0
void MbmInit(void)
8000a42c:	30 09       	mov	r9,0
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
    is_ptr->pool_ptr->rxRsvd  = is_ptr->rxRsvd;
    is_ptr->pool_ptr->txAlloc = (word)0;
8000a42e:	30 07       	mov	r7,0
    is_ptr->pool_ptr->rxAlloc = (word)0;

    while( num-- )
    {
        mbuf_ptr->start_ptr   = NULL;
8000a430:	b0 59       	st.h	r8[0xa],r9

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
    is_ptr->pool_ptr->rxRsvd  = is_ptr->rxRsvd;
    is_ptr->pool_ptr->txAlloc = (word)0;
    is_ptr->pool_ptr->rxAlloc = (word)0;
8000a432:	b0 49       	st.h	r8[0x8],r9
    MbmQueueInit(is_ptr->q_ptr, (word)MX_MBM_CS);

    is_ptr->pool_ptr->q_ptr   = is_ptr->q_ptr;
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
    is_ptr->pool_ptr->rxRsvd  = is_ptr->rxRsvd;
    is_ptr->pool_ptr->txAlloc = (word)0;
8000a434:	ea c5 f9 70 	sub	r5,r5,-1680
    Library function implementations
================================================================================
*/

#ifdef MBM_0
void MbmInit(void)
8000a438:	8d 47       	st.w	r6[0x10],r7
    is_ptr->pool_ptr->txAlloc = (word)0;
    is_ptr->pool_ptr->rxAlloc = (word)0;

    while( num-- )
    {
        mbuf_ptr->start_ptr   = NULL;
8000a43a:	8d a7       	st.w	r6[0x28],r7
        mbuf_ptr->hdr_ptr     = NULL;
8000a43c:	8d b7       	st.w	r6[0x2c],r7
        mbuf_ptr->payload_ptr = NULL;
8000a43e:	0c 9b       	mov	r11,r6

        /* Enqueue and go to next */
        _MbmEnqueue(is_ptr->q_ptr, mbuf_ptr++);
8000a440:	48 7c       	lddpc	r12,8000a45c <MbmInit+0x94>
8000a442:	2c 86       	sub	r6,-56
8000a444:	cb ee       	rcall	8000a1c0 <_MbmEnqueue>
8000a446:	0a 36       	cp.w	r6,r5
8000a448:	cf 81       	brne	8000a438 <MbmInit+0x70>
    is_ptr->pool_ptr->txRsvd  = is_ptr->txRsvd;
    is_ptr->pool_ptr->rxRsvd  = is_ptr->rxRsvd;
    is_ptr->pool_ptr->txAlloc = (word)0;
    is_ptr->pool_ptr->rxAlloc = (word)0;

    while( num-- )
8000a44a:	0e 9c       	mov	r12,r7
8000a44c:	fe b0 eb 36 	rcall	80007ab8 <mns_give>
    #endif
    _MbmInitPool(&msgPoolInitData);

    _MBM_USAGE_INIT();

    REL_MX(MX_MBM_CS);
8000a450:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    #ifdef MBM_USAGE_API
    MBM_USAGE_INIT_CALLBACK(&mbmUsage.threshold);
    #endif

    T_LIB_EXIT(MBM_0);
}
8000a454:	00 00       	add	r0,r0
8000a456:	34 6c       	mov	r12,70
8000a458:	00 00       	add	r0,r0
8000a45a:	35 2c       	mov	r12,82
8000a45c:	00 00       	add	r0,r0
8000a45e:	34 60       	mov	r0,70
8000a460:	00 00       	add	r0,r0
8000a462:	2d c4       	sub	r4,-36
8000a464:	00 00       	add	r0,r0
8000a466:	2d d0       	sub	r0,-35

8000a468 <MbmGetBufLength>:
8000a468:	eb cd 40 80 	pushm	r7,lr
8000a46c:	18 97       	mov	r7,r12
8000a46e:	58 0c       	cp.w	r12,0
8000a470:	c1 40       	breq	8000a498 <MbmGetBufLength+0x30>
8000a472:	6e a9       	ld.w	r9,r7[0x28]
8000a474:	f9 0c 00 32 	ld.sh	r12,r12[50]
8000a478:	f1 dc c0 10 	bfextu	r8,r12,0x0,0x10
8000a47c:	f2 08 00 08 	add	r8,r9,r8

    len = handle->hdr_len;

    T_API_ENTRY(MBM_25);
    /* Add length of payload if it's continuous with headers */
    if( (handle->hdr_ptr + handle->hdr_len) == handle->payload_ptr )
8000a480:	6e b9       	ld.w	r9,r7[0x2c]
8000a482:	10 39       	cp.w	r9,r8
8000a484:	c0 30       	breq	8000a48a <MbmGetBufLength+0x22>
    {
        len += handle->payload_len;
    }
    T_API_EXIT(MBM_25);
    return( len );
}                                       /*lint +esym( 818, handle ) no use of HCMBMBUF in API functions*/
8000a486:	e3 cd 80 80 	ldm	sp++,r7,pc

    T_API_ENTRY(MBM_25);
    /* Add length of payload if it's continuous with headers */
    if( (handle->hdr_ptr + handle->hdr_len) == handle->payload_ptr )
    {
        len += handle->payload_len;
8000a48a:	ef 08 00 34 	ld.sh	r8,r7[52]
8000a48e:	f0 0c 00 0c 	add	r12,r8,r12
8000a492:	5c 8c       	casts.h	r12
    }
    T_API_EXIT(MBM_25);
    return( len );
}                                       /*lint +esym( 818, handle ) no use of HCMBMBUF in API functions*/
8000a494:	e3 cd 80 80 	ldm	sp++,r7,pc
  */
word MbmGetBufLength(HMBMBUF handle)    /*lint -esym( 818, handle ) no use of HCMBMBUF in API functions*/
{
    word len;

    ASSERT(handle);
8000a498:	e0 68 00 d3 	mov	r8,211
8000a49c:	e0 6c 80 00 	mov	r12,32768
8000a4a0:	1a d8       	st.w	--sp,r8
8000a4a2:	30 1a       	mov	r10,1
8000a4a4:	31 0b       	mov	r11,16
8000a4a6:	fe b0 eb 23 	rcall	80007aec <mns_trace>
8000a4aa:	0e 9c       	mov	r12,r7
8000a4ac:	2f fd       	sub	sp,-4
8000a4ae:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a4b2:	d7 03       	nop

8000a4b4 <MbmGetBufData>:
8000a4b4:	eb cd 40 80 	pushm	r7,lr
  *             is always to the initial segment. The second, payload,
  *             segement is passed to the LLD by the PMS.
  * \return     Pointer to initial or only data segment
  */
byte *MbmGetBufData(HMBMBUF handle)         /*lint -esym( 818, handle ) no use of HCMBMBUF in API functions*/
{
8000a4b8:	18 97       	mov	r7,r12
    ASSERT(handle);
8000a4ba:	58 0c       	cp.w	r12,0
8000a4bc:	c0 40       	breq	8000a4c4 <MbmGetBufData+0x10>
        return(NULL);
    }

    T_API_ENTRY(MBM_24);
    T_API_EXIT(MBM_24);
    return( handle->hdr_ptr );
8000a4be:	78 ac       	ld.w	r12,r12[0x28]
}                                           /*lint +esym( 818, handle ) no use of HCMBMBUF in API functions*/
8000a4c0:	e3 cd 80 80 	ldm	sp++,r7,pc
  *             segement is passed to the LLD by the PMS.
  * \return     Pointer to initial or only data segment
  */
byte *MbmGetBufData(HMBMBUF handle)         /*lint -esym( 818, handle ) no use of HCMBMBUF in API functions*/
{
    ASSERT(handle);
8000a4c4:	e0 68 00 bb 	mov	r8,187
8000a4c8:	e0 6c 80 00 	mov	r12,32768
8000a4cc:	1a d8       	st.w	--sp,r8
8000a4ce:	30 1a       	mov	r10,1
8000a4d0:	31 0b       	mov	r11,16
8000a4d2:	fe b0 eb 0d 	rcall	80007aec <mns_trace>
8000a4d6:	0e 9c       	mov	r12,r7
8000a4d8:	2f fd       	sub	sp,-4
8000a4da:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a4de:	d7 03       	nop

8000a4e0 <MbmFlush>:
8000a4e0:	eb cd 40 80 	pushm	r7,lr
}
#endif

#ifdef MBM_23
void MbmFlush(MbmQueue *q_ptr)
{
8000a4e4:	18 97       	mov	r7,r12
    HMBMBUF handle;
    T_LIB_ENTRY(MBM_23);

    ASSERT(q_ptr);
8000a4e6:	58 0c       	cp.w	r12,0
8000a4e8:	c0 b0       	breq	8000a4fe <MbmFlush+0x1e>

    do
    {
        handle = MbmDequeue(q_ptr);
8000a4ea:	0e 9c       	mov	r12,r7
8000a4ec:	c0 6e       	rcall	8000a0f8 <MbmDequeue>
8000a4ee:	c0 60       	breq	8000a4fa <MbmFlush+0x1a>
        if( NULL != handle )
8000a4f0:	e0 a0 15 34 	rcall	8000cf58 <MbmFree>
        {
            MbmFree(handle);
8000a4f4:	0e 9c       	mov	r12,r7

    ASSERT(q_ptr);

    do
    {
        handle = MbmDequeue(q_ptr);
8000a4f6:	c0 1e       	rcall	8000a0f8 <MbmDequeue>
8000a4f8:	cf c1       	brne	8000a4f0 <MbmFlush+0x10>
8000a4fa:	e3 cd 80 80 	ldm	sp++,r7,pc
        if( NULL != handle )
8000a4fe:	e0 68 03 36 	mov	r8,822
void MbmFlush(MbmQueue *q_ptr)
{
    HMBMBUF handle;
    T_LIB_ENTRY(MBM_23);

    ASSERT(q_ptr);
8000a502:	30 1a       	mov	r10,1
8000a504:	1a d8       	st.w	--sp,r8
8000a506:	31 0b       	mov	r11,16
8000a508:	e0 6c 80 00 	mov	r12,32768
8000a50c:	fe b0 ea f0 	rcall	80007aec <mns_trace>
8000a510:	2f fd       	sub	sp,-4
8000a512:	ce cb       	rjmp	8000a4ea <MbmFlush+0xa>

8000a514 <MbmChangeType>:
8000a514:	eb cd 40 f8 	pushm	r3-r7,lr
8000a518:	20 4d       	sub	sp,16
8000a51a:	18 97       	mov	r7,r12
8000a51c:	16 96       	mov	r6,r11
8000a51e:	58 0c       	cp.w	r12,0
8000a520:	c0 50       	breq	8000a52a <MbmChangeType+0x16>
8000a522:	4e e8       	lddpc	r8,8000a6d8 <MbmChangeType+0x1c4>
{
    bool retval;

    T_LIB_ENTRY(MBM_30);

    if((handle >= &msgBufArray[0]) && (handle <= &msgBufArray[MBM_MSG_NUM-1]))
8000a524:	10 3c       	cp.w	r12,r8
8000a526:	e0 82 00 a3 	brhs	8000a66c <MbmChangeType+0x158>
    word rsvd;
    word used;

    T_LIB_ENTRY(MBM_16);

    ASSERT(handle && (MNS_FALSE != MbmIsFromPool(handle)));
8000a52a:	e0 68 02 a7 	mov	r8,679
8000a52e:	30 1a       	mov	r10,1
8000a530:	1a d8       	st.w	--sp,r8
8000a532:	31 0b       	mov	r11,16
8000a534:	e0 6c 80 00 	mov	r12,32768
8000a538:	fe b0 ea da 	rcall	80007aec <mns_trace>
    ASSERT((word)0 == (newType & (word)~MBM_TYPE_MASK)); /* parameter newtype must not contain status bits */
8000a53c:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
    word rsvd;
    word used;

    T_LIB_ENTRY(MBM_16);

    ASSERT(handle && (MNS_FALSE != MbmIsFromPool(handle)));
8000a540:	2f fd       	sub	sp,-4
    ASSERT((word)0 == (newType & (word)~MBM_TYPE_MASK)); /* parameter newtype must not contain status bits */
8000a542:	0a 98       	mov	r8,r5
8000a544:	e2 18 ff f0 	andl	r8,0xfff0,COH
8000a548:	e0 81 00 9e 	brne	8000a684 <MbmChangeType+0x170>

    oldType = MBM_GET_TYPE(handle);
8000a54c:	8e 64       	ld.sh	r4,r7[0xc]

    MBM_SET_TYPE(handle, newType);
    MBM_CLR_STATUS_BITS(handle, MBM_STAT_NONPROTECTED_MASK);
8000a54e:	f1 d6 c0 04 	bfextu	r8,r6,0x0,0x4
8000a552:	08 99       	mov	r9,r4
8000a554:	e2 19 1c 80 	andl	r9,0x1c80,COH
8000a558:	f3 e8 10 08 	or	r8,r9,r8
8000a55c:	ae 68       	st.h	r7[0xc],r8

    handle->tel_id = (byte)0;
8000a55e:	30 08       	mov	r8,0
8000a560:	ef 68 00 36 	st.b	r7[54],r8
    T_LIB_ENTRY(MBM_16);

    ASSERT(handle && (MNS_FALSE != MbmIsFromPool(handle)));
    ASSERT((word)0 == (newType & (word)~MBM_TYPE_MASK)); /* parameter newtype must not contain status bits */

    oldType = MBM_GET_TYPE(handle);
8000a564:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
    MBM_SET_TYPE(handle, newType);
    MBM_CLR_STATUS_BITS(handle, MBM_STAT_NONPROTECTED_MASK);

    handle->tel_id = (byte)0;

    if( (MBM_TYPE_CTRL_TX == oldType) && (MBM_TYPE_CTRL_RX == newType) )
8000a568:	30 4a       	mov	r10,4
8000a56a:	30 5b       	mov	r11,5
8000a56c:	f4 06 19 00 	cp.h	r6,r10
8000a570:	5f 0c       	sreq	r12
8000a572:	f6 04 19 00 	cp.h	r4,r11
8000a576:	5f 09       	sreq	r9
8000a578:	f9 e9 00 09 	and	r9,r12,r9
8000a57c:	f0 09 18 00 	cp.b	r9,r8
8000a580:	c2 c0       	breq	8000a5d8 <MbmChangeType+0xc4>
    {
        MbmCtrlTx  tx     = *MBM_GET_CTRL_TX_PTR(handle); /* Copy current structure */
8000a582:	ef 09 00 18 	ld.sh	r9,r7[24]
        rx_ptr->Src_Adr   = tx.Tgt_Adr;
        rx_ptr->FBlock_ID = tx.FBlock_ID;
        rx_ptr->Inst_ID   = tx.Inst_ID;
        rx_ptr->Func_ID   = tx.Func_ID;
        rx_ptr->Operation = tx.Operation;
        rx_ptr->Length    = tx.Length;
8000a586:	ef 59 00 18 	st.h	r7[24],r9

    handle->tel_id = (byte)0;

    if( (MBM_TYPE_CTRL_TX == oldType) && (MBM_TYPE_CTRL_RX == newType) )
    {
        MbmCtrlTx  tx     = *MBM_GET_CTRL_TX_PTR(handle); /* Copy current structure */
8000a58a:	ef 39 00 20 	ld.ub	r9,r7[32]
        MbmCtrlRx *rx_ptr = MBM_GET_CTRL_RX_PTR(handle);
        rx_ptr->Src_Adr   = tx.Tgt_Adr;
        rx_ptr->FBlock_ID = tx.FBlock_ID;
        rx_ptr->Inst_ID   = tx.Inst_ID;
        rx_ptr->Func_ID   = tx.Func_ID;
        rx_ptr->Operation = tx.Operation;
8000a58e:	ef 69 00 20 	st.b	r7[32],r9

    handle->tel_id = (byte)0;

    if( (MBM_TYPE_CTRL_TX == oldType) && (MBM_TYPE_CTRL_RX == newType) )
    {
        MbmCtrlTx  tx     = *MBM_GET_CTRL_TX_PTR(handle); /* Copy current structure */
8000a592:	ef 09 00 1c 	ld.sh	r9,r7[28]
        rx_ptr->Func_ID   = tx.Func_ID;
        rx_ptr->Operation = tx.Operation;
        rx_ptr->Length    = tx.Length;
        rx_ptr->Data      = tx.Data;
        rx_ptr->Rcv_Type  = PMS_DEF_RCVTYPE;
        rx_ptr->UsageCnt  = (byte)0;
8000a596:	ef 68 00 22 	st.b	r7[34],r8
        rx_ptr->Inst_ID   = tx.Inst_ID;
        rx_ptr->Func_ID   = tx.Func_ID;
        rx_ptr->Operation = tx.Operation;
        rx_ptr->Length    = tx.Length;
        rx_ptr->Data      = tx.Data;
        rx_ptr->Rcv_Type  = PMS_DEF_RCVTYPE;
8000a59a:	ef 68 00 21 	st.b	r7[33],r8
        MbmCtrlTx  tx     = *MBM_GET_CTRL_TX_PTR(handle); /* Copy current structure */
        MbmCtrlRx *rx_ptr = MBM_GET_CTRL_RX_PTR(handle);
        rx_ptr->Src_Adr   = tx.Tgt_Adr;
        rx_ptr->FBlock_ID = tx.FBlock_ID;
        rx_ptr->Inst_ID   = tx.Inst_ID;
        rx_ptr->Func_ID   = tx.Func_ID;
8000a59e:	ef 59 00 1c 	st.h	r7[28],r9

    handle->tel_id = (byte)0;

    if( (MBM_TYPE_CTRL_TX == oldType) && (MBM_TYPE_CTRL_RX == newType) )
    {
        MbmCtrlTx  tx     = *MBM_GET_CTRL_TX_PTR(handle); /* Copy current structure */
8000a5a2:	ef 39 00 1f 	ld.ub	r9,r7[31]
        MbmCtrlRx *rx_ptr = MBM_GET_CTRL_RX_PTR(handle);
        rx_ptr->Src_Adr   = tx.Tgt_Adr;
        rx_ptr->FBlock_ID = tx.FBlock_ID;
        rx_ptr->Inst_ID   = tx.Inst_ID;
8000a5a6:	ef 69 00 1f 	st.b	r7[31],r9

    handle->tel_id = (byte)0;

    if( (MBM_TYPE_CTRL_TX == oldType) && (MBM_TYPE_CTRL_RX == newType) )
    {
        MbmCtrlTx  tx     = *MBM_GET_CTRL_TX_PTR(handle); /* Copy current structure */
8000a5aa:	6e 58       	ld.w	r8,r7[0x14]
        rx_ptr->UsageCnt  = (byte)0;
        #ifdef CTRL_FILTER_ID
        rx_ptr->Filter_ID = tx.Filter_ID;
        #endif

        if( NULL == rx_ptr->Data )
8000a5ac:	58 08       	cp.w	r8,0
8000a5ae:	e0 80 00 91 	breq	8000a6d0 <MbmChangeType+0x1bc>
        */
        MbmReserve(handle, (word)PMS_CTRL_HDR_MAX_SIZE);
        tx_ptr->Length = (word)(handle->size - (tx_ptr->Data - handle->start_ptr));
    }

    WAIT4MX(MX_MBM_CS);
8000a5b2:	30 0c       	mov	r12,0
    if( (oldType ^ newType) & MBM_TYPE_TX_BIT ) /* Did the RX/TX type change? */
8000a5b4:	08 56       	eor	r6,r4
        */
        MbmReserve(handle, (word)PMS_CTRL_HDR_MAX_SIZE);
        tx_ptr->Length = (word)(handle->size - (tx_ptr->Data - handle->start_ptr));
    }

    WAIT4MX(MX_MBM_CS);
8000a5b6:	fe b0 ea 80 	rcall	80007ab6 <mns_take>
    if( (oldType ^ newType) & MBM_TYPE_TX_BIT ) /* Did the RX/TX type change? */
8000a5ba:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
8000a5be:	c4 50       	breq	8000a648 <MbmChangeType+0x134>
    {
        if( MBM_TYPE_TX_BIT & newType )         /* RX => TX? */
8000a5c0:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
8000a5c4:	c7 d0       	breq	8000a6be <MbmChangeType+0x1aa>
8000a5c6:	4c 68       	lddpc	r8,8000a6dc <MbmChangeType+0x1c8>
        {
            msgPool.rxAlloc--;
8000a5c8:	90 59       	ld.sh	r9,r8[0xa]
8000a5ca:	90 4a       	ld.sh	r10,r8[0x8]
            msgPool.txAlloc++;
8000a5cc:	20 19       	sub	r9,1
    WAIT4MX(MX_MBM_CS);
    if( (oldType ^ newType) & MBM_TYPE_TX_BIT ) /* Did the RX/TX type change? */
    {
        if( MBM_TYPE_TX_BIT & newType )         /* RX => TX? */
        {
            msgPool.rxAlloc--;
8000a5ce:	2f fa       	sub	r10,-1
            msgPool.txAlloc++;
8000a5d0:	5c 89       	casts.h	r9
    WAIT4MX(MX_MBM_CS);
    if( (oldType ^ newType) & MBM_TYPE_TX_BIT ) /* Did the RX/TX type change? */
    {
        if( MBM_TYPE_TX_BIT & newType )         /* RX => TX? */
        {
            msgPool.rxAlloc--;
8000a5d2:	b0 4a       	st.h	r8[0x8],r10
            msgPool.txAlloc++;
8000a5d4:	b0 59       	st.h	r8[0xa],r9
    WAIT4MX(MX_MBM_CS);
    if( (oldType ^ newType) & MBM_TYPE_TX_BIT ) /* Did the RX/TX type change? */
    {
        if( MBM_TYPE_TX_BIT & newType )         /* RX => TX? */
        {
            msgPool.rxAlloc--;
8000a5d6:	c6 48       	rjmp	8000a69e <MbmChangeType+0x18a>
8000a5d8:	f6 06 19 00 	cp.h	r6,r11
        {
            /* Always a valid pointer for RX messages */
            rx_ptr->Data = &mbmMemArray[0];
        }
    }
    else if( (MBM_TYPE_CTRL_RX == oldType) && (MBM_TYPE_CTRL_TX == newType) )
8000a5dc:	5f 0b       	sreq	r11
8000a5de:	f4 04 19 00 	cp.h	r4,r10
8000a5e2:	5f 08       	sreq	r8
8000a5e4:	f7 e8 00 08 	and	r8,r11,r8
8000a5e8:	f2 08 18 00 	cp.b	r8,r9
8000a5ec:	ce 30       	breq	8000a5b2 <MbmChangeType+0x9e>
8000a5ee:	ee c8 ff ec 	sub	r8,r7,-20
    {
        MbmCtrlRx  rx     = *MBM_GET_CTRL_RX_PTR(handle);
8000a5f2:	70 39       	ld.w	r9,r8[0xc]
8000a5f4:	70 0a       	ld.w	r10,r8[0x0]
8000a5f6:	70 1b       	ld.w	r11,r8[0x4]
8000a5f8:	70 2e       	ld.w	lr,r8[0x8]
8000a5fa:	f2 03 16 18 	lsr	r3,r9,0x18
8000a5fe:	ef 63 00 20 	st.b	r7[32],r3
        MbmCtrlTx *tx_ptr = MBM_GET_CTRL_TX_PTR(handle);
        tx_ptr->Tgt_Adr   = rx.Src_Adr;
        tx_ptr->FBlock_ID = rx.FBlock_ID;
        tx_ptr->Inst_ID   = rx.Inst_ID;
        tx_ptr->Func_ID   = rx.Func_ID;
        tx_ptr->Operation = rx.Operation;
8000a602:	50 2e       	stdsp	sp[0x8],lr
            rx_ptr->Data = &mbmMemArray[0];
        }
    }
    else if( (MBM_TYPE_CTRL_RX == oldType) && (MBM_TYPE_CTRL_TX == newType) )
    {
        MbmCtrlRx  rx     = *MBM_GET_CTRL_RX_PTR(handle);
8000a604:	50 1b       	stdsp	sp[0x4],r11
8000a606:	50 39       	stdsp	sp[0xc],r9
8000a608:	50 0a       	stdsp	sp[0x0],r10
8000a60a:	10 9c       	mov	r12,r8
        tx_ptr->Tgt_Adr   = rx.Src_Adr;
        tx_ptr->FBlock_ID = rx.FBlock_ID;
        tx_ptr->Inst_ID   = rx.Inst_ID;
        tx_ptr->Func_ID   = rx.Func_ID;
        tx_ptr->Operation = rx.Operation;
        PmsInsertRetryValues(tx_ptr);
8000a60c:	fb 38 00 0a 	ld.ub	r8,sp[10]
            rx_ptr->Data = &mbmMemArray[0];
        }
    }
    else if( (MBM_TYPE_CTRL_RX == oldType) && (MBM_TYPE_CTRL_TX == newType) )
    {
        MbmCtrlRx  rx     = *MBM_GET_CTRL_RX_PTR(handle);
8000a610:	ef 68 00 1e 	st.b	r7[30],r8
        MbmCtrlTx *tx_ptr = MBM_GET_CTRL_TX_PTR(handle);
        tx_ptr->Tgt_Adr   = rx.Src_Adr;
        tx_ptr->FBlock_ID = rx.FBlock_ID;
8000a614:	fb 38 00 0b 	ld.ub	r8,sp[11]
            rx_ptr->Data = &mbmMemArray[0];
        }
    }
    else if( (MBM_TYPE_CTRL_RX == oldType) && (MBM_TYPE_CTRL_TX == newType) )
    {
        MbmCtrlRx  rx     = *MBM_GET_CTRL_RX_PTR(handle);
8000a618:	ef 68 00 1f 	st.b	r7[31],r8
        MbmCtrlTx *tx_ptr = MBM_GET_CTRL_TX_PTR(handle);
        tx_ptr->Tgt_Adr   = rx.Src_Adr;
        tx_ptr->FBlock_ID = rx.FBlock_ID;
        tx_ptr->Inst_ID   = rx.Inst_ID;
8000a61c:	9a 48       	ld.sh	r8,sp[0x8]
            rx_ptr->Data = &mbmMemArray[0];
        }
    }
    else if( (MBM_TYPE_CTRL_RX == oldType) && (MBM_TYPE_CTRL_TX == newType) )
    {
        MbmCtrlRx  rx     = *MBM_GET_CTRL_RX_PTR(handle);
8000a61e:	ef 58 00 1c 	st.h	r7[28],r8
        MbmCtrlTx *tx_ptr = MBM_GET_CTRL_TX_PTR(handle);
        tx_ptr->Tgt_Adr   = rx.Src_Adr;
        tx_ptr->FBlock_ID = rx.FBlock_ID;
        tx_ptr->Inst_ID   = rx.Inst_ID;
        tx_ptr->Func_ID   = rx.Func_ID;
8000a622:	9a 38       	ld.sh	r8,sp[0x6]
    }
    else if( (MBM_TYPE_CTRL_RX == oldType) && (MBM_TYPE_CTRL_TX == newType) )
    {
        MbmCtrlRx  rx     = *MBM_GET_CTRL_RX_PTR(handle);
        MbmCtrlTx *tx_ptr = MBM_GET_CTRL_TX_PTR(handle);
        tx_ptr->Tgt_Adr   = rx.Src_Adr;
8000a624:	ef 58 00 1a 	st.h	r7[26],r8
8000a628:	e0 a0 11 64 	rcall	8000c8f0 <PmsInsertRetryValues>
        tx_ptr->FBlock_ID = rx.FBlock_ID;
        tx_ptr->Inst_ID   = rx.Inst_ID;
        tx_ptr->Func_ID   = rx.Func_ID;
        tx_ptr->Operation = rx.Operation;
        PmsInsertRetryValues(tx_ptr);
8000a62c:	31 4b       	mov	r11,20

        /*
        */
        MbmReserve(handle, (word)PMS_CTRL_HDR_MAX_SIZE);
8000a62e:	0e 9c       	mov	r12,r7
8000a630:	fe b0 fc bc 	rcall	80009fa8 <MbmReserve>
8000a634:	6e 48       	ld.w	r8,r7[0x10]
        tx_ptr->Length = (word)(handle->size - (tx_ptr->Data - handle->start_ptr));
8000a636:	ef 09 00 30 	ld.sh	r9,r7[48]
8000a63a:	10 09       	add	r9,r8
8000a63c:	6e 58       	ld.w	r8,r7[0x14]
8000a63e:	f2 08 01 08 	sub	r8,r9,r8
8000a642:	ef 58 00 18 	st.h	r7[24],r8
8000a646:	cb 6b       	rjmp	8000a5b2 <MbmChangeType+0x9e>
8000a648:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
            msgPool.rxAlloc++;
        }
    }

    /* Check if the conversion respects the reserved TX/RX */
    if( MBM_TYPE_TX_BIT & newType )
8000a64c:	c2 71       	brne	8000a69a <MbmChangeType+0x186>
8000a64e:	4a 48       	lddpc	r8,8000a6dc <MbmChangeType+0x1c8>
    {
        rsvd = msgPool.rxRsvd;
8000a650:	90 49       	ld.sh	r9,r8[0x8]
8000a652:	90 27       	ld.sh	r7,r8[0x4]
        used = msgPool.rxAlloc;
    }
    else
    {
        rsvd = msgPool.txRsvd;
8000a654:	f2 07 19 00 	cp.h	r7,r9
        used = msgPool.txAlloc;
    }

    if( used < rsvd )
8000a658:	e0 8b 00 28 	brhi	8000a6a8 <MbmChangeType+0x194>
8000a65c:	30 17       	mov	r7,1
8000a65e:	30 0c       	mov	r12,0

    _MBM_USAGE_UPDATE_TX();
    _MBM_USAGE_UPDATE_RX();
    _MBM_USAGE_UPDATE_NUM();
    T_CONVERT((int)handle, (int)msgPool.txAlloc, (int)msgPool.rxAlloc);
    REL_MX(MX_MBM_CS);
8000a660:	fe b0 ea 2c 	rcall	80007ab8 <mns_give>
8000a664:	0e 9c       	mov	r12,r7
    T_LIB_EXIT(MBM_16);

    return( retval );
}
8000a666:	2f cd       	sub	sp,-16
8000a668:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000a66c:	f0 c8 f9 a8 	sub	r8,r8,-1624
{
    bool retval;

    T_LIB_ENTRY(MBM_30);

    if((handle >= &msgBufArray[0]) && (handle <= &msgBufArray[MBM_MSG_NUM-1]))
8000a670:	10 3c       	cp.w	r12,r8
8000a672:	fe 9b ff 5c 	brhi	8000a52a <MbmChangeType+0x16>
8000a676:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
    word used;

    T_LIB_ENTRY(MBM_16);

    ASSERT(handle && (MNS_FALSE != MbmIsFromPool(handle)));
    ASSERT((word)0 == (newType & (word)~MBM_TYPE_MASK)); /* parameter newtype must not contain status bits */
8000a67a:	0a 98       	mov	r8,r5
8000a67c:	e2 18 ff f0 	andl	r8,0xfff0,COH
8000a680:	fe 90 ff 66 	breq	8000a54c <MbmChangeType+0x38>
8000a684:	e0 68 02 a8 	mov	r8,680
8000a688:	30 1a       	mov	r10,1
8000a68a:	1a d8       	st.w	--sp,r8
8000a68c:	31 0b       	mov	r11,16
8000a68e:	e0 6c 80 00 	mov	r12,32768
8000a692:	fe b0 ea 2d 	rcall	80007aec <mns_trace>
8000a696:	2f fd       	sub	sp,-4
8000a698:	c5 ab       	rjmp	8000a54c <MbmChangeType+0x38>
8000a69a:	49 18       	lddpc	r8,8000a6dc <MbmChangeType+0x1c8>
            msgPool.rxAlloc++;
        }
    }

    /* Check if the conversion respects the reserved TX/RX */
    if( MBM_TYPE_TX_BIT & newType )
8000a69c:	90 59       	ld.sh	r9,r8[0xa]
8000a69e:	90 37       	ld.sh	r7,r8[0x6]
    {
        rsvd = msgPool.rxRsvd;
8000a6a0:	f2 07 19 00 	cp.h	r7,r9
    {
        rsvd = msgPool.txRsvd;
        used = msgPool.txAlloc;
    }

    if( used < rsvd )
8000a6a4:	fe 98 ff dc 	brls	8000a65c <MbmChangeType+0x148>
8000a6a8:	12 17       	sub	r7,r9
    return( handle->hdr_ptr );
}
#endif

#ifdef MBM_16
bool MbmChangeType(HMBMBUF handle, word newType)
8000a6aa:	70 08       	ld.w	r8,r8[0x0]
8000a6ac:	5c 77       	castu.h	r7
8000a6ae:	90 d9       	ld.uh	r9,r8[0xa]
8000a6b0:	0e 39       	cp.w	r9,r7
8000a6b2:	f9 b7 04 01 	movge	r7,1
8000a6b6:	f9 b7 05 00 	movlt	r7,0
8000a6ba:	5c 57       	castu.b	r7
8000a6bc:	cd 1b       	rjmp	8000a65e <MbmChangeType+0x14a>
8000a6be:	48 88       	lddpc	r8,8000a6dc <MbmChangeType+0x1c8>
            msgPool.rxAlloc--;
            msgPool.txAlloc++;
        }
        else                                    /* TX => RX? */
        {
            msgPool.txAlloc--;
8000a6c0:	90 49       	ld.sh	r9,r8[0x8]
8000a6c2:	90 5a       	ld.sh	r10,r8[0xa]
            msgPool.rxAlloc++;
8000a6c4:	20 19       	sub	r9,1
            msgPool.rxAlloc--;
            msgPool.txAlloc++;
        }
        else                                    /* TX => RX? */
        {
            msgPool.txAlloc--;
8000a6c6:	2f fa       	sub	r10,-1
            msgPool.rxAlloc++;
8000a6c8:	5c 89       	casts.h	r9
            msgPool.rxAlloc--;
            msgPool.txAlloc++;
        }
        else                                    /* TX => RX? */
        {
            msgPool.txAlloc--;
8000a6ca:	b0 5a       	st.h	r8[0xa],r10
            msgPool.rxAlloc++;
8000a6cc:	b0 49       	st.h	r8[0x8],r9
            msgPool.rxAlloc--;
            msgPool.txAlloc++;
        }
        else                                    /* TX => RX? */
        {
            msgPool.txAlloc--;
8000a6ce:	cc 2b       	rjmp	8000a652 <MbmChangeType+0x13e>
8000a6d0:	48 48       	lddpc	r8,8000a6e0 <MbmChangeType+0x1cc>
        #endif

        if( NULL == rx_ptr->Data )
        {
            /* Always a valid pointer for RX messages */
            rx_ptr->Data = &mbmMemArray[0];
8000a6d2:	8f 58       	st.w	r7[0x14],r8
8000a6d4:	c6 fb       	rjmp	8000a5b2 <MbmChangeType+0x9e>
8000a6d6:	d7 03       	nop
8000a6d8:	00 00       	add	r0,r0
8000a6da:	2d d0       	sub	r0,-35
8000a6dc:	00 00       	add	r0,r0
8000a6de:	2d c4       	sub	r4,-36
8000a6e0:	00 00       	add	r0,r0
8000a6e2:	42 24       	lddsp	r4,sp[0x88]

8000a6e4 <MisGetResetCount>:
#endif


#ifdef MIS_10
byte MisGetResetCount(void)
{
8000a6e4:	48 28       	lddpc	r8,8000a6ec <MisGetResetCount+0x8>
    ret = mis_data.reset_counter;

    T_LIB_EXIT(MIS_10);

    return(ret);
}
8000a6e6:	f1 3c 00 41 	ld.ub	r12,r8[65]
8000a6ea:	5e fc       	retal	r12
8000a6ec:	00 00       	add	r0,r0
8000a6ee:	35 34       	mov	r4,83

8000a6f0 <MisSetResetCount>:
#ifdef MIS_11
void MisSetResetCount(byte count)
{
    T_LIB_ENTRY(MIS_11);

    mis_data.reset_counter = count;
8000a6f0:	48 28       	lddpc	r8,8000a6f8 <MisSetResetCount+0x8>
8000a6f2:	f1 6c 00 41 	st.b	r8[65],r12

    T_LIB_EXIT(MIS_11);
}
8000a6f6:	5e fc       	retal	r12
8000a6f8:	00 00       	add	r0,r0
8000a6fa:	35 34       	mov	r4,83

8000a6fc <MisFilterMostMsg>:
#endif


#ifdef MIS_12
void MisFilterMostMsg(HMBMBUF handle)
{
8000a6fc:	eb cd 40 e0 	pushm	r5-r7,lr
    bool    fblock_done = (MSG_SRC_INIC != msg_ptr->Src_Adr) ? MNS_TRUE : MNS_FALSE;
    #endif

    T_LIB_ENTRY(MIS_12);

    if (mis_data.reset_counter)
8000a700:	4d e8       	lddpc	r8,8000a878 <MisFilterMostMsg+0x17c>
8000a702:	30 09       	mov	r9,0
8000a704:	f1 3a 00 41 	ld.ub	r10,r8[65]
void MisFilterMostMsg(HMBMBUF handle)
{
    TMsgRx *msg_ptr     = MBM_GET_CTRL_RX_PTR(handle);
    #ifndef MNS_AVOID_ATTACH
    word    fblock_idx  = 0;
    bool    fblock_done = (MSG_SRC_INIC != msg_ptr->Src_Adr) ? MNS_TRUE : MNS_FALSE;
8000a708:	f9 05 00 1a 	ld.sh	r5,r12[26]

    T_LIB_ENTRY(MIS_12);

    if (mis_data.reset_counter)
    {
        mis_data.reset_counter = 0;
8000a70c:	f2 0a 18 00 	cp.b	r10,r9
8000a710:	f1 f9 1e 41 	st.bne	r8[0x41],r9
#endif


#ifdef MIS_12
void MisFilterMostMsg(HMBMBUF handle)
{
8000a714:	18 96       	mov	r6,r12
    TMsgRx *msg_ptr     = MBM_GET_CTRL_RX_PTR(handle);
8000a716:	f9 39 00 1e 	ld.ub	r9,r12[30]
8000a71a:	30 18       	mov	r8,1
8000a71c:	f0 09 18 00 	cp.b	r9,r8
8000a720:	e0 80 00 82 	breq	8000a824 <MisFilterMostMsg+0x128>
        WmcsRefreshNodePos(msg_ptr->Inst_ID);
    }
    #endif

    #ifndef MNS_AVOID_ATTACH
    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_PMS))
8000a724:	30 1c       	mov	r12,1
8000a726:	e0 a0 03 f5 	rcall	8000af10 <MnsIsNSInitComplete>
8000a72a:	c0 31       	brne	8000a730 <MisFilterMostMsg+0x34>
8000a72c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    {
        T_RX(msg_ptr->Src_Adr, msg_ptr->FBlock_ID, msg_ptr->Inst_ID,
8000a730:	ed 18 00 18 	ld.uh	r8,r6[24]
8000a734:	1a d8       	st.w	--sp,r8
8000a736:	ed 38 00 20 	ld.ub	r8,r6[32]
8000a73a:	1a d8       	st.w	--sp,r8
8000a73c:	ed 18 00 1c 	ld.uh	r8,r6[28]
8000a740:	1a d8       	st.w	--sp,r8
8000a742:	ed 38 00 1f 	ld.ub	r8,r6[31]
8000a746:	1a d8       	st.w	--sp,r8
8000a748:	ed 38 00 1e 	ld.ub	r8,r6[30]
8000a74c:	1a d8       	st.w	--sp,r8
8000a74e:	ed 18 00 1a 	ld.uh	r8,r6[26]


#ifdef MIS_12
void MisFilterMostMsg(HMBMBUF handle)
{
    TMsgRx *msg_ptr     = MBM_GET_CTRL_RX_PTR(handle);
8000a752:	ec c7 ff ec 	sub	r7,r6,-20
    #endif

    #ifndef MNS_AVOID_ATTACH
    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_PMS))
    {
        T_RX(msg_ptr->Src_Adr, msg_ptr->FBlock_ID, msg_ptr->Inst_ID,
8000a756:	1a d8       	st.w	--sp,r8
8000a758:	30 6a       	mov	r10,6
8000a75a:	30 bb       	mov	r11,11
8000a75c:	30 2c       	mov	r12,2
8000a75e:	fe b0 e9 c7 	rcall	80007aec <mns_trace>
             msg_ptr->Func_ID, msg_ptr->Operation, msg_ptr->Length);

        #ifdef VMSV_MIN
        VmsvRxFilter(msg_ptr);
8000a762:	0e 9c       	mov	r12,r7
8000a764:	e0 a0 2a 58 	rcall	8000fc14 <VmsvRxFilter>


#ifdef MIS_12
void MisFilterMostMsg(HMBMBUF handle)
{
    TMsgRx *msg_ptr     = MBM_GET_CTRL_RX_PTR(handle);
8000a768:	6c 78       	ld.w	r8,r6[0x1c]
8000a76a:	2f ad       	sub	sp,-24
8000a76c:	e0 18 ff 00 	andl	r8,0xff00
8000a770:	e0 69 01 00 	mov	r9,256
8000a774:	ea 19 04 05 	orh	r9,0x405
8000a778:	12 38       	cp.w	r8,r9
8000a77a:	c6 a0       	breq	8000a84e <MisFilterMostMsg+0x152>
        {
            VmsvHandleDiagResult(msg_ptr);
        }
        #endif

        while ((MNS_FALSE == fblock_done) && mis_most_handler_table[fblock_idx].func_table)
8000a77c:	30 18       	mov	r8,1
8000a77e:	f0 05 19 00 	cp.h	r5,r8
8000a782:	cd 51       	brne	8000a72c <MisFilterMostMsg+0x30>
8000a784:	30 08       	mov	r8,0
8000a786:	4b eb       	lddpc	r11,8000a87c <MisFilterMostMsg+0x180>
8000a788:	10 99       	mov	r9,r8
8000a78a:	ed 35 00 1e 	ld.ub	r5,r6[30]
8000a78e:	4b dc       	lddpc	r12,8000a880 <MisFilterMostMsg+0x184>
        {
            if (msg_ptr->FBlock_ID == mis_most_handler_table[fblock_idx].
8000a790:	16 9e       	mov	lr,r11
8000a792:	f6 08 07 38 	ld.ub	r8,r11[r8<<0x3]
8000a796:	ea 08 18 00 	cp.b	r8,r5
8000a79a:	c0 f0       	breq	8000a7b8 <MisFilterMostMsg+0xbc>
                        }
                    }
                    func_idx++;
                }
            }
            fblock_idx++;
8000a79c:	2f f9       	sub	r9,-1
8000a79e:	5c 89       	casts.h	r9
        {
            VmsvHandleDiagResult(msg_ptr);
        }
        #endif

        while ((MNS_FALSE == fblock_done) && mis_most_handler_table[fblock_idx].func_table)
8000a7a0:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
8000a7a4:	fc 08 00 3a 	add	r10,lr,r8<<0x3
8000a7a8:	74 1c       	ld.w	r12,r10[0x4]
8000a7aa:	58 0c       	cp.w	r12,0
8000a7ac:	cc 00       	breq	8000a72c <MisFilterMostMsg+0x30>
        {
            if (msg_ptr->FBlock_ID == mis_most_handler_table[fblock_idx].
8000a7ae:	f6 08 07 38 	ld.ub	r8,r11[r8<<0x3]
8000a7b2:	ea 08 18 00 	cp.b	r8,r5
8000a7b6:	cf 31       	brne	8000a79c <MisFilterMostMsg+0xa0>
8000a7b8:	30 08       	mov	r8,0
                                }
                            }
                            op_idx++;
                        }
                    }
                    func_idx++;
8000a7ba:	f0 ca ff ff 	sub	r10,r8,-1
                bool func_done = MNS_FALSE;
                word func_idx  = 0;

                fblock_done = MNS_TRUE;
                while ((MNS_FALSE == func_done) && mis_most_handler_table[fblock_idx].
                                     func_table[func_idx].
8000a7be:	5c 78       	castu.h	r8
8000a7c0:	f8 08 00 39 	add	r9,r12,r8<<0x3
                                }
                            }
                            op_idx++;
                        }
                    }
                    func_idx++;
8000a7c4:	f1 da b0 10 	bfexts	r8,r10,0x0,0x10
                word func_idx  = 0;

                fblock_done = MNS_TRUE;
                while ((MNS_FALSE == func_done) && mis_most_handler_table[fblock_idx].
                                     func_table[func_idx].
                                     op_type_table)
8000a7c8:	72 1b       	ld.w	r11,r9[0x4]
            {
                bool func_done = MNS_FALSE;
                word func_idx  = 0;

                fblock_done = MNS_TRUE;
                while ((MNS_FALSE == func_done) && mis_most_handler_table[fblock_idx].
8000a7ca:	58 0b       	cp.w	r11,0
8000a7cc:	c2 a0       	breq	8000a820 <MisFilterMostMsg+0x124>
                                     func_table[func_idx].
                                     op_type_table)
                {
                    if (msg_ptr->Func_ID ==
                        mis_most_handler_table[fblock_idx].
                        func_table[func_idx].func_id)
8000a7ce:	92 09       	ld.sh	r9,r9[0x0]
8000a7d0:	ed 0a 00 1c 	ld.sh	r10,r6[28]
8000a7d4:	f2 0a 19 00 	cp.h	r10,r9
8000a7d8:	cf 11       	brne	8000a7ba <MisFilterMostMsg+0xbe>
8000a7da:	30 08       	mov	r8,0
                                {
                                    handler_fptr_table[handler_idx](msg_ptr);
                                    handler_idx++;
                                }
                            }
                            op_idx++;
8000a7dc:	f0 ca ff ff 	sub	r10,r8,-1
                        word op_idx  = 0;

                        func_done = MNS_TRUE;
                        while ((MNS_FALSE == op_done) && mis_most_handler_table[fblock_idx].
                                           func_table[func_idx].
                                           op_type_table[op_idx].
8000a7e0:	5c 78       	castu.h	r8
8000a7e2:	f6 08 00 39 	add	r9,r11,r8<<0x3
                                {
                                    handler_fptr_table[handler_idx](msg_ptr);
                                    handler_idx++;
                                }
                            }
                            op_idx++;
8000a7e6:	f1 da b0 10 	bfexts	r8,r10,0x0,0x10

                        func_done = MNS_TRUE;
                        while ((MNS_FALSE == op_done) && mis_most_handler_table[fblock_idx].
                                           func_table[func_idx].
                                           op_type_table[op_idx].
                                           handler_fptr_table)
8000a7ea:	72 15       	ld.w	r5,r9[0x4]
                    {
                        bool op_done = MNS_FALSE;
                        word op_idx  = 0;

                        func_done = MNS_TRUE;
                        while ((MNS_FALSE == op_done) && mis_most_handler_table[fblock_idx].
8000a7ec:	58 05       	cp.w	r5,0
8000a7ee:	c1 70       	breq	8000a81c <MisFilterMostMsg+0x120>
                                           handler_fptr_table)
                        {
                            if (msg_ptr->Operation ==
                                mis_most_handler_table[fblock_idx].
                                func_table[func_idx].
                                op_type_table[op_idx].op_type)
8000a7f0:	13 89       	ld.ub	r9,r9[0x0]
8000a7f2:	ed 3a 00 20 	ld.ub	r10,r6[32]
8000a7f6:	f2 0a 18 00 	cp.b	r10,r9
8000a7fa:	cf 11       	brne	8000a7dc <MisFilterMostMsg+0xe0>
                                        func_table[func_idx].
                                        op_type_table[op_idx].
                                        handler_fptr_table;

                                op_done = MNS_TRUE;
                                while (handler_fptr_table[handler_idx])
8000a7fc:	6a 08       	ld.w	r8,r5[0x0]
8000a7fe:	58 08       	cp.w	r8,0
8000a800:	c9 60       	breq	8000a72c <MisFilterMostMsg+0x30>
8000a802:	30 06       	mov	r6,0
                                {
                                    handler_fptr_table[handler_idx](msg_ptr);
8000a804:	0e 9c       	mov	r12,r7
8000a806:	5d 18       	icall	r8
                                    handler_idx++;
8000a808:	2f f6       	sub	r6,-1
8000a80a:	5c 86       	casts.h	r6
                                        func_table[func_idx].
                                        op_type_table[op_idx].
                                        handler_fptr_table;

                                op_done = MNS_TRUE;
                                while (handler_fptr_table[handler_idx])
8000a80c:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
8000a810:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
8000a814:	58 08       	cp.w	r8,0
8000a816:	cf 71       	brne	8000a804 <MisFilterMostMsg+0x108>
8000a818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000a81c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000a820:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    {
        mis_data.reset_counter = 0;
    }

    #ifdef MCS_MIN
    if ((FBLOCK_NETBLOCK == msg_ptr->FBlock_ID) &&
8000a824:	f9 09 00 1a 	ld.sh	r9,r12[26]
8000a828:	30 18       	mov	r8,1
8000a82a:	f0 09 19 00 	cp.h	r9,r8
8000a82e:	c1 a0       	breq	8000a862 <MisFilterMostMsg+0x166>
8000a830:	f9 39 00 20 	ld.ub	r9,r12[32]
8000a834:	30 88       	mov	r8,8
8000a836:	f0 09 18 00 	cp.b	r9,r8
8000a83a:	fe 9b ff 75 	brhi	8000a724 <MisFilterMostMsg+0x28>
        (((MSG_SRC_INIC == msg_ptr->Src_Adr)    &&
          (OP_REPORTS <= msg_ptr->Operation))   ||
         ((OP_REPORTS > msg_ptr->Operation)     &&
          (0 != msg_ptr->Inst_ID))
8000a83e:	ed 3c 00 1f 	ld.ub	r12,r6[31]
    {
        mis_data.reset_counter = 0;
    }

    #ifdef MCS_MIN
    if ((FBLOCK_NETBLOCK == msg_ptr->FBlock_ID) &&
8000a842:	58 0c       	cp.w	r12,0
8000a844:	fe 90 ff 70 	breq	8000a724 <MisFilterMostMsg+0x28>
          (OP_REPORTS <= msg_ptr->Operation))   ||
         ((OP_REPORTS > msg_ptr->Operation)     &&
          (0 != msg_ptr->Inst_ID))
        ))
    {
        WmcsRefreshNodePos(msg_ptr->Inst_ID);
8000a848:	e0 a0 3a a6 	rcall	80011d94 <WmcsRefreshNodePos>
8000a84c:	c6 cb       	rjmp	8000a724 <MisFilterMostMsg+0x28>
        #ifdef VMSV_MIN
        VmsvRxFilter(msg_ptr);
        #endif

        #ifdef MSV_DIAG_RESULT_MSG
        if ((FBLOCK_NETBLOCK         == msg_ptr->FBlock_ID) &&
8000a84e:	ed 39 00 20 	ld.ub	r9,r6[32]
8000a852:	30 c8       	mov	r8,12
8000a854:	f0 09 18 00 	cp.b	r9,r8
8000a858:	c9 21       	brne	8000a77c <MisFilterMostMsg+0x80>
            (FUNC_NB_RBDRESULT       == msg_ptr->Func_ID)   &&
            (OP_STATUS               == msg_ptr->Operation))
        {
            VmsvHandleDiagResult(msg_ptr);
8000a85a:	0e 9c       	mov	r12,r7
8000a85c:	e0 a0 26 0c 	rcall	8000f474 <VmsvHandleDiagResult>
8000a860:	c8 eb       	rjmp	8000a77c <MisFilterMostMsg+0x80>


#ifdef MIS_12
void MisFilterMostMsg(HMBMBUF handle)
{
    TMsgRx *msg_ptr     = MBM_GET_CTRL_RX_PTR(handle);
8000a862:	f9 39 00 20 	ld.ub	r9,r12[32]
8000a866:	30 88       	mov	r8,8
8000a868:	f0 09 18 00 	cp.b	r9,r8
8000a86c:	fe 98 ff e9 	brls	8000a83e <MisFilterMostMsg+0x142>
8000a870:	f9 3c 00 1f 	ld.ub	r12,r12[31]
8000a874:	ce ab       	rjmp	8000a848 <MisFilterMostMsg+0x14c>
8000a876:	d7 03       	nop
8000a878:	00 00       	add	r0,r0
8000a87a:	35 34       	mov	r4,83
8000a87c:	80 06       	ld.sh	r6,r0[0x0]
8000a87e:	f7 b0       	*unknown*
8000a880:	80 06       	ld.sh	r6,r0[0x0]
8000a882:	f9 7c d4 01 	stcond	r12[-11263],r12

8000a884 <MisSetPendingEvent>:
8000a884:	d4 01       	pushm	lr
8000a886:	30 29       	mov	r9,2
8000a888:	5c 7c       	castu.h	r12
8000a88a:	48 3a       	lddpc	r10,8000a894 <MisSetPendingEvent+0x10>
8000a88c:	30 4b       	mov	r11,4
8000a88e:	e0 a0 05 77 	rcall	8000b37c <MnsSetPendingEventFlag>
8000a892:	d8 02       	popm	pc
8000a894:	00 00       	add	r0,r0
8000a896:	35 34       	mov	r4,83

8000a898 <MisResetInic>:

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_MIS_PE,
                           &(mis_data.pending_events), MNS_P_SRV_MIS);
    T_MOD_EXIT(MIS_3);
}
8000a898:	d4 01       	pushm	lr
8000a89a:	30 4c       	mov	r12,4
#ifdef MIS_9
void MisResetInic(void)
{
    T_LIB_ENTRY(MIS_9);

    MisSetPendingEvent(MIS_P_SYNC_FAILED);
8000a89c:	cf 4f       	rcall	8000a884 <MisSetPendingEvent>
8000a89e:	d8 02       	popm	pc

8000a8a0 <MisHandlePmsEvent>:

    T_LIB_EXIT(MIS_9);
}
8000a8a0:	d4 01       	pushm	lr
8000a8a2:	e0 68 02 00 	mov	r8,512
8000a8a6:	f0 0c 19 00 	cp.h	r12,r8
static void MisHandlePmsEvent(word event)
{
    word mis_event = MIS_P_NONE;

    T_MOD_ENTRY(MIS_5);
    switch (event)
8000a8aa:	c2 20       	breq	8000a8ee <MisHandlePmsEvent+0x4e>
8000a8ac:	e0 88 00 0f 	brls	8000a8ca <MisHandlePmsEvent+0x2a>
8000a8b0:	e0 68 04 00 	mov	r8,1024
8000a8b4:	f0 0c 19 00 	cp.h	r12,r8
8000a8b8:	c1 80       	breq	8000a8e8 <MisHandlePmsEvent+0x48>
8000a8ba:	e0 68 08 00 	mov	r8,2048
8000a8be:	f0 0c 19 00 	cp.h	r12,r8
8000a8c2:	c0 91       	brne	8000a8d4 <MisHandlePmsEvent+0x34>
            mis_event = MIS_P_SYNC_RESET;
            break;

        case PMS_E_SYNC_FAILED:
            mis_event = MIS_P_SYNC_FAILED;
            break;
8000a8c4:	32 0c       	mov	r12,32
            break;
    }

    if (MIS_P_NONE != mis_event)
    {
        MisSetPendingEvent(mis_event);
8000a8c6:	cd ff       	rcall	8000a884 <MisSetPendingEvent>
8000a8c8:	d8 02       	popm	pc
8000a8ca:	e0 68 01 00 	mov	r8,256
static void MisHandlePmsEvent(word event)
{
    word mis_event = MIS_P_NONE;

    T_MOD_ENTRY(MIS_5);
    switch (event)
8000a8ce:	f0 0c 19 00 	cp.h	r12,r8
8000a8d2:	c1 00       	breq	8000a8f2 <MisHandlePmsEvent+0x52>
8000a8d4:	e0 68 01 bd 	mov	r8,445
        case PMS_E_SYNC_NOT_SUPPORTED:
            mis_event = MIS_P_SYNC_NOT_SUPPORTED;
            break;

        default:
            FAILED_ASSERT();
8000a8d8:	30 1a       	mov	r10,1
8000a8da:	1a d8       	st.w	--sp,r8
8000a8dc:	31 0b       	mov	r11,16
8000a8de:	30 2c       	mov	r12,2
8000a8e0:	fe b0 e9 06 	rcall	80007aec <mns_trace>
8000a8e4:	2f fd       	sub	sp,-4
8000a8e6:	d8 02       	popm	pc
8000a8e8:	30 4c       	mov	r12,4
static void MisHandlePmsEvent(word event)
{
    word mis_event = MIS_P_NONE;

    T_MOD_ENTRY(MIS_5);
    switch (event)
8000a8ea:	cc df       	rcall	8000a884 <MisSetPendingEvent>
            break;
    }

    if (MIS_P_NONE != mis_event)
    {
        MisSetPendingEvent(mis_event);
8000a8ec:	d8 02       	popm	pc
8000a8ee:	30 2c       	mov	r12,2
8000a8f0:	ce bb       	rjmp	8000a8c6 <MisHandlePmsEvent+0x26>
static void MisHandlePmsEvent(word event)
{
    word mis_event = MIS_P_NONE;

    T_MOD_ENTRY(MIS_5);
    switch (event)
8000a8f2:	30 1c       	mov	r12,1
8000a8f4:	ce 9b       	rjmp	8000a8c6 <MisHandlePmsEvent+0x26>
        case PMS_E_SYNC_NOT_SUPPORTED:
            mis_event = MIS_P_SYNC_NOT_SUPPORTED;
            break;

        default:
            FAILED_ASSERT();
8000a8f6:	d7 03       	nop

8000a8f8 <MisService>:
8000a8f8:	d4 21       	pushm	r4-r7,lr
8000a8fa:	4d 27       	lddpc	r7,8000aa40 <MisService+0x148>
8000a8fc:	32 08       	mov	r8,32
8000a8fe:	30 19       	mov	r9,1
8000a900:	ee ca ff fe 	sub	r10,r7,-2
static word MisGetNextEventToHandle(void)
{
    word result = MIS_P_NONE;

    T_MOD_ENTRY(MIS_2);
    result = MnsGetNextEventFlagToCall(MX_MIS_PE,
8000a904:	0e 9b       	mov	r11,r7
8000a906:	30 4c       	mov	r12,4
8000a908:	e0 a0 04 9a 	rcall	8000b23c <MnsGetNextEventFlagToCall>
8000a90c:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10

    T_LIB_ENTRY(MIS_1);

    event_to_handle = MisGetNextEventToHandle();
    request_flag    = MNS_FALSE;
    TAKE_EVENTS();
8000a910:	30 4c       	mov	r12,4
8000a912:	fe b0 e8 d2 	rcall	80007ab6 <mns_take>
    init_complete = mis_data.init_complete;
    GIVE_EVENTS();
8000a916:	30 4c       	mov	r12,4
    T_LIB_ENTRY(MIS_1);

    event_to_handle = MisGetNextEventToHandle();
    request_flag    = MNS_FALSE;
    TAKE_EVENTS();
    init_complete = mis_data.init_complete;
8000a918:	ef 35 00 40 	ld.ub	r5,r7[64]
    GIVE_EVENTS();
8000a91c:	fe b0 e8 ce 	rcall	80007ab8 <mns_give>

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000a920:	30 48       	mov	r8,4
8000a922:	f0 06 19 00 	cp.h	r6,r8
8000a926:	c4 20       	breq	8000a9aa <MisService+0xb2>
8000a928:	e0 88 00 24 	brls	8000a970 <MisService+0x78>
8000a92c:	31 08       	mov	r8,16
8000a92e:	f0 06 19 00 	cp.h	r6,r8
8000a932:	c6 90       	breq	8000aa04 <MisService+0x10c>
8000a934:	32 08       	mov	r8,32
8000a936:	f0 06 19 00 	cp.h	r6,r8
8000a93a:	c3 30       	breq	8000a9a0 <MisService+0xa8>
8000a93c:	30 88       	mov	r8,8
8000a93e:	f0 06 19 00 	cp.h	r6,r8
8000a942:	c5 b0       	breq	8000a9f8 <MisService+0x100>
        case MIS_P_SYNC_NOT_SUPPORTED:
            MnsReportError(NSR_E_WRONG_PROTOCOL_CFG);
            break;

        default:
            FAILED_ASSERT();
8000a944:	e0 68 01 6a 	mov	r8,362
8000a948:	30 1a       	mov	r10,1
8000a94a:	1a d8       	st.w	--sp,r8
8000a94c:	31 0b       	mov	r11,16
8000a94e:	30 2c       	mov	r12,2
8000a950:	fe b0 e8 ce 	rcall	80007aec <mns_trace>
8000a954:	2f fd       	sub	sp,-4
            event_to_handle = MIS_P_NONE;
            break;
    }

    TAKE_EVENTS();
8000a956:	30 4c       	mov	r12,4
8000a958:	fe b0 e8 af 	rcall	80007ab6 <mns_take>
    request_flag = (MIS_P_NONE != mis_data.pending_events) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
8000a95c:	30 4c       	mov	r12,4
            event_to_handle = MIS_P_NONE;
            break;
    }

    TAKE_EVENTS();
    request_flag = (MIS_P_NONE != mis_data.pending_events) ? MNS_TRUE : MNS_FALSE;
8000a95e:	8e 07       	ld.sh	r7,r7[0x0]
    GIVE_EVENTS();
8000a960:	fe b0 e8 ac 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != request_flag)
8000a964:	58 07       	cp.w	r7,0
8000a966:	c0 40       	breq	8000a96e <MisService+0x76>
    {
        MnsSetPendingService(MNS_P_SRV_MIS);
8000a968:	30 2c       	mov	r12,2
8000a96a:	e0 a0 04 cf 	rcall	8000b308 <MnsSetPendingService>
8000a96e:	d8 22       	popm	r4-r7,pc
    init_complete = mis_data.init_complete;
    GIVE_EVENTS();

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000a970:	ec c8 00 01 	sub	r8,r6,1
8000a974:	30 14       	mov	r4,1
8000a976:	e8 08 19 00 	cp.h	r8,r4
8000a97a:	fe 9b ff e5 	brhi	8000a944 <MisService+0x4c>
    {
        case MIS_P_SYNC:
        case MIS_P_SYNC_RESET:

            MostClearTimer(&(mis_data.reset_timer));
8000a97e:	30 0a       	mov	r10,0
8000a980:	ee cc ff bc 	sub	r12,r7,-68
8000a984:	14 9b       	mov	r11,r10
8000a986:	e0 a0 03 91 	rcall	8000b0a8 <MostSetTimer>

            #ifdef PMS_RX_OPT3
            if ((MNS_FALSE == init_complete) && (MIS_P_SYNC == event_to_handle))
            #else
            if (MNS_FALSE == init_complete)
8000a98a:	58 05       	cp.w	r5,0
8000a98c:	c4 70       	breq	8000aa1a <MisService+0x122>

                MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_MIS);
            }
            else
            {
                if (MIS_P_SYNC_RESET == event_to_handle)
8000a98e:	30 28       	mov	r8,2
8000a990:	f0 06 19 00 	cp.h	r6,r8
8000a994:	c5 00       	breq	8000aa34 <MisService+0x13c>
                    MnsReportError(NSR_EI_RESET);

                }
                else
                {
                    MnsReportError(NSR_EI_SYNC);
8000a996:	e0 6c c3 03 	mov	r12,49923
8000a99a:	e0 a0 05 3f 	rcall	8000b418 <MnsReportError>
8000a99e:	cd cb       	rjmp	8000a956 <MisService+0x5e>
                mis_data.lld_cfg_ptr->on_buf_freed_fptr();
            }
            break;

        case MIS_P_SYNC_NOT_SUPPORTED:
            MnsReportError(NSR_E_WRONG_PROTOCOL_CFG);
8000a9a0:	e0 6c 87 00 	mov	r12,34560
8000a9a4:	e0 a0 05 3a 	rcall	8000b418 <MnsReportError>
            break;
8000a9a8:	cd 7b       	rjmp	8000a956 <MisService+0x5e>
                }
            }
            break;

        case MIS_P_SYNC_FAILED:
            if (mis_data.reset_counter >= MIS_RESET_TRIES)
8000a9aa:	ef 39 00 41 	ld.ub	r9,r7[65]
8000a9ae:	30 08       	mov	r8,0
8000a9b0:	f0 09 18 00 	cp.b	r9,r8
8000a9b4:	c2 e1       	brne	8000aa10 <MisService+0x118>
            {
                MnsReportError(NSR_E_NO_COMM);
            }
            else
            {
                PmsSetFifoInterface(PMS_M_FIFO_CTRL, mis_data.pms_config.icmIface);
8000a9b6:	ef 3b 00 2c 	ld.ub	r11,r7[44]
8000a9ba:	e0 6c 00 c0 	mov	r12,192
8000a9be:	e0 a0 1f ff 	rcall	8000e9bc <PmsSetFifoInterface>
                PmsSetFifoInterface(PMS_M_FIFO_MDP, mis_data.pms_config.mdpIface);
8000a9c2:	ef 3b 00 2e 	ld.ub	r11,r7[46]
8000a9c6:	32 0c       	mov	r12,32
8000a9c8:	e0 a0 1f fa 	rcall	8000e9bc <PmsSetFifoInterface>

                MnsReportError(NSR_EI_SYNC_FAILED);
8000a9cc:	e0 6c c3 02 	mov	r12,49922
8000a9d0:	e0 a0 05 24 	rcall	8000b418 <MnsReportError>

                mis_data.reset_counter++;
8000a9d4:	ef 38 00 41 	ld.ub	r8,r7[65]
8000a9d8:	2f f8       	sub	r8,-1
                MostSetTimer(&(mis_data.reset_timer), MIS_RESET_TIMEOUT, MNS_FALSE);
8000a9da:	30 0a       	mov	r10,0
                PmsSetFifoInterface(PMS_M_FIFO_CTRL, mis_data.pms_config.icmIface);
                PmsSetFifoInterface(PMS_M_FIFO_MDP, mis_data.pms_config.mdpIface);

                MnsReportError(NSR_EI_SYNC_FAILED);

                mis_data.reset_counter++;
8000a9dc:	ef 68 00 41 	st.b	r7[65],r8
                MostSetTimer(&(mis_data.reset_timer), MIS_RESET_TIMEOUT, MNS_FALSE);
8000a9e0:	e0 6b 03 e8 	mov	r11,1000
8000a9e4:	ee cc ff bc 	sub	r12,r7,-68
8000a9e8:	e0 a0 03 60 	rcall	8000b0a8 <MostSetTimer>
                if (mis_data.lld_cfg_ptr->reset_fptr)
8000a9ec:	6e f8       	ld.w	r8,r7[0x3c]
8000a9ee:	70 28       	ld.w	r8,r8[0x8]
8000a9f0:	58 08       	cp.w	r8,0
8000a9f2:	cb 20       	breq	8000a956 <MisService+0x5e>
            break;

        case MIS_P_BUF_FREED:
            if (mis_data.lld_cfg_ptr->on_buf_freed_fptr)
            {
                mis_data.lld_cfg_ptr->on_buf_freed_fptr();
8000a9f4:	5d 18       	icall	r8
8000a9f6:	cb 0b       	rjmp	8000a956 <MisService+0x5e>
                MnsReportError(NSR_E_NO_COMM);
            }
            break;

        case MIS_P_BUF_FREED:
            if (mis_data.lld_cfg_ptr->on_buf_freed_fptr)
8000a9f8:	6e f8       	ld.w	r8,r7[0x3c]
8000a9fa:	70 38       	ld.w	r8,r8[0xc]
8000a9fc:	58 08       	cp.w	r8,0
8000a9fe:	ca c0       	breq	8000a956 <MisService+0x5e>
            {
                mis_data.lld_cfg_ptr->on_buf_freed_fptr();
8000aa00:	5d 18       	icall	r8
8000aa02:	ca ab       	rjmp	8000a956 <MisService+0x5e>
                }
            }
            break;

        case MIS_P_RESET_TIMER:
            if (mis_data.reset_counter >= MIS_RESET_TRIES)
8000aa04:	ef 39 00 41 	ld.ub	r9,r7[65]
8000aa08:	30 08       	mov	r8,0
8000aa0a:	f0 09 18 00 	cp.b	r9,r8
8000aa0e:	ca 40       	breq	8000a956 <MisService+0x5e>
            {
                MnsReportError(NSR_E_NO_COMM);
8000aa10:	e0 6c 84 00 	mov	r12,33792
8000aa14:	e0 a0 05 02 	rcall	8000b418 <MnsReportError>
8000aa18:	c9 fb       	rjmp	8000a956 <MisService+0x5e>
            if ((MNS_FALSE == init_complete) && (MIS_P_SYNC == event_to_handle))
            #else
            if (MNS_FALSE == init_complete)
            #endif
            {
                TAKE_EVENTS();
8000aa1a:	30 4c       	mov	r12,4
8000aa1c:	fe b0 e8 4d 	rcall	80007ab6 <mns_take>
                mis_data.init_complete = MNS_TRUE;
                GIVE_EVENTS();
8000aa20:	30 4c       	mov	r12,4
            #else
            if (MNS_FALSE == init_complete)
            #endif
            {
                TAKE_EVENTS();
                mis_data.init_complete = MNS_TRUE;
8000aa22:	ef 64 00 40 	st.b	r7[64],r4
                GIVE_EVENTS();
8000aa26:	fe b0 e8 49 	rcall	80007ab8 <mns_give>

                MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_MIS);
8000aa2a:	30 2b       	mov	r11,2
8000aa2c:	16 9c       	mov	r12,r11
8000aa2e:	e0 a0 07 47 	rcall	8000b8bc <MnsServiceInitComplete>
8000aa32:	c9 2b       	rjmp	8000a956 <MisService+0x5e>
            }
            else
            {
                if (MIS_P_SYNC_RESET == event_to_handle)
                {
                    MnsReportError(NSR_EI_RESET);
8000aa34:	e0 6c c3 01 	mov	r12,49921
8000aa38:	e0 a0 04 f0 	rcall	8000b418 <MnsReportError>
8000aa3c:	c8 db       	rjmp	8000a956 <MisService+0x5e>
8000aa3e:	d7 03       	nop
8000aa40:	00 00       	add	r0,r0
8000aa42:	35 34       	mov	r4,83

8000aa44 <MisInit>:
8000aa44:	d4 21       	pushm	r4-r7,lr
8000aa46:	18 96       	mov	r6,r12
8000aa48:	16 95       	mov	r5,r11
8000aa4a:	30 2c       	mov	r12,2
8000aa4c:	30 7b       	mov	r11,7
8000aa4e:	14 94       	mov	r4,r10
8000aa50:	30 0a       	mov	r10,0
8000aa52:	fe b0 e8 4d 	rcall	80007aec <mns_trace>
8000aa56:	30 4c       	mov	r12,4
8000aa58:	4b 47       	lddpc	r7,8000ab28 <MisInit+0xe4>
8000aa5a:	8f f6       	st.w	r7[0x3c],r6
8000aa5c:	fe b0 e8 2d 	rcall	80007ab6 <mns_take>
8000aa60:	30 08       	mov	r8,0
8000aa62:	30 4c       	mov	r12,4
8000aa64:	ae 18       	st.h	r7[0x2],r8
8000aa66:	ae 08       	st.h	r7[0x0],r8
    #endif

    mis_data.lld_cfg_ptr          = lld_cfg_ptr;

    TAKE_EVENTS();
    mis_data.init_complete        = MNS_FALSE;
8000aa68:	ef 68 00 40 	st.b	r7[64],r8
    mis_data.pending_events       = MIS_P_NONE;
    mis_data.latest_handled_event = MIS_P_NONE;
    GIVE_EVENTS();
8000aa6c:	fe b0 e8 26 	rcall	80007ab8 <mns_give>

    mis_data.pms_config.cbBufFreed_fptr  = MisHandleBufFreed;
8000aa70:	fe c8 fd 80 	sub	r8,pc,-640
    mis_data.pms_config.cbExtEvents_fptr = MisHandlePmsEvent;
8000aa74:	8f c8       	st.w	r7[0x30],r8
8000aa76:	fe c8 01 d6 	sub	r8,pc,470
#ifdef MIS_8
    mis_data.pms_config.cbMdpRx_fptr     = MisHandlePacketData;
8000aa7a:	8f 18       	st.w	r7[0x4],r8
#else
    mis_data.pms_config.cbMdpRx_fptr     = NULL;
#endif
    mis_data.pms_config.startIfaces_fptr = lld_cfg_ptr->start_interfaces_fptr;
8000aa7c:	fe c8 fd e8 	sub	r8,pc,-536
    mis_data.pms_config.stopIfaces_fptr  = lld_cfg_ptr->stop_interfaces_fptr;
8000aa80:	8f 48       	st.w	r7[0x10],r8
8000aa82:	6c 08       	ld.w	r8,r6[0x0]
    mis_data.pms_config.dataTx_fptr      = lld_cfg_ptr->data_tx_fptr;
8000aa84:	8f 68       	st.w	r7[0x18],r8
8000aa86:	6c 18       	ld.w	r8,r6[0x4]

    ASSERT(pms_cfg_ptr->rx_burst);
8000aa88:	8f 78       	st.w	r7[0x1c],r8
8000aa8a:	6c 68       	ld.w	r8,r6[0x18]
8000aa8c:	8f a8       	st.w	r7[0x28],r8
    mis_data.pms_config.rx_burst         = pms_cfg_ptr->rx_burst ? pms_cfg_ptr->rx_burst : PMS_STD_RX_BURST;
8000aa8e:	0b 88       	ld.ub	r8,r5[0x0]
8000aa90:	58 08       	cp.w	r8,0

#ifndef PACKET_COMMUNICATION_ONLY
    #ifdef MIS_6
        mis_data.pms_config.cbIcmRx_fptr     = MisHandleInicMsg;
8000aa92:	c3 30       	breq	8000aaf8 <MisInit+0xb4>
8000aa94:	ef 68 00 38 	st.b	r7[56],r8
    #else
        mis_data.pms_config.cbIcmRx_fptr     = NULL;
    #endif

    #ifdef MIS_7
        mis_data.pms_config.cbMcmRx_fptr     = MisHandleMostMsg;
8000aa98:	fe c8 ff 48 	sub	r8,pc,-184
    #else
        mis_data.pms_config.cbMcmRx_fptr     = NULL;
    #endif

    #ifdef AMS_12
        mis_data.pms_config.cbRxErr_fptr     = MsgRxError;
8000aa9c:	8f 28       	st.w	r7[0x8],r8
    #endif
    #ifdef AMS_TX_OUT_FILTER
    mis_data.pms_config.cbTxOutFilter_fptr  = msg_cfg_ptr->tx_out_filter_fptr;
    #endif
    #ifdef NS_AMS_MSV2
    mis_data.pms_config.cbTxBufferFlushed_fptr = msg_cfg_ptr->tx_buffer_flushed_fptr;
8000aa9e:	fe c8 ff 72 	sub	r8,pc,-142
    #ifdef MSG_RX_USER_PAYLOAD
    mis_data.pms_config.cbGetPayloadBuf_fptr = msg_cfg_ptr->get_payload_buf_fptr;
    mis_data.pms_config.cbFreePayloadBuf_fptr = msg_cfg_ptr->free_payload_buf_fptr;
    mis_data.pms_config.cbReallocPayloadBuf_fptr = msg_cfg_ptr->reallocate_payload_buf_fptr;
    #endif
    mis_data.pms_config.i2cTx_fptr       = lld_cfg_ptr->i2c_tx_fptr;
8000aaa2:	8f 38       	st.w	r7[0xc],r8
8000aaa4:	fe c8 1d c4 	sub	r8,pc,7620
    mis_data.pms_config.ctrlTx_fptr      = lld_cfg_ptr->ctrl_tx_fptr;
8000aaa8:	8f 58       	st.w	r7[0x14],r8
    mis_data.pms_config.icmIface         = lld_cfg_ptr->ctrl_interface_id;
8000aaaa:	68 48       	ld.w	r8,r4[0x10]
8000aaac:	8f d8       	st.w	r7[0x34],r8
8000aaae:	6c 48       	ld.w	r8,r6[0x10]
8000aab0:	8f 88       	st.w	r7[0x20],r8
    mis_data.pms_config.mcmIface         = lld_cfg_ptr->ctrl_interface_id;
8000aab2:	6c 58       	ld.w	r8,r6[0x14]
8000aab4:	8f 98       	st.w	r7[0x24],r8
8000aab6:	ed 38 00 1c 	ld.ub	r8,r6[28]
    mis_data.pms_config.mdpIface         = lld_cfg_ptr->data_interface_id;
8000aaba:	ef 68 00 2c 	st.b	r7[44],r8
8000aabe:	ed 38 00 1c 	ld.ub	r8,r6[28]
#endif

    ASSERT(mis_data.lld_cfg_ptr->reset_fptr);
8000aac2:	ef 68 00 2d 	st.b	r7[45],r8
8000aac6:	ed 38 00 1d 	ld.ub	r8,r6[29]

    mis_data.reset_counter               = 0;
    MostRegisterTimer(&(mis_data.reset_timer), MisSetPendingEvent, MIS_P_RESET_TIMER);
8000aaca:	ef 68 00 2e 	st.b	r7[46],r8
    mis_data.pms_config.mdpIface         = lld_cfg_ptr->data_interface_id;
#endif

    ASSERT(mis_data.lld_cfg_ptr->reset_fptr);

    mis_data.reset_counter               = 0;
8000aace:	6e f8       	ld.w	r8,r7[0x3c]
    MostRegisterTimer(&(mis_data.reset_timer), MisSetPendingEvent, MIS_P_RESET_TIMER);
8000aad0:	70 28       	ld.w	r8,r8[0x8]
8000aad2:	58 08       	cp.w	r8,0
    mis_data.pms_config.mdpIface         = lld_cfg_ptr->data_interface_id;
#endif

    ASSERT(mis_data.lld_cfg_ptr->reset_fptr);

    mis_data.reset_counter               = 0;
8000aad4:	c2 00       	breq	8000ab14 <MisInit+0xd0>
8000aad6:	ee cc ff bc 	sub	r12,r7,-68
    MostRegisterTimer(&(mis_data.reset_timer), MisSetPendingEvent, MIS_P_RESET_TIMER);
8000aada:	30 08       	mov	r8,0

    MbmInit();
8000aadc:	31 0a       	mov	r10,16
8000aade:	fe cb 02 5a 	sub	r11,pc,602
    PmsInit(&(mis_data.pms_config));
8000aae2:	ef 68 00 41 	st.b	r7[65],r8
8000aae6:	e0 a0 03 57 	rcall	8000b194 <MostRegisterTimer>
#endif
    mis_data.pms_config.startIfaces_fptr = lld_cfg_ptr->start_interfaces_fptr;
    mis_data.pms_config.stopIfaces_fptr  = lld_cfg_ptr->stop_interfaces_fptr;
    mis_data.pms_config.dataTx_fptr      = lld_cfg_ptr->data_tx_fptr;

    ASSERT(pms_cfg_ptr->rx_burst);
8000aaea:	fe b0 fc 6f 	rcall	8000a3c8 <MbmInit>
8000aaee:	ee cc ff fc 	sub	r12,r7,-4
8000aaf2:	e0 a0 1f d7 	rcall	8000eaa0 <PmsInit>
8000aaf6:	d8 22       	popm	r4-r7,pc
8000aaf8:	e0 68 00 c5 	mov	r8,197
    mis_data.pms_config.rx_burst         = pms_cfg_ptr->rx_burst ? pms_cfg_ptr->rx_burst : PMS_STD_RX_BURST;
8000aafc:	30 1a       	mov	r10,1
8000aafe:	1a d8       	st.w	--sp,r8
8000ab00:	31 0b       	mov	r11,16
8000ab02:	30 2c       	mov	r12,2
8000ab04:	fe b0 e7 f4 	rcall	80007aec <mns_trace>
    mis_data.pms_config.icmIface         = lld_cfg_ptr->ctrl_interface_id;
    mis_data.pms_config.mcmIface         = lld_cfg_ptr->ctrl_interface_id;
    mis_data.pms_config.mdpIface         = lld_cfg_ptr->data_interface_id;
#endif

    ASSERT(mis_data.lld_cfg_ptr->reset_fptr);
8000ab08:	0b 88       	ld.ub	r8,r5[0x0]
8000ab0a:	2f fd       	sub	sp,-4
8000ab0c:	58 08       	cp.w	r8,0
8000ab0e:	f9 b8 00 04 	moveq	r8,4
8000ab12:	cc 1b       	rjmp	8000aa94 <MisInit+0x50>
8000ab14:	e0 68 00 fa 	mov	r8,250
8000ab18:	30 1a       	mov	r10,1
8000ab1a:	1a d8       	st.w	--sp,r8
8000ab1c:	31 0b       	mov	r11,16
8000ab1e:	30 2c       	mov	r12,2
8000ab20:	fe b0 e7 e6 	rcall	80007aec <mns_trace>
8000ab24:	2f fd       	sub	sp,-4
8000ab26:	cd 8b       	rjmp	8000aad6 <MisInit+0x92>
8000ab28:	00 00       	add	r0,r0
8000ab2a:	35 34       	mov	r4,83

8000ab2c <MisHandleMostMsg>:
8000ab2c:	eb cd 40 80 	pushm	r7,lr
8000ab30:	18 97       	mov	r7,r12
8000ab32:	e0 6c 00 ff 	mov	r12,255
8000ab36:	ce dd       	rcall	8000af10 <MnsIsNSInitComplete>
8000ab38:	c0 61       	brne	8000ab44 <MisHandleMostMsg+0x18>
8000ab3a:	0e 9c       	mov	r12,r7
8000ab3c:	e0 a0 12 0e 	rcall	8000cf58 <MbmFree>
8000ab40:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ab44:	ee cc ff ec 	sub	r12,r7,-20
8000ab48:	fe b0 f3 a2 	rcall	8000928c <MsgRxTrigger>
8000ab4c:	e3 cd 80 80 	ldm	sp++,r7,pc

8000ab50 <MisHandleInicMsg>:
8000ab50:	d4 21       	pushm	r4-r7,lr
8000ab52:	4c f8       	lddpc	r8,8000ac8c <MisHandleInicMsg+0x13c>

    T_MOD_ENTRY(MIS_7);

    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_ALL))
    {
        MsgRxTrigger(msg_ptr);
8000ab54:	30 09       	mov	r9,0
8000ab56:	f1 3a 00 41 	ld.ub	r10,r8[65]
8000ab5a:	18 96       	mov	r6,r12
8000ab5c:	f2 0a 18 00 	cp.b	r10,r9
    func_idx  = 0;
    msg_ptr   = MBM_GET_CTRL_RX_PTR(handle);

    if (mis_data.reset_counter)
    {
        mis_data.reset_counter = 0;
8000ab60:	f1 f9 1e 41 	st.bne	r8[0x41],r9
    }

    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_PMS))
8000ab64:	30 1c       	mov	r12,1
8000ab66:	cd 5d       	rcall	8000af10 <MnsIsNSInitComplete>
8000ab68:	c5 40       	breq	8000ac10 <MisHandleInicMsg+0xc0>
8000ab6a:	ec c7 ff ec 	sub	r7,r6,-20

    T_MOD_ENTRY(MIS_6);

    func_done = MNS_FALSE;
    func_idx  = 0;
    msg_ptr   = MBM_GET_CTRL_RX_PTR(handle);
8000ab6e:	e0 80 00 84 	breq	8000ac76 <MisHandleInicMsg+0x126>
        mis_data.reset_counter = 0;
    }

    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_PMS))
    {
        ASSERT(msg_ptr);
8000ab72:	ed 18 00 18 	ld.uh	r8,r6[24]
        T_RX(msg_ptr->Src_Adr, msg_ptr->FBlock_ID, msg_ptr->Inst_ID,
8000ab76:	1a d8       	st.w	--sp,r8
8000ab78:	ed 38 00 20 	ld.ub	r8,r6[32]
8000ab7c:	1a d8       	st.w	--sp,r8
8000ab7e:	ed 18 00 1c 	ld.uh	r8,r6[28]
8000ab82:	1a d8       	st.w	--sp,r8
8000ab84:	ed 38 00 1f 	ld.ub	r8,r6[31]
8000ab88:	1a d8       	st.w	--sp,r8
8000ab8a:	ed 38 00 1e 	ld.ub	r8,r6[30]
8000ab8e:	1a d8       	st.w	--sp,r8
8000ab90:	ed 18 00 1a 	ld.uh	r8,r6[26]
8000ab94:	30 6a       	mov	r10,6
8000ab96:	1a d8       	st.w	--sp,r8
8000ab98:	30 bb       	mov	r11,11
8000ab9a:	30 2c       	mov	r12,2
8000ab9c:	fe b0 e7 a8 	rcall	80007aec <mns_trace>
8000aba0:	e0 a0 21 fe 	rcall	8000ef9c <VmsvPhysicalLayerTestActive>
             msg_ptr->Func_ID, msg_ptr->Operation, msg_ptr->Length);

#ifndef DISABLE_PLT_FILTER
#ifdef VMSV_102
        if (MNS_FALSE == VmsvPhysicalLayerTestActive())
8000aba4:	2f ad       	sub	sp,-24
8000aba6:	58 0c       	cp.w	r12,0
8000aba8:	c3 81       	brne	8000ac18 <MisHandleInicMsg+0xc8>
8000abaa:	4b aa       	lddpc	r10,8000ac90 <MisHandleInicMsg+0x140>
8000abac:	14 95       	mov	r5,r10
#endif
#endif
        {
            while ((MNS_FALSE == func_done) && (NULL != inic_handler_table[func_idx].op_type_table))
8000abae:	f8 c9 ff ff 	sub	r9,r12,-1
                            }
                        }
                        op_idx++;
                    }
                }
                func_idx++;
8000abb2:	f1 dc c0 10 	bfextu	r8,r12,0x0,0x10
#ifdef VMSV_102
        if (MNS_FALSE == VmsvPhysicalLayerTestActive())
#endif
#endif
        {
            while ((MNS_FALSE == func_done) && (NULL != inic_handler_table[func_idx].op_type_table))
8000abb6:	f9 d9 b0 10 	bfexts	r12,r9,0x0,0x10
                            }
                        }
                        op_idx++;
                    }
                }
                func_idx++;
8000abba:	f4 08 00 39 	add	r9,r10,r8<<0x3
#ifdef VMSV_102
        if (MNS_FALSE == VmsvPhysicalLayerTestActive())
#endif
#endif
        {
            while ((MNS_FALSE == func_done) && (NULL != inic_handler_table[func_idx].op_type_table))
8000abbe:	72 1b       	ld.w	r11,r9[0x4]
8000abc0:	58 0b       	cp.w	r11,0
8000abc2:	c2 70       	breq	8000ac10 <MisHandleInicMsg+0xc0>
8000abc4:	ea 08 04 38 	ld.sh	r8,r5[r8<<0x3]

    T_MOD_ENTRY(MIS_6);

    func_done = MNS_FALSE;
    func_idx  = 0;
    msg_ptr   = MBM_GET_CTRL_RX_PTR(handle);
8000abc8:	ed 09 00 1c 	ld.sh	r9,r6[28]
8000abcc:	f0 09 19 00 	cp.h	r9,r8
8000abd0:	ce f1       	brne	8000abae <MisHandleInicMsg+0x5e>
8000abd2:	30 08       	mov	r8,0
8000abd4:	f0 ca ff ff 	sub	r10,r8,-1
                            {
                                handler_fptr_table[handler_idx](msg_ptr);
                                handler_idx++;
                            }
                        }
                        op_idx++;
8000abd8:	5c 78       	castu.h	r8
                    bool op_done = MNS_FALSE;
                    word op_idx  = 0;

                    func_done = MNS_TRUE;
                    while ((MNS_FALSE == op_done) &&
                           (NULL != inic_handler_table[func_idx].op_type_table[op_idx].handler_fptr_table))
8000abda:	f6 08 00 39 	add	r9,r11,r8<<0x3
8000abde:	f1 da b0 10 	bfexts	r8,r10,0x0,0x10
                            {
                                handler_fptr_table[handler_idx](msg_ptr);
                                handler_idx++;
                            }
                        }
                        op_idx++;
8000abe2:	72 14       	ld.w	r4,r9[0x4]
                    bool op_done = MNS_FALSE;
                    word op_idx  = 0;

                    func_done = MNS_TRUE;
                    while ((MNS_FALSE == op_done) &&
                           (NULL != inic_handler_table[func_idx].op_type_table[op_idx].handler_fptr_table))
8000abe4:	58 04       	cp.w	r4,0
                {
                    bool op_done = MNS_FALSE;
                    word op_idx  = 0;

                    func_done = MNS_TRUE;
                    while ((MNS_FALSE == op_done) &&
8000abe6:	c1 50       	breq	8000ac10 <MisHandleInicMsg+0xc0>
8000abe8:	13 89       	ld.ub	r9,r9[0x0]
                           (NULL != inic_handler_table[func_idx].op_type_table[op_idx].handler_fptr_table))
                    {
                        if (msg_ptr->Operation == inic_handler_table[func_idx].op_type_table[op_idx].op_type)
8000abea:	ed 3a 00 20 	ld.ub	r10,r6[32]
8000abee:	f2 0a 18 00 	cp.b	r10,r9
8000abf2:	cf 11       	brne	8000abd4 <MisHandleInicMsg+0x84>
8000abf4:	68 08       	ld.w	r8,r4[0x0]
                            _CONST TMisHandlerFuncPtr *handler_fptr_table =
                                inic_handler_table[func_idx].
                                op_type_table[op_idx].handler_fptr_table;

                            op_done = MNS_TRUE;
                            while (NULL != handler_fptr_table[handler_idx])
8000abf6:	58 08       	cp.w	r8,0
8000abf8:	c0 c0       	breq	8000ac10 <MisHandleInicMsg+0xc0>
8000abfa:	30 05       	mov	r5,0
8000abfc:	0e 9c       	mov	r12,r7
                            {
                                handler_fptr_table[handler_idx](msg_ptr);
8000abfe:	5d 18       	icall	r8
8000ac00:	2f f5       	sub	r5,-1
                                handler_idx++;
8000ac02:	5c 85       	casts.h	r5
8000ac04:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
                            _CONST TMisHandlerFuncPtr *handler_fptr_table =
                                inic_handler_table[func_idx].
                                op_type_table[op_idx].handler_fptr_table;

                            op_done = MNS_TRUE;
                            while (NULL != handler_fptr_table[handler_idx])
8000ac08:	e8 08 03 28 	ld.w	r8,r4[r8<<0x2]
8000ac0c:	58 08       	cp.w	r8,0
8000ac0e:	cf 71       	brne	8000abfc <MisHandleInicMsg+0xac>
8000ac10:	0c 9c       	mov	r12,r6
            }
        }
#endif
#endif
    }
    MbmFree(handle);
8000ac12:	e0 a0 11 a3 	rcall	8000cf58 <MbmFree>
8000ac16:	d8 22       	popm	r4-r7,pc
    T_MOD_EXIT(MIS_6);
#endif
}
8000ac18:	ed 08 00 1c 	ld.sh	r8,r6[28]
#ifndef DISABLE_PLT_FILTER
#ifdef VMSV_102
        else        /* only certain messages are allowed during PhysicalLayerTest */
        {
            #ifdef VMSV_97
            if ((FUNCID_INIC_NUMCODINGERRORS == msg_ptr->Func_ID  ) &&
8000ac1c:	e0 69 05 0d 	mov	r9,1293
8000ac20:	f2 08 19 00 	cp.h	r8,r9
8000ac24:	c1 f0       	breq	8000ac62 <MisHandleInicMsg+0x112>
8000ac26:	e0 69 05 06 	mov	r9,1286
            {
                VmsvHandleCodingErrorsStatus(msg_ptr);
            }
            else
            #endif
            if ((FUNCID_INIC_LOCKSTATE == msg_ptr->Func_ID  ) &&
8000ac2a:	f2 08 19 00 	cp.h	r8,r9
8000ac2e:	c1 00       	breq	8000ac4e <MisHandleInicMsg+0xfe>
8000ac30:	e0 69 03 00 	mov	r9,768
                (OP_STATUS             == msg_ptr->Operation))
            {
                VmsvHandleLockStateStatus(msg_ptr);
            }
            else if ((FUNCID_INIC_EHCISTATE == msg_ptr->Func_ID  ) &&
8000ac34:	f2 08 19 00 	cp.h	r8,r9
8000ac38:	ce c1       	brne	8000ac10 <MisHandleInicMsg+0xc0>
8000ac3a:	ed 39 00 20 	ld.ub	r9,r6[32]

    T_MOD_ENTRY(MIS_6);

    func_done = MNS_FALSE;
    func_idx  = 0;
    msg_ptr   = MBM_GET_CTRL_RX_PTR(handle);
8000ac3e:	30 c8       	mov	r8,12
8000ac40:	f0 09 18 00 	cp.b	r9,r8
8000ac44:	ce 61       	brne	8000ac10 <MisHandleInicMsg+0xc0>
8000ac46:	0e 9c       	mov	r12,r7
                VmsvHandleLockStateStatus(msg_ptr);
            }
            else if ((FUNCID_INIC_EHCISTATE == msg_ptr->Func_ID  ) &&
                     (OP_STATUS             == msg_ptr->Operation))
            {
                MnsHandleEHCIStateStatus(msg_ptr);
8000ac48:	e0 a0 08 9e 	rcall	8000bd84 <MnsHandleEHCIStateStatus>
8000ac4c:	ce 2b       	rjmp	8000ac10 <MisHandleInicMsg+0xc0>
8000ac4e:	ed 39 00 20 	ld.ub	r9,r6[32]

    T_MOD_ENTRY(MIS_6);

    func_done = MNS_FALSE;
    func_idx  = 0;
    msg_ptr   = MBM_GET_CTRL_RX_PTR(handle);
8000ac52:	30 c8       	mov	r8,12
8000ac54:	f0 09 18 00 	cp.b	r9,r8
8000ac58:	cd c1       	brne	8000ac10 <MisHandleInicMsg+0xc0>
8000ac5a:	0e 9c       	mov	r12,r7
            else
            #endif
            if ((FUNCID_INIC_LOCKSTATE == msg_ptr->Func_ID  ) &&
                (OP_STATUS             == msg_ptr->Operation))
            {
                VmsvHandleLockStateStatus(msg_ptr);
8000ac5c:	e0 a0 2a e0 	rcall	8001021c <VmsvHandleLockStateStatus>
8000ac60:	cd 8b       	rjmp	8000ac10 <MisHandleInicMsg+0xc0>
            {
                VmsvHandleCodingErrorsStatus(msg_ptr);
            }
            else
            #endif
            if ((FUNCID_INIC_LOCKSTATE == msg_ptr->Func_ID  ) &&
8000ac62:	ed 39 00 20 	ld.ub	r9,r6[32]

    T_MOD_ENTRY(MIS_6);

    func_done = MNS_FALSE;
    func_idx  = 0;
    msg_ptr   = MBM_GET_CTRL_RX_PTR(handle);
8000ac66:	30 c8       	mov	r8,12
8000ac68:	f0 09 18 00 	cp.b	r9,r8
8000ac6c:	cd 21       	brne	8000ac10 <MisHandleInicMsg+0xc0>
8000ac6e:	0e 9c       	mov	r12,r7
        {
            #ifdef VMSV_97
            if ((FUNCID_INIC_NUMCODINGERRORS == msg_ptr->Func_ID  ) &&
                (OP_STATUS                   == msg_ptr->Operation))
            {
                VmsvHandleCodingErrorsStatus(msg_ptr);
8000ac70:	e0 a0 22 f4 	rcall	8000f258 <VmsvHandleCodingErrorsStatus>
8000ac74:	cc eb       	rjmp	8000ac10 <MisHandleInicMsg+0xc0>
#ifndef DISABLE_PLT_FILTER
#ifdef VMSV_102
        else        /* only certain messages are allowed during PhysicalLayerTest */
        {
            #ifdef VMSV_97
            if ((FUNCID_INIC_NUMCODINGERRORS == msg_ptr->Func_ID  ) &&
8000ac76:	e0 68 01 e1 	mov	r8,481
        mis_data.reset_counter = 0;
    }

    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_PMS))
    {
        ASSERT(msg_ptr);
8000ac7a:	30 1a       	mov	r10,1
8000ac7c:	1a d8       	st.w	--sp,r8
8000ac7e:	31 0b       	mov	r11,16
8000ac80:	30 2c       	mov	r12,2
8000ac82:	fe b0 e7 35 	rcall	80007aec <mns_trace>
8000ac86:	2f fd       	sub	sp,-4
8000ac88:	c7 5b       	rjmp	8000ab72 <MisHandleInicMsg+0x22>
8000ac8a:	d7 03       	nop
8000ac8c:	00 00       	add	r0,r0
8000ac8e:	35 34       	mov	r4,83
8000ac90:	80 06       	ld.sh	r6,r0[0x0]
8000ac92:	fa f4 eb cd 	ld.w	r4,sp[-5171]

8000ac94 <MisHandlePacketData>:
8000ac94:	eb cd 40 80 	pushm	r7,lr
8000ac98:	18 97       	mov	r7,r12
8000ac9a:	e0 6c 00 ff 	mov	r12,255
8000ac9e:	c3 9d       	rcall	8000af10 <MnsIsNSInitComplete>
8000aca0:	c1 90       	breq	8000acd2 <MisHandlePacketData+0x3e>
8000aca2:	ee c8 ff ec 	sub	r8,r7,-20
8000aca6:	c1 b0       	breq	8000acdc <MisHandlePacketData+0x48>
8000aca8:	ef 18 00 18 	ld.uh	r8,r7[24]
8000acac:	1a d8       	st.w	--sp,r8
8000acae:	ef 39 00 1b 	ld.ub	r9,r7[27]
        if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_ALL))
        {
            #if (MNS_DEBUG & NST_C_RX)
                TDataRx *msg_ptr = MBM_GET_DATA_RX_PTR(handle);
                ASSERT(msg_ptr);
                T_RX_PACKET((msg_ptr->Src_Adr_H << 8) | msg_ptr->Src_Adr_L,
8000acb2:	ef 38 00 1c 	ld.ub	r8,r7[28]
8000acb6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000acba:	30 2a       	mov	r10,2
8000acbc:	1a d8       	st.w	--sp,r8
8000acbe:	14 9c       	mov	r12,r10
8000acc0:	31 6b       	mov	r11,22
8000acc2:	fe b0 e7 15 	rcall	80007aec <mns_trace>
8000acc6:	0e 9c       	mov	r12,r7
                            msg_ptr->Length);
            #endif
            DataRxTrigger(handle);
8000acc8:	e0 a0 33 f2 	rcall	800114ac <DataRxTrigger>
8000accc:	2f ed       	sub	sp,-8
8000acce:	e3 cd 80 80 	ldm	sp++,r7,pc
8000acd2:	0e 9c       	mov	r12,r7
        }
        else
        {
            MbmFree(handle);
8000acd4:	e0 a0 11 42 	rcall	8000cf58 <MbmFree>
8000acd8:	e3 cd 80 80 	ldm	sp++,r7,pc
8000acdc:	e0 68 02 b6 	mov	r8,694
    #ifdef ADS_MIN
        if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_ALL))
        {
            #if (MNS_DEBUG & NST_C_RX)
                TDataRx *msg_ptr = MBM_GET_DATA_RX_PTR(handle);
                ASSERT(msg_ptr);
8000ace0:	30 1a       	mov	r10,1
8000ace2:	1a d8       	st.w	--sp,r8
8000ace4:	31 0b       	mov	r11,16
8000ace6:	30 2c       	mov	r12,2
8000ace8:	fe b0 e7 02 	rcall	80007aec <mns_trace>
8000acec:	2f fd       	sub	sp,-4
8000acee:	cd db       	rjmp	8000aca8 <MisHandlePacketData+0x14>

8000acf0 <MisHandleBufFreed>:
8000acf0:	d4 01       	pushm	lr
8000acf2:	30 8b       	mov	r11,8
8000acf4:	30 2c       	mov	r12,2
8000acf6:	c0 3c       	rcall	8000acfc <MnsDistribEvent>
8000acf8:	d8 02       	popm	pc
8000acfa:	d7 03       	nop

8000acfc <MnsDistribEvent>:
}
#endif

#ifdef MNS_9
void MnsDistribEvent(word service, word event)
{
8000acfc:	eb cd 40 e0 	pushm	r5-r7,lr
8000ad00:	49 9a       	lddpc	r10,8000ad64 <MnsDistribEvent+0x68>
8000ad02:	30 09       	mov	r9,0
8000ad04:	14 95       	mov	r5,r10
                event_ptr = &(service_ptr->entry_table[++index]);
            }
        }
        else
        {
            service_ptr = (MnsServicePtr) &mns_events[++index];
8000ad06:	2f f9       	sub	r9,-1
}
#endif

#ifdef MNS_9
void MnsDistribEvent(word service, word event)
{
8000ad08:	16 96       	mov	r6,r11
                event_ptr = &(service_ptr->entry_table[++index]);
            }
        }
        else
        {
            service_ptr = (MnsServicePtr) &mns_events[++index];
8000ad0a:	5c 59       	castu.b	r9
    index         = 0;
    service_match = MNS_FALSE;
    service_ptr   = (MnsServicePtr) &mns_events[index];
    event_ptr     = NULL;

    while ((MNS_FALSE == service_match) && service_ptr->service)
8000ad0c:	8a 08       	ld.sh	r8,r5[0x0]
8000ad0e:	58 08       	cp.w	r8,0
8000ad10:	c0 b0       	breq	8000ad26 <MnsDistribEvent+0x2a>
    {
        if (service == service_ptr->service)
8000ad12:	f8 08 19 00 	cp.h	r8,r12
8000ad16:	c0 a0       	breq	8000ad2a <MnsDistribEvent+0x2e>
                event_ptr = &(service_ptr->entry_table[++index]);
            }
        }
        else
        {
            service_ptr = (MnsServicePtr) &mns_events[++index];
8000ad18:	f4 09 00 35 	add	r5,r10,r9<<0x3
8000ad1c:	2f f9       	sub	r9,-1
    index         = 0;
    service_match = MNS_FALSE;
    service_ptr   = (MnsServicePtr) &mns_events[index];
    event_ptr     = NULL;

    while ((MNS_FALSE == service_match) && service_ptr->service)
8000ad1e:	8a 08       	ld.sh	r8,r5[0x0]
                event_ptr = &(service_ptr->entry_table[++index]);
            }
        }
        else
        {
            service_ptr = (MnsServicePtr) &mns_events[++index];
8000ad20:	5c 59       	castu.b	r9
    index         = 0;
    service_match = MNS_FALSE;
    service_ptr   = (MnsServicePtr) &mns_events[index];
    event_ptr     = NULL;

    while ((MNS_FALSE == service_match) && service_ptr->service)
8000ad22:	58 08       	cp.w	r8,0
8000ad24:	cf 71       	brne	8000ad12 <MnsDistribEvent+0x16>
8000ad26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    {
        if (service == service_ptr->service)
        {
            service_match = MNS_TRUE;
            index         = 0;
            event_ptr     = &(service_ptr->entry_table[index]);
8000ad2a:	6a 1a       	ld.w	r10,r5[0x4]
8000ad2c:	14 99       	mov	r9,r10

            while (event_ptr->source_event)
8000ad2e:	94 08       	ld.sh	r8,r10[0x0]
8000ad30:	58 08       	cp.w	r8,0
8000ad32:	cf a0       	breq	8000ad26 <MnsDistribEvent+0x2a>
8000ad34:	30 07       	mov	r7,0
8000ad36:	c0 a8       	rjmp	8000ad4a <MnsDistribEvent+0x4e>
                    if (event_ptr->cb_ptr)
                    {
                        event_ptr->cb_ptr(event_ptr->target_event);
                    }
                }
                event_ptr = &(service_ptr->entry_table[++index]);
8000ad38:	2f f7       	sub	r7,-1
8000ad3a:	5c 57       	castu.b	r7
8000ad3c:	ee 07 00 19 	add	r9,r7,r7<<0x1
8000ad40:	f4 09 00 29 	add	r9,r10,r9<<0x2
        {
            service_match = MNS_TRUE;
            index         = 0;
            event_ptr     = &(service_ptr->entry_table[index]);

            while (event_ptr->source_event)
8000ad44:	92 08       	ld.sh	r8,r9[0x0]
8000ad46:	58 08       	cp.w	r8,0
8000ad48:	c0 b0       	breq	8000ad5e <MnsDistribEvent+0x62>
            {
                if (event == event_ptr->source_event)
8000ad4a:	ec 08 19 00 	cp.h	r8,r6
8000ad4e:	cf 51       	brne	8000ad38 <MnsDistribEvent+0x3c>
                {
                    if (event_ptr->cb_ptr)
8000ad50:	72 18       	ld.w	r8,r9[0x4]
8000ad52:	58 08       	cp.w	r8,0
8000ad54:	cf 20       	breq	8000ad38 <MnsDistribEvent+0x3c>
                    {
                        event_ptr->cb_ptr(event_ptr->target_event);
8000ad56:	92 cc       	ld.uh	r12,r9[0x8]
8000ad58:	5d 18       	icall	r8
8000ad5a:	6a 1a       	ld.w	r10,r5[0x4]
8000ad5c:	ce eb       	rjmp	8000ad38 <MnsDistribEvent+0x3c>
8000ad5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ad62:	d7 03       	nop
8000ad64:	80 06       	ld.sh	r6,r0[0x0]
8000ad66:	fd ec       	*unknown*

8000ad68 <MnsMemSet>:
#ifdef MNS_59
_INLINE void MnsMemSet(byte* tgt_ptr, byte value, word size)
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
8000ad68:	58 0a       	cp.w	r10,0
8000ad6a:	5e 0c       	reteq	r12
    {
        *tgt_ptr++ = value;
8000ad6c:	b8 8b       	st.b	r12[0x0],r11
  * @param      tgt_ptr is a byte pointer to the target buffer
  * @param      value is the value to set
  * @param      size is the amount of bytes to set
  */
#ifdef MNS_59
_INLINE void MnsMemSet(byte* tgt_ptr, byte value, word size)
8000ad6e:	f8 c8 ff ff 	sub	r8,r12,-1
8000ad72:	f4 c9 00 01 	sub	r9,r10,1
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
    {
        *tgt_ptr++ = value;
8000ad76:	10 9c       	mov	r12,r8
  * @param      tgt_ptr is a byte pointer to the target buffer
  * @param      value is the value to set
  * @param      size is the amount of bytes to set
  */
#ifdef MNS_59
_INLINE void MnsMemSet(byte* tgt_ptr, byte value, word size)
8000ad78:	5c 79       	castu.h	r9
8000ad7a:	f0 09 00 09 	add	r9,r8,r9
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
8000ad7e:	12 38       	cp.w	r8,r9
8000ad80:	5e 0c       	reteq	r12
    {
        *tgt_ptr++ = value;
8000ad82:	b8 8b       	st.b	r12[0x0],r11
8000ad84:	2f f8       	sub	r8,-1
8000ad86:	10 9c       	mov	r12,r8
#ifdef MNS_59
_INLINE void MnsMemSet(byte* tgt_ptr, byte value, word size)
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
8000ad88:	12 38       	cp.w	r8,r9
8000ad8a:	cf c1       	brne	8000ad82 <MnsMemSet+0x1a>
8000ad8c:	5e fc       	retal	r12
8000ad8e:	d7 03       	nop

8000ad90 <GetNetServicesConfig>:
  */
TNetServicesConfig * GetNetServicesConfig(void)
{
    T_API_ENTRY(MNS_63);

    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));
8000ad90:	49 78       	lddpc	r8,8000adec <GetNetServicesConfig+0x5c>
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
    {
        *tgt_ptr++ = value;
8000ad92:	30 0a       	mov	r10,0
  */
TNetServicesConfig * GetNetServicesConfig(void)
{
    T_API_ENTRY(MNS_63);

    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));
8000ad94:	f0 c9 ff 7c 	sub	r9,r8,-132
  *             central configuration structure of the type TNetServicesConfig.
  *             Its field need to be setup by the application before
  *             InitNetServices() is called.
  * \return     Pointer to the central configuration structure
  */
TNetServicesConfig * GetNetServicesConfig(void)
8000ad98:	f0 cb fe bc 	sub	r11,r8,-324
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
    {
        *tgt_ptr++ = value;
8000ad9c:	12 ca       	st.b	r9++,r10
#ifdef MNS_59
_INLINE void MnsMemSet(byte* tgt_ptr, byte value, word size)
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
8000ad9e:	16 39       	cp.w	r9,r11
8000ada0:	cf e1       	brne	8000ad9c <GetNetServicesConfig+0xc>
    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));

    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
    mns.config.general.watchdogmode.auto_shutdown_delay = MNS_TM_WD_DISABLE;
    mns.config.general.watchdogmode.threshold           = MNS_TM_WD_THRESHOLD_DISABLE;
    mns.config.general.burst                            = MNS_STD_BURST;
8000ada2:	30 19       	mov	r9,1
    #endif


    #ifdef SCM_MIN
    mns.config.scm.packet.mode                          = SCM_PM_NONE;
    mns.config.scm.packet.clock_config                  = SCM_PORT_CFG_MLB_512_FS;
8000ada4:	f1 69 01 39 	st.b	r8[313],r9
    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));

    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
    mns.config.general.watchdogmode.auto_shutdown_delay = MNS_TM_WD_DISABLE;
    mns.config.general.watchdogmode.threshold           = MNS_TM_WD_THRESHOLD_DISABLE;
    mns.config.general.burst                            = MNS_STD_BURST;
8000ada8:	f1 69 00 ac 	st.b	r8[172],r9
    mns.config.lld.ctrl_interface_id                    = PMS_IFACE_I2C;
    mns.config.lld.data_interface_id                    = PMS_IFACE_I2C;

    mns.config.pms.rx_burst                             = PMS_STD_RX_BURST;
    #ifdef AMS_MIN
    mns.config.msg.rx_burst                             = MSG_STD_RX_BURST;
8000adac:	f1 69 00 f0 	st.b	r8[240],r9
    #endif

    #ifdef ADS_MIN
    mns.config.wads.rx_burst                            = DATA_STD_RX_BURST;
8000adb0:	f1 69 01 00 	st.b	r8[256],r9
    T_API_ENTRY(MNS_63);

    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));

    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
    mns.config.general.watchdogmode.auto_shutdown_delay = MNS_TM_WD_DISABLE;
8000adb4:	3f f9       	mov	r9,-1
    mns.config.general.watchdogmode.threshold           = MNS_TM_WD_THRESHOLD_DISABLE;
8000adb6:	f1 59 00 aa 	st.h	r8[170],r9
    T_API_ENTRY(MNS_63);

    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));

    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
    mns.config.general.watchdogmode.auto_shutdown_delay = MNS_TM_WD_DISABLE;
8000adba:	f1 59 00 a8 	st.h	r8[168],r9
{
    T_API_ENTRY(MNS_63);

    MNS_MEM_SET((byte *)&mns.config, (byte)0,(word)sizeof(mns.config));

    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
8000adbe:	e0 69 01 f4 	mov	r9,500
8000adc2:	f1 59 00 a6 	st.h	r8[166],r9
    mns.config.general.watchdogmode.threshold           = MNS_TM_WD_THRESHOLD_DISABLE;
    mns.config.general.burst                            = MNS_STD_BURST;
    mns.config.lld.ctrl_interface_id                    = PMS_IFACE_I2C;
    mns.config.lld.data_interface_id                    = PMS_IFACE_I2C;

    mns.config.pms.rx_burst                             = PMS_STD_RX_BURST;
8000adc6:	30 49       	mov	r9,4
8000adc8:	f1 69 00 d0 	st.b	r8[208],r9


    #ifdef SCM_MIN
    mns.config.scm.packet.mode                          = SCM_PM_NONE;
    mns.config.scm.packet.clock_config                  = SCM_PORT_CFG_MLB_512_FS;
    mns.config.scm.packet.in.address                    = (word)0x0008;
8000adcc:	30 89       	mov	r9,8
    mns.config.wads.rx_burst                            = DATA_STD_RX_BURST;
    #endif


    #ifdef SCM_MIN
    mns.config.scm.packet.mode                          = SCM_PM_NONE;
8000adce:	f1 6a 01 38 	st.b	r8[312],r10
    mns.config.scm.packet.clock_config                  = SCM_PORT_CFG_MLB_512_FS;
    mns.config.scm.packet.in.address                    = (word)0x0008;
8000add2:	f1 59 01 3a 	st.h	r8[314],r9

    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
    mns.config.general.watchdogmode.auto_shutdown_delay = MNS_TM_WD_DISABLE;
    mns.config.general.watchdogmode.threshold           = MNS_TM_WD_THRESHOLD_DISABLE;
    mns.config.general.burst                            = MNS_STD_BURST;
    mns.config.lld.ctrl_interface_id                    = PMS_IFACE_I2C;
8000add6:	f1 6a 00 cc 	st.b	r8[204],r10

    #ifdef SCM_MIN
    mns.config.scm.packet.mode                          = SCM_PM_NONE;
    mns.config.scm.packet.clock_config                  = SCM_PORT_CFG_MLB_512_FS;
    mns.config.scm.packet.in.address                    = (word)0x0008;
    mns.config.scm.packet.out.address                   = (word)0x0006;
8000adda:	30 69       	mov	r9,6
    mns.config.general.watchdogmode.timeout             = MNS_TM_WD_MAX_TIMEOUT;
    mns.config.general.watchdogmode.auto_shutdown_delay = MNS_TM_WD_DISABLE;
    mns.config.general.watchdogmode.threshold           = MNS_TM_WD_THRESHOLD_DISABLE;
    mns.config.general.burst                            = MNS_STD_BURST;
    mns.config.lld.ctrl_interface_id                    = PMS_IFACE_I2C;
    mns.config.lld.data_interface_id                    = PMS_IFACE_I2C;
8000addc:	f1 6a 00 cd 	st.b	r8[205],r10


    T_API_EXIT(MNS_63);

    return(&(mns.config));
}
8000ade0:	f0 cc ff 7c 	sub	r12,r8,-132

    #ifdef SCM_MIN
    mns.config.scm.packet.mode                          = SCM_PM_NONE;
    mns.config.scm.packet.clock_config                  = SCM_PORT_CFG_MLB_512_FS;
    mns.config.scm.packet.in.address                    = (word)0x0008;
    mns.config.scm.packet.out.address                   = (word)0x0006;
8000ade4:	f1 59 01 3e 	st.h	r8[318],r9


    T_API_EXIT(MNS_63);

    return(&(mns.config));
}
8000ade8:	5e fc       	retal	r12
8000adea:	d7 03       	nop
8000adec:	00 00       	add	r0,r0
8000adee:	35 94       	mov	r4,89

8000adf0 <MnsGetWatchdogKickTimeout>:
}
#endif

#ifdef MNS_108
word MnsGetWatchdogKickTimeout(void)
{
8000adf0:	eb cd 40 80 	pushm	r7,lr
    word timeout;

    T_LIB_ENTRY(MNS_108);

    TAKE_MNS();
8000adf4:	30 8c       	mov	r12,8
8000adf6:	fe b0 e6 60 	rcall	80007ab6 <mns_take>
    if( MNS_TM_WD_DISABLE == mns.config.general.watchdogmode.timeout )
8000adfa:	48 98       	lddpc	r8,8000ae1c <MnsGetWatchdogKickTimeout+0x2c>
8000adfc:	3f f9       	mov	r9,-1
8000adfe:	f1 0a 00 a6 	ld.sh	r10,r8[166]
    }
    else
    {
        timeout = mns.watchdogmode.timeout_wdsm;
    }
    GIVE_MNS();
8000ae02:	30 8c       	mov	r12,8
    word timeout;

    T_LIB_ENTRY(MNS_108);

    TAKE_MNS();
    if( MNS_TM_WD_DISABLE == mns.config.general.watchdogmode.timeout )
8000ae04:	f2 0a 19 00 	cp.h	r10,r9
8000ae08:	f9 b7 00 ff 	moveq	r7,-1
    {
        timeout = MNS_TM_WD_DISABLE;
    }
    else
    {
        timeout = mns.watchdogmode.timeout_wdsm;
8000ae0c:	f1 f7 12 1c 	ld.shne	r7,r8[0x38]
    }
    GIVE_MNS();
8000ae10:	fe b0 e6 54 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(MNS_108);

    return( timeout );
}
8000ae14:	0e 9c       	mov	r12,r7
8000ae16:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ae1a:	d7 03       	nop
8000ae1c:	00 00       	add	r0,r0
8000ae1e:	35 94       	mov	r4,89

8000ae20 <MnsSignalNetOn>:
8000ae20:	d4 01       	pushm	lr
8000ae22:	30 8c       	mov	r12,8
8000ae24:	fe b0 e6 49 	rcall	80007ab6 <mns_take>
void MnsSignalNetOn(void)
{
    T_LIB_ENTRY(MNS_102);

    TAKE_MNS();
    mns.signal_net_on = MNS_TRUE;
8000ae28:	30 19       	mov	r9,1
8000ae2a:	48 48       	lddpc	r8,8000ae38 <MnsSignalNetOn+0x18>
    GIVE_MNS();
8000ae2c:	30 8c       	mov	r12,8
void MnsSignalNetOn(void)
{
    T_LIB_ENTRY(MNS_102);

    TAKE_MNS();
    mns.signal_net_on = MNS_TRUE;
8000ae2e:	f1 69 01 46 	st.b	r8[326],r9
    GIVE_MNS();
8000ae32:	fe b0 e6 43 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(MNS_102);
}
8000ae36:	d8 02       	popm	pc
8000ae38:	00 00       	add	r0,r0
8000ae3a:	35 94       	mov	r4,89

8000ae3c <MostGetRevision>:
8000ae3c:	eb cd 40 80 	pushm	r7,lr
8000ae40:	18 97       	mov	r7,r12
8000ae42:	30 8c       	mov	r12,8

    T_API_ENTRY(MNS_58);

    count = 3;

    TAKE_MNS();
8000ae44:	fe b0 e6 39 	rcall	80007ab6 <mns_take>

    while (count--)
    {
        *tgt_ptr++ = mns.shadow.version.public.fw_date[count];
8000ae48:	48 88       	lddpc	r8,8000ae68 <MostGetRevision+0x2c>
8000ae4a:	f1 39 00 22 	ld.ub	r9,r8[34]
8000ae4e:	0e c9       	st.b	r7++,r9
8000ae50:	f1 39 00 21 	ld.ub	r9,r8[33]
8000ae54:	ae 89       	st.b	r7[0x0],r9
8000ae56:	f1 38 00 20 	ld.ub	r8,r8[32]
    }

    GIVE_MNS();
8000ae5a:	30 8c       	mov	r12,8

    TAKE_MNS();

    while (count--)
    {
        *tgt_ptr++ = mns.shadow.version.public.fw_date[count];
8000ae5c:	ae 98       	st.b	r7[0x1],r8
    }

    GIVE_MNS();
8000ae5e:	fe b0 e6 2d 	rcall	80007ab8 <mns_give>

    T_API_EXIT(MNS_58);
}
8000ae62:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ae66:	d7 03       	nop
8000ae68:	00 00       	add	r0,r0
8000ae6a:	35 94       	mov	r4,89

8000ae6c <MnsNtfCheck>:
8000ae6c:	eb cd 40 e0 	pushm	r5-r7,lr
8000ae70:	18 95       	mov	r5,r12
8000ae72:	30 8c       	mov	r12,8

    T_LIB_ENTRY(MNS_55);

    complete = MNS_FALSE;

    TAKE_MNS();
8000ae74:	fe b0 e6 21 	rcall	80007ab6 <mns_take>
    mask = mns.shadow.version.ntf_mask;
    GIVE_MNS();
8000ae78:	30 8c       	mov	r12,8
    T_LIB_ENTRY(MNS_55);

    complete = MNS_FALSE;

    TAKE_MNS();
    mask = mns.shadow.version.ntf_mask;
8000ae7a:	48 e7       	lddpc	r7,8000aeb0 <MnsNtfCheck+0x44>
8000ae7c:	6e c6       	ld.w	r6,r7[0x30]
    GIVE_MNS();
8000ae7e:	fe b0 e6 1d 	rcall	80007ab8 <mns_give>

    TAKE_EVENTS();
8000ae82:	30 7c       	mov	r12,7
8000ae84:	fe b0 e6 19 	rcall	80007ab6 <mns_take>
    mns.events.ntf_state |= flag;
8000ae88:	6e 28       	ld.w	r8,r7[0x8]
8000ae8a:	10 45       	or	r5,r8
8000ae8c:	8f 25       	st.w	r7[0x8],r5
    if (mask == (mask & mns.events.ntf_state))
8000ae8e:	0c 65       	and	r5,r6
8000ae90:	0c 35       	cp.w	r5,r6
8000ae92:	c0 60       	breq	8000ae9e <MnsNtfCheck+0x32>
    {
        complete = MNS_TRUE;
    }
    GIVE_EVENTS();
8000ae94:	30 7c       	mov	r12,7
8000ae96:	fe b0 e6 11 	rcall	80007ab8 <mns_give>
8000ae9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ae9e:	30 7c       	mov	r12,7
8000aea0:	fe b0 e6 0c 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != complete)
    {
        MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_NTF_COMPLETE);
8000aea4:	e0 6b 08 00 	mov	r11,2048
8000aea8:	30 4c       	mov	r12,4
8000aeaa:	c2 9f       	rcall	8000acfc <MnsDistribEvent>
8000aeac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000aeb0:	00 00       	add	r0,r0
8000aeb2:	35 94       	mov	r4,89

8000aeb4 <MostIsSupported>:
8000aeb4:	eb cd 40 c0 	pushm	r6-r7,lr
8000aeb8:	18 96       	mov	r6,r12
8000aeba:	30 8c       	mov	r12,8
8000aebc:	fe b0 e5 fd 	rcall	80007ab6 <mns_take>
8000aec0:	48 b8       	lddpc	r8,8000aeec <MostIsSupported+0x38>
8000aec2:	30 8c       	mov	r12,8
    T_API_ENTRY(MNS_54);

    supported = MNS_FALSE;

    TAKE_MNS();
    mask = mns.shadow.version.feature_mask;
8000aec4:	f1 07 00 34 	ld.sh	r7,r8[52]
    GIVE_MNS();
8000aec8:	fe b0 e5 f8 	rcall	80007ab8 <mns_give>

    if ((INIC_SHADOW_INVALID_WORD != mask) && (mask & feature))
8000aecc:	fe 78 ee ee 	mov	r8,-4370
8000aed0:	f0 07 19 00 	cp.h	r7,r8
8000aed4:	c0 90       	breq	8000aee6 <MostIsSupported+0x32>
  *
  * @param      feature is the feature to query  (NSF_* constants)
  * @return     whether it is supported (MNS_TRUE) or not (MNS_FALSE)
  */
#ifdef MNS_54
bool MostIsSupported(word feature)
8000aed6:	ed e7 00 07 	and	r7,r6,r7
8000aeda:	30 08       	mov	r8,0
8000aedc:	f0 07 19 00 	cp.h	r7,r8
8000aee0:	5f 1c       	srne	r12
    }

    T_API_EXIT(MNS_54);

    return(supported);
}
8000aee2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    TAKE_MNS();
    mask = mns.shadow.version.feature_mask;
    GIVE_MNS();

    if ((INIC_SHADOW_INVALID_WORD != mask) && (mask & feature))
8000aee6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000aeea:	d7 03       	nop
8000aeec:	00 00       	add	r0,r0
8000aeee:	35 94       	mov	r4,89

8000aef0 <MnsGetEHCIState>:
8000aef0:	eb cd 40 80 	pushm	r7,lr
8000aef4:	30 8c       	mov	r12,8
8000aef6:	fe b0 e5 e0 	rcall	80007ab6 <mns_take>
{
    byte result;

    T_LIB_ENTRY(MNS_43);
    TAKE_MNS();
    result = mns.shadow.ehci_state;
8000aefa:	48 58       	lddpc	r8,8000af0c <MnsGetEHCIState+0x1c>
    GIVE_MNS();
8000aefc:	30 8c       	mov	r12,8
{
    byte result;

    T_LIB_ENTRY(MNS_43);
    TAKE_MNS();
    result = mns.shadow.ehci_state;
8000aefe:	f1 37 00 18 	ld.ub	r7,r8[24]
    GIVE_MNS();
8000af02:	fe b0 e5 db 	rcall	80007ab8 <mns_give>
    T_LIB_EXIT(MNS_43);

    return(result);
}
8000af06:	0e 9c       	mov	r12,r7
8000af08:	e3 cd 80 80 	ldm	sp++,r7,pc
8000af0c:	00 00       	add	r0,r0
8000af0e:	35 94       	mov	r4,89

8000af10 <MnsIsNSInitComplete>:
8000af10:	eb cd 40 80 	pushm	r7,lr
8000af14:	18 97       	mov	r7,r12
8000af16:	30 8c       	mov	r12,8

    T_LIB_ENTRY(MNS_12);

    result = MNS_FALSE;

    TAKE_MNS();
8000af18:	fe b0 e5 cf 	rcall	80007ab6 <mns_take>
    T_LIB_EXIT(MNS_11);
}
#endif

#ifdef MNS_12
bool MnsIsNSInitComplete(word mask)
8000af1c:	48 78       	lddpc	r8,8000af38 <MnsIsNSInitComplete+0x28>
8000af1e:	f1 08 00 10 	ld.sh	r8,r8[16]
8000af22:	ef e8 00 08 	and	r8,r7,r8
    TAKE_MNS();
    if ((mask & mns.services.ms_init_mask) == mask)
    {
        result = MNS_TRUE;
    }
    GIVE_MNS();
8000af26:	30 8c       	mov	r12,8
    T_LIB_EXIT(MNS_11);
}
#endif

#ifdef MNS_12
bool MnsIsNSInitComplete(word mask)
8000af28:	f0 07 19 00 	cp.h	r7,r8
8000af2c:	5f 07       	sreq	r7
    TAKE_MNS();
    if ((mask & mns.services.ms_init_mask) == mask)
    {
        result = MNS_TRUE;
    }
    GIVE_MNS();
8000af2e:	fe b0 e5 c5 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(MNS_12);
    return(result);
}
8000af32:	0e 9c       	mov	r12,r7
8000af34:	e3 cd 80 80 	ldm	sp++,r7,pc
8000af38:	00 00       	add	r0,r0
8000af3a:	35 94       	mov	r4,89

8000af3c <MnsTMDiff>:
8000af3c:	eb cd 40 80 	pushm	r7,lr
8000af40:	49 77       	lddpc	r7,8000af9c <MnsTMDiff+0x60>
8000af42:	ee fc 00 9c 	ld.w	r12,r7[156]
static void MnsTMDiff(void)
{
    T_MOD_ENTRY(MNS_98);
    T_TM_OP(MNS_TM_OP_DIFF);

    if (mns.config.general.get_tick_count_fptr)
8000af46:	58 0c       	cp.w	r12,0
8000af48:	c1 a0       	breq	8000af7c <MnsTMDiff+0x40>
    {
        word current_tick = mns.config.general.get_tick_count_fptr();
8000af4a:	5d 1c       	icall	r12
        word current_diff = current_tick - mns.tm.last_tick;
8000af4c:	ef 08 00 3e 	ld.sh	r8,r7[62]

        mns.tm.last_tick = current_tick;
8000af50:	ef 5c 00 3e 	st.h	r7[62],r12
    T_TM_OP(MNS_TM_OP_DIFF);

    if (mns.config.general.get_tick_count_fptr)
    {
        word current_tick = mns.config.general.get_tick_count_fptr();
        word current_diff = current_tick - mns.tm.last_tick;
8000af54:	10 1c       	sub	r12,r8

        mns.tm.last_tick = current_tick;
        mns.tm.diff += current_diff;
8000af56:	ef 08 00 40 	ld.sh	r8,r7[64]
    T_TM_OP(MNS_TM_OP_DIFF);

    if (mns.config.general.get_tick_count_fptr)
    {
        word current_tick = mns.config.general.get_tick_count_fptr();
        word current_diff = current_tick - mns.tm.last_tick;
8000af5a:	5c 8c       	casts.h	r12

        mns.tm.last_tick = current_tick;
        mns.tm.diff += current_diff;
8000af5c:	18 08       	add	r8,r12
8000af5e:	ef 58 00 40 	st.h	r7[64],r8

        if(mns.tm.scheduled_timeout)
8000af62:	ef 08 00 44 	ld.sh	r8,r7[68]
8000af66:	58 08       	cp.w	r8,0
8000af68:	c1 30       	breq	8000af8e <MnsTMDiff+0x52>
        {
            mns.tm.scheduled_timeout = (current_diff >= mns.tm.scheduled_timeout) ?
8000af6a:	f0 0c 19 00 	cp.h	r12,r8
8000af6e:	c1 22       	brcc	8000af92 <MnsTMDiff+0x56>
8000af70:	f0 0c 01 0c 	sub	r12,r8,r12
8000af74:	ef 5c 00 44 	st.h	r7[68],r12
8000af78:	e3 cd 80 80 	ldm	sp++,r7,pc
                (word) 1 : mns.tm.scheduled_timeout - current_diff;
        }
    }
    else
    {
        FAILED_ASSERT();
8000af7c:	e0 68 0c 35 	mov	r8,3125
8000af80:	30 1a       	mov	r10,1
8000af82:	1a d8       	st.w	--sp,r8
8000af84:	31 0b       	mov	r11,16
8000af86:	30 4c       	mov	r12,4
8000af88:	fe b0 e5 b2 	rcall	80007aec <mns_trace>
8000af8c:	2f fd       	sub	sp,-4
8000af8e:	e3 cd 80 80 	ldm	sp++,r7,pc
        mns.tm.last_tick = current_tick;
        mns.tm.diff += current_diff;

        if(mns.tm.scheduled_timeout)
        {
            mns.tm.scheduled_timeout = (current_diff >= mns.tm.scheduled_timeout) ?
8000af92:	30 1c       	mov	r12,1
8000af94:	ef 5c 00 44 	st.h	r7[68],r12
8000af98:	e3 cd 80 80 	ldm	sp++,r7,pc
8000af9c:	00 00       	add	r0,r0
8000af9e:	35 94       	mov	r4,89

8000afa0 <MnsTMHandleEvent>:
8000afa0:	d4 21       	pushm	r4-r7,lr
8000afa2:	18 95       	mov	r5,r12
void MnsTMHandleEvent(byte event)
{
    T_LIB_ENTRY(MNS_96);
    T_TM_EV(event);

    TAKE_TM();
8000afa4:	30 9c       	mov	r12,9
8000afa6:	fe b0 e5 88 	rcall	80007ab6 <mns_take>
    switch(event)
8000afaa:	30 48       	mov	r8,4
8000afac:	f0 05 18 00 	cp.b	r5,r8
8000afb0:	c4 e0       	breq	8000b04c <MnsTMHandleEvent+0xac>
8000afb2:	e0 8b 00 17 	brhi	8000afe0 <MnsTMHandleEvent+0x40>
8000afb6:	30 28       	mov	r8,2
8000afb8:	f0 05 18 00 	cp.b	r5,r8
8000afbc:	c6 a0       	breq	8000b090 <MnsTMHandleEvent+0xf0>
8000afbe:	30 38       	mov	r8,3
8000afc0:	f0 05 18 00 	cp.b	r5,r8
8000afc4:	c1 30       	breq	8000afea <MnsTMHandleEvent+0x4a>
                }
            }
            break;

        default:
            FAILED_ASSERT();
8000afc6:	e0 68 0b ea 	mov	r8,3050
8000afca:	30 1a       	mov	r10,1
8000afcc:	1a d8       	st.w	--sp,r8
8000afce:	31 0b       	mov	r11,16
8000afd0:	30 4c       	mov	r12,4
8000afd2:	fe b0 e5 8d 	rcall	80007aec <mns_trace>
8000afd6:	2f fd       	sub	sp,-4
            break;
    }
    GIVE_TM();
8000afd8:	30 9c       	mov	r12,9
8000afda:	fe b0 e5 6f 	rcall	80007ab8 <mns_give>

    T_MOD_EXIT(MNS_96);
}
8000afde:	d8 22       	popm	r4-r7,pc
{
    T_LIB_ENTRY(MNS_96);
    T_TM_EV(event);

    TAKE_TM();
    switch(event)
8000afe0:	30 68       	mov	r8,6
8000afe2:	f0 05 18 00 	cp.b	r5,r8
8000afe6:	fe 9b ff f0 	brhi	8000afc6 <MnsTMHandleEvent+0x26>
8000afea:	4a d6       	lddpc	r6,8000b09c <MnsTMHandleEvent+0xfc>
            mns.tm.scheduled_timeout = 0;
        /*lint -e(616) control flow into case default */
        case MNS_TM_EV_TIMEOUT:
        case MNS_TM_EV_UPDATE:
        case MNS_TM_EV_SERVICE:
            MnsTMDiff();
8000afec:	ca 8f       	rcall	8000af3c <MnsTMDiff>
8000afee:	4a c4       	lddpc	r4,8000b09c <MnsTMHandleEvent+0xfc>
            if(mns.tm.diff)
8000aff0:	ed 09 00 40 	ld.sh	r9,r6[64]
8000aff4:	30 08       	mov	r8,0
8000aff6:	f0 09 19 00 	cp.h	r9,r8
8000affa:	c2 a0       	breq	8000b04e <MnsTMHandleEvent+0xae>
8000affc:	3f f8       	mov	r8,-1
    current_ptr = mns.timer.first_ptr;

    T_TM_OP(MNS_TM_OP_UPDATE);
    ASSERT(mns.tm.diff);

    mns.tm.min_timeout = 0xFFFF;
8000affe:	e9 58 00 42 	st.h	r4[66],r8
8000b002:	69 57       	ld.w	r7,r4[0x54]
{
    TMostTimer *current_ptr;

    T_MOD_ENTRY(MNS_97);

    current_ptr = mns.timer.first_ptr;
8000b004:	58 07       	cp.w	r7,0
    T_TM_OP(MNS_TM_OP_UPDATE);
    ASSERT(mns.tm.diff);

    mns.tm.min_timeout = 0xFFFF;

    while (current_ptr)
8000b006:	c1 51       	brne	8000b030 <MnsTMHandleEvent+0x90>
8000b008:	c3 c8       	rjmp	8000b080 <MnsTMHandleEvent+0xe0>
8000b00a:	8e 49       	ld.sh	r9,r7[0x8]
    {
        if (current_ptr->value)
        {
            if (mns.tm.diff >= current_ptr->value)
            {
                current_ptr->value = current_ptr->periodic;
8000b00c:	ae 39       	st.h	r7[0x6],r9
8000b00e:	6e 08       	ld.w	r8,r7[0x0]
                if (current_ptr->cb_ptr)
8000b010:	58 08       	cp.w	r8,0
8000b012:	c0 40       	breq	8000b01a <MnsTMHandleEvent+0x7a>
8000b014:	8e ac       	ld.uh	r12,r7[0x4]
                {
                    current_ptr->cb_ptr(current_ptr->event);
8000b016:	5d 18       	icall	r8
8000b018:	8e 39       	ld.sh	r9,r7[0x6]
8000b01a:	58 09       	cp.w	r9,0
            else
            {
                current_ptr->value -= mns.tm.diff;
            }

            if (current_ptr->value && (current_ptr->value< mns.tm.min_timeout))
8000b01c:	c0 70       	breq	8000b02a <MnsTMHandleEvent+0x8a>
8000b01e:	ed 08 00 42 	ld.sh	r8,r6[66]
8000b022:	f2 08 19 00 	cp.h	r8,r9
            {
                mns.tm.min_timeout = current_ptr->value;
8000b026:	e9 f9 bc 21 	st.hhi	r4[0x42],r9
8000b02a:	6e 47       	ld.w	r7,r7[0x10]
            }
        }
        current_ptr = current_ptr->next_ptr;
8000b02c:	58 07       	cp.w	r7,0
    T_TM_OP(MNS_TM_OP_UPDATE);
    ASSERT(mns.tm.diff);

    mns.tm.min_timeout = 0xFFFF;

    while (current_ptr)
8000b02e:	c2 90       	breq	8000b080 <MnsTMHandleEvent+0xe0>
8000b030:	8e 38       	ld.sh	r8,r7[0x6]
    {
        if (current_ptr->value)
8000b032:	58 08       	cp.w	r8,0
8000b034:	cf b0       	breq	8000b02a <MnsTMHandleEvent+0x8a>
8000b036:	ed 0a 00 40 	ld.sh	r10,r6[64]
        {
            if (mns.tm.diff >= current_ptr->value)
8000b03a:	f0 0a 01 09 	sub	r9,r8,r10
                    current_ptr->cb_ptr(current_ptr->event);
                }
            }
            else
            {
                current_ptr->value -= mns.tm.diff;
8000b03e:	f4 08 19 00 	cp.h	r8,r10

    while (current_ptr)
    {
        if (current_ptr->value)
        {
            if (mns.tm.diff >= current_ptr->value)
8000b042:	fe 98 ff e4 	brls	8000b00a <MnsTMHandleEvent+0x6a>
8000b046:	5c 89       	casts.h	r9
                    current_ptr->cb_ptr(current_ptr->event);
                }
            }
            else
            {
                current_ptr->value -= mns.tm.diff;
8000b048:	ae 39       	st.h	r7[0x6],r9
8000b04a:	ce 8b       	rjmp	8000b01a <MnsTMHandleEvent+0x7a>
8000b04c:	49 46       	lddpc	r6,8000b09c <MnsTMHandleEvent+0xfc>
8000b04e:	ed 08 00 42 	ld.sh	r8,r6[66]
                    break;
                }
            }
        /*lint -e(616) control flow into case default */
        case MNS_TM_EV_SCHEDULE:
            if(mns.tm.min_timeout)
8000b052:	49 39       	lddpc	r9,8000b09c <MnsTMHandleEvent+0xfc>
8000b054:	58 08       	cp.w	r8,0
8000b056:	cc 10       	breq	8000afd8 <MnsTMHandleEvent+0x38>
8000b058:	f3 0a 00 44 	ld.sh	r10,r9[68]
            {
                if(mns.tm.scheduled_timeout)
8000b05c:	58 0a       	cp.w	r10,0
8000b05e:	c0 40       	breq	8000b066 <MnsTMHandleEvent+0xc6>
8000b060:	f4 08 19 00 	cp.h	r8,r10
                {
                    if(mns.tm.min_timeout < mns.tm.scheduled_timeout)
8000b064:	cb a2       	brcc	8000afd8 <MnsTMHandleEvent+0x38>
8000b066:	f3 58 00 44 	st.h	r9[68],r8
static void MnsTMSchedule(void)
{
    T_MOD_ENTRY(MNS_100);
    T_TM_OP(MNS_TM_OP_SCHEDULE);

    mns.tm.scheduled_timeout = mns.tm.min_timeout;
8000b06a:	f2 f8 00 a0 	ld.w	r8,r9[160]

    if (mns.config.general.next_min_timeout_fptr)
8000b06e:	58 08       	cp.w	r8,0
8000b070:	cb 40       	breq	8000afd8 <MnsTMHandleEvent+0x38>
8000b072:	f3 1c 00 42 	ld.uh	r12,r9[66]
    {
        mns.config.general.next_min_timeout_fptr(mns.tm.min_timeout);
8000b076:	5d 18       	icall	r8
8000b078:	30 9c       	mov	r12,9

        default:
            FAILED_ASSERT();
            break;
    }
    GIVE_TM();
8000b07a:	fe b0 e5 1f 	rcall	80007ab8 <mns_give>
8000b07e:	d8 22       	popm	r4-r7,pc

    T_MOD_EXIT(MNS_96);
}
8000b080:	30 08       	mov	r8,0
                mns.tm.min_timeout = current_ptr->value;
            }
        }
        current_ptr = current_ptr->next_ptr;
    }
    mns.tm.diff = 0;
8000b082:	ed 58 00 40 	st.h	r6[64],r8
8000b086:	30 58       	mov	r8,5
            MnsTMDiff();
            if(mns.tm.diff)
            {
                MnsTMUpdate();

                if (MNS_TM_EV_UPDATE == event)
8000b088:	f0 05 18 00 	cp.b	r5,r8
8000b08c:	ce 11       	brne	8000b04e <MnsTMHandleEvent+0xae>
8000b08e:	ca 5b       	rjmp	8000afd8 <MnsTMHandleEvent+0x38>
8000b090:	48 36       	lddpc	r6,8000b09c <MnsTMHandleEvent+0xfc>

    TAKE_TM();
    switch(event)
    {
        case MNS_TM_EV_TIMEOUT_API:
            mns.tm.scheduled_timeout = 0;
8000b092:	30 08       	mov	r8,0
8000b094:	ed 58 00 44 	st.h	r6[68],r8
8000b098:	ca ab       	rjmp	8000afec <MnsTMHandleEvent+0x4c>
8000b09a:	d7 03       	nop
8000b09c:	00 00       	add	r0,r0
8000b09e:	35 94       	mov	r4,89

8000b0a0 <MostCheckTimers>:
8000b0a0:	d4 01       	pushm	lr
8000b0a2:	30 2c       	mov	r12,2
8000b0a4:	c7 ef       	rcall	8000afa0 <MnsTMHandleEvent>
8000b0a6:	d8 02       	popm	pc

8000b0a8 <MostSetTimer>:
8000b0a8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b0ac:	16 97       	mov	r7,r11
8000b0ae:	18 96       	mov	r6,r12
  * \param[in]  timer_ptr      Pointer to the timer instance
  * \param[in]  milliseconds   Timeout to be set in milliseconds
  * \param[in]  periodic       MNS_TRUE if the timer is periodic
  */
void MostSetTimer(TMostTimer *timer_ptr, word milliseconds, bool periodic)
{
8000b0b0:	14 95       	mov	r5,r10
    T_API_ENTRY(MNS_16);
    MnsTMHandleEvent(MNS_TM_EV_UPDATE);
8000b0b2:	30 5c       	mov	r12,5
8000b0b4:	c7 6f       	rcall	8000afa0 <MnsTMHandleEvent>
8000b0b6:	30 9c       	mov	r12,9
    TAKE_TM();
8000b0b8:	fe b0 e4 ff 	rcall	80007ab6 <mns_take>
8000b0bc:	ac 37       	st.h	r6[0x6],r7
    timer_ptr->value = milliseconds;
8000b0be:	58 05       	cp.w	r5,0
    timer_ptr->periodic = periodic ? milliseconds : 0;
8000b0c0:	c0 30       	breq	8000b0c6 <MostSetTimer+0x1e>
8000b0c2:	0e 95       	mov	r5,r7
8000b0c4:	5c 85       	casts.h	r5
8000b0c6:	ac 45       	st.h	r6[0x8],r5
8000b0c8:	58 07       	cp.w	r7,0

    if (milliseconds)
8000b0ca:	c0 90       	breq	8000b0dc <MostSetTimer+0x34>
8000b0cc:	48 a8       	lddpc	r8,8000b0f4 <MostSetTimer+0x4c>
    {
        if ((milliseconds<mns.tm.min_timeout)|| (mns.tm.min_timeout==0))
8000b0ce:	f1 09 00 42 	ld.sh	r9,r8[66]
8000b0d2:	f2 07 19 00 	cp.h	r7,r9
8000b0d6:	c0 a2       	brcc	8000b0ea <MostSetTimer+0x42>
8000b0d8:	f1 57 00 42 	st.h	r8[66],r7
        {
            mns.tm.min_timeout = milliseconds;
8000b0dc:	30 9c       	mov	r12,9
        }
    }

    GIVE_TM();
8000b0de:	fe b0 e4 ed 	rcall	80007ab8 <mns_give>
8000b0e2:	30 4c       	mov	r12,4
    MnsTMHandleEvent(MNS_TM_EV_SCHEDULE);
8000b0e4:	c5 ef       	rcall	8000afa0 <MnsTMHandleEvent>
8000b0e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    T_API_EXIT(MNS_16);
}
8000b0ea:	58 09       	cp.w	r9,0
8000b0ec:	cf 81       	brne	8000b0dc <MostSetTimer+0x34>
    timer_ptr->value = milliseconds;
    timer_ptr->periodic = periodic ? milliseconds : 0;

    if (milliseconds)
    {
        if ((milliseconds<mns.tm.min_timeout)|| (mns.tm.min_timeout==0))
8000b0ee:	f1 57 00 42 	st.h	r8[66],r7
        {
            mns.tm.min_timeout = milliseconds;
8000b0f2:	cf 5b       	rjmp	8000b0dc <MostSetTimer+0x34>
8000b0f4:	00 00       	add	r0,r0
8000b0f6:	35 94       	mov	r4,89

8000b0f8 <MnsMemCpy>:
8000b0f8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b0fc:	18 96       	mov	r6,r12
8000b0fe:	16 97       	mov	r7,r11
8000b100:	14 95       	mov	r5,r10
8000b102:	58 0b       	cp.w	r11,0
8000b104:	c1 00       	breq	8000b124 <MnsMemCpy+0x2c>
8000b106:	58 05       	cp.w	r5,0
_INLINE void MnsMemCpy(byte* tgt_ptr, const byte* src_ptr, word size)
{
    ASSERT(src_ptr);
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_56); */
    while (size--)
8000b108:	c0 c0       	breq	8000b120 <MnsMemCpy+0x28>
  * @param      tgt_ptr is a byte pointer to the target buffer
  * @param      src_ptr is a byte pointer to the source buffer
  * @param      size is the amount of bytes to copy
  */
#ifdef MNS_56
_INLINE void MnsMemCpy(byte* tgt_ptr, const byte* src_ptr, word size)
8000b10a:	20 15       	sub	r5,1
8000b10c:	30 08       	mov	r8,0
8000b10e:	5c 75       	castu.h	r5
8000b110:	2f f5       	sub	r5,-1
    ASSERT(src_ptr);
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_56); */
    while (size--)
    {
        *tgt_ptr++ = *src_ptr++;
8000b112:	ee 08 07 09 	ld.ub	r9,r7[r8]
8000b116:	ec 08 0b 09 	st.b	r6[r8],r9
8000b11a:	2f f8       	sub	r8,-1
_INLINE void MnsMemCpy(byte* tgt_ptr, const byte* src_ptr, word size)
{
    ASSERT(src_ptr);
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_56); */
    while (size--)
8000b11c:	0a 38       	cp.w	r8,r5
8000b11e:	cf a1       	brne	8000b112 <MnsMemCpy+0x1a>
8000b120:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  * @param      size is the amount of bytes to copy
  */
#ifdef MNS_56
_INLINE void MnsMemCpy(byte* tgt_ptr, const byte* src_ptr, word size)
{
    ASSERT(src_ptr);
8000b124:	e0 68 08 e7 	mov	r8,2279
8000b128:	30 1a       	mov	r10,1
8000b12a:	1a d8       	st.w	--sp,r8
8000b12c:	31 0b       	mov	r11,16
8000b12e:	30 4c       	mov	r12,4
8000b130:	fe b0 e4 de 	rcall	80007aec <mns_trace>
8000b134:	2f fd       	sub	sp,-4
8000b136:	ce 8b       	rjmp	8000b106 <MnsMemCpy+0xe>

8000b138 <MostGetVersionInfo>:
8000b138:	eb cd 40 c0 	pushm	r6-r7,lr
  *             NetServices in use.
  * \param[out] info_ptr  Pointer to a TMostVersionInfo structure containing the current
  *                       version information
  */
void MostGetVersionInfo(TMostVersionInfo *info_ptr)
{
8000b13c:	18 96       	mov	r6,r12
    T_API_ENTRY(MNS_57);
    TAKE_MNS();
8000b13e:	30 8c       	mov	r12,8
8000b140:	fe b0 e4 bb 	rcall	80007ab6 <mns_take>

    info_ptr->hw = mns.shadow.version.public.hw;
8000b144:	49 37       	lddpc	r7,8000b190 <MostGetVersionInfo+0x58>
8000b146:	ef 38 00 1c 	ld.ub	r8,r7[28]
8000b14a:	0c 9c       	mov	r12,r6
    MNS_MEM_CPY(info_ptr->fw, mns.shadow.version.public.fw,
8000b14c:	ee cb ff e3 	sub	r11,r7,-29
void MostGetVersionInfo(TMostVersionInfo *info_ptr)
{
    T_API_ENTRY(MNS_57);
    TAKE_MNS();

    info_ptr->hw = mns.shadow.version.public.hw;
8000b150:	18 c8       	st.b	r12++,r8
    MNS_MEM_CPY(info_ptr->fw, mns.shadow.version.public.fw,
8000b152:	30 3a       	mov	r10,3
8000b154:	cd 2f       	rcall	8000b0f8 <MnsMemCpy>
8000b156:	ee cb ff e0 	sub	r11,r7,-32
                (word)sizeof(mns.shadow.version.public.fw));
    MNS_MEM_CPY(info_ptr->fw_date, mns.shadow.version.public.fw_date,
8000b15a:	ec cc ff fc 	sub	r12,r6,-4
8000b15e:	30 3a       	mov	r10,3
8000b160:	cc cf       	rcall	8000b0f8 <MnsMemCpy>
8000b162:	ee cb ff d9 	sub	r11,r7,-39
                (word)sizeof(mns.shadow.version.public.fw_date));
    MNS_MEM_CPY(info_ptr->cs, mns.shadow.version.public.cs,
8000b166:	ec cc ff f5 	sub	r12,r6,-11
8000b16a:	30 3a       	mov	r10,3
8000b16c:	cc 6f       	rcall	8000b0f8 <MnsMemCpy>
8000b16e:	ee cb ff dd 	sub	r11,r7,-35
8000b172:	ec cc ff f9 	sub	r12,r6,-7
                (word)sizeof(mns.shadow.version.public.cs));
    MNS_MEM_CPY(info_ptr->ns, mns.shadow.version.public.ns,
8000b176:	30 4a       	mov	r10,4
8000b178:	cc 0f       	rcall	8000b0f8 <MnsMemCpy>
8000b17a:	ec cc ff f2 	sub	r12,r6,-14
8000b17e:	ee cb ff d6 	sub	r11,r7,-42
                (word)sizeof(mns.shadow.version.public.ns));
    MNS_MEM_CPY(info_ptr->api, mns.shadow.version.public.api,
8000b182:	30 3a       	mov	r10,3
8000b184:	cb af       	rcall	8000b0f8 <MnsMemCpy>
8000b186:	30 8c       	mov	r12,8
8000b188:	fe b0 e4 98 	rcall	80007ab8 <mns_give>
8000b18c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                (word)sizeof(mns.shadow.version.public.api));

    GIVE_MNS();
8000b190:	00 00       	add	r0,r0
8000b192:	35 94       	mov	r4,89

8000b194 <MostRegisterTimer>:
8000b194:	eb cd 40 e0 	pushm	r5-r7,lr
    T_API_EXIT(MNS_57);
}
8000b198:	18 97       	mov	r7,r12
8000b19a:	16 95       	mov	r5,r11
8000b19c:	14 96       	mov	r6,r10
8000b19e:	58 0c       	cp.w	r12,0
8000b1a0:	c2 80       	breq	8000b1f0 <MostRegisterTimer+0x5c>
8000b1a2:	30 9c       	mov	r12,9
8000b1a4:	fe b0 e4 89 	rcall	80007ab6 <mns_take>
8000b1a8:	49 78       	lddpc	r8,8000b204 <MostRegisterTimer+0x70>
8000b1aa:	71 59       	ld.w	r9,r8[0x54]

    result = MNS_FALSE;

    current_ptr = mns.timer.first_ptr;

    while (current_ptr && !result)
8000b1ac:	58 09       	cp.w	r9,0
8000b1ae:	c1 d0       	breq	8000b1e8 <MostRegisterTimer+0x54>
8000b1b0:	12 98       	mov	r8,r9
8000b1b2:	c0 38       	rjmp	8000b1b8 <MostRegisterTimer+0x24>
8000b1b4:	58 0a       	cp.w	r10,0
8000b1b6:	c1 41       	brne	8000b1de <MostRegisterTimer+0x4a>
  * @param      cb_ptr function pointer of the callback to call if timeout is
  *                    reached.
  * @param      event parameter to be passed to the given callback
  */
#ifdef MNS_45
void MostRegisterTimer(TMostTimer *timer_ptr, TMostEventCB *cb_ptr, word event)
8000b1b8:	10 37       	cp.w	r7,r8
8000b1ba:	5f 0a       	sreq	r10
    {
        if (current_ptr == timer_ptr)
        {
            result = MNS_TRUE;
        }
        current_ptr = current_ptr->next_ptr;
8000b1bc:	70 48       	ld.w	r8,r8[0x10]

    result = MNS_FALSE;

    current_ptr = mns.timer.first_ptr;

    while (current_ptr && !result)
8000b1be:	58 08       	cp.w	r8,0
8000b1c0:	cf a1       	brne	8000b1b4 <MostRegisterTimer+0x20>
    T_API_ENTRY(MNS_45);

    ASSERT(timer_ptr);

    TAKE_TM();
    if (MNS_FALSE == MnsTimerRegistered(timer_ptr))
8000b1c2:	58 0a       	cp.w	r10,0
8000b1c4:	c0 d1       	brne	8000b1de <MostRegisterTimer+0x4a>
    {
        if (mns.timer.first_ptr)
        {
            TMostTimer *last_ptr = mns.timer.first_ptr;

            while (last_ptr->next_ptr)
8000b1c6:	12 98       	mov	r8,r9
8000b1c8:	72 49       	ld.w	r9,r9[0x10]
8000b1ca:	58 09       	cp.w	r9,0
8000b1cc:	cf d1       	brne	8000b1c6 <MostRegisterTimer+0x32>
            {
                last_ptr = last_ptr->next_ptr;
            }

            last_ptr->next_ptr = timer_ptr;
8000b1ce:	91 47       	st.w	r8[0x10],r7
            timer_ptr->prev_ptr = last_ptr;
8000b1d0:	8f 38       	st.w	r7[0xc],r8
        {
            mns.timer.first_ptr = timer_ptr;
            timer_ptr->prev_ptr = NULL;
        }

        timer_ptr->next_ptr = NULL;
8000b1d2:	30 08       	mov	r8,0
        timer_ptr->cb_ptr = cb_ptr;
8000b1d4:	8f 05       	st.w	r7[0x0],r5
        timer_ptr->event = event;
8000b1d6:	ae 26       	st.h	r7[0x4],r6
        timer_ptr->value = 0;
        timer_ptr->periodic = 0;
8000b1d8:	ae 48       	st.h	r7[0x8],r8
        {
            mns.timer.first_ptr = timer_ptr;
            timer_ptr->prev_ptr = NULL;
        }

        timer_ptr->next_ptr = NULL;
8000b1da:	8f 48       	st.w	r7[0x10],r8
        timer_ptr->cb_ptr = cb_ptr;
        timer_ptr->event = event;
        timer_ptr->value = 0;
8000b1dc:	ae 38       	st.h	r7[0x6],r8
        timer_ptr->periodic = 0;
    }
    GIVE_TM();
8000b1de:	30 9c       	mov	r12,9
8000b1e0:	fe b0 e4 6c 	rcall	80007ab8 <mns_give>

    T_API_EXIT(MNS_45);
}
8000b1e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            last_ptr->next_ptr = timer_ptr;
            timer_ptr->prev_ptr = last_ptr;
        }
        else
        {
            mns.timer.first_ptr = timer_ptr;
8000b1e8:	f1 47 00 54 	st.w	r8[84],r7
            timer_ptr->prev_ptr = NULL;
8000b1ec:	8f 39       	st.w	r7[0xc],r9
8000b1ee:	cf 2b       	rjmp	8000b1d2 <MostRegisterTimer+0x3e>
#ifdef MNS_45
void MostRegisterTimer(TMostTimer *timer_ptr, TMostEventCB *cb_ptr, word event)
{
    T_API_ENTRY(MNS_45);

    ASSERT(timer_ptr);
8000b1f0:	e0 68 07 63 	mov	r8,1891
8000b1f4:	30 1a       	mov	r10,1
8000b1f6:	1a d8       	st.w	--sp,r8
8000b1f8:	31 0b       	mov	r11,16
8000b1fa:	30 4c       	mov	r12,4
8000b1fc:	fe b0 e4 78 	rcall	80007aec <mns_trace>
8000b200:	2f fd       	sub	sp,-4
8000b202:	cd 0b       	rjmp	8000b1a2 <MostRegisterTimer+0xe>
8000b204:	00 00       	add	r0,r0
8000b206:	35 94       	mov	r4,89

8000b208 <MostGetTimer>:
8000b208:	eb cd 40 80 	pushm	r7,lr
8000b20c:	18 97       	mov	r7,r12
8000b20e:	58 0c       	cp.w	r12,0
8000b210:	c0 b0       	breq	8000b226 <MostGetTimer+0x1e>
8000b212:	30 9c       	mov	r12,9

    T_API_ENTRY(MNS_17);

    ASSERT(timer_ptr);

    TAKE_TM();
8000b214:	fe b0 e4 51 	rcall	80007ab6 <mns_take>
    temp = timer_ptr->value;
    GIVE_TM();
8000b218:	30 9c       	mov	r12,9
    T_API_ENTRY(MNS_17);

    ASSERT(timer_ptr);

    TAKE_TM();
    temp = timer_ptr->value;
8000b21a:	8e 37       	ld.sh	r7,r7[0x6]
    GIVE_TM();
8000b21c:	fe b0 e4 4e 	rcall	80007ab8 <mns_give>
    T_API_EXIT(MNS_17);

    return(temp);
}
8000b220:	0e 9c       	mov	r12,r7
8000b222:	e3 cd 80 80 	ldm	sp++,r7,pc
{
    word temp;

    T_API_ENTRY(MNS_17);

    ASSERT(timer_ptr);
8000b226:	e0 68 05 06 	mov	r8,1286
8000b22a:	30 1a       	mov	r10,1
8000b22c:	1a d8       	st.w	--sp,r8
8000b22e:	31 0b       	mov	r11,16
8000b230:	30 4c       	mov	r12,4
8000b232:	fe b0 e4 5d 	rcall	80007aec <mns_trace>
8000b236:	2f fd       	sub	sp,-4
8000b238:	ce db       	rjmp	8000b212 <MostGetTimer+0xa>
8000b23a:	d7 03       	nop

8000b23c <MnsGetNextEventFlagToCall>:
8000b23c:	d4 21       	pushm	r4-r7,lr
8000b23e:	20 2d       	sub	sp,8
8000b240:	18 97       	mov	r7,r12
8000b242:	16 96       	mov	r6,r11
8000b244:	14 95       	mov	r5,r10
8000b246:	58 0b       	cp.w	r11,0

    T_LIB_ENTRY(MNS_4);

    candidate = MNS_P_NONE;

    ASSERT(pending_ptr);
8000b248:	c5 10       	breq	8000b2ea <MnsGetNextEventFlagToCall+0xae>
    ASSERT(latest_called_ptr);
8000b24a:	58 05       	cp.w	r5,0
8000b24c:	c4 10       	breq	8000b2ce <MnsGetNextEventFlagToCall+0x92>

    if(MX_INVALID != pending_mutex_id)
8000b24e:	3f fa       	mov	r10,-1
8000b250:	f4 07 19 00 	cp.h	r7,r10
8000b254:	c0 90       	breq	8000b266 <MnsGetNextEventFlagToCall+0x2a>
    {
        WAIT4MX(pending_mutex_id);
8000b256:	50 19       	stdsp	sp[0x4],r9
8000b258:	50 08       	stdsp	sp[0x0],r8
8000b25a:	0e 9c       	mov	r12,r7
8000b25c:	5c 7c       	castu.h	r12
8000b25e:	fe b0 e4 2c 	rcall	80007ab6 <mns_take>
8000b262:	40 08       	lddsp	r8,sp[0x0]
8000b264:	40 19       	lddsp	r9,sp[0x4]
    }
    if (MNS_P_NONE != *pending_ptr)
8000b266:	8c 0b       	ld.sh	r11,r6[0x0]
8000b268:	58 0b       	cp.w	r11,0
8000b26a:	c2 30       	breq	8000b2b0 <MnsGetNextEventFlagToCall+0x74>
    {
        bool match = MNS_FALSE;
        bool cycle = MNS_FALSE;

        candidate = (MNS_P_NONE != *latest_called_ptr) ?
8000b26c:	8a 04       	ld.sh	r4,r5[0x0]
8000b26e:	58 04       	cp.w	r4,0
8000b270:	c2 c0       	breq	8000b2c8 <MnsGetNextEventFlagToCall+0x8c>
8000b272:	30 0e       	mov	lr,0

        while(MNS_FALSE == match)
        {
            if (last == candidate)
            {
                if(MNS_FALSE == cycle)
8000b274:	5c 89       	casts.h	r9
        bool cycle = MNS_FALSE;

        candidate = (MNS_P_NONE != *latest_called_ptr) ?
                     *latest_called_ptr : last;

        while(MNS_FALSE == match)
8000b276:	1c 9c       	mov	r12,lr
8000b278:	c0 88       	rjmp	8000b288 <MnsGetNextEventFlagToCall+0x4c>
                    break;
                }
            }
            else
            {
                candidate <<= 1;
8000b27a:	a1 74       	lsl	r4,0x1
8000b27c:	5c 84       	casts.h	r4
        bool cycle = MNS_FALSE;

        candidate = (MNS_P_NONE != *latest_called_ptr) ?
                     *latest_called_ptr : last;

        while(MNS_FALSE == match)
8000b27e:	e9 eb 00 0a 	and	r10,r4,r11
8000b282:	f8 0a 19 00 	cp.h	r10,r12
8000b286:	c0 d1       	brne	8000b2a0 <MnsGetNextEventFlagToCall+0x64>
        {
            if (last == candidate)
8000b288:	e8 08 19 00 	cp.h	r8,r4
8000b28c:	cf 71       	brne	8000b27a <MnsGetNextEventFlagToCall+0x3e>
            {
                if(MNS_FALSE == cycle)
8000b28e:	58 0e       	cp.w	lr,0
8000b290:	c1 01       	brne	8000b2b0 <MnsGetNextEventFlagToCall+0x74>
8000b292:	12 94       	mov	r4,r9
8000b294:	30 1e       	mov	lr,1
        bool cycle = MNS_FALSE;

        candidate = (MNS_P_NONE != *latest_called_ptr) ?
                     *latest_called_ptr : last;

        while(MNS_FALSE == match)
8000b296:	e9 eb 00 0a 	and	r10,r4,r11
8000b29a:	f8 0a 19 00 	cp.h	r10,r12
8000b29e:	cf 50       	breq	8000b288 <MnsGetNextEventFlagToCall+0x4c>
8000b2a0:	08 98       	mov	r8,r4
8000b2a2:	5c 88       	casts.h	r8
        }
    }

    if (MNS_P_NONE != candidate)
    {
        *latest_called_ptr = candidate;
8000b2a4:	aa 08       	st.h	r5[0x0],r8
        *pending_ptr &= (word) ~candidate;
8000b2a6:	5c d8       	com	r8
8000b2a8:	8c 09       	ld.sh	r9,r6[0x0]
8000b2aa:	12 68       	and	r8,r9
8000b2ac:	ac 08       	st.h	r6[0x0],r8
8000b2ae:	c0 28       	rjmp	8000b2b2 <MnsGetNextEventFlagToCall+0x76>
8000b2b0:	30 04       	mov	r4,0
    }
    if(MX_INVALID != pending_mutex_id)
8000b2b2:	3f f8       	mov	r8,-1
8000b2b4:	f0 07 19 00 	cp.h	r7,r8
8000b2b8:	c0 50       	breq	8000b2c2 <MnsGetNextEventFlagToCall+0x86>
    {
        REL_MX(pending_mutex_id);
8000b2ba:	0e 9c       	mov	r12,r7
8000b2bc:	5c 7c       	castu.h	r12
8000b2be:	fe b0 e3 fd 	rcall	80007ab8 <mns_give>
    }

    T_LIB_EXIT(MNS_4);
    return(candidate);
}
8000b2c2:	08 9c       	mov	r12,r4
8000b2c4:	2f ed       	sub	sp,-8
8000b2c6:	d8 22       	popm	r4-r7,pc
    if (MNS_P_NONE != *pending_ptr)
    {
        bool match = MNS_FALSE;
        bool cycle = MNS_FALSE;

        candidate = (MNS_P_NONE != *latest_called_ptr) ?
8000b2c8:	e9 d8 b0 10 	bfexts	r4,r8,0x0,0x10
8000b2cc:	cd 3b       	rjmp	8000b272 <MnsGetNextEventFlagToCall+0x36>
    T_LIB_ENTRY(MNS_4);

    candidate = MNS_P_NONE;

    ASSERT(pending_ptr);
    ASSERT(latest_called_ptr);
8000b2ce:	e0 6a 02 44 	mov	r10,580
8000b2d2:	31 0b       	mov	r11,16
8000b2d4:	1a da       	st.w	--sp,r10
8000b2d6:	30 4c       	mov	r12,4
8000b2d8:	50 29       	stdsp	sp[0x8],r9
8000b2da:	50 18       	stdsp	sp[0x4],r8
8000b2dc:	30 1a       	mov	r10,1
8000b2de:	fe b0 e4 07 	rcall	80007aec <mns_trace>
8000b2e2:	2f fd       	sub	sp,-4
8000b2e4:	40 08       	lddsp	r8,sp[0x0]
8000b2e6:	40 19       	lddsp	r9,sp[0x4]
8000b2e8:	cb 3b       	rjmp	8000b24e <MnsGetNextEventFlagToCall+0x12>

    T_LIB_ENTRY(MNS_4);

    candidate = MNS_P_NONE;

    ASSERT(pending_ptr);
8000b2ea:	e0 6a 02 43 	mov	r10,579
8000b2ee:	31 0b       	mov	r11,16
8000b2f0:	1a da       	st.w	--sp,r10
8000b2f2:	30 4c       	mov	r12,4
8000b2f4:	50 29       	stdsp	sp[0x8],r9
8000b2f6:	50 18       	stdsp	sp[0x4],r8
8000b2f8:	30 1a       	mov	r10,1
8000b2fa:	fe b0 e3 f9 	rcall	80007aec <mns_trace>
8000b2fe:	2f fd       	sub	sp,-4
8000b300:	40 08       	lddsp	r8,sp[0x0]
8000b302:	40 19       	lddsp	r9,sp[0x4]
8000b304:	ca 3b       	rjmp	8000b24a <MnsGetNextEventFlagToCall+0xe>
8000b306:	d7 03       	nop

8000b308 <MnsSetPendingService>:
8000b308:	d4 21       	pushm	r4-r7,lr
8000b30a:	18 94       	mov	r4,r12
8000b30c:	30 8c       	mov	r12,8
8000b30e:	fe b0 e3 d4 	rcall	80007ab6 <mns_take>
8000b312:	49 a6       	lddpc	r6,8000b378 <MnsSetPendingService+0x70>
    T_LIB_ENTRY(MNS_2);

    request_flag = MNS_FALSE;

    TAKE_MNS();
    if((MNS_FALSE != mns.stopped) && (MNS_FALSE != mns.signaled_ns_stopped))
8000b314:	30 08       	mov	r8,0
8000b316:	ed 39 01 44 	ld.ub	r9,r6[324]
8000b31a:	f0 09 18 00 	cp.b	r9,r8
8000b31e:	c0 a0       	breq	8000b332 <MnsSetPendingService+0x2a>
8000b320:	ed 39 01 45 	ld.ub	r9,r6[325]
8000b324:	f0 09 18 00 	cp.b	r9,r8
8000b328:	c0 50       	breq	8000b332 <MnsSetPendingService+0x2a>
    {
        request_flag = MNS_TRUE;
    }
    GIVE_MNS();
8000b32a:	30 8c       	mov	r12,8
8000b32c:	fe b0 e3 c6 	rcall	80007ab8 <mns_give>
8000b330:	d8 22       	popm	r4-r7,pc
8000b332:	30 8c       	mov	r12,8
8000b334:	fe b0 e3 c2 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE == request_flag)
    {
        T_MOST_REQUEST(service_flag);

        TAKE_SERVICES();
8000b338:	30 6c       	mov	r12,6
8000b33a:	fe b0 e3 be 	rcall	80007ab6 <mns_take>
        request_flag = (MNS_P_NONE == mns.services.pending) ? MNS_TRUE : MNS_FALSE;
        mns.services.pending |= service_flag;
        GIVE_SERVICES();
8000b33e:	30 6c       	mov	r12,6
    if (MNS_FALSE == request_flag)
    {
        T_MOST_REQUEST(service_flag);

        TAKE_SERVICES();
        request_flag = (MNS_P_NONE == mns.services.pending) ? MNS_TRUE : MNS_FALSE;
8000b340:	8c 65       	ld.sh	r5,r6[0xc]
8000b342:	48 e7       	lddpc	r7,8000b378 <MnsSetPendingService+0x70>
        mns.services.pending |= service_flag;
8000b344:	0a 44       	or	r4,r5
8000b346:	ac 64       	st.h	r6[0xc],r4
        GIVE_SERVICES();
8000b348:	fe b0 e3 b8 	rcall	80007ab8 <mns_give>

        if (MNS_FALSE != request_flag)
8000b34c:	58 05       	cp.w	r5,0
8000b34e:	cf 11       	brne	8000b330 <MnsSetPendingService+0x28>
        {
            ASSERT(mns.config.general.most_service_request_fptr);
8000b350:	ee f8 00 84 	ld.w	r8,r7[132]
8000b354:	58 08       	cp.w	r8,0
8000b356:	c0 30       	breq	8000b35c <MnsSetPendingService+0x54>
            if (mns.config.general.most_service_request_fptr)
            {
                mns.config.general.most_service_request_fptr();
8000b358:	5d 18       	icall	r8
8000b35a:	d8 22       	popm	r4-r7,pc
        mns.services.pending |= service_flag;
        GIVE_SERVICES();

        if (MNS_FALSE != request_flag)
        {
            ASSERT(mns.config.general.most_service_request_fptr);
8000b35c:	e0 68 02 0c 	mov	r8,524
8000b360:	30 1a       	mov	r10,1
8000b362:	1a d8       	st.w	--sp,r8
8000b364:	31 0b       	mov	r11,16
8000b366:	30 4c       	mov	r12,4
8000b368:	fe b0 e3 c2 	rcall	80007aec <mns_trace>
            if (mns.config.general.most_service_request_fptr)
8000b36c:	ee f8 00 84 	ld.w	r8,r7[132]
8000b370:	2f fd       	sub	sp,-4
8000b372:	58 08       	cp.w	r8,0
8000b374:	cd e0       	breq	8000b330 <MnsSetPendingService+0x28>
8000b376:	cf 1b       	rjmp	8000b358 <MnsSetPendingService+0x50>
8000b378:	00 00       	add	r0,r0
8000b37a:	35 94       	mov	r4,89

8000b37c <MnsSetPendingEventFlag>:
8000b37c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b380:	20 1d       	sub	sp,4
8000b382:	18 95       	mov	r5,r12
8000b384:	16 96       	mov	r6,r11
8000b386:	14 97       	mov	r7,r10

    T_LIB_ENTRY(MNS_3);

    request_flag = MNS_FALSE;

    ASSERT(pending_ptr);
8000b388:	58 0a       	cp.w	r10,0
8000b38a:	c1 f0       	breq	8000b3c8 <MnsSetPendingEventFlag+0x4c>

    if(MX_INVALID != pending_mutex_id)
8000b38c:	3f f8       	mov	r8,-1
8000b38e:	f0 06 19 00 	cp.h	r6,r8
8000b392:	c1 60       	breq	8000b3be <MnsSetPendingEventFlag+0x42>
    {
        WAIT4MX(pending_mutex_id);
8000b394:	5c 76       	castu.h	r6
8000b396:	50 09       	stdsp	sp[0x0],r9
8000b398:	0c 9c       	mov	r12,r6
8000b39a:	fe b0 e3 8e 	rcall	80007ab6 <mns_take>
    }
    request_flag = (MNS_P_NONE == *pending_ptr) ? MNS_TRUE : MNS_FALSE;
    *pending_ptr |= event;
    if(MX_INVALID != pending_mutex_id)
    {
        REL_MX(pending_mutex_id);
8000b39e:	0c 9c       	mov	r12,r6

    if(MX_INVALID != pending_mutex_id)
    {
        WAIT4MX(pending_mutex_id);
    }
    request_flag = (MNS_P_NONE == *pending_ptr) ? MNS_TRUE : MNS_FALSE;
8000b3a0:	8e 06       	ld.sh	r6,r7[0x0]
    *pending_ptr |= event;
8000b3a2:	ed e5 10 05 	or	r5,r6,r5
8000b3a6:	ae 05       	st.h	r7[0x0],r5
    if(MX_INVALID != pending_mutex_id)
    {
        REL_MX(pending_mutex_id);
8000b3a8:	fe b0 e3 88 	rcall	80007ab8 <mns_give>
8000b3ac:	40 09       	lddsp	r9,sp[0x0]
    }

    if (MNS_FALSE != request_flag)
8000b3ae:	58 06       	cp.w	r6,0
8000b3b0:	c0 41       	brne	8000b3b8 <MnsSetPendingEventFlag+0x3c>
    {
        MnsSetPendingService(service_to_call);
8000b3b2:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
8000b3b6:	ca 9f       	rcall	8000b308 <MnsSetPendingService>
8000b3b8:	2f fd       	sub	sp,-4
    }

    T_LIB_EXIT(MNS_3);
}
8000b3ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b3be:	8e 06       	ld.sh	r6,r7[0x0]

    if(MX_INVALID != pending_mutex_id)
    {
        WAIT4MX(pending_mutex_id);
    }
    request_flag = (MNS_P_NONE == *pending_ptr) ? MNS_TRUE : MNS_FALSE;
8000b3c0:	ed e5 10 05 	or	r5,r6,r5
    *pending_ptr |= event;
8000b3c4:	ae 05       	st.h	r7[0x0],r5
8000b3c6:	cf 4b       	rjmp	8000b3ae <MnsSetPendingEventFlag+0x32>
8000b3c8:	e0 68 02 22 	mov	r8,546

    T_LIB_ENTRY(MNS_3);

    request_flag = MNS_FALSE;

    ASSERT(pending_ptr);
8000b3cc:	30 1a       	mov	r10,1
8000b3ce:	1a d8       	st.w	--sp,r8
8000b3d0:	31 0b       	mov	r11,16
8000b3d2:	50 19       	stdsp	sp[0x4],r9
8000b3d4:	30 4c       	mov	r12,4
8000b3d6:	fe b0 e3 8b 	rcall	80007aec <mns_trace>
8000b3da:	2f fd       	sub	sp,-4
8000b3dc:	40 09       	lddsp	r9,sp[0x0]
8000b3de:	cd 7b       	rjmp	8000b38c <MnsSetPendingEventFlag+0x10>

8000b3e0 <MnsSetPendingEvent>:
8000b3e0:	d4 01       	pushm	lr
8000b3e2:	30 49       	mov	r9,4
8000b3e4:	5c 7c       	castu.h	r12
8000b3e6:	48 3a       	lddpc	r10,8000b3f0 <MnsSetPendingEvent+0x10>
8000b3e8:	30 7b       	mov	r11,7
8000b3ea:	cc 9f       	rcall	8000b37c <MnsSetPendingEventFlag>
8000b3ec:	d8 02       	popm	pc
8000b3ee:	d7 03       	nop
8000b3f0:	00 00       	add	r0,r0
8000b3f2:	35 94       	mov	r4,89

8000b3f4 <MnsRequestLayer2>:

    MnsSetPendingEventFlag(event_flag, MX_MNS_PE,
                           &mns.events.pending, MNS_P_SRV_MNS);

    T_MOD_EXIT(MNS_7);
}
8000b3f4:	d4 01       	pushm	lr
8000b3f6:	30 7c       	mov	r12,7
#ifdef MNS_29
void MnsRequestLayer2(word flags)
{
    (void) flags;
    T_MOD_ENTRY(MNS_29);
    TAKE_EVENTS();
8000b3f8:	fe b0 e3 5f 	rcall	80007ab6 <mns_take>
    mns.events.pending_l2 |= MNS2_E_REQ_EXTERN;
8000b3fc:	48 69       	lddpc	r9,8000b414 <MnsRequestLayer2+0x20>
8000b3fe:	92 28       	ld.sh	r8,r9[0x4]
8000b400:	af a8       	sbr	r8,0xe
    GIVE_EVENTS();
8000b402:	30 7c       	mov	r12,7
void MnsRequestLayer2(word flags)
{
    (void) flags;
    T_MOD_ENTRY(MNS_29);
    TAKE_EVENTS();
    mns.events.pending_l2 |= MNS2_E_REQ_EXTERN;
8000b404:	b2 28       	st.h	r9[0x4],r8
    GIVE_EVENTS();
8000b406:	fe b0 e3 59 	rcall	80007ab8 <mns_give>
    T_L2_REQUEST(MNS2_E_REQ_EXTERN);
    MnsSetPendingEvent(MNS_P_L2);
8000b40a:	e0 6c 00 80 	mov	r12,128
8000b40e:	ce 9f       	rcall	8000b3e0 <MnsSetPendingEvent>
8000b410:	d8 02       	popm	pc
    T_MOD_EXIT(MNS_29);
}
8000b412:	d7 03       	nop
8000b414:	00 00       	add	r0,r0
8000b416:	35 94       	mov	r4,89

8000b418 <MnsReportError>:
8000b418:	eb cd 40 e0 	pushm	r5-r7,lr
8000b41c:	fe 78 83 00 	mov	r8,-32000
8000b420:	18 97       	mov	r7,r12
8000b422:	f0 0c 19 00 	cp.h	r12,r8
    static bool inic_reset_case = MNS_FALSE;

    T_LIB_ENTRY(MNS_20);

    #ifndef PACKET_COMMUNICATION_ONLY
    if (NSR_E_REATTACH == code)
8000b426:	c4 20       	breq	8000b4aa <MnsReportError+0x92>
8000b428:	4a 86       	lddpc	r6,8000b4c8 <MnsReportError+0xb0>
    {
        MostSetTimer(&(mns.timer.init), MNS_INIT_TIMER, MNS_FALSE);
    }
    #endif

    if ((MNS_FALSE != mns.stopped) && (NSR_E_NO_COMM == code))
8000b42a:	ed 39 01 44 	ld.ub	r9,r6[324]
8000b42e:	30 08       	mov	r8,0
8000b430:	f0 09 18 00 	cp.b	r9,r8
8000b434:	c0 60       	breq	8000b440 <MnsReportError+0x28>
8000b436:	fe 78 84 00 	mov	r8,-31744
8000b43a:	f0 07 19 00 	cp.h	r7,r8
8000b43e:	c2 a0       	breq	8000b492 <MnsReportError+0x7a>
        TAKE_MNS();
        mns.shadow.ehci_state = EHCISTATE_UNKNOWN;
        GIVE_MNS();
    }

    if (NSR_EI_RESET == code)
8000b440:	fe 78 c3 01 	mov	r8,-15615
8000b444:	f0 07 19 00 	cp.h	r7,r8
8000b448:	c3 a0       	breq	8000b4bc <MnsReportError+0xa4>
8000b44a:	4a 15       	lddpc	r5,8000b4cc <MnsReportError+0xb4>

        MnsSetPendingEvent(MNS_P_INIT_TIMER);

    }

    if ((MNS_FALSE != inic_reset_case) && ((NSR_E_INIT_TIMEOUT == code) || (NSR_E_REATTACH == code)))
8000b44c:	0b 89       	ld.ub	r9,r5[0x0]
8000b44e:	30 08       	mov	r8,0
8000b450:	f0 09 18 00 	cp.b	r9,r8
8000b454:	c1 00       	breq	8000b474 <MnsReportError+0x5c>
8000b456:	fe 79 83 00 	mov	r9,-32000
8000b45a:	fe 7a c3 04 	mov	r10,-15612
8000b45e:	f2 07 19 00 	cp.h	r7,r9
8000b462:	5f 09       	sreq	r9
8000b464:	f4 07 19 00 	cp.h	r7,r10
8000b468:	5f 0a       	sreq	r10
8000b46a:	f3 ea 10 0a 	or	r10,r9,r10
8000b46e:	f0 0a 18 00 	cp.b	r10,r8
8000b472:	c0 a1       	brne	8000b486 <MnsReportError+0x6e>
        if (NSR_E_REATTACH == code)
        {
            inic_reset_case = MNS_FALSE;
        }
    }
    else if (mns.config.general.on_error_fptr)
8000b474:	ec f8 00 94 	ld.w	r8,r6[148]
8000b478:	58 08       	cp.w	r8,0
8000b47a:	c0 40       	breq	8000b482 <MnsReportError+0x6a>
    {
        mns.config.general.on_error_fptr(code);
8000b47c:	0e 9c       	mov	r12,r7
8000b47e:	5c 7c       	castu.h	r12
8000b480:	5d 18       	icall	r8
8000b482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    }

    if ((MNS_FALSE != inic_reset_case) && ((NSR_E_INIT_TIMEOUT == code) || (NSR_E_REATTACH == code)))
    {
        if (NSR_E_REATTACH == code)
8000b486:	58 09       	cp.w	r9,0
8000b488:	cf d0       	breq	8000b482 <MnsReportError+0x6a>
        {
            inic_reset_case = MNS_FALSE;
8000b48a:	49 19       	lddpc	r9,8000b4cc <MnsReportError+0xb4>
8000b48c:	b2 88       	st.b	r9[0x0],r8
8000b48e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    #endif

    if ((MNS_FALSE != mns.stopped) && (NSR_E_NO_COMM == code))
    {

        TAKE_MNS();
8000b492:	30 8c       	mov	r12,8
8000b494:	fe b0 e3 11 	rcall	80007ab6 <mns_take>
        mns.shadow.ehci_state = EHCISTATE_UNKNOWN;
8000b498:	3f f9       	mov	r9,-1
8000b49a:	48 c8       	lddpc	r8,8000b4c8 <MnsReportError+0xb0>
        GIVE_MNS();
8000b49c:	30 8c       	mov	r12,8

    if ((MNS_FALSE != mns.stopped) && (NSR_E_NO_COMM == code))
    {

        TAKE_MNS();
        mns.shadow.ehci_state = EHCISTATE_UNKNOWN;
8000b49e:	f1 69 00 18 	st.b	r8[24],r9
8000b4a2:	48 b5       	lddpc	r5,8000b4cc <MnsReportError+0xb4>
        GIVE_MNS();
8000b4a4:	fe b0 e3 0a 	rcall	80007ab8 <mns_give>
8000b4a8:	cd 2b       	rjmp	8000b44c <MnsReportError+0x34>
    T_LIB_ENTRY(MNS_20);

    #ifndef PACKET_COMMUNICATION_ONLY
    if (NSR_E_REATTACH == code)
    {
        MostSetTimer(&(mns.timer.init), MNS_INIT_TIMER, MNS_FALSE);
8000b4aa:	48 86       	lddpc	r6,8000b4c8 <MnsReportError+0xb0>
8000b4ac:	30 0a       	mov	r10,0
8000b4ae:	e0 6b 0b b8 	mov	r11,3000
8000b4b2:	ec cc ff a8 	sub	r12,r6,-88
8000b4b6:	fe b0 fd f9 	rcall	8000b0a8 <MostSetTimer>
8000b4ba:	cb 8b       	rjmp	8000b42a <MnsReportError+0x12>
        GIVE_MNS();
    }

    if (NSR_EI_RESET == code)
    {
        inic_reset_case = MNS_TRUE;
8000b4bc:	30 18       	mov	r8,1
8000b4be:	48 45       	lddpc	r5,8000b4cc <MnsReportError+0xb4>

        MnsSetPendingEvent(MNS_P_INIT_TIMER);
8000b4c0:	34 0c       	mov	r12,64
        GIVE_MNS();
    }

    if (NSR_EI_RESET == code)
    {
        inic_reset_case = MNS_TRUE;
8000b4c2:	aa 88       	st.b	r5[0x0],r8

        MnsSetPendingEvent(MNS_P_INIT_TIMER);
8000b4c4:	c8 ef       	rcall	8000b3e0 <MnsSetPendingEvent>
8000b4c6:	cc 3b       	rjmp	8000b44c <MnsReportError+0x34>
8000b4c8:	00 00       	add	r0,r0
8000b4ca:	35 94       	mov	r4,89
8000b4cc:	00 00       	add	r0,r0
8000b4ce:	35 90       	mov	r0,89

8000b4d0 <MnsHandleError>:
8000b4d0:	eb cd 40 80 	pushm	r7,lr
8000b4d4:	18 97       	mov	r7,r12
8000b4d6:	58 0c       	cp.w	r12,0
8000b4d8:	c3 70       	breq	8000b546 <MnsHandleError+0x76>
8000b4da:	8e 48       	ld.sh	r8,r7[0x8]
8000b4dc:	e0 69 03 08 	mov	r9,776
8000b4e0:	f2 08 19 00 	cp.h	r8,r9
{
    T_LIB_ENTRY(MNS_68);

    ASSERT(msg_ptr);

    switch (msg_ptr->Func_ID)
8000b4e4:	c2 c0       	breq	8000b53c <MnsHandleError+0x6c>
8000b4e6:	e0 69 03 0a 	mov	r9,778
8000b4ea:	f2 08 19 00 	cp.h	r8,r9
8000b4ee:	c2 20       	breq	8000b532 <MnsHandleError+0x62>
8000b4f0:	e0 69 02 06 	mov	r9,518
8000b4f4:	f2 08 19 00 	cp.h	r8,r9
8000b4f8:	c0 c0       	breq	8000b510 <MnsHandleError+0x40>
        case FUNCID_INIC_WATCHDOGMODE:
            MnsReportError(NSR_E_INVALID_WATCHDOG_MODE_CONFIG);
            break;

        default:
            FAILED_ASSERT();
8000b4fa:	e0 68 0a 61 	mov	r8,2657
8000b4fe:	30 1a       	mov	r10,1
8000b500:	1a d8       	st.w	--sp,r8
8000b502:	31 0b       	mov	r11,16
8000b504:	30 4c       	mov	r12,4
8000b506:	fe b0 e2 f3 	rcall	80007aec <mns_trace>
8000b50a:	2f fd       	sub	sp,-4
8000b50c:	e3 cd 80 80 	ldm	sp++,r7,pc
            break;

        case FUNCID_INIC_BIST:
            {
                TMnsResult result;
                result = NSR_BUILD(MNS_FALSE, 0xC2, msg_ptr->Data[0]);
8000b510:	6e 08       	ld.w	r8,r7[0x0]
8000b512:	11 8c       	ld.ub	r12,r8[0x0]
                if (NSR_E_BIST_MEMORY <= result)
8000b514:	fe 78 c2 80 	mov	r8,-15744
            break;

        case FUNCID_INIC_BIST:
            {
                TMnsResult result;
                result = NSR_BUILD(MNS_FALSE, 0xC2, msg_ptr->Data[0]);
8000b518:	ea 1c ff ff 	orh	r12,0xffff
8000b51c:	e8 1c c2 00 	orl	r12,0xc200
                if (NSR_E_BIST_MEMORY <= result)
8000b520:	f0 0c 19 00 	cp.h	r12,r8
8000b524:	fe 98 ff f4 	brls	8000b50c <MnsHandleError+0x3c>
                {
                    MnsReportError(result);
8000b528:	e2 1c c2 ff 	andl	r12,0xc2ff,COH
8000b52c:	c7 6f       	rcall	8000b418 <MnsReportError>
8000b52e:	e3 cd 80 80 	ldm	sp++,r7,pc
8000b532:	e0 6c c1 02 	mov	r12,49410
                }
            }
            break;

        case FUNCID_INIC_WATCHDOGMODE:
            MnsReportError(NSR_E_INVALID_WATCHDOG_MODE_CONFIG);
8000b536:	c7 1f       	rcall	8000b418 <MnsReportError>
8000b538:	e3 cd 80 80 	ldm	sp++,r7,pc
            break;
8000b53c:	e0 6c c1 01 	mov	r12,49409
    ASSERT(msg_ptr);

    switch (msg_ptr->Func_ID)
    {
        case FUNCID_INIC_REMOTEACCESS:
            MnsReportError(NSR_E_INVALID_REMOTE_ACCESS_CONFIG);
8000b540:	c6 cf       	rcall	8000b418 <MnsReportError>
8000b542:	e3 cd 80 80 	ldm	sp++,r7,pc
8000b546:	e0 68 0a 49 	mov	r8,2633
            break;
8000b54a:	30 1a       	mov	r10,1
  */
void MnsHandleError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(MNS_68);

    ASSERT(msg_ptr);
8000b54c:	1a d8       	st.w	--sp,r8
8000b54e:	31 0b       	mov	r11,16
8000b550:	30 4c       	mov	r12,4
8000b552:	fe b0 e2 cd 	rcall	80007aec <mns_trace>
8000b556:	2f fd       	sub	sp,-4
8000b558:	cc 1b       	rjmp	8000b4da <MnsHandleError+0xa>
8000b55a:	d7 03       	nop

8000b55c <MnsStopLayer2>:
8000b55c:	eb cd 40 80 	pushm	r7,lr
8000b560:	48 c7       	lddpc	r7,8000b590 <MnsStopLayer2+0x34>
8000b562:	30 08       	mov	r8,0
8000b564:	ef 39 00 15 	ld.ub	r9,r7[21]
{
    T_LIB_ENTRY(MNS_75);

    T_STOP_L2();

    if (MNS_FALSE != mns.services.ms_layer2)
8000b568:	f0 09 18 00 	cp.b	r9,r8
8000b56c:	c1 00       	breq	8000b58c <MnsStopLayer2+0x30>
    {
        mns.services.ms_layer2 = MNS_FALSE;
8000b56e:	ef 68 00 15 	st.b	r7[21],r8

        WAIT4MX(MX_MNS_PE);
8000b572:	30 7c       	mov	r12,7
8000b574:	fe b0 e2 a1 	rcall	80007ab6 <mns_take>
        mns.events.pending &= ~MNS_P_L2;
        REL_MX(MX_MNS_PE);
8000b578:	30 7c       	mov	r12,7
    if (MNS_FALSE != mns.services.ms_layer2)
    {
        mns.services.ms_layer2 = MNS_FALSE;

        WAIT4MX(MX_MNS_PE);
        mns.events.pending &= ~MNS_P_L2;
8000b57a:	8e 08       	ld.sh	r8,r7[0x0]
8000b57c:	a7 d8       	cbr	r8,0x7
8000b57e:	ae 08       	st.h	r7[0x0],r8
        REL_MX(MX_MNS_PE);
8000b580:	fe b0 e2 9c 	rcall	80007ab8 <mns_give>

        #ifdef NS_MSV_ET
            ET_Go_Net_Off();
8000b584:	e0 a0 48 e2 	rcall	80014748 <ET_Go_Net_Off>
        #endif

        #ifdef NS_MSV_NB
            NbGoNetOff();
8000b588:	e0 a0 4c b4 	rcall	80014ef0 <NbGoNetOff>
8000b58c:	e3 cd 80 80 	ldm	sp++,r7,pc
8000b590:	00 00       	add	r0,r0
8000b592:	35 94       	mov	r4,89

8000b594 <MnsStartLayer2>:
8000b594:	d4 01       	pushm	lr
8000b596:	48 78       	lddpc	r8,8000b5b0 <MnsStartLayer2+0x1c>
8000b598:	30 09       	mov	r9,0
8000b59a:	f1 3a 00 15 	ld.ub	r10,r8[21]
8000b59e:	f2 0a 18 00 	cp.b	r10,r9
8000b5a2:	c0 61       	brne	8000b5ae <MnsStartLayer2+0x1a>

    T_START_L2();

    if (MNS_FALSE == mns.services.ms_layer2)
    {
        mns.services.ms_layer2 = MNS_TRUE;
8000b5a4:	30 19       	mov	r9,1
8000b5a6:	f1 69 00 15 	st.b	r8[21],r9

        #ifdef NS_MNS_MNS2
            InitNetServicesLayer2();
8000b5aa:	e0 a0 4b 99 	rcall	80014cdc <InitNetServicesLayer2>
8000b5ae:	d8 02       	popm	pc
8000b5b0:	00 00       	add	r0,r0
8000b5b2:	35 94       	mov	r4,89

8000b5b4 <MnsPMReady>:
8000b5b4:	d4 01       	pushm	lr
8000b5b6:	48 88       	lddpc	r8,8000b5d4 <MnsPMReady+0x20>
    bool result;

    T_LIB_ENTRY(MNS_69);
    result = MNS_FALSE;
#ifdef SCM_MIN
    if((PMS_IFACE_I2C == mns.config.lld.ctrl_interface_id) ||
8000b5b8:	f1 38 00 cc 	ld.ub	r8,r8[204]
8000b5bc:	58 08       	cp.w	r8,0
8000b5be:	c0 21       	brne	8000b5c2 <MnsPMReady+0xe>
8000b5c0:	da 0a       	popm	pc,r12=1
8000b5c2:	30 19       	mov	r9,1
8000b5c4:	f2 08 18 00 	cp.b	r8,r9
8000b5c8:	c0 20       	breq	8000b5cc <MnsPMReady+0x18>
8000b5ca:	d8 0a       	popm	pc,r12=0
8000b5cc:	e0 a0 36 12 	rcall	800121f0 <ScmPMComplete>
    result = MNS_TRUE;
#endif
    T_LIB_EXIT(MNS_69);

    return(result);
}
8000b5d0:	d8 02       	popm	pc
8000b5d2:	d7 03       	nop
8000b5d4:	00 00       	add	r0,r0
8000b5d6:	35 94       	mov	r4,89

8000b5d8 <MnsCheckHigherLayers>:
8000b5d8:	eb cd 40 e0 	pushm	r5-r7,lr
    bool bdvalid;
    #endif

    T_LIB_ENTRY(MNS_73);

    attached = EHCISTATE_IS_ATTACHED() ? MNS_TRUE : MNS_FALSE;
8000b5dc:	fe b0 fc 8a 	rcall	8000aef0 <MnsGetEHCIState>
8000b5e0:	18 95       	mov	r5,r12
    net_on   = (MNS_NET_ON == MostGetState()) ? MNS_TRUE : MNS_FALSE;
8000b5e2:	e0 a0 23 ed 	rcall	8000fdbc <MostGetState>
8000b5e6:	18 96       	mov	r6,r12
    pm_ready = MnsPMReady();
8000b5e8:	ce 6f       	rcall	8000b5b4 <MnsPMReady>
8000b5ea:	e0 a0 38 1b 	rcall	80012620 <ScmGetBoundary>
    #ifdef SCM_MIN
    boundary = ScmGetBoundary();
8000b5ee:	3e e8       	mov	r8,-18
    bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000b5f0:	18 97       	mov	r7,r12

    attached = EHCISTATE_IS_ATTACHED() ? MNS_TRUE : MNS_FALSE;
    net_on   = (MNS_NET_ON == MostGetState()) ? MNS_TRUE : MNS_FALSE;
    pm_ready = MnsPMReady();
    #ifdef SCM_MIN
    boundary = ScmGetBoundary();
8000b5f2:	f0 0c 18 00 	cp.b	r12,r8
    bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000b5f6:	c1 40       	breq	8000b61e <MnsCheckHigherLayers+0x46>
8000b5f8:	30 8c       	mov	r12,8
8000b5fa:	fe b0 fc 5d 	rcall	8000aeb4 <MostIsSupported>
8000b5fe:	c0 d1       	brne	8000b618 <MnsCheckHigherLayers+0x40>
8000b600:	30 19       	mov	r9,1
8000b602:	30 48       	mov	r8,4
    #else
    bdvalid  = MNS_TRUE;
    #endif

    /* check conditions for Layer2 */
    if ( (MNS_FALSE != net_on)   &&
8000b604:	f0 06 18 00 	cp.b	r6,r8
8000b608:	c0 51       	brne	8000b612 <MnsCheckHigherLayers+0x3a>
8000b60a:	30 28       	mov	r8,2
8000b60c:	f0 05 18 00 	cp.b	r5,r8
8000b610:	c0 90       	breq	8000b622 <MnsCheckHigherLayers+0x4a>
8000b612:	ca 5f       	rcall	8000b55c <MnsStopLayer2>
        #endif
    }
    else
    {
        #ifdef MNS_75
        MnsStopLayer2();
8000b614:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b618:	58 07       	cp.w	r7,0
8000b61a:	5f 19       	srne	r9
    attached = EHCISTATE_IS_ATTACHED() ? MNS_TRUE : MNS_FALSE;
    net_on   = (MNS_NET_ON == MostGetState()) ? MNS_TRUE : MNS_FALSE;
    pm_ready = MnsPMReady();
    #ifdef SCM_MIN
    boundary = ScmGetBoundary();
    bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000b61c:	cf 3b       	rjmp	8000b602 <MnsCheckHigherLayers+0x2a>
8000b61e:	30 09       	mov	r9,0
8000b620:	cf 1b       	rjmp	8000b602 <MnsCheckHigherLayers+0x2a>
8000b622:	58 09       	cp.w	r9,0
8000b624:	cf 70       	breq	8000b612 <MnsCheckHigherLayers+0x3a>
    #else
    bdvalid  = MNS_TRUE;
    #endif

    /* check conditions for Layer2 */
    if ( (MNS_FALSE != net_on)   &&
8000b626:	cb 7f       	rcall	8000b594 <MnsStartLayer2>
8000b628:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b62c <MnsEnforceRemoteAccess>:
         (MNS_FALSE != attached) &&
         (MNS_FALSE != bdvalid ) )
    {
        #ifdef MNS_74
        MnsStartLayer2();
8000b62c:	eb cd 40 c0 	pushm	r6-r7,lr
    #else
    bdvalid  = MNS_TRUE;
    #endif

    /* check conditions for Layer2 */
    if ( (MNS_FALSE != net_on)   &&
8000b630:	30 8c       	mov	r12,8
8000b632:	fe b0 e2 42 	rcall	80007ab6 <mns_take>
8000b636:	30 8c       	mov	r12,8
8000b638:	49 57       	lddpc	r7,8000b68c <MnsEnforceRemoteAccess+0x60>
8000b63a:	ef 36 01 48 	ld.ub	r6,r7[328]
8000b63e:	fe b0 e2 3d 	rcall	80007ab8 <mns_give>
8000b642:	30 1c       	mov	r12,1
8000b644:	fe b0 ec 2c 	rcall	80008e9c <MsgGetTxPtrExt>
8000b648:	c1 40       	breq	8000b670 <MnsEnforceRemoteAccess+0x44>
8000b64a:	30 0a       	mov	r10,0
8000b64c:	78 08       	ld.w	r8,r12[0x0]
8000b64e:	f9 6a 00 0c 	st.b	r12[12],r10
    msg_ptr = MsgGetTxPtrExt(1);
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_REMOTEACCESS;
        msg_ptr->Inst_ID   = 0;
8000b652:	f9 6a 00 0b 	st.b	r12[11],r10


    msg_ptr = MsgGetTxPtrExt(1);
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000b656:	30 19       	mov	r9,1
        msg_ptr->Func_ID   = FUNCID_INIC_REMOTEACCESS;
8000b658:	e0 6a 03 08 	mov	r10,776


    msg_ptr = MsgGetTxPtrExt(1);
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000b65c:	b8 39       	st.h	r12[0x6],r9
        msg_ptr->Func_ID   = FUNCID_INIC_REMOTEACCESS;
8000b65e:	b8 4a       	st.h	r12[0x8],r10
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Data[0]   = (MNS_ALLOW == access) ? MNS_TRUE : MNS_FALSE;
8000b660:	f2 06 18 00 	cp.b	r6,r9
8000b664:	5f 09       	sreq	r9
8000b666:	b0 89       	st.b	r8[0x0],r9
        MsgSend3(msg_ptr);
8000b668:	fe b0 ef 5e 	rcall	80009524 <MsgSend3>
8000b66c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(MNS_RETRY_REMOTE_ACCESS);
8000b670:	30 8c       	mov	r12,8
8000b672:	fe b0 e2 22 	rcall	80007ab6 <mns_take>
8000b676:	ef 08 00 80 	ld.sh	r8,r7[128]
8000b67a:	a7 a8       	sbr	r8,0x6
8000b67c:	30 8c       	mov	r12,8
8000b67e:	ef 58 00 80 	st.h	r7[128],r8
8000b682:	fe b0 e2 1b 	rcall	80007ab8 <mns_give>
8000b686:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(MNS_66);
    return(result);
}
8000b688:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000b68c:	00 00       	add	r0,r0
8000b68e:	35 94       	mov	r4,89

8000b690 <MnsForceProtected>:
8000b690:	d4 01       	pushm	lr
8000b692:	30 1c       	mov	r12,1
8000b694:	fe b0 ec 04 	rcall	80008e9c <MsgGetTxPtrExt>
8000b698:	c1 00       	breq	8000b6b8 <MnsForceProtected+0x28>
8000b69a:	30 1a       	mov	r10,1
8000b69c:	30 09       	mov	r9,0
8000b69e:	b8 3a       	st.h	r12[0x6],r10

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
        msg_ptr->Inst_ID   = 0;
8000b6a0:	f9 69 00 0b 	st.b	r12[11],r9
        msg_ptr->Operation = OP_SET;
8000b6a4:	f9 69 00 0c 	st.b	r12[12],r9
        msg_ptr->Data[0]   = EHCISTATE_PROTECTED;
8000b6a8:	78 08       	ld.w	r8,r12[0x0]
    msg_ptr = MsgGetTxPtrExt(1);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
8000b6aa:	e0 6a 03 00 	mov	r10,768
8000b6ae:	b8 4a       	st.h	r12[0x8],r10
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Data[0]   = EHCISTATE_PROTECTED;
8000b6b0:	b0 89       	st.b	r8[0x0],r9

        MsgSend3(msg_ptr);
8000b6b2:	fe b0 ef 39 	rcall	80009524 <MsgSend3>
8000b6b6:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(MNS_RETRY_FORCE_PROTECTED);
8000b6b8:	30 8c       	mov	r12,8
8000b6ba:	fe b0 e1 fe 	rcall	80007ab6 <mns_take>
8000b6be:	48 69       	lddpc	r9,8000b6d4 <MnsForceProtected+0x44>
8000b6c0:	f3 08 00 80 	ld.sh	r8,r9[128]
8000b6c4:	a5 b8       	sbr	r8,0x5
8000b6c6:	30 8c       	mov	r12,8
8000b6c8:	f3 58 00 80 	st.h	r9[128],r8
8000b6cc:	fe b0 e1 f6 	rcall	80007ab8 <mns_give>
8000b6d0:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(MNS_61);
    return(result);
}
8000b6d2:	d8 02       	popm	pc
8000b6d4:	00 00       	add	r0,r0
8000b6d6:	35 94       	mov	r4,89

8000b6d8 <StopNetServices>:
8000b6d8:	d4 01       	pushm	lr
8000b6da:	30 8c       	mov	r12,8
8000b6dc:	fe b0 e1 ed 	rcall	80007ab6 <mns_take>
8000b6e0:	30 19       	mov	r9,1
8000b6e2:	48 58       	lddpc	r8,8000b6f4 <StopNetServices+0x1c>
8000b6e4:	30 8c       	mov	r12,8
8000b6e6:	f1 69 01 44 	st.b	r8[324],r9
{
    T_API_ENTRY(MNS_64);

    TAKE_MNS();
    mns.stopped = MNS_TRUE;
    GIVE_MNS();
8000b6ea:	fe b0 e1 e7 	rcall	80007ab8 <mns_give>

    #ifndef MNS_AVOID_ATTACH
    (void)MnsForceProtected();
8000b6ee:	cd 1f       	rcall	8000b690 <MnsForceProtected>
8000b6f0:	d8 02       	popm	pc
        mns.config.general.most_service_request_fptr();
    }
    #endif

    T_API_EXIT(MNS_64);
}
8000b6f2:	d7 03       	nop
8000b6f4:	00 00       	add	r0,r0
8000b6f6:	35 94       	mov	r4,89

8000b6f8 <MnsRequestEHCIState>:
8000b6f8:	d4 01       	pushm	lr
8000b6fa:	30 0c       	mov	r12,0
8000b6fc:	fe b0 eb d0 	rcall	80008e9c <MsgGetTxPtrExt>
8000b700:	c0 e0       	breq	8000b71c <MnsRequestEHCIState+0x24>
8000b702:	30 19       	mov	r9,1
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Operation = OP_GET;
8000b704:	f9 69 00 0c 	st.b	r12[12],r9
    result  = ERR_NO;
    msg_ptr = MsgGetTxPtrExt(0);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000b708:	b8 39       	st.h	r12[0x6],r9
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
8000b70a:	e0 69 03 00 	mov	r9,768
8000b70e:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Inst_ID   = 0;
8000b710:	30 09       	mov	r9,0
8000b712:	f9 69 00 0b 	st.b	r12[11],r9
        msg_ptr->Operation = OP_GET;

        MsgSend3(msg_ptr);
8000b716:	fe b0 ef 07 	rcall	80009524 <MsgSend3>
8000b71a:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(MNS_RETRY_REQ_EHCISTATE);
8000b71c:	30 8c       	mov	r12,8
8000b71e:	fe b0 e1 cc 	rcall	80007ab6 <mns_take>
8000b722:	48 69       	lddpc	r9,8000b738 <MnsRequestEHCIState+0x40>
8000b724:	f3 08 00 80 	ld.sh	r8,r9[128]
8000b728:	a5 a8       	sbr	r8,0x4
8000b72a:	30 8c       	mov	r12,8
8000b72c:	f3 58 00 80 	st.h	r9[128],r8
8000b730:	fe b0 e1 c4 	rcall	80007ab8 <mns_give>
8000b734:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(MNS_60);
    return(result);
}
8000b736:	d8 02       	popm	pc
8000b738:	00 00       	add	r0,r0
8000b73a:	35 94       	mov	r4,89

8000b73c <MnsCheckWatchdogMode>:
8000b73c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b740:	30 7c       	mov	r12,7
8000b742:	fe b0 eb ad 	rcall	80008e9c <MsgGetTxPtrExt>
8000b746:	18 97       	mov	r7,r12
8000b748:	c4 60       	breq	8000b7d4 <MnsCheckWatchdogMode+0x98>
8000b74a:	e0 68 03 0a 	mov	r8,778
    msg_ptr = MsgGetTxPtrExt((word)7);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000b74e:	30 06       	mov	r6,0
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNCID_INIC_WATCHDOGMODE;
8000b750:	b8 48       	st.h	r12[0x8],r8
    msg_ptr = MsgGetTxPtrExt((word)7);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000b752:	f9 66 00 0a 	st.b	r12[10],r6
        msg_ptr->Inst_ID   = 0;
8000b756:	f9 66 00 0b 	st.b	r12[11],r6
    result  = ERR_NO;
    msg_ptr = MsgGetTxPtrExt((word)7);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000b75a:	30 15       	mov	r5,1
8000b75c:	b8 35       	st.h	r12[0x6],r5
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNCID_INIC_WATCHDOGMODE;

        TAKE_MNS();
8000b75e:	30 8c       	mov	r12,8
8000b760:	fe b0 e1 ab 	rcall	80007ab6 <mns_take>
        if (mns.config.general.watchdogmode.overwrite)
8000b764:	4a 58       	lddpc	r8,8000b7f8 <MnsCheckWatchdogMode+0xbc>
8000b766:	f1 39 00 a4 	ld.ub	r9,r8[164]
8000b76a:	ec 09 18 00 	cp.b	r9,r6
8000b76e:	c2 70       	breq	8000b7bc <MnsCheckWatchdogMode+0x80>
        {
            msg_ptr->Operation = OP_SETGET;
8000b770:	30 29       	mov	r9,2
8000b772:	ef 69 00 0c 	st.b	r7[12],r9
            msg_ptr->Data[0]   = (byte)mns.config.general.watchdogmode.reset;
8000b776:	6e 09       	ld.w	r9,r7[0x0]
8000b778:	f1 3a 00 a5 	ld.ub	r10,r8[165]
8000b77c:	b2 8a       	st.b	r9[0x0],r10
            msg_ptr->Data[1]   = HB(mns.config.general.watchdogmode.timeout);
8000b77e:	6e 09       	ld.w	r9,r7[0x0]
8000b780:	f1 3a 00 a6 	ld.ub	r10,r8[166]
8000b784:	b2 9a       	st.b	r9[0x1],r10
            msg_ptr->Data[2]   = LB(mns.config.general.watchdogmode.timeout);
8000b786:	6e 09       	ld.w	r9,r7[0x0]
8000b788:	f1 0a 00 a6 	ld.sh	r10,r8[166]
8000b78c:	b2 aa       	st.b	r9[0x2],r10
            msg_ptr->Data[3]   = HB(mns.config.general.watchdogmode.auto_shutdown_delay);
8000b78e:	6e 09       	ld.w	r9,r7[0x0]
8000b790:	f1 3a 00 a8 	ld.ub	r10,r8[168]
8000b794:	b2 ba       	st.b	r9[0x3],r10
            msg_ptr->Data[4]   = LB(mns.config.general.watchdogmode.auto_shutdown_delay);
8000b796:	6e 09       	ld.w	r9,r7[0x0]
8000b798:	f1 0a 00 a8 	ld.sh	r10,r8[168]
8000b79c:	b2 ca       	st.b	r9[0x4],r10
            #ifdef _OS81110_WD_TH
            if (MNS_TM_WD_THRESHOLD_DISABLE != mns.config.general.watchdogmode.threshold)
8000b79e:	3f fa       	mov	r10,-1
8000b7a0:	f1 09 00 aa 	ld.sh	r9,r8[170]
8000b7a4:	f4 09 19 00 	cp.h	r9,r10
8000b7a8:	c2 50       	breq	8000b7f2 <MnsCheckWatchdogMode+0xb6>
            {
                msg_ptr->Data[5]   = HB(mns.config.general.watchdogmode.threshold);
8000b7aa:	f3 d9 c1 08 	bfextu	r9,r9,0x8,0x8
8000b7ae:	6e 0a       	ld.w	r10,r7[0x0]
8000b7b0:	b4 d9       	st.b	r10[0x5],r9
                msg_ptr->Data[6]   = LB(mns.config.general.watchdogmode.threshold);
8000b7b2:	f1 09 00 aa 	ld.sh	r9,r8[170]
8000b7b6:	6e 08       	ld.w	r8,r7[0x0]
8000b7b8:	b0 e9       	st.b	r8[0x6],r9
8000b7ba:	c0 58       	rjmp	8000b7c4 <MnsCheckWatchdogMode+0x88>
            #endif
        }
        else
        {
            msg_ptr->Operation = OP_GET;
            msg_ptr->Length = (word)0;
8000b7bc:	30 08       	mov	r8,0
            msg_ptr->Length = (word)5;
            #endif
        }
        else
        {
            msg_ptr->Operation = OP_GET;
8000b7be:	ef 65 00 0c 	st.b	r7[12],r5
            msg_ptr->Length = (word)0;
8000b7c2:	ae 28       	st.h	r7[0x4],r8
        }
        GIVE_MNS();
8000b7c4:	30 8c       	mov	r12,8
8000b7c6:	fe b0 e1 79 	rcall	80007ab8 <mns_give>

        MsgSend3(msg_ptr);
8000b7ca:	0e 9c       	mov	r12,r7
8000b7cc:	fe b0 ee ac 	rcall	80009524 <MsgSend3>
8000b7d0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(MNS_RETRY_CHECK_WATCHDOGMODE);
8000b7d4:	30 8c       	mov	r12,8
8000b7d6:	fe b0 e1 70 	rcall	80007ab6 <mns_take>
8000b7da:	48 89       	lddpc	r9,8000b7f8 <MnsCheckWatchdogMode+0xbc>
8000b7dc:	30 8c       	mov	r12,8
8000b7de:	f3 08 00 80 	ld.sh	r8,r9[128]
8000b7e2:	18 48       	or	r8,r12
8000b7e4:	f3 58 00 80 	st.h	r9[128],r8
8000b7e8:	fe b0 e1 68 	rcall	80007ab8 <mns_give>
8000b7ec:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }
    T_MOD_EXIT(MNS_52);

    return(result);
}
8000b7ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                msg_ptr->Data[5]   = HB(mns.config.general.watchdogmode.threshold);
                msg_ptr->Data[6]   = LB(mns.config.general.watchdogmode.threshold);
            }
            else
            {
                msg_ptr->Length = (word)5;
8000b7f2:	30 58       	mov	r8,5
8000b7f4:	ae 28       	st.h	r7[0x4],r8
8000b7f6:	ce 7b       	rjmp	8000b7c4 <MnsCheckWatchdogMode+0x88>
8000b7f8:	00 00       	add	r0,r0
8000b7fa:	35 94       	mov	r4,89

8000b7fc <MnsResetComplete>:
8000b7fc:	eb cd 40 e0 	pushm	r5-r7,lr
8000b800:	30 8c       	mov	r12,8
8000b802:	fe b0 e1 5a 	rcall	80007ab6 <mns_take>
8000b806:	30 08       	mov	r8,0
8000b808:	4a c7       	lddpc	r7,8000b8b8 <MnsResetComplete+0xbc>
8000b80a:	ef 39 01 44 	ld.ub	r9,r7[324]
    msg_ptr = NULL;
    result  = ERR_NO;
    mns_stopped = MNS_FALSE;

    TAKE_MNS();
    if((MNS_FALSE != mns.stopped) && (MNS_FALSE == mns.signaled_ns_stopped))
8000b80e:	f0 09 18 00 	cp.b	r9,r8
8000b812:	c1 a0       	breq	8000b846 <MnsResetComplete+0x4a>
8000b814:	ef 39 01 45 	ld.ub	r9,r7[325]
8000b818:	f0 09 18 00 	cp.b	r9,r8
8000b81c:	c1 51       	brne	8000b846 <MnsResetComplete+0x4a>
    {
        mns_stopped = MNS_TRUE;
        mns.shadow.ehci_state = EHCISTATE_UNKNOWN;  /* signale on_stop_netservices_cb() in MostService() */
8000b81e:	3f f8       	mov	r8,-1
    }
    GIVE_MNS();
8000b820:	30 8c       	mov	r12,8

    TAKE_MNS();
    if((MNS_FALSE != mns.stopped) && (MNS_FALSE == mns.signaled_ns_stopped))
    {
        mns_stopped = MNS_TRUE;
        mns.shadow.ehci_state = EHCISTATE_UNKNOWN;  /* signale on_stop_netservices_cb() in MostService() */
8000b822:	ef 68 00 18 	st.b	r7[24],r8
    }
    GIVE_MNS();
8000b826:	fe b0 e1 49 	rcall	80007ab8 <mns_give>
            MostSetTimer(&(mns.timer.watchdog), timeout, MNS_TRUE);
        }
    }
    else
    {
        SCHEDULE_RETRY(MNS_RETRY_RESET_COMPLETE);
8000b82a:	30 8c       	mov	r12,8
8000b82c:	fe b0 e1 45 	rcall	80007ab6 <mns_take>
8000b830:	ef 08 00 80 	ld.sh	r8,r7[128]
8000b834:	a1 b8       	sbr	r8,0x1
8000b836:	30 8c       	mov	r12,8
8000b838:	ef 58 00 80 	st.h	r7[128],r8
8000b83c:	fe b0 e1 3e 	rcall	80007ab8 <mns_give>
8000b840:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(MNS_70);
    return(result);
}
8000b842:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    if((MNS_FALSE != mns.stopped) && (MNS_FALSE == mns.signaled_ns_stopped))
    {
        mns_stopped = MNS_TRUE;
        mns.shadow.ehci_state = EHCISTATE_UNKNOWN;  /* signale on_stop_netservices_cb() in MostService() */
    }
    GIVE_MNS();
8000b846:	30 8c       	mov	r12,8
8000b848:	fe b0 e1 38 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE == mns_stopped)     /* do not start to reattach if StopNetServices() was called  */
    {
        msg_ptr = MsgGetTxPtrExt(2);
8000b84c:	30 2c       	mov	r12,2
8000b84e:	fe b0 eb 27 	rcall	80008e9c <MsgGetTxPtrExt>
    }

    if (NULL != msg_ptr)
8000b852:	ce c0       	breq	8000b82a <MnsResetComplete+0x2e>
        bool wd_active;
        word timeout;

        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
        msg_ptr->Inst_ID   = 0;
8000b854:	30 09       	mov	r9,0
    if (NULL != msg_ptr)
    {
        bool wd_active;
        word timeout;

        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000b856:	30 1a       	mov	r10,1
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Operation = OP_SET;
8000b858:	f9 69 00 0c 	st.b	r12[12],r9
    if (NULL != msg_ptr)
    {
        bool wd_active;
        word timeout;

        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000b85c:	b8 3a       	st.h	r12[0x6],r10
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
        msg_ptr->Inst_ID   = 0;
8000b85e:	f9 69 00 0b 	st.b	r12[11],r9
    {
        bool wd_active;
        word timeout;

        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
8000b862:	e0 6b 03 00 	mov	r11,768
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Length    = 2;
8000b866:	30 29       	mov	r9,2
    {
        bool wd_active;
        word timeout;

        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
8000b868:	b8 4b       	st.h	r12[0x8],r11
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Length    = 2;
8000b86a:	b8 29       	st.h	r12[0x4],r9
        msg_ptr->Data[0]   = EHCISTATE_SEMI_PROTECTED;
8000b86c:	78 0b       	ld.w	r11,r12[0x0]
8000b86e:	b6 8a       	st.b	r11[0x0],r10
        msg_ptr->Data[1]   = EHCISTATE_NTF_ALL;
8000b870:	78 08       	ld.w	r8,r12[0x0]
8000b872:	b0 99       	st.b	r8[0x1],r9

        MsgSend3(msg_ptr);
8000b874:	fe b0 ee 58 	rcall	80009524 <MsgSend3>
        (void)MnsCheckWatchdogMode();
8000b878:	c6 2f       	rcall	8000b73c <MnsCheckWatchdogMode>
8000b87a:	30 9c       	mov	r12,9

        #ifndef MNS_DISABLE_WD_SUPERVISION
        TAKE_TM();
8000b87c:	fe b0 e1 1d 	rcall	80007ab6 <mns_take>
8000b880:	3f f6       	mov	r6,-1
        mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable watchdog supervision */
8000b882:	30 9c       	mov	r12,9
        GIVE_TM();
8000b884:	ef 56 00 3a 	st.h	r7[58],r6
        MsgSend3(msg_ptr);
        (void)MnsCheckWatchdogMode();

        #ifndef MNS_DISABLE_WD_SUPERVISION
        TAKE_TM();
        mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable watchdog supervision */
8000b888:	fe b0 e1 18 	rcall	80007ab8 <mns_give>
        GIVE_TM();
8000b88c:	30 8c       	mov	r12,8
        #endif

        TAKE_MNS();
8000b88e:	fe b0 e1 14 	rcall	80007ab6 <mns_take>
8000b892:	30 8c       	mov	r12,8
        wd_active = (MNS_TM_WD_DISABLE != mns.config.general.watchdogmode.timeout)
            ? MNS_TRUE : MNS_FALSE;
        timeout = mns.watchdogmode.timeout_wdsm;
        GIVE_MNS();
8000b894:	ef 05 00 38 	ld.sh	r5,r7[56]
        #endif

        TAKE_MNS();
        wd_active = (MNS_TM_WD_DISABLE != mns.config.general.watchdogmode.timeout)
            ? MNS_TRUE : MNS_FALSE;
        timeout = mns.watchdogmode.timeout_wdsm;
8000b898:	ef 07 00 a6 	ld.sh	r7,r7[166]
        mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable watchdog supervision */
        GIVE_TM();
        #endif

        TAKE_MNS();
        wd_active = (MNS_TM_WD_DISABLE != mns.config.general.watchdogmode.timeout)
8000b89c:	fe b0 e1 0e 	rcall	80007ab8 <mns_give>
            ? MNS_TRUE : MNS_FALSE;
        timeout = mns.watchdogmode.timeout_wdsm;
        GIVE_MNS();
8000b8a0:	ec 07 19 00 	cp.h	r7,r6
        if (MNS_FALSE != wd_active)
8000b8a4:	c0 80       	breq	8000b8b4 <MnsResetComplete+0xb8>
8000b8a6:	48 5c       	lddpc	r12,8000b8b8 <MnsResetComplete+0xbc>
        {
            MostSetTimer(&(mns.timer.watchdog), timeout, MNS_TRUE);
8000b8a8:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b8ac:	29 4c       	sub	r12,-108
8000b8ae:	30 1a       	mov	r10,1
8000b8b0:	fe b0 fb fc 	rcall	8000b0a8 <MostSetTimer>
8000b8b4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000b8b8:	00 00       	add	r0,r0
8000b8ba:	35 94       	mov	r4,89

8000b8bc <MnsServiceInitComplete>:
8000b8bc:	eb cd 40 f8 	pushm	r3-r7,lr
8000b8c0:	30 17       	mov	r7,1
8000b8c2:	16 95       	mov	r5,r11
8000b8c4:	ee 0c 18 00 	cp.b	r12,r7
8000b8c8:	c1 00       	breq	8000b8e8 <MnsServiceInitComplete+0x2c>
8000b8ca:	30 28       	mov	r8,2
8000b8cc:	f0 0c 18 00 	cp.b	r12,r8
8000b8d0:	c3 90       	breq	8000b942 <MnsServiceInitComplete+0x86>
8000b8d2:	e0 68 04 b5 	mov	r8,1205
8000b8d6:	30 1a       	mov	r10,1
            }
            #endif
            break;

        default:
            FAILED_ASSERT();
8000b8d8:	1a d8       	st.w	--sp,r8
8000b8da:	31 0b       	mov	r11,16
8000b8dc:	30 4c       	mov	r12,4
8000b8de:	fe b0 e1 07 	rcall	80007aec <mns_trace>
8000b8e2:	2f fd       	sub	sp,-4
8000b8e4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
                }
            }
            break;

        case MNS_PHASE_RESET:
            TAKE_MNS();
8000b8e8:	30 8c       	mov	r12,8
8000b8ea:	fe b0 e0 e6 	rcall	80007ab6 <mns_take>
            old_state = mns.services.ms_reset_mask;
8000b8ee:	4b 78       	lddpc	r8,8000b9c8 <MnsServiceInitComplete+0x10c>
            mns.services.ms_reset_mask |= service;
            new_state = mns.services.ms_reset_mask;
            GIVE_MNS();
8000b8f0:	30 8c       	mov	r12,8
            }
            break;

        case MNS_PHASE_RESET:
            TAKE_MNS();
            old_state = mns.services.ms_reset_mask;
8000b8f2:	f1 06 00 12 	ld.sh	r6,r8[18]
            mns.services.ms_reset_mask |= service;
8000b8f6:	eb e6 10 07 	or	r7,r5,r6
8000b8fa:	5c 87       	casts.h	r7
8000b8fc:	f1 57 00 12 	st.h	r8[18],r7
            new_state = mns.services.ms_reset_mask;
            GIVE_MNS();
8000b900:	fe b0 e0 dc 	rcall	80007ab8 <mns_give>


            #ifndef MNS_AVOID_ATTACH
            if(old_state != new_state)
8000b904:	ee 06 19 00 	cp.h	r6,r7
8000b908:	ce e0       	breq	8000b8e4 <MnsServiceInitComplete+0x28>
            {
                T_RESET_PHASE_CHANGE(new_state);
8000b90a:	5c 77       	castu.h	r7
8000b90c:	30 76       	mov	r6,7
8000b90e:	1a d7       	st.w	--sp,r7
8000b910:	30 2a       	mov	r10,2
8000b912:	1a d6       	st.w	--sp,r6
8000b914:	30 fb       	mov	r11,15
8000b916:	30 4c       	mov	r12,4
8000b918:	fe b0 e0 ea 	rcall	80007aec <mns_trace>

                if (MNS_P_SRV_ALL_RESET == (new_state & MNS_P_SRV_ALL_RESET))
8000b91c:	e2 17 00 dc 	andl	r7,0xdc,COH
8000b920:	2f ed       	sub	sp,-8
8000b922:	e0 47 00 dc 	cp.w	r7,220
8000b926:	cd f1       	brne	8000b8e4 <MnsServiceInitComplete+0x28>
                {
                    T_RESET_PHASE_CHANGE(0xFFFF);
8000b928:	e0 68 ff ff 	mov	r8,65535
8000b92c:	30 2a       	mov	r10,2
8000b92e:	1a d8       	st.w	--sp,r8
8000b930:	30 fb       	mov	r11,15
8000b932:	1a d6       	st.w	--sp,r6
8000b934:	30 4c       	mov	r12,4
8000b936:	fe b0 e0 db 	rcall	80007aec <mns_trace>
                    (void)MnsResetComplete();
8000b93a:	c6 1f       	rcall	8000b7fc <MnsResetComplete>
8000b93c:	2f ed       	sub	sp,-8
8000b93e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000b942:	30 8c       	mov	r12,8
    {
        case MNS_PHASE_INIT:
            {
                bool comm_ready;

                TAKE_MNS();
8000b944:	fe b0 e0 b9 	rcall	80007ab6 <mns_take>
8000b948:	4a 06       	lddpc	r6,8000b9c8 <MnsServiceInitComplete+0x10c>
                old_state = mns.services.ms_init_mask;
8000b94a:	30 8c       	mov	r12,8
                mns.services.ms_init_mask |= service;
                new_state = mns.services.ms_init_mask;
                comm_ready = mns.services.ms_comm_ready;
                GIVE_MNS();
8000b94c:	ed 03 00 10 	ld.sh	r3,r6[16]
        case MNS_PHASE_INIT:
            {
                bool comm_ready;

                TAKE_MNS();
                old_state = mns.services.ms_init_mask;
8000b950:	ed 34 00 14 	ld.ub	r4,r6[20]
                mns.services.ms_init_mask |= service;
                new_state = mns.services.ms_init_mask;
                comm_ready = mns.services.ms_comm_ready;
8000b954:	06 45       	or	r5,r3
            {
                bool comm_ready;

                TAKE_MNS();
                old_state = mns.services.ms_init_mask;
                mns.services.ms_init_mask |= service;
8000b956:	5c 85       	casts.h	r5
8000b958:	ed 55 00 10 	st.h	r6[16],r5
8000b95c:	fe b0 e0 ae 	rcall	80007ab8 <mns_give>
                new_state = mns.services.ms_init_mask;
                comm_ready = mns.services.ms_comm_ready;
                GIVE_MNS();
8000b960:	ea 03 19 00 	cp.h	r3,r5

                if(old_state != new_state)
8000b964:	cc 00       	breq	8000b8e4 <MnsServiceInitComplete+0x28>
8000b966:	30 68       	mov	r8,6
                {
                    T_INIT_PHASE_CHANGE(new_state);
8000b968:	5c 75       	castu.h	r5
8000b96a:	30 2a       	mov	r10,2
8000b96c:	1a d5       	st.w	--sp,r5
8000b96e:	30 fb       	mov	r11,15
8000b970:	1a d8       	st.w	--sp,r8
8000b972:	30 4c       	mov	r12,4
8000b974:	fe b0 e0 bc 	rcall	80007aec <mns_trace>
8000b978:	2f ed       	sub	sp,-8

                    if ((MNS_FALSE == comm_ready) && (MNS_P_SRV_COMM ==
8000b97a:	58 04       	cp.w	r4,0
8000b97c:	c0 61       	brne	8000b988 <MnsServiceInitComplete+0xcc>
8000b97e:	0a 98       	mov	r8,r5
8000b980:	e2 18 00 0b 	andl	r8,0xb,COH
8000b984:	58 b8       	cp.w	r8,11
8000b986:	c1 60       	breq	8000b9b2 <MnsServiceInitComplete+0xf6>
8000b988:	eb d5 c0 08 	bfextu	r5,r5,0x0,0x8

                        #ifdef MNS_60
                        (void)MnsRequestEHCIState();
                        #endif
                    }
                    if (MNS_P_SRV_ALL == (new_state & MNS_P_SRV_ALL))
8000b98c:	e0 45 00 ff 	cp.w	r5,255
8000b990:	ca a1       	brne	8000b8e4 <MnsServiceInitComplete+0x28>
8000b992:	e0 68 ff ff 	mov	r8,65535
                    {
                        T_INIT_PHASE_CHANGE(0xFFFF);
8000b996:	1a d8       	st.w	--sp,r8
8000b998:	30 68       	mov	r8,6
8000b99a:	30 2a       	mov	r10,2
8000b99c:	1a d8       	st.w	--sp,r8
8000b99e:	30 fb       	mov	r11,15
8000b9a0:	30 4c       	mov	r12,4
8000b9a2:	fe b0 e0 a5 	rcall	80007aec <mns_trace>
8000b9a6:	30 1c       	mov	r12,1
                        MnsSetPendingEvent(MNS_P_ALL_SERVICES_READY);
8000b9a8:	fe b0 fd 1c 	rcall	8000b3e0 <MnsSetPendingEvent>
8000b9ac:	2f ed       	sub	sp,-8
8000b9ae:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000b9b2:	30 8c       	mov	r12,8
                    T_INIT_PHASE_CHANGE(new_state);

                    if ((MNS_FALSE == comm_ready) && (MNS_P_SRV_COMM ==
                                          (new_state & MNS_P_SRV_COMM)))
                    {
                        TAKE_MNS();
8000b9b4:	fe b0 e0 81 	rcall	80007ab6 <mns_take>
8000b9b8:	30 8c       	mov	r12,8
                        mns.services.ms_comm_ready = MNS_TRUE;
                        GIVE_MNS();
8000b9ba:	ed 67 00 14 	st.b	r6[20],r7

                    if ((MNS_FALSE == comm_ready) && (MNS_P_SRV_COMM ==
                                          (new_state & MNS_P_SRV_COMM)))
                    {
                        TAKE_MNS();
                        mns.services.ms_comm_ready = MNS_TRUE;
8000b9be:	fe b0 e0 7d 	rcall	80007ab8 <mns_give>
                        GIVE_MNS();
8000b9c2:	c9 be       	rcall	8000b6f8 <MnsRequestEHCIState>

                        #ifdef MNS_60
                        (void)MnsRequestEHCIState();
8000b9c4:	ce 2b       	rjmp	8000b988 <MnsServiceInitComplete+0xcc>
8000b9c6:	d7 03       	nop
8000b9c8:	00 00       	add	r0,r0
8000b9ca:	35 94       	mov	r4,89

8000b9cc <MnsHandleVersionInfo>:
8000b9cc:	eb cd 40 fc 	pushm	r2-r7,lr
8000b9d0:	18 94       	mov	r4,r12
8000b9d2:	58 0c       	cp.w	r12,0
8000b9d4:	e0 80 00 d3 	breq	8000bb7a <MnsHandleVersionInfo+0x1ae>
8000b9d8:	30 8c       	mov	r12,8
8000b9da:	fe b0 e0 6e 	rcall	80007ab6 <mns_take>
8000b9de:	68 09       	ld.w	r9,r4[0x0]
8000b9e0:	30 0a       	mov	r10,0
8000b9e2:	13 88       	ld.ub	r8,r9[0x0]
8000b9e4:	f4 08 18 00 	cp.b	r8,r10

    ASSERT(msg_ptr);

    /* get the full info message ... index 0,0 */
    TAKE_MNS();
    if (!(msg_ptr->Data[0]) && !(msg_ptr->Data[1]))
8000b9e8:	c0 51       	brne	8000b9f2 <MnsHandleVersionInfo+0x26>
8000b9ea:	13 99       	ld.ub	r9,r9[0x1]
8000b9ec:	f0 09 18 00 	cp.b	r9,r8
8000b9f0:	c0 a0       	breq	8000ba04 <MnsHandleVersionInfo+0x38>
                okay = MNS_TRUE;
            }
            current_ptr++;
        }
    }
    GIVE_MNS();
8000b9f2:	30 8c       	mov	r12,8
8000b9f4:	fe b0 e0 62 	rcall	80007ab8 <mns_give>
        }
        #endif
    }
    else
    {
        MnsReportError(NSR_E_INIC_VERSION);
8000b9f8:	e0 6c 82 00 	mov	r12,33280
8000b9fc:	fe b0 fd 0e 	rcall	8000b418 <MnsReportError>
8000ba00:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
            {
                count--;
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
8000ba04:	4e 35       	lddpc	r5,8000bb90 <MnsHandleVersionInfo+0x1c4>
                okay = MNS_TRUE;
            }
            current_ptr++;
        }
    }
    GIVE_MNS();
8000ba06:	4e 46       	lddpc	r6,8000bb94 <MnsHandleVersionInfo+0x1c8>
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
            {
                count--;
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
8000ba08:	3f f7       	mov	r7,-1
                count--;
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+8], current_ptr->fw_ver[count]);
            }
            if (MNS_FALSE == next)
            {
                MNS_MEM_CPY(mns.shadow.version.public.fw, &(msg_ptr->Data[8]),(word)3);
8000ba0a:	ea c3 ff e3 	sub	r3,r5,-29
                okay = MNS_TRUE;
            }
            current_ptr++;
        }
    }
    GIVE_MNS();
8000ba0e:	30 48       	mov	r8,4
            count = 4;
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
            {
                count--;
8000ba10:	20 18       	sub	r8,1
8000ba12:	5c 58       	castu.b	r8
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
8000ba14:	ec 08 00 09 	add	r9,r6,r8
8000ba18:	f3 39 00 12 	ld.ub	r9,r9[18]
8000ba1c:	ee 09 18 00 	cp.b	r9,r7
8000ba20:	c3 c0       	breq	8000ba98 <MnsHandleVersionInfo+0xcc>
8000ba22:	ea 08 00 0a 	add	r10,r5,r8
8000ba26:	f5 3a 00 23 	ld.ub	r10,r10[35]
8000ba2a:	ee 0a 18 00 	cp.b	r10,r7
8000ba2e:	c3 50       	breq	8000ba98 <MnsHandleVersionInfo+0xcc>
8000ba30:	f4 09 18 00 	cp.b	r9,r10
8000ba34:	5f 19       	srne	r9
        while ((current_ptr->hw_ver[0] != 0) && (MNS_FALSE == okay))
        {
            count = 4;
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
8000ba36:	58 08       	cp.w	r8,0
8000ba38:	c3 30       	breq	8000ba9e <MnsHandleVersionInfo+0xd2>
8000ba3a:	58 09       	cp.w	r9,0
8000ba3c:	ce a0       	breq	8000ba10 <MnsHandleVersionInfo+0x44>
                mns.shadow.version.ntf_mask &= ~NTF_MASK_VMSV;
                #endif
                mns.shadow.version.feature_mask = current_ptr->feature_mask;
                okay = MNS_TRUE;
            }
            current_ptr++;
8000ba3e:	2e 86       	sub	r6,-24
                #endif

                #ifndef VMSV_MIN
                mns.shadow.version.ntf_mask &= ~NTF_MASK_VMSV;
                #endif
                mns.shadow.version.feature_mask = current_ptr->feature_mask;
8000ba40:	30 02       	mov	r2,0
    {
        _CONST MnsVerCheckLine *current_ptr = mns_valid_versions;
        byte count;
        bool next;

        while ((current_ptr->hw_ver[0] != 0) && (MNS_FALSE == okay))
8000ba42:	0d 89       	ld.ub	r9,r6[0x0]
8000ba44:	30 08       	mov	r8,0
8000ba46:	f0 09 18 00 	cp.b	r9,r8
8000ba4a:	e0 80 00 91 	breq	8000bb6c <MnsHandleVersionInfo+0x1a0>
8000ba4e:	58 02       	cp.w	r2,0
8000ba50:	cd f0       	breq	8000ba0e <MnsHandleVersionInfo+0x42>
                okay = MNS_TRUE;
            }
            current_ptr++;
        }
    }
    GIVE_MNS();
8000ba52:	30 8c       	mov	r12,8
8000ba54:	fe b0 e0 32 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != okay)
    {
        T_INIC_INIT();
8000ba58:	4c e8       	lddpc	r8,8000bb90 <MnsHandleVersionInfo+0x1c4>
8000ba5a:	f1 37 00 1f 	ld.ub	r7,r8[31]
8000ba5e:	f1 39 00 1c 	ld.ub	r9,r8[28]
8000ba62:	1a d7       	st.w	--sp,r7
8000ba64:	f1 37 00 1e 	ld.ub	r7,r8[30]
8000ba68:	1a d7       	st.w	--sp,r7
8000ba6a:	f1 38 00 1d 	ld.ub	r8,r8[29]
8000ba6e:	30 4a       	mov	r10,4
8000ba70:	1a d8       	st.w	--sp,r8
8000ba72:	14 9c       	mov	r12,r10
8000ba74:	1a d9       	st.w	--sp,r9
8000ba76:	31 7b       	mov	r11,23
8000ba78:	fe b0 e0 3a 	rcall	80007aec <mns_trace>
        MnsNtfCheck(NTF_VERSIONINFO);
8000ba7c:	e0 6c 02 00 	mov	r12,512
8000ba80:	fe b0 f9 f6 	rcall	8000ae6c <MnsNtfCheck>
        MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_AS_GO_SEMI_PROTECTED);
8000ba84:	30 8b       	mov	r11,8
8000ba86:	30 4c       	mov	r12,4
8000ba88:	fe b0 f9 3a 	rcall	8000acfc <MnsDistribEvent>
        MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_MNS);
8000ba8c:	30 4b       	mov	r11,4
8000ba8e:	30 2c       	mov	r12,2
8000ba90:	c1 6f       	rcall	8000b8bc <MnsServiceInitComplete>
8000ba92:	2f cd       	sub	sp,-16
8000ba94:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000ba98:	30 09       	mov	r9,0
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
            {
                count--;
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
8000ba9a:	58 08       	cp.w	r8,0
        while ((current_ptr->hw_ver[0] != 0) && (MNS_FALSE == okay))
        {
            count = 4;
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
8000ba9c:	cc f1       	brne	8000ba3a <MnsHandleVersionInfo+0x6e>
8000ba9e:	58 09       	cp.w	r9,0
            {
                count--;
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
            }
            count = 5;
            while (count && (MNS_FALSE == next))
8000baa0:	cc f1       	brne	8000ba3e <MnsHandleVersionInfo+0x72>
8000baa2:	68 0b       	ld.w	r11,r4[0x0]
        while ((current_ptr->hw_ver[0] != 0) && (MNS_FALSE == okay))
        {
            count = 4;
            next = MNS_FALSE;

            while (count && (MNS_FALSE == next))
8000baa4:	30 58       	mov	r8,5
8000baa6:	c0 d8       	rjmp	8000bac0 <MnsHandleVersionInfo+0xf4>
8000baa8:	ec 08 07 0a 	ld.ub	r10,r6[r8]
            }
            count = 5;
            while (count && (MNS_FALSE == next))
            {
                count--;
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+2], current_ptr->hw_ver[count]);
8000baac:	ee 0a 18 00 	cp.b	r10,r7
8000bab0:	c1 00       	breq	8000bad0 <MnsHandleVersionInfo+0x104>
8000bab2:	f4 09 18 00 	cp.b	r9,r10
8000bab6:	5f 19       	srne	r9
8000bab8:	58 08       	cp.w	r8,0
            {
                count--;
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
            }
            count = 5;
            while (count && (MNS_FALSE == next))
8000baba:	c0 e0       	breq	8000bad6 <MnsHandleVersionInfo+0x10a>
8000babc:	58 09       	cp.w	r9,0
8000babe:	cc 01       	brne	8000ba3e <MnsHandleVersionInfo+0x72>
8000bac0:	20 18       	sub	r8,1
            {
                count--;
8000bac2:	5c 58       	castu.b	r8
8000bac4:	f6 08 00 09 	add	r9,r11,r8
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+2], current_ptr->hw_ver[count]);
8000bac8:	13 a9       	ld.ub	r9,r9[0x2]
8000baca:	ee 09 18 00 	cp.b	r9,r7
8000bace:	ce d1       	brne	8000baa8 <MnsHandleVersionInfo+0xdc>
8000bad0:	30 09       	mov	r9,0
8000bad2:	58 08       	cp.w	r8,0
            {
                count--;
                next = MNS_IS_NOT_VALID(current_ptr->ns_ver[count], mns.shadow.version.public.ns[count]);
            }
            count = 5;
            while (count && (MNS_FALSE == next))
8000bad4:	cf 41       	brne	8000babc <MnsHandleVersionInfo+0xf0>
8000bad6:	58 09       	cp.w	r9,0
            {
                count--;
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+2], current_ptr->hw_ver[count]);
            }
            if (MNS_FALSE == next)
8000bad8:	cb 31       	brne	8000ba3e <MnsHandleVersionInfo+0x72>
8000bada:	0d d8       	ld.ub	r8,r6[0x5]
            {
                mns.shadow.version.public.hw = current_ptr->chip_id;
8000badc:	eb 68 00 1c 	st.b	r5[28],r8
8000bae0:	30 38       	mov	r8,3
8000bae2:	68 0b       	ld.w	r11,r4[0x0]
8000bae4:	c0 e8       	rjmp	8000bb00 <MnsHandleVersionInfo+0x134>
8000bae6:	ec 08 00 0a 	add	r10,r6,r8
            }
            count = 3;
            while (count && (MNS_FALSE == next))
            {
                count--;
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+8], current_ptr->fw_ver[count]);
8000baea:	15 ea       	ld.ub	r10,r10[0x6]
8000baec:	ee 0a 18 00 	cp.b	r10,r7
8000baf0:	c1 10       	breq	8000bb12 <MnsHandleVersionInfo+0x146>
8000baf2:	f4 09 18 00 	cp.b	r9,r10
8000baf6:	5f 19       	srne	r9
8000baf8:	58 08       	cp.w	r8,0
            if (MNS_FALSE == next)
            {
                mns.shadow.version.public.hw = current_ptr->chip_id;
            }
            count = 3;
            while (count && (MNS_FALSE == next))
8000bafa:	c0 f0       	breq	8000bb18 <MnsHandleVersionInfo+0x14c>
8000bafc:	58 09       	cp.w	r9,0
8000bafe:	ca 01       	brne	8000ba3e <MnsHandleVersionInfo+0x72>
8000bb00:	20 18       	sub	r8,1
            {
                count--;
8000bb02:	5c 58       	castu.b	r8
8000bb04:	f6 08 00 09 	add	r9,r11,r8
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+8], current_ptr->fw_ver[count]);
8000bb08:	f3 39 00 08 	ld.ub	r9,r9[8]
8000bb0c:	ee 09 18 00 	cp.b	r9,r7
8000bb10:	ce b1       	brne	8000bae6 <MnsHandleVersionInfo+0x11a>
8000bb12:	30 09       	mov	r9,0
8000bb14:	58 08       	cp.w	r8,0
            if (MNS_FALSE == next)
            {
                mns.shadow.version.public.hw = current_ptr->chip_id;
            }
            count = 3;
            while (count && (MNS_FALSE == next))
8000bb16:	cf 31       	brne	8000bafc <MnsHandleVersionInfo+0x130>
8000bb18:	58 09       	cp.w	r9,0
            {
                count--;
                next = MNS_IS_NOT_VALID(msg_ptr->Data[count+8], current_ptr->fw_ver[count]);
            }
            if (MNS_FALSE == next)
8000bb1a:	c9 21       	brne	8000ba3e <MnsHandleVersionInfo+0x72>
8000bb1c:	2f 8b       	sub	r11,-8
            {
                MNS_MEM_CPY(mns.shadow.version.public.fw, &(msg_ptr->Data[8]),(word)3);
8000bb1e:	30 3a       	mov	r10,3
8000bb20:	06 9c       	mov	r12,r3
8000bb22:	fe b0 fa eb 	rcall	8000b0f8 <MnsMemCpy>
8000bb26:	30 3a       	mov	r10,3
                MNS_MEM_CPY(mns.shadow.version.public.fw_date, &(msg_ptr->Data[11]),(word)3);
8000bb28:	68 0b       	ld.w	r11,r4[0x0]
8000bb2a:	ea cc ff e0 	sub	r12,r5,-32
8000bb2e:	2f 5b       	sub	r11,-11
8000bb30:	fe b0 fa e4 	rcall	8000b0f8 <MnsMemCpy>
8000bb34:	30 3a       	mov	r10,3
                MNS_MEM_CPY(mns.shadow.version.public.cs, &(msg_ptr->Data[14]),(word)3);
8000bb36:	68 0b       	ld.w	r11,r4[0x0]
8000bb38:	ea cc ff d9 	sub	r12,r5,-39
8000bb3c:	2f 2b       	sub	r11,-14
8000bb3e:	fe b0 fa dd 	rcall	8000b0f8 <MnsMemCpy>
8000bb42:	68 0b       	ld.w	r11,r4[0x0]
                MNS_MEM_CPY(mns.shadow.version.public.api, &(msg_ptr->Data[17]),(word)3);
8000bb44:	30 3a       	mov	r10,3
8000bb46:	2e fb       	sub	r11,-17
8000bb48:	ea cc ff d6 	sub	r12,r5,-42
8000bb4c:	fe b0 fa d6 	rcall	8000b0f8 <MnsMemCpy>
8000bb50:	6c 38       	ld.w	r8,r6[0xc]
                mns.shadow.version.ntf_mask = current_ptr->ntf_mask;
8000bb52:	8b c8       	st.w	r5[0x30],r8
8000bb54:	ed 08 00 10 	ld.sh	r8,r6[16]
                #endif

                #ifndef VMSV_MIN
                mns.shadow.version.ntf_mask &= ~NTF_MASK_VMSV;
                #endif
                mns.shadow.version.feature_mask = current_ptr->feature_mask;
8000bb58:	eb 58 00 34 	st.h	r5[52],r8
8000bb5c:	2e 86       	sub	r6,-24
                okay = MNS_TRUE;
            }
            current_ptr++;
8000bb5e:	30 12       	mov	r2,1
                #endif

                #ifndef VMSV_MIN
                mns.shadow.version.ntf_mask &= ~NTF_MASK_VMSV;
                #endif
                mns.shadow.version.feature_mask = current_ptr->feature_mask;
8000bb60:	0d 89       	ld.ub	r9,r6[0x0]
    {
        _CONST MnsVerCheckLine *current_ptr = mns_valid_versions;
        byte count;
        bool next;

        while ((current_ptr->hw_ver[0] != 0) && (MNS_FALSE == okay))
8000bb62:	30 08       	mov	r8,0
8000bb64:	f0 09 18 00 	cp.b	r9,r8
8000bb68:	fe 91 ff 73 	brne	8000ba4e <MnsHandleVersionInfo+0x82>
8000bb6c:	30 8c       	mov	r12,8
                okay = MNS_TRUE;
            }
            current_ptr++;
        }
    }
    GIVE_MNS();
8000bb6e:	fe b0 df a5 	rcall	80007ab8 <mns_give>
8000bb72:	58 02       	cp.w	r2,0

    if (MNS_FALSE != okay)
8000bb74:	fe 91 ff 72 	brne	8000ba58 <MnsHandleVersionInfo+0x8c>
8000bb78:	c4 0b       	rjmp	8000b9f8 <MnsHandleVersionInfo+0x2c>
8000bb7a:	e0 68 06 05 	mov	r8,1541

    T_MOD_ENTRY(MNS_26);

    okay  = MNS_FALSE;

    ASSERT(msg_ptr);
8000bb7e:	30 1a       	mov	r10,1
8000bb80:	1a d8       	st.w	--sp,r8
8000bb82:	31 0b       	mov	r11,16
8000bb84:	30 4c       	mov	r12,4
8000bb86:	fe b0 df b3 	rcall	80007aec <mns_trace>
8000bb8a:	2f fd       	sub	sp,-4
8000bb8c:	c2 6b       	rjmp	8000b9d8 <MnsHandleVersionInfo+0xc>
8000bb8e:	d7 03       	nop
8000bb90:	00 00       	add	r0,r0
8000bb92:	35 94       	mov	r4,89
8000bb94:	80 06       	ld.sh	r6,r0[0x0]
8000bb96:	fd 80       	*unknown*

8000bb98 <MnsFireWatchdogTrigger>:
8000bb98:	eb cd 40 80 	pushm	r7,lr
8000bb9c:	30 9c       	mov	r12,9
8000bb9e:	fe b0 df 8c 	rcall	80007ab6 <mns_take>
8000bba2:	4a 17       	lddpc	r7,8000bc24 <MnsFireWatchdogTrigger+0x8c>
8000bba4:	6f 28       	ld.w	r8,r7[0x48]
8000bba6:	58 08       	cp.w	r8,0
8000bba8:	c3 40       	breq	8000bc10 <MnsFireWatchdogTrigger+0x78>
8000bbaa:	ef 38 00 50 	ld.ub	r8,r7[80]
8000bbae:	49 e7       	lddpc	r7,8000bc24 <MnsFireWatchdogTrigger+0x8c>
8000bbb0:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
8000bbb4:	c1 01       	brne	8000bbd4 <MnsFireWatchdogTrigger+0x3c>
8000bbb6:	a1 a8       	sbr	r8,0x0
    if(MNS_WD_FLAG_BUSY_MASK != (mns.wd.flags & MNS_WD_FLAG_BUSY_MASK)) /* flag not set */
    {
        mns.wd.flags |= MNS_WD_FLAG_BUSY_MASK;
        send = MNS_TRUE;
        #ifndef MNS_DISABLE_WD_SUPERVISION
        mns.watchdogmode.tx_busy_cnt = MNS_WD_SUPERVIS_CNT_START;
8000bbb8:	ef 59 00 3c 	st.h	r7[60],r9
    TAKE_TM();
    ASSERT(mns.wd.msg_ptr);

    if(MNS_WD_FLAG_BUSY_MASK != (mns.wd.flags & MNS_WD_FLAG_BUSY_MASK)) /* flag not set */
    {
        mns.wd.flags |= MNS_WD_FLAG_BUSY_MASK;
8000bbbc:	ef 68 00 50 	st.b	r7[80],r8
            error = MNS_TRUE;
            mns.watchdogmode.tx_busy_cnt = MNS_WD_SUPERVIS_CNT_START;
        }
        #endif
    }
    GIVE_TM();
8000bbc0:	30 9c       	mov	r12,9
8000bbc2:	fe b0 df 7b 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != send)
    {
        PmsSend(mns.wd.handle, MnsWDTxComplete);
8000bbc6:	6f 3c       	ld.w	r12,r7[0x4c]
8000bbc8:	fe cb fe 9c 	sub	r11,pc,-356
8000bbcc:	e0 a0 0c 36 	rcall	8000d438 <PmsSend>
8000bbd0:	e3 cd 80 80 	ldm	sp++,r7,pc
        mns.watchdogmode.tx_busy_cnt = MNS_WD_SUPERVIS_CNT_START;
        #endif
    }
    else
    {
        mns.wd.flags |= MNS_WD_FLAG_SCHEDULE_MASK;
8000bbd4:	a1 b8       	sbr	r8,0x1
8000bbd6:	ef 68 00 50 	st.b	r7[80],r8

        #ifndef MNS_DISABLE_WD_SUPERVISION
        mns.watchdogmode.tx_busy_cnt++;
8000bbda:	ef 08 00 3c 	ld.sh	r8,r7[60]
8000bbde:	2f f8       	sub	r8,-1
8000bbe0:	ef 58 00 3c 	st.h	r7[60],r8
        if (mns.watchdogmode.tx_busy_cnt > mns.watchdogmode.max_tx_busy_cnt)
8000bbe4:	ef 09 00 3a 	ld.sh	r9,r7[58]
8000bbe8:	f0 09 19 00 	cp.h	r9,r8
        {
            error = MNS_TRUE;
            mns.watchdogmode.tx_busy_cnt = MNS_WD_SUPERVIS_CNT_START;
8000bbec:	c0 d2       	brcc	8000bc06 <MnsFireWatchdogTrigger+0x6e>
        }
        #endif
    }
    GIVE_TM();
8000bbee:	30 08       	mov	r8,0
        #ifndef MNS_DISABLE_WD_SUPERVISION
        mns.watchdogmode.tx_busy_cnt++;
        if (mns.watchdogmode.tx_busy_cnt > mns.watchdogmode.max_tx_busy_cnt)
        {
            error = MNS_TRUE;
            mns.watchdogmode.tx_busy_cnt = MNS_WD_SUPERVIS_CNT_START;
8000bbf0:	30 9c       	mov	r12,9
8000bbf2:	ef 58 00 3c 	st.h	r7[60],r8
        }
        #endif
    }
    GIVE_TM();
8000bbf6:	fe b0 df 61 	rcall	80007ab8 <mns_give>
    }

    #ifndef MNS_DISABLE_WD_SUPERVISION
    if (MNS_FALSE != error)
    {
        MnsReportError(NSR_E_NO_COMM);
8000bbfa:	e0 6c 84 00 	mov	r12,33792
8000bbfe:	fe b0 fc 0d 	rcall	8000b418 <MnsReportError>
8000bc02:	e3 cd 80 80 	ldm	sp++,r7,pc
            error = MNS_TRUE;
            mns.watchdogmode.tx_busy_cnt = MNS_WD_SUPERVIS_CNT_START;
        }
        #endif
    }
    GIVE_TM();
8000bc06:	30 9c       	mov	r12,9
8000bc08:	fe b0 df 58 	rcall	80007ab8 <mns_give>
8000bc0c:	e3 cd 80 80 	ldm	sp++,r7,pc
    #ifndef MNS_DISABLE_WD_SUPERVISION
    error = MNS_FALSE;
    #endif

    TAKE_TM();
    ASSERT(mns.wd.msg_ptr);
8000bc10:	e0 68 07 c3 	mov	r8,1987
8000bc14:	30 1a       	mov	r10,1
8000bc16:	1a d8       	st.w	--sp,r8
8000bc18:	31 0b       	mov	r11,16
8000bc1a:	30 4c       	mov	r12,4
8000bc1c:	fe b0 df 68 	rcall	80007aec <mns_trace>
8000bc20:	2f fd       	sub	sp,-4
8000bc22:	cc 4b       	rjmp	8000bbaa <MnsFireWatchdogTrigger+0x12>
8000bc24:	00 00       	add	r0,r0
8000bc26:	35 94       	mov	r4,89

8000bc28 <MnsHandleWatchdogModeStatus>:
8000bc28:	d4 21       	pushm	r4-r7,lr
8000bc2a:	18 96       	mov	r6,r12
8000bc2c:	58 0c       	cp.w	r12,0
8000bc2e:	c7 20       	breq	8000bd12 <MnsHandleWatchdogModeStatus+0xea>
8000bc30:	4b e7       	lddpc	r7,8000bd28 <MnsHandleWatchdogModeStatus+0x100>
8000bc32:	30 8c       	mov	r12,8
8000bc34:	fe b0 df 41 	rcall	80007ab6 <mns_take>
8000bc38:	6c 08       	ld.w	r8,r6[0x0]
8000bc3a:	11 89       	ld.ub	r9,r8[0x0]
8000bc3c:	30 08       	mov	r8,0
8000bc3e:	f0 09 18 00 	cp.b	r9,r8
    T_LIB_ENTRY(MNS_53);

    ASSERT(msg_ptr);

    TAKE_MNS();
    mns.config.general.watchdogmode.reset                = msg_ptr->Data[0];
8000bc42:	5f 18       	srne	r8
8000bc44:	ef 68 00 a5 	st.b	r7[165],r8
    mns.config.general.watchdogmode.timeout              = msg_ptr->Data[1] << 8;
8000bc48:	6c 08       	ld.w	r8,r6[0x0]
8000bc4a:	f1 25 00 01 	ld.sb	r5,r8[1]
8000bc4e:	a9 65       	lsl	r5,0x8
8000bc50:	ef 55 00 a6 	st.h	r7[166],r5
    mns.config.general.watchdogmode.timeout             |= msg_ptr->Data[2];
8000bc54:	6c 08       	ld.w	r8,r6[0x0]
8000bc56:	11 a8       	ld.ub	r8,r8[0x2]
8000bc58:	10 45       	or	r5,r8
8000bc5a:	ef 55 00 a6 	st.h	r7[166],r5
    mns.watchdogmode.timeout_wdsm = mns.config.general.watchdogmode.timeout -
8000bc5e:	e9 d5 c0 4e 	bfextu	r4,r5,0x2,0xe
8000bc62:	ea 04 01 04 	sub	r4,r5,r4
8000bc66:	5c 84       	casts.h	r4
8000bc68:	ef 54 00 38 	st.h	r7[56],r4
        (mns.config.general.watchdogmode.timeout >> MNS_TM_WDSM_POWER);
    mns.config.general.watchdogmode.auto_shutdown_delay  = msg_ptr->Data[3] << 8;
8000bc6c:	6c 08       	ld.w	r8,r6[0x0]
8000bc6e:	f1 28 00 03 	ld.sb	r8,r8[3]
8000bc72:	a9 68       	lsl	r8,0x8
8000bc74:	ef 58 00 a8 	st.h	r7[168],r8
    mns.config.general.watchdogmode.auto_shutdown_delay |= msg_ptr->Data[4];
8000bc78:	6c 09       	ld.w	r9,r6[0x0]
8000bc7a:	13 c9       	ld.ub	r9,r9[0x4]
8000bc7c:	12 48       	or	r8,r9
    new_timeout = mns.config.general.watchdogmode.timeout;
    new_wdsm = mns.watchdogmode.timeout_wdsm;
    GIVE_MNS();
8000bc7e:	30 8c       	mov	r12,8
    mns.config.general.watchdogmode.timeout              = msg_ptr->Data[1] << 8;
    mns.config.general.watchdogmode.timeout             |= msg_ptr->Data[2];
    mns.watchdogmode.timeout_wdsm = mns.config.general.watchdogmode.timeout -
        (mns.config.general.watchdogmode.timeout >> MNS_TM_WDSM_POWER);
    mns.config.general.watchdogmode.auto_shutdown_delay  = msg_ptr->Data[3] << 8;
    mns.config.general.watchdogmode.auto_shutdown_delay |= msg_ptr->Data[4];
8000bc80:	ef 58 00 a8 	st.h	r7[168],r8
    new_timeout = mns.config.general.watchdogmode.timeout;
    new_wdsm = mns.watchdogmode.timeout_wdsm;
    GIVE_MNS();
8000bc84:	fe b0 df 1a 	rcall	80007ab8 <mns_give>

    #ifndef MNS_DISABLE_WD_SUPERVISION
    TAKE_TM();
8000bc88:	30 9c       	mov	r12,9
8000bc8a:	fe b0 df 16 	rcall	80007ab6 <mns_take>
    if ((MNS_TM_WD_MIN_TIMEOUT >> 1) <= new_wdsm)
8000bc8e:	30 98       	mov	r8,9
8000bc90:	08 99       	mov	r9,r4
8000bc92:	f0 04 19 00 	cp.h	r4,r8
8000bc96:	e0 88 00 27 	brls	8000bce4 <MnsHandleWatchdogModeStatus+0xbc>
    {
        mns.watchdogmode.max_tx_busy_cnt = (word)(MNS_WD_STATUS_TIMEOUT / new_wdsm)
8000bc9a:	5c 79       	castu.h	r9
8000bc9c:	e0 68 0d ac 	mov	r8,3500
8000bca0:	f0 09 0d 08 	divu	r8,r8,r9
8000bca4:	2f f8       	sub	r8,-1
8000bca6:	ef 58 00 3a 	st.h	r7[58],r8
                                           + (word)1;
        mns.watchdogmode.tx_busy_cnt     = MNS_WD_SUPERVIS_CNT_START;
8000bcaa:	30 08       	mov	r8,0
8000bcac:	ef 58 00 3c 	st.h	r7[60],r8
    {
        mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable watchdog supervision */
        mns.watchdogmode.tx_busy_cnt     = MNS_WD_SUPERVIS_CNT_START;
        FAILED_ASSERT();                                                /* invalid wd security margin */
    }
    GIVE_TM();
8000bcb0:	30 9c       	mov	r12,9
8000bcb2:	fe b0 df 03 	rcall	80007ab8 <mns_give>
    #endif

    if (MNS_TM_WD_DISABLE != new_timeout)
8000bcb6:	3f f8       	mov	r8,-1
8000bcb8:	f0 05 19 00 	cp.h	r5,r8
8000bcbc:	c2 40       	breq	8000bd04 <MnsHandleWatchdogModeStatus+0xdc>
    {
        MnsFireWatchdogTrigger();
8000bcbe:	c6 df       	rcall	8000bb98 <MnsFireWatchdogTrigger>
8000bcc0:	08 9b       	mov	r11,r4
        MostSetTimer(&(mns.timer.watchdog), new_wdsm, MNS_TRUE);
8000bcc2:	ee cc ff 94 	sub	r12,r7,-108
8000bcc6:	5c 7b       	castu.h	r11
8000bcc8:	30 1a       	mov	r10,1
8000bcca:	fe b0 f9 ef 	rcall	8000b0a8 <MostSetTimer>
8000bcce:	fe b0 f9 11 	rcall	8000aef0 <MnsGetEHCIState>
    else
    {
        MostClearTimer(&(mns.timer.watchdog));
    }

    if (!EHCISTATE_IS_ATTACHED())
8000bcd2:	30 28       	mov	r8,2
8000bcd4:	f0 0c 18 00 	cp.b	r12,r8
8000bcd8:	c0 50       	breq	8000bce2 <MnsHandleWatchdogModeStatus+0xba>
8000bcda:	e0 7c 00 00 	mov	r12,65536
    {
        MnsNtfCheck(NTF_WATCHDOGMODE);
8000bcde:	fe b0 f8 c7 	rcall	8000ae6c <MnsNtfCheck>
8000bce2:	d8 22       	popm	r4-r7,pc
8000bce4:	3f f8       	mov	r8,-1
                                           + (word)1;
        mns.watchdogmode.tx_busy_cnt     = MNS_WD_SUPERVIS_CNT_START;
    }
    else
    {
        mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable watchdog supervision */
8000bce6:	ef 58 00 3a 	st.h	r7[58],r8
8000bcea:	30 08       	mov	r8,0
        mns.watchdogmode.tx_busy_cnt     = MNS_WD_SUPERVIS_CNT_START;
8000bcec:	ef 58 00 3c 	st.h	r7[60],r8
8000bcf0:	e0 68 08 75 	mov	r8,2165
        FAILED_ASSERT();                                                /* invalid wd security margin */
8000bcf4:	30 1a       	mov	r10,1
8000bcf6:	1a d8       	st.w	--sp,r8
8000bcf8:	31 0b       	mov	r11,16
8000bcfa:	30 4c       	mov	r12,4
8000bcfc:	fe b0 de f8 	rcall	80007aec <mns_trace>
8000bd00:	2f fd       	sub	sp,-4
8000bd02:	cd 7b       	rjmp	8000bcb0 <MnsHandleWatchdogModeStatus+0x88>
8000bd04:	30 0a       	mov	r10,0
        MnsFireWatchdogTrigger();
        MostSetTimer(&(mns.timer.watchdog), new_wdsm, MNS_TRUE);
    }
    else
    {
        MostClearTimer(&(mns.timer.watchdog));
8000bd06:	ee cc ff 94 	sub	r12,r7,-108
8000bd0a:	14 9b       	mov	r11,r10
8000bd0c:	fe b0 f9 ce 	rcall	8000b0a8 <MostSetTimer>
8000bd10:	cd fb       	rjmp	8000bcce <MnsHandleWatchdogModeStatus+0xa6>
8000bd12:	e0 68 08 5b 	mov	r8,2139
    word new_timeout;
    word new_wdsm;

    T_LIB_ENTRY(MNS_53);

    ASSERT(msg_ptr);
8000bd16:	30 1a       	mov	r10,1
8000bd18:	1a d8       	st.w	--sp,r8
8000bd1a:	31 0b       	mov	r11,16
8000bd1c:	30 4c       	mov	r12,4
8000bd1e:	fe b0 de e7 	rcall	80007aec <mns_trace>
8000bd22:	2f fd       	sub	sp,-4
8000bd24:	c8 6b       	rjmp	8000bc30 <MnsHandleWatchdogModeStatus+0x8>
8000bd26:	d7 03       	nop
8000bd28:	00 00       	add	r0,r0
8000bd2a:	35 94       	mov	r4,89

8000bd2c <MnsWDTxComplete>:
8000bd2c:	d4 01       	pushm	lr
8000bd2e:	31 08       	mov	r8,16
8000bd30:	f0 0b 18 00 	cp.b	r11,r8
8000bd34:	c0 a0       	breq	8000bd48 <MnsWDTxComplete+0x1c>
8000bd36:	e0 68 0c 75 	mov	r8,3189
8000bd3a:	30 1a       	mov	r10,1
8000bd3c:	1a d8       	st.w	--sp,r8
8000bd3e:	31 0b       	mov	r11,16
8000bd40:	30 4c       	mov	r12,4
8000bd42:	fe b0 de d5 	rcall	80007aec <mns_trace>
8000bd46:	2f fd       	sub	sp,-4
    scheduled = MNS_FALSE;
    (void) handle;
    ASSERT(XMIT_SUCCESS == status);
    (void) status;

    TAKE_TM();
8000bd48:	30 9c       	mov	r12,9
8000bd4a:	fe b0 de b6 	rcall	80007ab6 <mns_take>
    mns.wd.flags &= ~MNS_WD_FLAG_BUSY_MASK;
8000bd4e:	48 d8       	lddpc	r8,8000bd80 <MnsWDTxComplete+0x54>
8000bd50:	f1 39 00 50 	ld.ub	r9,r8[80]
8000bd54:	12 9a       	mov	r10,r9
8000bd56:	e2 1a 00 fe 	andl	r10,0xfe,COH
8000bd5a:	f1 6a 00 50 	st.b	r8[80],r10

    if(mns.wd.flags & MNS_WD_FLAG_SCHEDULE_MASK)
8000bd5e:	ed b9 00 01 	bld	r9,0x1
8000bd62:	c0 a1       	brne	8000bd76 <MnsWDTxComplete+0x4a>
    {
        mns.wd.flags &= ~MNS_WD_FLAG_SCHEDULE_MASK;
8000bd64:	e2 19 00 fc 	andl	r9,0xfc,COH
        scheduled = MNS_TRUE;
    }
    GIVE_TM();
8000bd68:	30 9c       	mov	r12,9
    TAKE_TM();
    mns.wd.flags &= ~MNS_WD_FLAG_BUSY_MASK;

    if(mns.wd.flags & MNS_WD_FLAG_SCHEDULE_MASK)
    {
        mns.wd.flags &= ~MNS_WD_FLAG_SCHEDULE_MASK;
8000bd6a:	f1 69 00 50 	st.b	r8[80],r9
        scheduled = MNS_TRUE;
    }
    GIVE_TM();
8000bd6e:	fe b0 de a5 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != scheduled)
    {
        MnsFireWatchdogTrigger();
8000bd72:	c1 3f       	rcall	8000bb98 <MnsFireWatchdogTrigger>
8000bd74:	d8 0a       	popm	pc,r12=0
    }

    T_MOD_EXIT(MNS_104);

    return(PMS_RELEASE);
}
8000bd76:	30 9c       	mov	r12,9
    if(mns.wd.flags & MNS_WD_FLAG_SCHEDULE_MASK)
    {
        mns.wd.flags &= ~MNS_WD_FLAG_SCHEDULE_MASK;
        scheduled = MNS_TRUE;
    }
    GIVE_TM();
8000bd78:	fe b0 de a0 	rcall	80007ab8 <mns_give>
8000bd7c:	d8 0a       	popm	pc,r12=0
    }

    T_MOD_EXIT(MNS_104);

    return(PMS_RELEASE);
}
8000bd7e:	d7 03       	nop
8000bd80:	00 00       	add	r0,r0
8000bd82:	35 94       	mov	r4,89

8000bd84 <MnsHandleEHCIStateStatus>:
8000bd84:	d4 21       	pushm	r4-r7,lr
8000bd86:	18 97       	mov	r7,r12
8000bd88:	58 0c       	cp.w	r12,0
8000bd8a:	e0 80 00 ad 	breq	8000bee4 <MnsHandleEHCIStateStatus+0x160>
8000bd8e:	30 8c       	mov	r12,8
8000bd90:	fe b0 de 93 	rcall	80007ab6 <mns_take>
    T_MOD_ENTRY(MNS_27);

    ASSERT(msg_ptr);

    TAKE_MNS();
        current_state = mns.shadow.ehci_state;
8000bd94:	4d c6       	lddpc	r6,8000bf04 <MnsHandleEHCIStateStatus+0x180>
    GIVE_MNS();
8000bd96:	30 8c       	mov	r12,8
    T_MOD_ENTRY(MNS_27);

    ASSERT(msg_ptr);

    TAKE_MNS();
        current_state = mns.shadow.ehci_state;
8000bd98:	ed 35 00 18 	ld.ub	r5,r6[24]
    GIVE_MNS();
8000bd9c:	fe b0 de 8e 	rcall	80007ab8 <mns_give>

    if ((EHCISTATE_UNKNOWN == current_state) &&
8000bda0:	3f f8       	mov	r8,-1
8000bda2:	f0 05 18 00 	cp.b	r5,r8
8000bda6:	c4 b0       	breq	8000be3c <MnsHandleEHCIStateStatus+0xb8>
    {
        (void)MnsForceProtected();
    }
    else
    {
        switch (msg_ptr->Data[0])
8000bda8:	6e 08       	ld.w	r8,r7[0x0]
8000bdaa:	11 84       	ld.ub	r4,r8[0x0]
8000bdac:	30 18       	mov	r8,1
8000bdae:	f0 04 18 00 	cp.b	r4,r8
8000bdb2:	c2 e0       	breq	8000be0e <MnsHandleEHCIStateStatus+0x8a>
8000bdb4:	30 28       	mov	r8,2
8000bdb6:	f0 04 18 00 	cp.b	r4,r8
8000bdba:	c0 d0       	breq	8000bdd4 <MnsHandleEHCIStateStatus+0x50>
                }
                #endif  /* #ifdef MNS_113 */
                break;

            default:
                ASSERT(EHCISTATE_PROTECTED == msg_ptr->Data[0]);
8000bdbc:	58 04       	cp.w	r4,0
8000bdbe:	c4 50       	breq	8000be48 <MnsHandleEHCIStateStatus+0xc4>
8000bdc0:	e0 68 06 87 	mov	r8,1671
8000bdc4:	30 1a       	mov	r10,1
8000bdc6:	1a d8       	st.w	--sp,r8
8000bdc8:	31 0b       	mov	r11,16
8000bdca:	30 4c       	mov	r12,4
8000bdcc:	fe b0 de 90 	rcall	80007aec <mns_trace>
8000bdd0:	2f fd       	sub	sp,-4
8000bdd2:	c3 b8       	rjmp	8000be48 <MnsHandleEHCIStateStatus+0xc4>
    else
    {
        switch (msg_ptr->Data[0])
        {
            case EHCISTATE_ATTACHED:
                if (EHCISTATE_ATTACHED != current_state)
8000bdd4:	f0 05 18 00 	cp.b	r5,r8
8000bdd8:	c1 b0       	breq	8000be0e <MnsHandleEHCIStateStatus+0x8a>
                {
                    TAKE_MNS();
8000bdda:	30 8c       	mov	r12,8
8000bddc:	fe b0 de 6d 	rcall	80007ab6 <mns_take>
                    mns.shadow.ehci_state = EHCISTATE_ATTACHED;
                    GIVE_MNS();
8000bde0:	30 8c       	mov	r12,8
        {
            case EHCISTATE_ATTACHED:
                if (EHCISTATE_ATTACHED != current_state)
                {
                    TAKE_MNS();
                    mns.shadow.ehci_state = EHCISTATE_ATTACHED;
8000bde2:	ed 64 00 18 	st.b	r6[24],r4
                    GIVE_MNS();
8000bde6:	fe b0 de 69 	rcall	80007ab8 <mns_give>
                    T_EHCISTATE_CHANGE(EHCISTATE_ATTACHED);
8000bdea:	30 38       	mov	r8,3
8000bdec:	30 2a       	mov	r10,2
8000bdee:	30 fb       	mov	r11,15
8000bdf0:	1a da       	st.w	--sp,r10
8000bdf2:	30 4c       	mov	r12,4
8000bdf4:	1a d8       	st.w	--sp,r8
8000bdf6:	fe b0 de 7b 	rcall	80007aec <mns_trace>

    #if (defined PACKET_COMMUNICATION_ONLY) && (defined NS_MNS_MHP)
        MnsStartPacketLayers();
    #endif

    if (mns.config.general.on_init_complete_fptr)
8000bdfa:	ec f8 00 88 	ld.w	r8,r6[136]
8000bdfe:	2f ed       	sub	sp,-8
8000be00:	58 08       	cp.w	r8,0
8000be02:	c0 20       	breq	8000be06 <MnsHandleEHCIStateStatus+0x82>
    {
        mns.config.general.on_init_complete_fptr();
8000be04:	5d 18       	icall	r8

                    /* MnsReportInitComplete() must be here, so it is reported
                     * BEFORE the delayed callbacks
                     */
                    MnsReportInitComplete();
                    MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_AS_GO_ATTACHED);
8000be06:	31 0b       	mov	r11,16
8000be08:	30 4c       	mov	r12,4
8000be0a:	fe b0 f7 79 	rcall	8000acfc <MnsDistribEvent>
                T_RESET_PHASE_CHANGE(MNS_P_NONE);
                MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_AS_GO_PROTECTED);
                break;
        }

        MnsSetPendingEvent(MNS_P_SRV_CHECK);
8000be0e:	e0 6c 20 00 	mov	r12,8192
8000be12:	fe b0 fa e7 	rcall	8000b3e0 <MnsSetPendingEvent>

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
8000be16:	6e 08       	ld.w	r8,r7[0x0]
8000be18:	11 89       	ld.ub	r9,r8[0x0]
8000be1a:	30 28       	mov	r8,2
8000be1c:	f0 09 18 00 	cp.b	r9,r8
8000be20:	c4 e0       	breq	8000bebc <MnsHandleEHCIStateStatus+0x138>
            #endif
        }
        else
        {
            #ifdef AMS_MIN
                MsgNIStateNetOn(MNS_FALSE);
8000be22:	30 0c       	mov	r12,0
8000be24:	fe b0 e8 fc 	rcall	8000901c <MsgNIStateNetOn>
            #endif
        }

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
8000be28:	6e 08       	ld.w	r8,r7[0x0]
8000be2a:	11 89       	ld.ub	r9,r8[0x0]
8000be2c:	30 28       	mov	r8,2
8000be2e:	f0 09 18 00 	cp.b	r9,r8
8000be32:	c3 80       	breq	8000bea2 <MnsHandleEHCIStateStatus+0x11e>
            #endif
        }
        else
        {
            #ifdef ADS_10
                DataNIStateNetOn(MNS_FALSE);
8000be34:	30 0c       	mov	r12,0
8000be36:	e0 a0 2a 6d 	rcall	80011310 <DataNIStateNetOn>
8000be3a:	d8 22       	popm	r4-r7,pc
    TAKE_MNS();
        current_state = mns.shadow.ehci_state;
    GIVE_MNS();

    if ((EHCISTATE_UNKNOWN == current_state) &&
        (EHCISTATE_PROTECTED != msg_ptr->Data[0]))
8000be3c:	6e 08       	ld.w	r8,r7[0x0]
8000be3e:	11 89       	ld.ub	r9,r8[0x0]
8000be40:	30 08       	mov	r8,0
8000be42:	f0 09 18 00 	cp.b	r9,r8
8000be46:	c5 91       	brne	8000bef8 <MnsHandleEHCIStateStatus+0x174>
                #endif  /* #ifdef MNS_113 */
                break;

            default:
                ASSERT(EHCISTATE_PROTECTED == msg_ptr->Data[0]);
                T_TRANSITION_CAUSE(msg_ptr->Length, msg_ptr->Data[1]);
8000be48:	8e 29       	ld.sh	r9,r7[0x4]
8000be4a:	30 18       	mov	r8,1
8000be4c:	f0 09 19 00 	cp.h	r9,r8
8000be50:	e0 88 00 0b 	brls	8000be66 <MnsHandleEHCIStateStatus+0xe2>
8000be54:	6e 08       	ld.w	r8,r7[0x0]
8000be56:	11 98       	ld.ub	r8,r8[0x1]
8000be58:	30 1a       	mov	r10,1
8000be5a:	1a d8       	st.w	--sp,r8
8000be5c:	33 1b       	mov	r11,49
8000be5e:	30 4c       	mov	r12,4
8000be60:	fe b0 de 46 	rcall	80007aec <mns_trace>
8000be64:	2f fd       	sub	sp,-4
                TAKE_MNS();
8000be66:	30 8c       	mov	r12,8
8000be68:	fe b0 de 27 	rcall	80007ab6 <mns_take>
                mns.services.ms_init_mask &= ~MNS_P_SRV_SHADOW;
8000be6c:	ed 08 00 10 	ld.sh	r8,r6[16]
8000be70:	e0 18 ff 2f 	andl	r8,0xff2f
8000be74:	ed 58 00 10 	st.h	r6[16],r8
                mns.services.ms_reset_mask = MNS_P_NONE;
8000be78:	30 08       	mov	r8,0
                GIVE_MNS();
8000be7a:	30 8c       	mov	r12,8
            default:
                ASSERT(EHCISTATE_PROTECTED == msg_ptr->Data[0]);
                T_TRANSITION_CAUSE(msg_ptr->Length, msg_ptr->Data[1]);
                TAKE_MNS();
                mns.services.ms_init_mask &= ~MNS_P_SRV_SHADOW;
                mns.services.ms_reset_mask = MNS_P_NONE;
8000be7c:	ed 58 00 12 	st.h	r6[18],r8
                GIVE_MNS();
8000be80:	fe b0 de 1c 	rcall	80007ab8 <mns_give>
                T_RESET_PHASE_CHANGE(MNS_P_NONE);
8000be84:	30 08       	mov	r8,0
8000be86:	1a d8       	st.w	--sp,r8
8000be88:	30 78       	mov	r8,7
8000be8a:	30 2a       	mov	r10,2
8000be8c:	1a d8       	st.w	--sp,r8
8000be8e:	30 fb       	mov	r11,15
8000be90:	30 4c       	mov	r12,4
8000be92:	fe b0 de 2d 	rcall	80007aec <mns_trace>
                MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_AS_GO_PROTECTED);
8000be96:	30 2b       	mov	r11,2
8000be98:	30 4c       	mov	r12,4
8000be9a:	fe b0 f7 31 	rcall	8000acfc <MnsDistribEvent>
8000be9e:	2f ed       	sub	sp,-8
8000bea0:	cb 7b       	rjmp	8000be0e <MnsHandleEHCIStateStatus+0x8a>
                MsgNIStateNetOn(MNS_FALSE);
            #endif
        }

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
            (MNS_NET_ON == MostGetState())           &&
8000bea2:	e0 a0 1f 8d 	rcall	8000fdbc <MostGetState>
            #ifdef AMS_MIN
                MsgNIStateNetOn(MNS_FALSE);
            #endif
        }

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
8000bea6:	30 48       	mov	r8,4
8000bea8:	f0 0c 18 00 	cp.b	r12,r8
8000beac:	cc 41       	brne	8000be34 <MnsHandleEHCIStateStatus+0xb0>
8000beae:	fe b0 fb 83 	rcall	8000b5b4 <MnsPMReady>
8000beb2:	cc 10       	breq	8000be34 <MnsHandleEHCIStateStatus+0xb0>
            (MNS_NET_ON == MostGetState())           &&
            (MNS_FALSE != MnsPMReady()))
        {
            #ifdef ADS_10
                DataNIStateNetOn(MNS_TRUE);
8000beb4:	30 1c       	mov	r12,1
8000beb6:	e0 a0 2a 2d 	rcall	80011310 <DataNIStateNetOn>
            #ifdef AMS_MIN
                MsgNIStateNetOn(MNS_FALSE);
            #endif
        }

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
8000beba:	d8 22       	popm	r4-r7,pc
        }

        MnsSetPendingEvent(MNS_P_SRV_CHECK);

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
            (MNS_NET_ON == MostGetState()))
8000bebc:	e0 a0 1f 80 	rcall	8000fdbc <MostGetState>
                break;
        }

        MnsSetPendingEvent(MNS_P_SRV_CHECK);

        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
8000bec0:	30 48       	mov	r8,4
8000bec2:	f0 0c 18 00 	cp.b	r12,r8
8000bec6:	ca e1       	brne	8000be22 <MnsHandleEHCIStateStatus+0x9e>
            (MNS_NET_ON == MostGetState()))
        {
            #ifdef AMS_MIN
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
8000bec8:	e0 a0 33 ac 	rcall	80012620 <ScmGetBoundary>
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000becc:	3e e8       	mov	r8,-18
        if ((EHCISTATE_ATTACHED == msg_ptr->Data[0]) &&
            (MNS_NET_ON == MostGetState()))
        {
            #ifdef AMS_MIN
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
8000bece:	18 96       	mov	r6,r12
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000bed0:	f0 0c 18 00 	cp.b	r12,r8
8000bed4:	ca a0       	breq	8000be28 <MnsHandleEHCIStateStatus+0xa4>
8000bed6:	30 8c       	mov	r12,8
8000bed8:	fe b0 f7 ee 	rcall	8000aeb4 <MostIsSupported>
8000bedc:	c1 11       	brne	8000befe <MnsHandleEHCIStateStatus+0x17a>
            bool bdvalid  = MNS_TRUE;
            #endif

            if (MNS_FALSE != bdvalid)
            {
                MnsSignalNetOn();
8000bede:	fe b0 f7 a1 	rcall	8000ae20 <MnsSignalNetOn>
8000bee2:	ca 3b       	rjmp	8000be28 <MnsHandleEHCIStateStatus+0xa4>
{
    byte current_state;

    T_MOD_ENTRY(MNS_27);

    ASSERT(msg_ptr);
8000bee4:	e0 68 06 5c 	mov	r8,1628
8000bee8:	30 1a       	mov	r10,1
8000beea:	1a d8       	st.w	--sp,r8
8000beec:	31 0b       	mov	r11,16
8000beee:	30 4c       	mov	r12,4
8000bef0:	fe b0 dd fe 	rcall	80007aec <mns_trace>
8000bef4:	2f fd       	sub	sp,-4
8000bef6:	c4 cb       	rjmp	8000bd8e <MnsHandleEHCIStateStatus+0xa>
    GIVE_MNS();

    if ((EHCISTATE_UNKNOWN == current_state) &&
        (EHCISTATE_PROTECTED != msg_ptr->Data[0]))
    {
        (void)MnsForceProtected();
8000bef8:	fe b0 fb cc 	rcall	8000b690 <MnsForceProtected>

    TAKE_MNS();
        current_state = mns.shadow.ehci_state;
    GIVE_MNS();

    if ((EHCISTATE_UNKNOWN == current_state) &&
8000befc:	d8 22       	popm	r4-r7,pc
            (MNS_NET_ON == MostGetState()))
        {
            #ifdef AMS_MIN
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000befe:	58 06       	cp.w	r6,0
8000bf00:	c9 40       	breq	8000be28 <MnsHandleEHCIStateStatus+0xa4>
8000bf02:	ce eb       	rjmp	8000bede <MnsHandleEHCIStateStatus+0x15a>
8000bf04:	00 00       	add	r0,r0
8000bf06:	35 94       	mov	r4,89

8000bf08 <MnsEHCIGoSemiProtected>:
8000bf08:	eb cd 40 c0 	pushm	r6-r7,lr
8000bf0c:	e0 6c 00 ff 	mov	r12,255
8000bf10:	fe b0 f8 00 	rcall	8000af10 <MnsIsNSInitComplete>
8000bf14:	c2 b0       	breq	8000bf6a <MnsEHCIGoSemiProtected+0x62>
8000bf16:	49 c7       	lddpc	r7,8000bf84 <MnsEHCIGoSemiProtected+0x7c>
8000bf18:	ee f8 00 90 	ld.w	r8,r7[144]
8000bf1c:	58 08       	cp.w	r8,0
8000bf1e:	c0 40       	breq	8000bf26 <MnsEHCIGoSemiProtected+0x1e>
8000bf20:	e0 a0 18 36 	rcall	8000ef8c <VmsvGetNCStateShutdown>
8000bf24:	c2 51       	brne	8000bf6e <MnsEHCIGoSemiProtected+0x66>
8000bf26:	30 1c       	mov	r12,1
8000bf28:	fe b0 e7 ba 	rcall	80008e9c <MsgGetTxPtrExt>
8000bf2c:	c1 30       	breq	8000bf52 <MnsEHCIGoSemiProtected+0x4a>
8000bf2e:	30 19       	mov	r9,1
8000bf30:	b8 29       	st.h	r12[0x4],r9
8000bf32:	b8 39       	st.h	r12[0x6],r9
8000bf34:	30 09       	mov	r9,0
8000bf36:	f9 69 00 0c 	st.b	r12[12],r9
8000bf3a:	f9 69 00 0b 	st.b	r12[11],r9

            msg_ptr = MsgGetTxPtrExt(1);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
8000bf3e:	e0 69 03 00 	mov	r9,768
                msg_ptr->Inst_ID   = 0;
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = 1;
                msg_ptr->Data[0]   = EHCISTATE_ATTACHED;
8000bf42:	78 08       	ld.w	r8,r12[0x0]

            msg_ptr = MsgGetTxPtrExt(1);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_EHCISTATE;
8000bf44:	b8 49       	st.h	r12[0x8],r9
                msg_ptr->Inst_ID   = 0;
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = 1;
                msg_ptr->Data[0]   = EHCISTATE_ATTACHED;
8000bf46:	30 29       	mov	r9,2
8000bf48:	b0 89       	st.b	r8[0x0],r9

                MsgSend3(msg_ptr);
8000bf4a:	fe b0 ea ed 	rcall	80009524 <MsgSend3>
8000bf4e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
            else
            {
                SCHEDULE_RETRY(MNS_RETRY_GO_SEMI_PROTECTED);
8000bf52:	30 8c       	mov	r12,8
8000bf54:	fe b0 dd b1 	rcall	80007ab6 <mns_take>
8000bf58:	ef 08 00 80 	ld.sh	r8,r7[128]
8000bf5c:	a3 a8       	sbr	r8,0x2
8000bf5e:	30 8c       	mov	r12,8
8000bf60:	ef 58 00 80 	st.h	r7[128],r8
8000bf64:	fe b0 dd aa 	rcall	80007ab8 <mns_give>
8000bf68:	30 4c       	mov	r12,4
    }

    T_MOD_EXIT(MNS_23);

    return(result);
}
8000bf6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        byte target_mode = MNS_GO_ATTACHED_MODE;

        if (mns.config.general.wakeup_query_fptr &&
            (MNS_FALSE != VmsvGetNCStateShutdown()))
        {
            target_mode = mns.config.general.wakeup_query_fptr();
8000bf6e:	ee fc 00 90 	ld.w	r12,r7[144]
8000bf72:	5d 1c       	icall	r12
8000bf74:	18 96       	mov	r6,r12
        }

        if (MNS_GO_PROTECTED_MODE == target_mode)
8000bf76:	cd 81       	brne	8000bf26 <MnsEHCIGoSemiProtected+0x1e>
        {
            StopNetServices();
8000bf78:	fe b0 fb b0 	rcall	8000b6d8 <StopNetServices>
8000bf7c:	0c 9c       	mov	r12,r6
8000bf7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000bf82:	d7 03       	nop
8000bf84:	00 00       	add	r0,r0
8000bf86:	35 94       	mov	r4,89

8000bf88 <InitNetServices>:
8000bf88:	d4 21       	pushm	r4-r7,lr
8000bf8a:	30 5c       	mov	r12,5
8000bf8c:	fe b0 dd 95 	rcall	80007ab6 <mns_take>
8000bf90:	30 6c       	mov	r12,6
8000bf92:	fe b0 dd 92 	rcall	80007ab6 <mns_take>
8000bf96:	30 06       	mov	r6,0
8000bf98:	fe f7 02 6c 	ld.w	r7,pc[620]
8000bf9c:	30 6c       	mov	r12,6
8000bf9e:	ae 66       	st.h	r7[0xc],r6
8000bfa0:	ae 76       	st.h	r7[0xe],r6
8000bfa2:	fe b0 dd 8b 	rcall	80007ab8 <mns_give>

    T_MOD_ENTRY(MNS_10);

    temp_tick_count = 0;

    T_INIT();
8000bfa6:	30 0a       	mov	r10,0
8000bfa8:	30 7b       	mov	r11,7
8000bfaa:	30 4c       	mov	r12,4
8000bfac:	fe b0 dd a0 	rcall	80007aec <mns_trace>

    TAKE_EVENTS();
8000bfb0:	30 7c       	mov	r12,7
8000bfb2:	fe b0 dd 82 	rcall	80007ab6 <mns_take>
    #endif

    #ifdef NS_MNS_PMHS
    mns.events.pending_pmhs = MNS_P_NONE;
    #endif
    GIVE_EVENTS();
8000bfb6:	30 7c       	mov	r12,7
    temp_tick_count = 0;

    T_INIT();

    TAKE_EVENTS();
    mns.events.pending     = MNS_P_NONE;
8000bfb8:	ae 06       	st.h	r7[0x0],r6
    mns.events.latest      = MNS_P_NONE;
8000bfba:	ae 16       	st.h	r7[0x2],r6
    #ifdef NS_MNS_MNS2
    mns.events.pending_l2 = MNS_P_NONE;
8000bfbc:	ae 26       	st.h	r7[0x4],r6
    #endif

    #ifdef NS_MNS_PMHS
    mns.events.pending_pmhs = MNS_P_NONE;
    #endif
    GIVE_EVENTS();
8000bfbe:	fe b0 dd 7d 	rcall	80007ab8 <mns_give>

    mns.stopped                 = MNS_FALSE;
    mns.signaled_ns_stopped     = MNS_FALSE;
    mns.signal_net_on           = MNS_FALSE;
    mns.services.ms_init_mask   = MNS_P_NONE;
    T_INIT_PHASE_CHANGE(MNS_P_NONE);
8000bfc2:	30 68       	mov	r8,6
    GIVE_EVENTS();

    mns.stopped                 = MNS_FALSE;
    mns.signaled_ns_stopped     = MNS_FALSE;
    mns.signal_net_on           = MNS_FALSE;
    mns.services.ms_init_mask   = MNS_P_NONE;
8000bfc4:	ef 56 00 10 	st.h	r7[16],r6
    #ifdef NS_MNS_PMHS
    mns.events.pending_pmhs = MNS_P_NONE;
    #endif
    GIVE_EVENTS();

    mns.stopped                 = MNS_FALSE;
8000bfc8:	ef 66 01 44 	st.b	r7[324],r6
    mns.signaled_ns_stopped     = MNS_FALSE;
8000bfcc:	ef 66 01 45 	st.b	r7[325],r6
    mns.signal_net_on           = MNS_FALSE;
8000bfd0:	ef 66 01 46 	st.b	r7[326],r6
    mns.services.ms_init_mask   = MNS_P_NONE;
    T_INIT_PHASE_CHANGE(MNS_P_NONE);
8000bfd4:	30 2a       	mov	r10,2
8000bfd6:	30 06       	mov	r6,0
8000bfd8:	30 fb       	mov	r11,15
8000bfda:	1a d6       	st.w	--sp,r6
8000bfdc:	30 4c       	mov	r12,4
8000bfde:	1a d8       	st.w	--sp,r8
8000bfe0:	fe b0 dd 86 	rcall	80007aec <mns_trace>
    mns.services.ms_reset_mask  = MNS_P_NONE;
    T_RESET_PHASE_CHANGE(MNS_P_NONE);
8000bfe4:	1a d6       	st.w	--sp,r6
    mns.stopped                 = MNS_FALSE;
    mns.signaled_ns_stopped     = MNS_FALSE;
    mns.signal_net_on           = MNS_FALSE;
    mns.services.ms_init_mask   = MNS_P_NONE;
    T_INIT_PHASE_CHANGE(MNS_P_NONE);
    mns.services.ms_reset_mask  = MNS_P_NONE;
8000bfe6:	ef 56 00 12 	st.h	r7[18],r6
    T_RESET_PHASE_CHANGE(MNS_P_NONE);
8000bfea:	30 78       	mov	r8,7
8000bfec:	30 2a       	mov	r10,2
8000bfee:	1a d8       	st.w	--sp,r8
8000bff0:	30 fb       	mov	r11,15
8000bff2:	30 4c       	mov	r12,4
8000bff4:	fe b0 dd 7c 	rcall	80007aec <mns_trace>

    if (mns.config.general.get_tick_count_fptr)
8000bff8:	2f cd       	sub	sp,-16
8000bffa:	ee f4 00 9c 	ld.w	r4,r7[156]
8000bffe:	58 04       	cp.w	r4,0
8000c000:	e0 80 00 f6 	breq	8000c1ec <InitNetServices+0x264>
    {
        temp_tick_count = mns.config.general.get_tick_count_fptr();
8000c004:	5d 14       	icall	r4
8000c006:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
    {
        /* get_tick_count_fptr is mandatory ! */
        FAILED_ASSERT();
    }

    TAKE_MNS();
8000c00a:	30 8c       	mov	r12,8
8000c00c:	fe b0 dd 55 	rcall	80007ab6 <mns_take>
    /* check for valid timeout */
    if (((MNS_TM_WD_MIN_TIMEOUT > mns.config.general.watchdogmode.timeout)  ||
8000c010:	ef 08 00 a6 	ld.sh	r8,r7[166]
8000c014:	f0 ca 00 14 	sub	r10,r8,20
8000c018:	e0 69 01 e0 	mov	r9,480
8000c01c:	f2 0a 19 00 	cp.h	r10,r9
8000c020:	f9 b9 0b 01 	movhi	r9,1
8000c024:	f9 b9 08 00 	movls	r9,0
8000c028:	3f fa       	mov	r10,-1
8000c02a:	f4 08 19 00 	cp.h	r8,r10
8000c02e:	5f 1a       	srne	r10
8000c030:	f5 e9 00 09 	and	r9,r10,r9
8000c034:	e0 81 00 c7 	brne	8000c1c2 <InitNetServices+0x23a>
8000c038:	f3 d8 c0 4e 	bfextu	r9,r8,0x2,0xe
8000c03c:	12 18       	sub	r8,r9
         (MNS_TM_WD_MAX_TIMEOUT < mns.config.general.watchdogmode.timeout)) &&
        (MNS_TM_WD_DISABLE    != mns.config.general.watchdogmode.timeout))
    {
        mns.config.general.watchdogmode.timeout = MNS_TM_WD_MAX_TIMEOUT;
    }
    mns.watchdogmode.timeout_wdsm = mns.config.general.watchdogmode.timeout -
8000c03e:	ef 58 00 38 	st.h	r7[56],r8
        (mns.config.general.watchdogmode.timeout >> MNS_TM_WDSM_POWER);

    mns.retry = 0;
8000c042:	30 08       	mov	r8,0
8000c044:	ef 58 00 80 	st.h	r7[128],r8

    if(!mns.config.general.burst)
8000c048:	ef 39 00 ac 	ld.ub	r9,r7[172]
8000c04c:	f0 09 18 00 	cp.b	r9,r8
8000c050:	c0 51       	brne	8000c05a <InitNetServices+0xd2>
    {
        mns.config.general.burst = MNS_STD_BURST;
8000c052:	30 19       	mov	r9,1
8000c054:	4e c8       	lddpc	r8,8000c204 <InitNetServices+0x27c>
8000c056:	f1 69 00 ac 	st.b	r8[172],r9
    mns.shadow.ehci_state             = EHCISTATE_UNKNOWN;
    /* The version information is entered automatically by the
     * PrePreprocessor.
     */
    mns.shadow.version.public.ns[0]          = 0x03;
    mns.shadow.version.public.ns[1]          = 0x00;
8000c05a:	30 06       	mov	r6,0
8000c05c:	ef 66 00 24 	st.b	r7[36],r6
    mns.shadow.version.public.ns[2]          = 0x04;
    mns.shadow.version.public.ns[3]          = 0xD0;

    mns.services.ms_comm_ready        = MNS_FALSE;
8000c060:	ef 66 00 14 	st.b	r7[20],r6

        #ifdef ALLOW_AUTO_CONFIG
            config |= MNS_F_ALLOW_AUTO_CONFIG;
        #endif

        T_MOST_INIT(MNS_P_SRV_ALL, config);
8000c064:	30 48       	mov	r8,4
    if(!mns.config.general.burst)
    {
        mns.config.general.burst = MNS_STD_BURST;
    }

    mns.shadow.ehci_state             = EHCISTATE_UNKNOWN;
8000c066:	3f f9       	mov	r9,-1

        #ifdef ALLOW_AUTO_CONFIG
            config |= MNS_F_ALLOW_AUTO_CONFIG;
        #endif

        T_MOST_INIT(MNS_P_SRV_ALL, config);
8000c068:	1a d8       	st.w	--sp,r8
    if(!mns.config.general.burst)
    {
        mns.config.general.burst = MNS_STD_BURST;
    }

    mns.shadow.ehci_state             = EHCISTATE_UNKNOWN;
8000c06a:	ef 69 00 18 	st.b	r7[24],r9
    /* The version information is entered automatically by the
     * PrePreprocessor.
     */
    mns.shadow.version.public.ns[0]          = 0x03;
8000c06e:	30 39       	mov	r9,3
8000c070:	ef 69 00 23 	st.b	r7[35],r9
    mns.shadow.version.public.ns[1]          = 0x00;
    mns.shadow.version.public.ns[2]          = 0x04;
8000c074:	30 49       	mov	r9,4
8000c076:	ef 69 00 25 	st.b	r7[37],r9
    mns.shadow.version.public.ns[3]          = 0xD0;
8000c07a:	3d 09       	mov	r9,-48
8000c07c:	ef 69 00 26 	st.b	r7[38],r9

        #ifdef ALLOW_AUTO_CONFIG
            config |= MNS_F_ALLOW_AUTO_CONFIG;
        #endif

        T_MOST_INIT(MNS_P_SRV_ALL, config);
8000c080:	e0 69 00 ff 	mov	r9,255
8000c084:	10 9c       	mov	r12,r8
8000c086:	1a d9       	st.w	--sp,r9
8000c088:	e0 69 00 d0 	mov	r9,208
8000c08c:	1a d9       	st.w	--sp,r9
8000c08e:	1a d8       	st.w	--sp,r8
8000c090:	30 38       	mov	r8,3
8000c092:	30 05       	mov	r5,0
8000c094:	30 6a       	mov	r10,6
8000c096:	1a d5       	st.w	--sp,r5
8000c098:	30 cb       	mov	r11,12
8000c09a:	1a d8       	st.w	--sp,r8
8000c09c:	fe b0 dd 28 	rcall	80007aec <mns_trace>
    }
#endif

    mns.services.ms_layer2          = MNS_FALSE;
8000c0a0:	ef 65 00 15 	st.b	r7[21],r5
    mns.services.ms_packet_layers   = MNS_FALSE;
8000c0a4:	ef 66 00 16 	st.b	r7[22],r6
    mns.buf_freed                   = MNS_FALSE;
8000c0a8:	ef 66 01 47 	st.b	r7[327],r6
    mns.remote_access               = MNS_DENY;
8000c0ac:	ef 66 01 48 	st.b	r7[328],r6
    if(MNS_FALSE != first_init)
8000c0b0:	4d 68       	lddpc	r8,8000c208 <InitNetServices+0x280>
8000c0b2:	2f ad       	sub	sp,-24
8000c0b4:	11 89       	ld.ub	r9,r8[0x0]
8000c0b6:	ec 09 18 00 	cp.b	r9,r6
8000c0ba:	c0 50       	breq	8000c0c4 <InitNetServices+0x13c>
    {
        mns.pending_mdm = MNS_FALSE;
        first_init      = MNS_FALSE;
8000c0bc:	b0 86       	st.b	r8[0x0],r6
    mns.services.ms_packet_layers   = MNS_FALSE;
    mns.buf_freed                   = MNS_FALSE;
    mns.remote_access               = MNS_DENY;
    if(MNS_FALSE != first_init)
    {
        mns.pending_mdm = MNS_FALSE;
8000c0be:	4d 28       	lddpc	r8,8000c204 <InitNetServices+0x27c>
8000c0c0:	f1 66 01 49 	st.b	r8[329],r6
        first_init      = MNS_FALSE;
    }
    GIVE_MNS();
8000c0c4:	30 8c       	mov	r12,8
8000c0c6:	fe b0 dc f9 	rcall	80007ab8 <mns_give>

    TAKE_TM();
8000c0ca:	30 9c       	mov	r12,9
8000c0cc:	fe b0 dc f5 	rcall	80007ab6 <mns_take>
    mns.tm.last_tick    = temp_tick_count;
    mns.tm.diff         = 0;
8000c0d0:	30 08       	mov	r8,0
    mns.tm.scheduled_timeout = 0;
    #ifndef PACKET_COMMUNICATION_ONLY
    mns.tm.flags        = 0;
    #endif

    mns.wd.flags        = 0;
8000c0d2:	ef 68 00 50 	st.b	r7[80],r8
    }
    GIVE_MNS();

    TAKE_TM();
    mns.tm.last_tick    = temp_tick_count;
    mns.tm.diff         = 0;
8000c0d6:	ef 58 00 40 	st.h	r7[64],r8
    mns.tm.min_timeout  = 0;
8000c0da:	ef 58 00 42 	st.h	r7[66],r8
    mns.tm.scheduled_timeout = 0;
8000c0de:	ef 58 00 44 	st.h	r7[68],r8
    #ifndef PACKET_COMMUNICATION_ONLY
    mns.tm.flags        = 0;
8000c0e2:	ef 68 00 46 	st.b	r7[70],r8

    mns.wd.flags        = 0;
    mns.timer.first_ptr = NULL;

    #ifndef MNS_DISABLE_WD_SUPERVISION
    mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable counting during initialization */
8000c0e6:	3f f8       	mov	r8,-1
    #ifndef PACKET_COMMUNICATION_ONLY
    mns.tm.flags        = 0;
    #endif

    mns.wd.flags        = 0;
    mns.timer.first_ptr = NULL;
8000c0e8:	30 06       	mov	r6,0

    #ifndef MNS_DISABLE_WD_SUPERVISION
    mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable counting during initialization */
8000c0ea:	ef 58 00 3a 	st.h	r7[58],r8
    #ifndef PACKET_COMMUNICATION_ONLY
    mns.tm.flags        = 0;
    #endif

    mns.wd.flags        = 0;
    mns.timer.first_ptr = NULL;
8000c0ee:	ef 46 00 54 	st.w	r7[84],r6

    #ifndef MNS_DISABLE_WD_SUPERVISION
    mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable counting during initialization */
    mns.watchdogmode.tx_busy_cnt     = MNS_WD_SUPERVIS_CNT_START;   /* reset counter */
8000c0f2:	ef 56 00 3c 	st.h	r7[60],r6
    #endif
    GIVE_TM();
8000c0f6:	30 9c       	mov	r12,9
        first_init      = MNS_FALSE;
    }
    GIVE_MNS();

    TAKE_TM();
    mns.tm.last_tick    = temp_tick_count;
8000c0f8:	ef 54 00 3e 	st.h	r7[62],r4

    #ifndef MNS_DISABLE_WD_SUPERVISION
    mns.watchdogmode.max_tx_busy_cnt = MNS_WD_SUPERVIS_CNT_DISABLE; /* disable counting during initialization */
    mns.watchdogmode.tx_busy_cnt     = MNS_WD_SUPERVIS_CNT_START;   /* reset counter */
    #endif
    GIVE_TM();
8000c0fc:	fe b0 dc de 	rcall	80007ab8 <mns_give>

    MostRegisterTimer(&(mns.timer.init), MnsSetPendingEvent, MNS_P_INIT_TIMER);
8000c100:	ee c5 ff a8 	sub	r5,r7,-88
8000c104:	34 0a       	mov	r10,64
8000c106:	fe cb 0d 26 	sub	r11,pc,3366
8000c10a:	0a 9c       	mov	r12,r5
8000c10c:	fe b0 f8 44 	rcall	8000b194 <MostRegisterTimer>
    MostRegisterTimer(&(mns.timer.watchdog), MnsSetPendingEvent,
8000c110:	fe cb 0d 30 	sub	r11,pc,3376
8000c114:	ee cc ff 94 	sub	r12,r7,-108
8000c118:	e0 6a 04 00 	mov	r10,1024
        MNS_P_WATCHDOG_TIMER);

    #ifndef PACKET_COMMUNICATION_ONLY
        MostSetTimer(&(mns.timer.init), MNS_INIT_TIMER, MNS_FALSE);
8000c11c:	fe b0 f8 3c 	rcall	8000b194 <MostRegisterTimer>
8000c120:	0c 9a       	mov	r10,r6
8000c122:	0a 9c       	mov	r12,r5
8000c124:	e0 6b 0b b8 	mov	r11,3000
        mns.services.pending = MNS_P_NONE;
        mns.services.latest  = MNS_P_NONE;
    GIVE_SERVICES();

    MnsInit();
    MisInit(&(mns.config.lld), &(mns.config.pms), &(mns.config.msg)
8000c128:	fe b0 f7 c0 	rcall	8000b0a8 <MostSetTimer>
8000c12c:	ee ca ff 2c 	sub	r10,r7,-212
8000c130:	ee cb ff 30 	sub	r11,r7,-208
8000c134:	ee cc ff 50 	sub	r12,r7,-176
            , &(mns.config.mdm)
            #endif
            );

    #if (defined NS_MNS_MNS2) && (defined CMD_MIN)
        mns.config.msg.rx_complete_fptr = MsgRxOutMsg;
8000c138:	fe b0 f4 86 	rcall	8000aa44 <MisInit>
8000c13c:	4b 48       	lddpc	r8,8000c20c <InitNetServices+0x284>
8000c13e:	0c 9c       	mov	r12,r6
    #endif

    #ifdef MNS_104
        temp_msg_ptr    = MsgGetTxPtrExt(0);
8000c140:	ef 48 00 dc 	st.w	r7[220],r8
8000c144:	fe b0 e6 ac 	rcall	80008e9c <MsgGetTxPtrExt>
        /*lint -e{413} See ASSERT */
        temp_msg_handle = temp_msg_ptr ? MbmGetHandleByMsgPtr(temp_msg_ptr) : NULL;
8000c148:	18 96       	mov	r6,r12
8000c14a:	c4 30       	breq	8000c1d0 <InitNetServices+0x248>
8000c14c:	fe b0 ee 2e 	rcall	80009da8 <MbmGetHandleByMsgPtr>
        ASSERT(temp_msg_ptr && temp_msg_handle);
        if(temp_msg_ptr && temp_msg_handle)
        {
            TAKE_TM();
8000c150:	18 95       	mov	r5,r12
8000c152:	c5 70       	breq	8000c200 <InitNetServices+0x278>
8000c154:	30 9c       	mov	r12,9
            mns.wd.msg_ptr = temp_msg_ptr;
8000c156:	fe b0 dc b0 	rcall	80007ab6 <mns_take>
            mns.wd.handle  = temp_msg_handle;
8000c15a:	ef 46 00 48 	st.w	r7[72],r6
            mns.wd.msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000c15e:	ef 45 00 4c 	st.w	r7[76],r5
            mns.wd.msg_ptr->FBlock_ID = FBLOCK_INIC;
8000c162:	30 18       	mov	r8,1
8000c164:	ac 38       	st.h	r6[0x6],r8
8000c166:	6f 29       	ld.w	r9,r7[0x48]
8000c168:	30 08       	mov	r8,0
            mns.wd.msg_ptr->Inst_ID   = 0;
8000c16a:	f3 68 00 0a 	st.b	r9[10],r8
8000c16e:	6f 29       	ld.w	r9,r7[0x48]
            mns.wd.msg_ptr->Func_ID   = FUNCID_INIC_WATCHDOG;
8000c170:	f3 68 00 0b 	st.b	r9[11],r8
8000c174:	6f 29       	ld.w	r9,r7[0x48]
8000c176:	e0 6a 03 09 	mov	r10,777
            mns.wd.msg_ptr->Operation = OP_START;
            GIVE_TM();
8000c17a:	b2 4a       	st.h	r9[0x8],r10
            mns.wd.handle  = temp_msg_handle;
            mns.wd.msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
            mns.wd.msg_ptr->FBlock_ID = FBLOCK_INIC;
            mns.wd.msg_ptr->Inst_ID   = 0;
            mns.wd.msg_ptr->Func_ID   = FUNCID_INIC_WATCHDOG;
            mns.wd.msg_ptr->Operation = OP_START;
8000c17c:	6f 29       	ld.w	r9,r7[0x48]
8000c17e:	30 9c       	mov	r12,9
            GIVE_TM();
8000c180:	f3 68 00 0c 	st.b	r9[12],r8
        }
    #endif


    #ifdef AMS_MIN
        MsgInit(&(mns.config.msg));
8000c184:	fe b0 dc 9a 	rcall	80007ab8 <mns_give>
8000c188:	ee cc ff 2c 	sub	r12,r7,-212
    #endif
    #ifdef MCS_MIN
        WmcsInit();
8000c18c:	fe b0 ed 3e 	rcall	80009c08 <MsgInit>
    #endif
    #ifdef ADS_MIN
        DataInit(&(mns.config.wads));
8000c190:	e0 a0 2f e6 	rcall	8001215c <WmcsInit>
8000c194:	ee cc ff 0c 	sub	r12,r7,-244
    #endif
    #ifdef VMSV_MIN
        VmsvInit(&(mns.config.vmsv));
8000c198:	e0 a0 29 f2 	rcall	8001157c <DataInit>
8000c19c:	ee cc fe fc 	sub	r12,r7,-260
    #endif

    #ifdef SCM_MIN
        if (PMS_IFACE_I2C == mns.config.lld.ctrl_interface_id)
8000c1a0:	e0 a0 28 46 	rcall	8001122c <VmsvInit>
8000c1a4:	ef 38 00 cc 	ld.ub	r8,r7[204]
        {
            mns.config.scm.packet.mode = SCM_PM_NONE;
8000c1a8:	58 08       	cp.w	r8,0
8000c1aa:	c0 41       	brne	8000c1b2 <InitNetServices+0x22a>
8000c1ac:	49 69       	lddpc	r9,8000c204 <InitNetServices+0x27c>
        }
        ScmInit(&(mns.config.scm));
8000c1ae:	f3 68 01 38 	st.b	r9[312],r8
8000c1b2:	ee cc fe d4 	sub	r12,r7,-300
    #endif
    #ifdef AAM_MIN
        AamInit();
    #endif

    GIVE_MS();
8000c1b6:	e0 a0 3c 3b 	rcall	80013a2c <ScmInit>
8000c1ba:	30 5c       	mov	r12,5
    T_API_EXIT(MNS_0);
}
8000c1bc:	fe b0 dc 7e 	rcall	80007ab8 <mns_give>
    /* check for valid timeout */
    if (((MNS_TM_WD_MIN_TIMEOUT > mns.config.general.watchdogmode.timeout)  ||
         (MNS_TM_WD_MAX_TIMEOUT < mns.config.general.watchdogmode.timeout)) &&
        (MNS_TM_WD_DISABLE    != mns.config.general.watchdogmode.timeout))
    {
        mns.config.general.watchdogmode.timeout = MNS_TM_WD_MAX_TIMEOUT;
8000c1c0:	d8 22       	popm	r4-r7,pc
8000c1c2:	e0 68 01 f4 	mov	r8,500
8000c1c6:	ef 58 00 a6 	st.h	r7[166],r8
8000c1ca:	e0 68 01 77 	mov	r8,375
    #endif

    #ifdef MNS_104
        temp_msg_ptr    = MsgGetTxPtrExt(0);
        /*lint -e{413} See ASSERT */
        temp_msg_handle = temp_msg_ptr ? MbmGetHandleByMsgPtr(temp_msg_ptr) : NULL;
8000c1ce:	c3 8b       	rjmp	8000c03e <InitNetServices+0xb6>
        ASSERT(temp_msg_ptr && temp_msg_handle);
8000c1d0:	18 94       	mov	r4,r12
8000c1d2:	18 95       	mov	r5,r12
8000c1d4:	e0 68 01 36 	mov	r8,310
8000c1d8:	30 1a       	mov	r10,1
8000c1da:	1a d8       	st.w	--sp,r8
8000c1dc:	31 0b       	mov	r11,16
8000c1de:	30 4c       	mov	r12,4
        if(temp_msg_ptr && temp_msg_handle)
8000c1e0:	fe b0 dc 86 	rcall	80007aec <mns_trace>
8000c1e4:	2f fd       	sub	sp,-4
8000c1e6:	58 04       	cp.w	r4,0
        temp_tick_count = mns.config.general.get_tick_count_fptr();
    }
    else
    {
        /* get_tick_count_fptr is mandatory ! */
        FAILED_ASSERT();
8000c1e8:	cd 00       	breq	8000c188 <InitNetServices+0x200>
8000c1ea:	cb 5b       	rjmp	8000c154 <InitNetServices+0x1cc>
8000c1ec:	e0 68 04 10 	mov	r8,1040
8000c1f0:	30 1a       	mov	r10,1
8000c1f2:	1a d8       	st.w	--sp,r8
8000c1f4:	31 0b       	mov	r11,16
8000c1f6:	30 4c       	mov	r12,4
8000c1f8:	fe b0 dc 7a 	rcall	80007aec <mns_trace>

    #ifdef MNS_104
        temp_msg_ptr    = MsgGetTxPtrExt(0);
        /*lint -e{413} See ASSERT */
        temp_msg_handle = temp_msg_ptr ? MbmGetHandleByMsgPtr(temp_msg_ptr) : NULL;
        ASSERT(temp_msg_ptr && temp_msg_handle);
8000c1fc:	2f fd       	sub	sp,-4
8000c1fe:	c0 6b       	rjmp	8000c00a <InitNetServices+0x82>
8000c200:	18 94       	mov	r4,r12
8000c202:	ce 9b       	rjmp	8000c1d4 <InitNetServices+0x24c>
8000c204:	00 00       	add	r0,r0
8000c206:	35 94       	mov	r4,89
8000c208:	00 00       	add	r0,r0
8000c20a:	00 a8       	st.w	r0++,r8
8000c20c:	80 01       	ld.sh	r1,r0[0x0]
8000c20e:	42 ac       	lddsp	r12,sp[0xa8]

8000c210 <MostService>:
8000c210:	d4 31       	pushm	r0-r7,lr
8000c212:	20 3d       	sub	sp,12
8000c214:	30 5c       	mov	r12,5
8000c216:	fe b0 dc 50 	rcall	80007ab6 <mns_take>
8000c21a:	30 9c       	mov	r12,9
8000c21c:	fe b0 dc 4d 	rcall	80007ab6 <mns_take>
8000c220:	fe b0 f6 8e 	rcall	8000af3c <MnsTMDiff>
8000c224:	30 9c       	mov	r12,9
8000c226:	fe b0 dc 49 	rcall	80007ab8 <mns_give>
8000c22a:	fe f6 06 1e 	ld.w	r6,pc[1566]
8000c22e:	30 03       	mov	r3,0
8000c230:	ec c8 ff a8 	sub	r8,r6,-88
8000c234:	0c 94       	mov	r4,r6
8000c236:	06 95       	mov	r5,r3
8000c238:	3f f0       	mov	r0,-1
8000c23a:	fe f2 06 12 	ld.w	r2,pc[1554]
8000c23e:	ec c7 ff f2 	sub	r7,r6,-14
8000c242:	50 18       	stdsp	sp[0x4],r8
    T_MOD_ENTRY(MNS_117);

    fire_callback = MNS_FALSE;
    terminated = MNS_FALSE;

    TAKE_MNS();
8000c244:	30 8c       	mov	r12,8
8000c246:	fe b0 dc 38 	rcall	80007ab6 <mns_take>
    if(MNS_FALSE != mns.stopped)
8000c24a:	fe f1 05 fe 	ld.w	r1,pc[1534]
8000c24e:	ed 38 01 44 	ld.ub	r8,r6[324]
8000c252:	ea 08 18 00 	cp.b	r8,r5
8000c256:	c0 c0       	breq	8000c26e <MostService+0x5e>
    {
        if (MNS_FALSE != mns.signaled_ns_stopped)
8000c258:	e9 38 01 45 	ld.ub	r8,r4[325]
8000c25c:	ea 08 18 00 	cp.b	r8,r5
8000c260:	c4 f1       	brne	8000c2fe <MostService+0xee>
        {
            terminated = MNS_TRUE;
        }
        else if (EHCISTATE_UNKNOWN == mns.shadow.ehci_state)
8000c262:	e9 38 00 18 	ld.ub	r8,r4[24]
8000c266:	e0 08 18 00 	cp.b	r8,r0
8000c26a:	e0 80 00 8a 	breq	8000c37e <MostService+0x16e>
            terminated = MNS_TRUE;
            fire_callback = MNS_TRUE;
            mns.signaled_ns_stopped = MNS_TRUE;
        }
    }
    GIVE_MNS();
8000c26e:	30 8c       	mov	r12,8
8000c270:	fe b0 dc 24 	rcall	80007ab8 <mns_give>

    T_MOD_ENTRY(MNS_5);

    result = MNS_P_NONE;

    if (MNS_FALSE == run_high_prio)
8000c274:	05 88       	ld.ub	r8,r2[0x0]
8000c276:	ea 08 18 00 	cp.b	r8,r5
8000c27a:	c5 f0       	breq	8000c338 <MostService+0x128>
                                           MNS_P_SRV_MNS);
        run_high_prio = (MNS_P_NONE != result) ? MNS_TRUE : MNS_FALSE;
    }
    else
    {
        run_high_prio = MNS_FALSE;
8000c27c:	a4 85       	st.b	r2[0x0],r5
    }

    if (MNS_FALSE == run_high_prio)
    {
        result = MnsGetNextEventFlagToCall(MX_MNS_PS,
8000c27e:	e0 68 01 00 	mov	r8,256
8000c282:	30 19       	mov	r9,1
8000c284:	0e 9a       	mov	r10,r7
8000c286:	ec cb ff f4 	sub	r11,r6,-12
8000c28a:	30 6c       	mov	r12,6
8000c28c:	fe b0 f7 d8 	rcall	8000b23c <MnsGetNextEventFlagToCall>
            service_to_run = MnsGetNextServiceToCall();
            request_flag   = MNS_FALSE;

            T_MOST_SERVICE(service_to_run);

            switch (service_to_run)
8000c290:	30 88       	mov	r8,8
        run_high_prio = MNS_FALSE;
    }

    if (MNS_FALSE == run_high_prio)
    {
        result = MnsGetNextEventFlagToCall(MX_MNS_PS,
8000c292:	5c 8c       	casts.h	r12
            service_to_run = MnsGetNextServiceToCall();
            request_flag   = MNS_FALSE;

            T_MOST_SERVICE(service_to_run);

            switch (service_to_run)
8000c294:	f0 0c 19 00 	cp.h	r12,r8
8000c298:	c6 60       	breq	8000c364 <MostService+0x154>
8000c29a:	f0 0c 19 00 	cp.h	r12,r8
8000c29e:	e0 8b 00 3b 	brhi	8000c314 <MostService+0x104>
8000c2a2:	30 28       	mov	r8,2
8000c2a4:	f0 0c 19 00 	cp.h	r12,r8
8000c2a8:	e0 80 00 b0 	breq	8000c408 <MostService+0x1f8>
8000c2ac:	30 48       	mov	r8,4
8000c2ae:	f0 0c 19 00 	cp.h	r12,r8
8000c2b2:	c7 40       	breq	8000c39a <MostService+0x18a>
8000c2b4:	30 18       	mov	r8,1
8000c2b6:	f0 0c 19 00 	cp.h	r12,r8
8000c2ba:	c5 f0       	breq	8000c378 <MostService+0x168>
                        break;
                #endif

                default:
                    /* unknown service */
                    ASSERT(!service_to_run);
8000c2bc:	58 0c       	cp.w	r12,0
8000c2be:	e0 81 00 be 	brne	8000c43a <MostService+0x22a>
                    break;
            }

            TAKE_SERVICES();
8000c2c2:	30 6c       	mov	r12,6
8000c2c4:	fe b0 db f9 	rcall	80007ab6 <mns_take>
            request_flag = (MNS_P_NONE != mns.services.pending) ? MNS_TRUE : MNS_FALSE;
            GIVE_SERVICES();
8000c2c8:	30 6c       	mov	r12,6
                    ASSERT(!service_to_run);
                    break;
            }

            TAKE_SERVICES();
            request_flag = (MNS_P_NONE != mns.services.pending) ? MNS_TRUE : MNS_FALSE;
8000c2ca:	8c 61       	ld.sh	r1,r6[0xc]
            GIVE_SERVICES();
8000c2cc:	fe b0 db f6 	rcall	80007ab8 <mns_give>

            count++;
            if (MNS_FALSE != request_flag)
8000c2d0:	58 01       	cp.w	r1,0
8000c2d2:	c1 90       	breq	8000c304 <MostService+0xf4>

            TAKE_SERVICES();
            request_flag = (MNS_P_NONE != mns.services.pending) ? MNS_TRUE : MNS_FALSE;
            GIVE_SERVICES();

            count++;
8000c2d4:	2f f3       	sub	r3,-1
            if (MNS_FALSE != request_flag)
            {
                if (count >= mns.config.general.burst)
8000c2d6:	e9 38 00 ac 	ld.ub	r8,r4[172]

            TAKE_SERVICES();
            request_flag = (MNS_P_NONE != mns.services.pending) ? MNS_TRUE : MNS_FALSE;
            GIVE_SERVICES();

            count++;
8000c2da:	5c 53       	castu.b	r3
            if (MNS_FALSE != request_flag)
            {
                if (count >= mns.config.general.burst)
8000c2dc:	e6 08 18 00 	cp.b	r8,r3
8000c2e0:	fe 9b ff b2 	brhi	8000c244 <MostService+0x34>
                {
                    ASSERT(mns.config.general.most_service_request_fptr);
8000c2e4:	e8 f8 00 84 	ld.w	r8,r4[132]
8000c2e8:	58 08       	cp.w	r8,0
8000c2ea:	e0 80 00 99 	breq	8000c41c <MostService+0x20c>
                    if (mns.config.general.most_service_request_fptr)
                    {
                        mns.config.general.most_service_request_fptr();
8000c2ee:	5d 18       	icall	r8
        else
        {
            count = mns.config.general.burst;
        }

    } while (count < mns.config.general.burst);
8000c2f0:	ed 38 00 ac 	ld.ub	r8,r6[172]
8000c2f4:	e6 08 18 00 	cp.b	r8,r3
8000c2f8:	fe 9b ff a6 	brhi	8000c244 <MostService+0x34>
8000c2fc:	c0 48       	rjmp	8000c304 <MostService+0xf4>
            terminated = MNS_TRUE;
            fire_callback = MNS_TRUE;
            mns.signaled_ns_stopped = MNS_TRUE;
        }
    }
    GIVE_MNS();
8000c2fe:	30 8c       	mov	r12,8
8000c300:	fe b0 db dc 	rcall	80007ab8 <mns_give>
            count = mns.config.general.burst;
        }

    } while (count < mns.config.general.burst);

    MnsTMHandleEvent(MNS_TM_EV_SCHEDULE);
8000c304:	30 4c       	mov	r12,4
8000c306:	fe b0 f6 4d 	rcall	8000afa0 <MnsTMHandleEvent>

    GIVE_MS();
8000c30a:	30 5c       	mov	r12,5
8000c30c:	fe b0 db d6 	rcall	80007ab8 <mns_give>

    T_API_EXIT(MNS_1);
}
8000c310:	2f dd       	sub	sp,-12
8000c312:	d8 32       	popm	r0-r7,pc
            service_to_run = MnsGetNextServiceToCall();
            request_flag   = MNS_FALSE;

            T_MOST_SERVICE(service_to_run);

            switch (service_to_run)
8000c314:	32 08       	mov	r8,32
8000c316:	f0 0c 19 00 	cp.h	r12,r8
8000c31a:	c7 10       	breq	8000c3fc <MostService+0x1ec>
8000c31c:	e0 88 00 27 	brls	8000c36a <MostService+0x15a>
8000c320:	34 08       	mov	r8,64
8000c322:	f0 0c 19 00 	cp.h	r12,r8
8000c326:	c6 e0       	breq	8000c402 <MostService+0x1f2>
8000c328:	e0 68 00 80 	mov	r8,128
8000c32c:	f0 0c 19 00 	cp.h	r12,r8
8000c330:	cc 61       	brne	8000c2bc <MostService+0xac>
                        break;
                #endif

                #ifdef SCM_MIN
                    case MNS_P_SRV_WSCM:
                        ScmService();
8000c332:	e0 a0 3a 51 	rcall	800137d4 <ScmService>
                        break;
8000c336:	cc 6b       	rjmp	8000c2c2 <MostService+0xb2>

    result = MNS_P_NONE;

    if (MNS_FALSE == run_high_prio)
    {
        word latest_called_dummy = MNS_P_NONE;
8000c338:	30 01       	mov	r1,0
8000c33a:	fa ca ff f4 	sub	r10,sp,-12

        result = MnsGetNextEventFlagToCall(MX_MNS_PS,
8000c33e:	30 48       	mov	r8,4

    result = MNS_P_NONE;

    if (MNS_FALSE == run_high_prio)
    {
        word latest_called_dummy = MNS_P_NONE;
8000c340:	14 e1       	st.h	--r10,r1

        result = MnsGetNextEventFlagToCall(MX_MNS_PS,
8000c342:	30 19       	mov	r9,1
8000c344:	ec cb ff f4 	sub	r11,r6,-12
8000c348:	30 6c       	mov	r12,6
8000c34a:	fe b0 f7 79 	rcall	8000b23c <MnsGetNextEventFlagToCall>
8000c34e:	5c 8c       	casts.h	r12
                                           &mns.services.pending,
                                           &latest_called_dummy,
                                           MNS_P_SRV_PMS,
                                           MNS_P_SRV_MNS);
        run_high_prio = (MNS_P_NONE != result) ? MNS_TRUE : MNS_FALSE;
8000c350:	e2 0c 19 00 	cp.h	r12,r1
8000c354:	5f 18       	srne	r8
8000c356:	a4 88       	st.b	r2[0x0],r8
    else
    {
        run_high_prio = MNS_FALSE;
    }

    if (MNS_FALSE == run_high_prio)
8000c358:	58 08       	cp.w	r8,0
8000c35a:	c9 20       	breq	8000c27e <MostService+0x6e>
            service_to_run = MnsGetNextServiceToCall();
            request_flag   = MNS_FALSE;

            T_MOST_SERVICE(service_to_run);

            switch (service_to_run)
8000c35c:	30 88       	mov	r8,8
8000c35e:	f0 0c 19 00 	cp.h	r12,r8
8000c362:	c9 c1       	brne	8000c29a <MostService+0x8a>
                    break;
                #endif

                #ifdef AMS_MIN
                case MNS_P_SRV_AMS:
                    MsgService();
8000c364:	fe b0 eb 5c 	rcall	80009a1c <MsgService>
                    break;
8000c368:	ca db       	rjmp	8000c2c2 <MostService+0xb2>
            service_to_run = MnsGetNextServiceToCall();
            request_flag   = MNS_FALSE;

            T_MOST_SERVICE(service_to_run);

            switch (service_to_run)
8000c36a:	31 08       	mov	r8,16
8000c36c:	f0 0c 19 00 	cp.h	r12,r8
8000c370:	ca 61       	brne	8000c2bc <MostService+0xac>
                    MsgService();
                    break;
                #endif
                #ifdef MCS_MIN
                case MNS_P_SRV_WMCS:
                    WmcsService();
8000c372:	e0 a0 2d e9 	rcall	80011f44 <WmcsService>
                    break;
8000c376:	ca 6b       	rjmp	8000c2c2 <MostService+0xb2>

            switch (service_to_run)
            {
                #ifdef PMS_MIN
                    case MNS_P_SRV_PMS:
                        PmsService();
8000c378:	e0 a0 0a a0 	rcall	8000d8b8 <PmsService>
                        break;
8000c37c:	ca 3b       	rjmp	8000c2c2 <MostService+0xb2>
        }
        else if (EHCISTATE_UNKNOWN == mns.shadow.ehci_state)
        {
            terminated = MNS_TRUE;
            fire_callback = MNS_TRUE;
            mns.signaled_ns_stopped = MNS_TRUE;
8000c37e:	30 18       	mov	r8,1
        }
    }
    GIVE_MNS();
8000c380:	30 8c       	mov	r12,8
        }
        else if (EHCISTATE_UNKNOWN == mns.shadow.ehci_state)
        {
            terminated = MNS_TRUE;
            fire_callback = MNS_TRUE;
            mns.signaled_ns_stopped = MNS_TRUE;
8000c382:	e3 68 01 45 	st.b	r1[325],r8
        }
    }
    GIVE_MNS();
8000c386:	fe b0 db 99 	rcall	80007ab8 <mns_give>
static _INLINE void MnsPrepareReInit(void)
{
    T_MOD_ENTRY(MNS_116);

    #ifdef PMS_46
    PmsPrepareReInit();
8000c38a:	e0 a0 02 63 	rcall	8000c850 <PmsPrepareReInit>

    if (MNS_FALSE != fire_callback)
    {
        MnsPrepareReInit();

        if (NULL != mns.config.general.on_stop_netservices_fptr)
8000c38e:	e2 f8 00 8c 	ld.w	r8,r1[140]
8000c392:	58 08       	cp.w	r8,0
8000c394:	cb 80       	breq	8000c304 <MostService+0xf4>
        {
            mns.config.general.on_stop_netservices_fptr();
8000c396:	5d 18       	icall	r8
8000c398:	cb 6b       	rjmp	8000c304 <MostService+0xf4>
    T_MOD_ENTRY(MNS_8);

    result = MNS_P_NONE;
    run    = MNS_FALSE;

    TAKE_EVENTS();
8000c39a:	30 7c       	mov	r12,7
8000c39c:	fe b0 db 8d 	rcall	80007ab6 <mns_take>
    if ((MNS_FALSE == mns.services.ms_layer2) &&
8000c3a0:	ed 38 00 15 	ld.ub	r8,r6[21]
8000c3a4:	ea 08 18 00 	cp.b	r8,r5
8000c3a8:	c3 30       	breq	8000c40e <MostService+0x1fe>
8000c3aa:	88 01       	ld.sh	r1,r4[0x0]
        (mns.events.pending & MNS_P_L2))
    {
        mns.events.pending &= ~MNS_P_L2;
    }
    if ((MNS_FALSE == mns.services.ms_packet_layers) &&
8000c3ac:	ed 38 00 16 	ld.ub	r8,r6[22]
8000c3b0:	ea 08 18 00 	cp.b	r8,r5
8000c3b4:	c0 81       	brne	8000c3c4 <MostService+0x1b4>
8000c3b6:	02 98       	mov	r8,r1
8000c3b8:	e2 18 03 00 	andl	r8,0x300,COH
8000c3bc:	c0 40       	breq	8000c3c4 <MostService+0x1b4>
        (mns.events.pending & MNS_P_PACKET_LAYERS))
    {
        mns.events.pending &= ~MNS_P_PACKET_LAYERS;
8000c3be:	e0 11 fc ff 	andl	r1,0xfcff
8000c3c2:	a8 01       	st.h	r4[0x0],r1
    }
    run = mns.events.pending ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
8000c3c4:	30 7c       	mov	r12,7
8000c3c6:	fe b0 db 79 	rcall	80007ab8 <mns_give>

    if (run)
8000c3ca:	58 01       	cp.w	r1,0
8000c3cc:	c4 11       	brne	8000c44e <MostService+0x23e>
            #endif
        }
            break;

        default:
            FAILED_ASSERT();
8000c3ce:	e0 68 03 65 	mov	r8,869
8000c3d2:	30 1a       	mov	r10,1
8000c3d4:	1a d8       	st.w	--sp,r8
8000c3d6:	31 0b       	mov	r11,16
8000c3d8:	30 4c       	mov	r12,4
8000c3da:	fe b0 db 89 	rcall	80007aec <mns_trace>
8000c3de:	2f fd       	sub	sp,-4
            event_to_handle = MNS_P_NONE;
            break;
    }

    TAKE_EVENTS();
8000c3e0:	30 7c       	mov	r12,7
8000c3e2:	fe b0 db 6a 	rcall	80007ab6 <mns_take>
    request_flag = (MNS_P_NONE != mns.events.pending) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
8000c3e6:	30 7c       	mov	r12,7
            event_to_handle = MNS_P_NONE;
            break;
    }

    TAKE_EVENTS();
    request_flag = (MNS_P_NONE != mns.events.pending) ? MNS_TRUE : MNS_FALSE;
8000c3e8:	8c 01       	ld.sh	r1,r6[0x0]
    GIVE_EVENTS();
8000c3ea:	fe b0 db 67 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != request_flag)
8000c3ee:	58 01       	cp.w	r1,0
8000c3f0:	fe 90 ff 69 	breq	8000c2c2 <MostService+0xb2>
    {
        MnsSetPendingService(MNS_P_SRV_MNS);
8000c3f4:	30 4c       	mov	r12,4
8000c3f6:	fe b0 f7 89 	rcall	8000b308 <MnsSetPendingService>
8000c3fa:	c6 4b       	rjmp	8000c2c2 <MostService+0xb2>
                    WmcsService();
                    break;
                #endif
                #ifdef ADS_MIN
                    case MNS_P_SRV_WADS:
                        DataService();
8000c3fc:	e0 a0 28 94 	rcall	80011524 <DataService>
                        break;
8000c400:	c6 1b       	rjmp	8000c2c2 <MostService+0xb2>
                #endif
                #ifdef VMSV_MIN
                    case MNS_P_SRV_VMSV:
                        VmsvService();
8000c402:	e0 a0 22 59 	rcall	800108b4 <VmsvService>
                        break;
8000c406:	c5 eb       	rjmp	8000c2c2 <MostService+0xb2>
                        break;
                #endif

                #ifdef MIS_MIN
                case MNS_P_SRV_MIS:
                    MisService();
8000c408:	fe b0 f2 78 	rcall	8000a8f8 <MisService>
                    break;
8000c40c:	c5 bb       	rjmp	8000c2c2 <MostService+0xb2>
    result = MNS_P_NONE;
    run    = MNS_FALSE;

    TAKE_EVENTS();
    if ((MNS_FALSE == mns.services.ms_layer2) &&
        (mns.events.pending & MNS_P_L2))
8000c40e:	88 01       	ld.sh	r1,r4[0x0]

    result = MNS_P_NONE;
    run    = MNS_FALSE;

    TAKE_EVENTS();
    if ((MNS_FALSE == mns.services.ms_layer2) &&
8000c410:	ed b1 00 07 	bld	r1,0x7
8000c414:	cc c1       	brne	8000c3ac <MostService+0x19c>
        (mns.events.pending & MNS_P_L2))
    {
        mns.events.pending &= ~MNS_P_L2;
8000c416:	a7 d1       	cbr	r1,0x7
8000c418:	a8 01       	st.h	r4[0x0],r1
8000c41a:	cc 9b       	rjmp	8000c3ac <MostService+0x19c>
            count++;
            if (MNS_FALSE != request_flag)
            {
                if (count >= mns.config.general.burst)
                {
                    ASSERT(mns.config.general.most_service_request_fptr);
8000c41c:	e0 68 01 d6 	mov	r8,470
8000c420:	30 1a       	mov	r10,1
8000c422:	1a d8       	st.w	--sp,r8
8000c424:	31 0b       	mov	r11,16
8000c426:	30 4c       	mov	r12,4
8000c428:	fe b0 db 62 	rcall	80007aec <mns_trace>
                    if (mns.config.general.most_service_request_fptr)
8000c42c:	e8 f8 00 84 	ld.w	r8,r4[132]
8000c430:	2f fd       	sub	sp,-4
8000c432:	58 08       	cp.w	r8,0
8000c434:	fe 90 ff 5e 	breq	8000c2f0 <MostService+0xe0>
8000c438:	c5 bb       	rjmp	8000c2ee <MostService+0xde>
                        break;
                #endif

                default:
                    /* unknown service */
                    ASSERT(!service_to_run);
8000c43a:	e0 68 01 c9 	mov	r8,457
8000c43e:	30 1a       	mov	r10,1
8000c440:	1a d8       	st.w	--sp,r8
8000c442:	31 0b       	mov	r11,16
8000c444:	30 4c       	mov	r12,4
8000c446:	fe b0 db 53 	rcall	80007aec <mns_trace>
8000c44a:	2f fd       	sub	sp,-4
8000c44c:	c3 bb       	rjmp	8000c2c2 <MostService+0xb2>
    run = mns.events.pending ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();

    if (run)
    {
        result = MnsGetNextEventFlagToCall(MX_MNS_PE,
8000c44e:	e0 68 40 00 	mov	r8,16384
8000c452:	fe f1 03 f6 	ld.w	r1,pc[1014]
8000c456:	30 19       	mov	r9,1
8000c458:	ec ca ff fe 	sub	r10,r6,-2
8000c45c:	02 9b       	mov	r11,r1
8000c45e:	30 7c       	mov	r12,7
8000c460:	fe b0 f6 ee 	rcall	8000b23c <MnsGetNextEventFlagToCall>
    event_to_handle = MnsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000c464:	34 08       	mov	r8,64
    run = mns.events.pending ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();

    if (run)
    {
        result = MnsGetNextEventFlagToCall(MX_MNS_PE,
8000c466:	5c 8c       	casts.h	r12
    event_to_handle = MnsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000c468:	f0 0c 19 00 	cp.h	r12,r8
8000c46c:	e0 80 00 a7 	breq	8000c5ba <MostService+0x3aa>
8000c470:	e0 8b 00 8e 	brhi	8000c58c <MostService+0x37c>
8000c474:	30 48       	mov	r8,4
8000c476:	f0 0c 19 00 	cp.h	r12,r8
8000c47a:	e0 80 00 c0 	breq	8000c5fa <MostService+0x3ea>
8000c47e:	e0 8b 01 10 	brhi	8000c69e <MostService+0x48e>
8000c482:	30 18       	mov	r8,1
8000c484:	f0 0c 19 00 	cp.h	r12,r8
8000c488:	e0 80 00 96 	breq	8000c5b4 <MostService+0x3a4>
8000c48c:	30 28       	mov	r8,2
8000c48e:	f0 0c 19 00 	cp.h	r12,r8
8000c492:	c9 e1       	brne	8000c3ce <MostService+0x1be>
{
    byte old_ehci_state;

    T_MOD_ENTRY(MNS_22);

    TAKE_EVENTS();
8000c494:	30 7c       	mov	r12,7
8000c496:	fe b0 db 10 	rcall	80007ab6 <mns_take>
    mns.events.ntf_state = NTF_NONE;
8000c49a:	30 08       	mov	r8,0
    GIVE_EVENTS();
8000c49c:	30 7c       	mov	r12,7
    byte old_ehci_state;

    T_MOD_ENTRY(MNS_22);

    TAKE_EVENTS();
    mns.events.ntf_state = NTF_NONE;
8000c49e:	89 28       	st.w	r4[0x8],r8
    GIVE_EVENTS();
8000c4a0:	fe b0 db 0c 	rcall	80007ab8 <mns_give>

    TAKE_TM();
8000c4a4:	30 9c       	mov	r12,9
8000c4a6:	fe b0 db 08 	rcall	80007ab6 <mns_take>
    mns.tm.scheduled_timeout = 0;
8000c4aa:	30 08       	mov	r8,0
    GIVE_TM();
8000c4ac:	30 9c       	mov	r12,9
    TAKE_EVENTS();
    mns.events.ntf_state = NTF_NONE;
    GIVE_EVENTS();

    TAKE_TM();
    mns.tm.scheduled_timeout = 0;
8000c4ae:	e9 58 00 44 	st.h	r4[68],r8
    GIVE_TM();
8000c4b2:	fe b0 db 03 	rcall	80007ab8 <mns_give>

    TAKE_MNS();
8000c4b6:	30 8c       	mov	r12,8
8000c4b8:	fe b0 da ff 	rcall	80007ab6 <mns_take>
    mns.shadow.version.public.hw = INIC_SHADOW_INVALID_BYTE;
8000c4bc:	3e e8       	mov	r8,-18
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
    {
        *tgt_ptr++ = value;
8000c4be:	e9 68 00 2c 	st.b	r4[44],r8
    TAKE_TM();
    mns.tm.scheduled_timeout = 0;
    GIVE_TM();

    TAKE_MNS();
    mns.shadow.version.public.hw = INIC_SHADOW_INVALID_BYTE;
8000c4c2:	e9 68 00 1c 	st.b	r4[28],r8
{
    /* Trace macros disabled for performance. */
    /* T_LIB_ENTRY(MNS_59); */
    while (size--)
    {
        *tgt_ptr++ = value;
8000c4c6:	e9 68 00 1d 	st.b	r4[29],r8
8000c4ca:	e9 68 00 1e 	st.b	r4[30],r8
8000c4ce:	e9 68 00 1f 	st.b	r4[31],r8
8000c4d2:	e9 68 00 20 	st.b	r4[32],r8
8000c4d6:	e9 68 00 21 	st.b	r4[33],r8
8000c4da:	e9 68 00 22 	st.b	r4[34],r8
8000c4de:	e9 68 00 27 	st.b	r4[39],r8
8000c4e2:	e9 68 00 28 	st.b	r4[40],r8
8000c4e6:	e9 68 00 29 	st.b	r4[41],r8
8000c4ea:	e9 68 00 2a 	st.b	r4[42],r8
8000c4ee:	e9 68 00 2b 	st.b	r4[43],r8
                (word)sizeof(mns.shadow.version.public.fw_date));
    MNS_MEM_SET(mns.shadow.version.public.cs, INIC_SHADOW_INVALID_BYTE,
                (word)sizeof(mns.shadow.version.public.cs));
    MNS_MEM_SET(mns.shadow.version.public.api, INIC_SHADOW_INVALID_BYTE,
                (word)sizeof(mns.shadow.version.public.api));
    mns.shadow.version.ntf_mask = NTF_MASK;
8000c4f2:	ec 78 b3 fb 	mov	r8,898043
8000c4f6:	89 c8       	st.w	r4[0x30],r8
    mns.shadow.version.feature_mask = INIC_SHADOW_INVALID_WORD;
8000c4f8:	fe 78 ee ee 	mov	r8,-4370
    GIVE_MNS();
8000c4fc:	30 8c       	mov	r12,8
    MNS_MEM_SET(mns.shadow.version.public.cs, INIC_SHADOW_INVALID_BYTE,
                (word)sizeof(mns.shadow.version.public.cs));
    MNS_MEM_SET(mns.shadow.version.public.api, INIC_SHADOW_INVALID_BYTE,
                (word)sizeof(mns.shadow.version.public.api));
    mns.shadow.version.ntf_mask = NTF_MASK;
    mns.shadow.version.feature_mask = INIC_SHADOW_INVALID_WORD;
8000c4fe:	e9 58 00 34 	st.h	r4[52],r8
    GIVE_MNS();
8000c502:	fe b0 da db 	rcall	80007ab8 <mns_give>

    /* Reset the PMS FIFO Interfaces to default */
    PmsSetFifoInterface( PMS_M_FIFO_CTRL, mns.config.lld.ctrl_interface_id );
8000c506:	e9 3b 00 cc 	ld.ub	r11,r4[204]
8000c50a:	e0 6c 00 c0 	mov	r12,192
8000c50e:	e0 a0 12 57 	rcall	8000e9bc <PmsSetFifoInterface>
    PmsSetFifoInterface( PMS_M_FIFO_DATA, mns.config.lld.data_interface_id );
8000c512:	e9 3b 00 cd 	ld.ub	r11,r4[205]
8000c516:	32 0c       	mov	r12,32
8000c518:	e0 a0 12 52 	rcall	8000e9bc <PmsSetFifoInterface>

    TAKE_MNS();
8000c51c:	30 8c       	mov	r12,8
8000c51e:	fe b0 da cc 	rcall	80007ab6 <mns_take>
    old_ehci_state = mns.shadow.ehci_state;
    mns.shadow.ehci_state = EHCISTATE_PROTECTED;
    mns.retry = 0;
8000c522:	30 08       	mov	r8,0
    /* Reset the PMS FIFO Interfaces to default */
    PmsSetFifoInterface( PMS_M_FIFO_CTRL, mns.config.lld.ctrl_interface_id );
    PmsSetFifoInterface( PMS_M_FIFO_DATA, mns.config.lld.data_interface_id );

    TAKE_MNS();
    old_ehci_state = mns.shadow.ehci_state;
8000c524:	e9 31 00 18 	ld.ub	r1,r4[24]
    mns.shadow.ehci_state = EHCISTATE_PROTECTED;
    mns.retry = 0;
8000c528:	e9 58 00 80 	st.h	r4[128],r8
    PmsSetFifoInterface( PMS_M_FIFO_CTRL, mns.config.lld.ctrl_interface_id );
    PmsSetFifoInterface( PMS_M_FIFO_DATA, mns.config.lld.data_interface_id );

    TAKE_MNS();
    old_ehci_state = mns.shadow.ehci_state;
    mns.shadow.ehci_state = EHCISTATE_PROTECTED;
8000c52c:	e9 68 00 18 	st.b	r4[24],r8
    mns.retry = 0;
    GIVE_MNS();
8000c530:	30 8c       	mov	r12,8
8000c532:	fe b0 da c3 	rcall	80007ab8 <mns_give>
    T_EHCISTATE_CHANGE(EHCISTATE_PROTECTED);
8000c536:	30 08       	mov	r8,0
8000c538:	1a d8       	st.w	--sp,r8
8000c53a:	30 38       	mov	r8,3
8000c53c:	30 2a       	mov	r10,2
8000c53e:	1a d8       	st.w	--sp,r8
8000c540:	30 fb       	mov	r11,15
8000c542:	30 4c       	mov	r12,4
8000c544:	fe b0 da d4 	rcall	80007aec <mns_trace>

    T_INIT_PHASE_CHANGE(mns.services.ms_init_mask);
8000c548:	e9 18 00 10 	ld.uh	r8,r4[16]
8000c54c:	1a d8       	st.w	--sp,r8
8000c54e:	30 68       	mov	r8,6
8000c550:	30 2a       	mov	r10,2
8000c552:	1a d8       	st.w	--sp,r8
8000c554:	30 fb       	mov	r11,15
8000c556:	30 4c       	mov	r12,4
8000c558:	fe b0 da ca 	rcall	80007aec <mns_trace>

    if (EHCISTATE_UNKNOWN != old_ehci_state)
8000c55c:	2f cd       	sub	sp,-16
8000c55e:	e0 01 18 00 	cp.b	r1,r0
8000c562:	c0 50       	breq	8000c56c <MostService+0x35c>
    {
        MnsReportError(NSR_E_REATTACH);
8000c564:	e0 6c 83 00 	mov	r12,33536
8000c568:	fe b0 f7 58 	rcall	8000b418 <MnsReportError>
    }

    MnsServiceInitComplete(MNS_PHASE_RESET, MNS_P_SRV_MNS);
8000c56c:	30 4b       	mov	r11,4
8000c56e:	30 1c       	mov	r12,1
8000c570:	fe b0 f9 a6 	rcall	8000b8bc <MnsServiceInitComplete>
    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_MNS);
8000c574:	30 4b       	mov	r11,4
8000c576:	30 2c       	mov	r12,2
8000c578:	fe b0 f9 a2 	rcall	8000b8bc <MnsServiceInitComplete>

    #ifndef PACKET_COMMUNICATION_ONLY
    MostSetTimer(&(mns.timer.init), MNS_INIT_TIMER, MNS_FALSE);
8000c57c:	30 0a       	mov	r10,0
8000c57e:	e0 6b 0b b8 	mov	r11,3000
8000c582:	ec cc ff a8 	sub	r12,r6,-88
8000c586:	fe b0 f5 91 	rcall	8000b0a8 <MostSetTimer>
8000c58a:	c2 bb       	rjmp	8000c3e0 <MostService+0x1d0>
    event_to_handle = MnsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000c58c:	e0 68 02 00 	mov	r8,512
8000c590:	f0 0c 19 00 	cp.h	r12,r8
8000c594:	fe 90 ff 26 	breq	8000c3e0 <MostService+0x1d0>
8000c598:	e0 8b 00 a9 	brhi	8000c6ea <MostService+0x4da>
8000c59c:	e0 68 00 80 	mov	r8,128
8000c5a0:	f0 0c 19 00 	cp.h	r12,r8
8000c5a4:	c6 20       	breq	8000c668 <MostService+0x458>
8000c5a6:	e0 68 01 00 	mov	r8,256
8000c5aa:	f0 0c 19 00 	cp.h	r12,r8
8000c5ae:	fe 91 ff 10 	brne	8000c3ce <MostService+0x1be>
8000c5b2:	c1 7b       	rjmp	8000c3e0 <MostService+0x1d0>
            (void)MnsEHCIGoProtected();
            break;

        #ifndef MNS_AVOID_ATTACH
            case MNS_P_AS_GO_SEMI_PROTECTED:
                (void)MnsEHCIGoSemiProtected();
8000c5b4:	fe b0 fc aa 	rcall	8000bf08 <MnsEHCIGoSemiProtected>
8000c5b8:	c1 4b       	rjmp	8000c3e0 <MostService+0x1d0>
        #ifndef MNS_AVOID_ATTACH
        case MNS_P_INIT_TIMER:
        {
            byte count;
            bool mns_stopped;
            MostClearTimer(&(mns.timer.init));
8000c5ba:	30 0a       	mov	r10,0
8000c5bc:	e2 cc ff a8 	sub	r12,r1,-88
8000c5c0:	14 9b       	mov	r11,r10
8000c5c2:	fe b0 f5 73 	rcall	8000b0a8 <MostSetTimer>
            MnsReportError(NSR_E_INIT_TIMEOUT);
8000c5c6:	e0 6c c3 04 	mov	r12,49924
8000c5ca:	fe b0 f7 27 	rcall	8000b418 <MnsReportError>
            MnsReportError(NSR_E_REATTACH);
8000c5ce:	e0 6c 83 00 	mov	r12,33536
8000c5d2:	fe b0 f7 23 	rcall	8000b418 <MnsReportError>
            #ifdef MNS_115
            MnsCheckNbminNotification();
            #endif

            GIVE_MS();
8000c5d6:	30 5c       	mov	r12,5
8000c5d8:	fe b0 da 70 	rcall	80007ab8 <mns_give>
static _INLINE void MnsPrepareReInit(void)
{
    T_MOD_ENTRY(MNS_116);

    #ifdef PMS_46
    PmsPrepareReInit();
8000c5dc:	c3 ad       	rcall	8000c850 <PmsPrepareReInit>
8000c5de:	fe b0 f0 83 	rcall	8000a6e4 <MisGetResetCount>

            GIVE_MS();

            MnsPrepareReInit();

            count = MisGetResetCount();
8000c5e2:	e3 37 01 44 	ld.ub	r7,r1[324]
            mns_stopped = mns.stopped;
8000c5e6:	50 0c       	stdsp	sp[0x0],r12
            InitNetServices();
8000c5e8:	fe b0 fc d0 	rcall	8000bf88 <InitNetServices>
8000c5ec:	e3 67 01 44 	st.b	r1[324],r7
            mns.stopped = mns_stopped;
8000c5f0:	40 0c       	lddsp	r12,sp[0x0]
            MisSetResetCount(count);
8000c5f2:	fe b0 f0 7f 	rcall	8000a6f0 <MisSetResetCount>
8000c5f6:	fe 9f fe 8d 	bral	8000c310 <MostService+0x100>
8000c5fa:	30 8c       	mov	r12,8
    T_MOD_ENTRY(MNS_51);

    retry  = 0;
    result = ERR_NO;

    TAKE_MNS();
8000c5fc:	fe b0 da 5d 	rcall	80007ab6 <mns_take>
8000c600:	30 8c       	mov	r12,8
    retry = mns.retry;
    GIVE_MNS();
8000c602:	e9 01 00 80 	ld.sh	r1,r4[128]

    retry  = 0;
    result = ERR_NO;

    TAKE_MNS();
    retry = mns.retry;
8000c606:	fe b0 da 59 	rcall	80007ab8 <mns_give>
    GIVE_MNS();
8000c60a:	5c 71       	castu.h	r1

    #ifndef MNS_AVOID_ATTACH
    PROCESS_RETRY    (MNS_RETRY_RESET_COMPLETE,     MnsResetComplete);
8000c60c:	ed b1 00 01 	bld	r1,0x1
8000c610:	e0 80 00 b1 	breq	8000c772 <MostService+0x562>
8000c614:	ed b1 00 02 	bld	r1,0x2
    PROCESS_RETRY    (MNS_RETRY_GO_SEMI_PROTECTED,  MnsEHCIGoSemiProtected);
8000c618:	e0 80 00 df 	breq	8000c7d6 <MostService+0x5c6>
8000c61c:	ed b1 00 03 	bld	r1,0x3
    PROCESS_RETRY    (MNS_RETRY_CHECK_WATCHDOGMODE, MnsCheckWatchdogMode);
8000c620:	e0 80 00 fd 	breq	8000c81a <MostService+0x60a>
8000c624:	ed b1 00 04 	bld	r1,0x4
    PROCESS_RETRY    (MNS_RETRY_REQ_EHCISTATE,      MnsRequestEHCIState);
8000c628:	e0 80 00 e8 	breq	8000c7f8 <MostService+0x5e8>
8000c62c:	ed b1 00 05 	bld	r1,0x5
    PROCESS_RETRY    (MNS_RETRY_FORCE_PROTECTED,    MnsForceProtected);
8000c630:	e0 80 00 c2 	breq	8000c7b4 <MostService+0x5a4>
8000c634:	ed b1 00 06 	bld	r1,0x6
    PROCESS_RETRY    (MNS_RETRY_REMOTE_ACCESS,      MnsEnforceRemoteAccess);
8000c638:	e0 80 00 ad 	breq	8000c792 <MostService+0x582>
8000c63c:	ec f8 00 98 	ld.w	r8,r6[152]

    switch (event_to_handle)
    {
        case MNS_P_BUF_FREED:
            #ifndef PACKET_COMMUNICATION_ONLY
            if ((ERR_NO == MnsRetry()) &&
8000c640:	58 08       	cp.w	r8,0
8000c642:	fe 90 fe cf 	breq	8000c3e0 <MostService+0x1d0>
8000c646:	fe b0 f4 55 	rcall	8000aef0 <MnsGetEHCIState>
                mns.config.general.on_buf_freed_fptr)
            {
                if (EHCISTATE_IS_ATTACHED())
8000c64a:	30 28       	mov	r8,2
8000c64c:	f0 0c 18 00 	cp.b	r12,r8
8000c650:	e0 80 00 f6 	breq	8000c83c <MostService+0x62c>
8000c654:	30 8c       	mov	r12,8
                {
                    mns.config.general.on_buf_freed_fptr();
                }
                else  /* can't call on_buf_freed callback */
                {
                    TAKE_MNS();
8000c656:	fe b0 da 30 	rcall	80007ab6 <mns_take>
8000c65a:	30 18       	mov	r8,1
                    mns.buf_freed = MNS_TRUE;      /* need to re-trigger callback when attached */
8000c65c:	30 8c       	mov	r12,8
                    GIVE_MNS();
8000c65e:	e9 68 01 47 	st.b	r4[327],r8
                    mns.config.general.on_buf_freed_fptr();
                }
                else  /* can't call on_buf_freed callback */
                {
                    TAKE_MNS();
                    mns.buf_freed = MNS_TRUE;      /* need to re-trigger callback when attached */
8000c662:	fe b0 da 2b 	rcall	80007ab8 <mns_give>
                    GIVE_MNS();
8000c666:	cb da       	rjmp	8000c3e0 <MostService+0x1d0>
8000c668:	30 08       	mov	r8,0

        case MNS_P_L2:
            #ifdef NS_MNS_MNS2
            {
                word sub_events = mns.events.pending_l2;
                mns.events.pending_l2 = MNS_P_NONE;
8000c66a:	88 2b       	ld.sh	r11,r4[0x4]
        #endif

        case MNS_P_L2:
            #ifdef NS_MNS_MNS2
            {
                word sub_events = mns.events.pending_l2;
8000c66c:	30 0c       	mov	r12,0
                mns.events.pending_l2 = MNS_P_NONE;

                T_L2_SERVICE(sub_events);
                if (MostServiceLayer2(0, sub_events))
8000c66e:	5c 7b       	castu.h	r11
8000c670:	a8 28       	st.h	r4[0x4],r8

        case MNS_P_L2:
            #ifdef NS_MNS_MNS2
            {
                word sub_events = mns.events.pending_l2;
                mns.events.pending_l2 = MNS_P_NONE;
8000c672:	e0 a0 43 05 	rcall	80014c7c <MostServiceLayer2>

                T_L2_SERVICE(sub_events);
                if (MostServiceLayer2(0, sub_events))
8000c676:	5c 8c       	casts.h	r12
8000c678:	fe 90 fe b4 	breq	8000c3e0 <MostService+0x1d0>
8000c67c:	30 7c       	mov	r12,7
                {
                    TAKE_EVENTS();
8000c67e:	fe b0 da 1c 	rcall	80007ab6 <mns_take>
8000c682:	88 28       	ld.sh	r8,r4[0x4]
                    mns.events.pending_l2 |= MNS2_E_PEN_EXTERN;
8000c684:	ea 18 ff ff 	orh	r8,0xffff
8000c688:	e8 18 80 00 	orl	r8,0x8000
8000c68c:	30 7c       	mov	r12,7
                    GIVE_EVENTS();
8000c68e:	a8 28       	st.h	r4[0x4],r8

                T_L2_SERVICE(sub_events);
                if (MostServiceLayer2(0, sub_events))
                {
                    TAKE_EVENTS();
                    mns.events.pending_l2 |= MNS2_E_PEN_EXTERN;
8000c690:	fe b0 da 14 	rcall	80007ab8 <mns_give>
                    GIVE_EVENTS();
8000c694:	e0 6c 00 80 	mov	r12,128
                    MnsSetPendingEvent(MNS_P_L2);
8000c698:	fe b0 f6 a4 	rcall	8000b3e0 <MnsSetPendingEvent>
8000c69c:	ca 2a       	rjmp	8000c3e0 <MostService+0x1d0>
8000c69e:	30 88       	mov	r8,8
    event_to_handle = MnsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000c6a0:	f0 0c 19 00 	cp.h	r12,r8
8000c6a4:	c8 80       	breq	8000c5b4 <MostService+0x3a4>
8000c6a6:	31 08       	mov	r8,16
8000c6a8:	f0 0c 19 00 	cp.h	r12,r8
8000c6ac:	fe 91 fe 91 	brne	8000c3ce <MostService+0x1be>
8000c6b0:	e0 6c 00 ff 	mov	r12,255

    T_MOD_ENTRY(MNS_24);

    call_buf_freed_cb = MNS_FALSE;

    if (MNS_FALSE != MnsIsNSInitComplete(MNS_P_SRV_ALL))
8000c6b4:	fe b0 f4 2e 	rcall	8000af10 <MnsIsNSInitComplete>
8000c6b8:	fe 90 fe 94 	breq	8000c3e0 <MostService+0x1d0>
8000c6bc:	30 0a       	mov	r10,0
    {
        #ifndef PACKET_COMMUNICATION_ONLY
        MostClearTimer(&(mns.timer.init));
8000c6be:	40 1c       	lddsp	r12,sp[0x4]
8000c6c0:	14 9b       	mov	r11,r10
8000c6c2:	fe b0 f4 f3 	rcall	8000b0a8 <MostSetTimer>
8000c6c6:	30 8c       	mov	r12,8
        #endif


        TAKE_MNS();
8000c6c8:	fe b0 d9 f7 	rcall	80007ab6 <mns_take>
8000c6cc:	e9 38 01 47 	ld.ub	r8,r4[327]
        if (MNS_FALSE != mns.buf_freed)  /* a buffer has been freed during re-attached */
8000c6d0:	ea 08 18 00 	cp.b	r8,r5
8000c6d4:	c4 a0       	breq	8000c768 <MostService+0x558>
8000c6d6:	e9 65 01 47 	st.b	r4[327],r5
        {
            mns.buf_freed = MNS_FALSE;
8000c6da:	30 8c       	mov	r12,8
            call_buf_freed_cb = MNS_TRUE;
        }
        GIVE_MNS();
8000c6dc:	fe b0 d9 ee 	rcall	80007ab8 <mns_give>
8000c6e0:	30 4c       	mov	r12,4

        if (MNS_FALSE != call_buf_freed_cb)
        {
            (void)MnsSetPendingEvent(MNS_P_BUF_FREED);   /* trigger callback general.on_buf_freed */
8000c6e2:	fe b0 f6 7f 	rcall	8000b3e0 <MnsSetPendingEvent>
8000c6e6:	fe 9f fe 7d 	bral	8000c3e0 <MostService+0x1d0>
8000c6ea:	e0 68 10 00 	mov	r8,4096
    event_to_handle = MnsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8000c6ee:	f0 0c 19 00 	cp.h	r12,r8
8000c6f2:	c1 d0       	breq	8000c72c <MostService+0x51c>
8000c6f4:	e0 68 20 00 	mov	r8,8192
8000c6f8:	f0 0c 19 00 	cp.h	r12,r8
8000c6fc:	c2 10       	breq	8000c73e <MostService+0x52e>
8000c6fe:	e0 68 04 00 	mov	r8,1024
8000c702:	f0 0c 19 00 	cp.h	r12,r8
8000c706:	fe 91 fe 64 	brne	8000c3ce <MostService+0x1be>
8000c70a:	30 8c       	mov	r12,8

        case MNS_P_WATCHDOG_TIMER:
            {
                bool wd_active;

                TAKE_MNS();
8000c70c:	fe b0 d9 d5 	rcall	80007ab6 <mns_take>
8000c710:	30 8c       	mov	r12,8
                wd_active = (MNS_TM_WD_DISABLE != mns.config.general.watchdogmode.timeout)
                            ? MNS_TRUE : MNS_FALSE;
                GIVE_MNS();
8000c712:	e9 01 00 a6 	ld.sh	r1,r4[166]
        case MNS_P_WATCHDOG_TIMER:
            {
                bool wd_active;

                TAKE_MNS();
                wd_active = (MNS_TM_WD_DISABLE != mns.config.general.watchdogmode.timeout)
8000c716:	fe b0 d9 d1 	rcall	80007ab8 <mns_give>
                            ? MNS_TRUE : MNS_FALSE;
                GIVE_MNS();
8000c71a:	3f f8       	mov	r8,-1
                if (MNS_FALSE != wd_active)
8000c71c:	f0 01 19 00 	cp.h	r1,r8
8000c720:	fe 90 fe 60 	breq	8000c3e0 <MostService+0x1d0>
8000c724:	fe b0 fa 3a 	rcall	8000bb98 <MnsFireWatchdogTrigger>
                {
                    #ifndef PACKET_COMMUNICATION_ONLY
                    MnsFireWatchdogTrigger();
8000c728:	fe 9f fe 5c 	bral	8000c3e0 <MostService+0x1d0>
8000c72c:	e0 6c 20 00 	mov	r12,8192
                #endif
                break;

        case MNS_P_PM_DONE:
            #ifndef PACKET_COMMUNICATION_ONLY
            MnsSetPendingEvent(MNS_P_SRV_CHECK);
8000c730:	fe b0 f6 58 	rcall	8000b3e0 <MnsSetPendingEvent>
8000c734:	30 1c       	mov	r12,1
            #endif
            #ifdef ADS_10
            DataNIStateNetOn(MNS_TRUE);
8000c736:	e0 a0 25 ed 	rcall	80011310 <DataNIStateNetOn>
8000c73a:	fe 9f fe 53 	bral	8000c3e0 <MostService+0x1d0>
8000c73e:	fe b0 f7 4d 	rcall	8000b5d8 <MnsCheckHigherLayers>
            #ifdef AMS_MIN
            bool signal_net_on;
            #endif

            #ifdef MNS_73
            MnsCheckHigherLayers();
8000c742:	30 8c       	mov	r12,8
            #endif

            #ifdef AMS_MIN
            TAKE_MNS();
8000c744:	fe b0 d9 b9 	rcall	80007ab6 <mns_take>
8000c748:	30 8c       	mov	r12,8
            signal_net_on = mns.signal_net_on;
            GIVE_MNS();
8000c74a:	e9 31 01 46 	ld.ub	r1,r4[326]
            MnsCheckHigherLayers();
            #endif

            #ifdef AMS_MIN
            TAKE_MNS();
            signal_net_on = mns.signal_net_on;
8000c74e:	fe b0 d9 b5 	rcall	80007ab8 <mns_give>
            GIVE_MNS();
8000c752:	58 01       	cp.w	r1,0

            if (MNS_FALSE != signal_net_on)
8000c754:	fe 90 fe 46 	breq	8000c3e0 <MostService+0x1d0>
8000c758:	30 1c       	mov	r12,1
            {
                MsgNIStateNetOn(MNS_TRUE);
8000c75a:	fe b0 e4 61 	rcall	8000901c <MsgNIStateNetOn>
8000c75e:	30 8c       	mov	r12,8
                TAKE_MNS();
8000c760:	fe b0 d9 ab 	rcall	80007ab6 <mns_take>
8000c764:	e9 65 01 46 	st.b	r4[326],r5
                mns.signal_net_on = MNS_FALSE;
8000c768:	30 8c       	mov	r12,8
                GIVE_MNS();
8000c76a:	fe b0 d9 a7 	rcall	80007ab8 <mns_give>
8000c76e:	fe 9f fe 39 	bral	8000c3e0 <MostService+0x1d0>
8000c772:	30 8c       	mov	r12,8
    TAKE_MNS();
    retry = mns.retry;
    GIVE_MNS();

    #ifndef MNS_AVOID_ATTACH
    PROCESS_RETRY    (MNS_RETRY_RESET_COMPLETE,     MnsResetComplete);
8000c774:	fe b0 d9 a1 	rcall	80007ab6 <mns_take>
8000c778:	e9 08 00 80 	ld.sh	r8,r4[128]
8000c77c:	a1 d8       	cbr	r8,0x1
8000c77e:	30 8c       	mov	r12,8
8000c780:	e9 58 00 80 	st.h	r4[128],r8
8000c784:	fe b0 d9 9a 	rcall	80007ab8 <mns_give>
8000c788:	fe b0 f8 3a 	rcall	8000b7fc <MnsResetComplete>
8000c78c:	fe 91 fe 2a 	brne	8000c3e0 <MostService+0x1d0>
    PROCESS_RETRY    (MNS_RETRY_GO_SEMI_PROTECTED,  MnsEHCIGoSemiProtected);
8000c790:	c4 2b       	rjmp	8000c614 <MostService+0x404>
8000c792:	30 8c       	mov	r12,8
    PROCESS_RETRY    (MNS_RETRY_CHECK_WATCHDOGMODE, MnsCheckWatchdogMode);
    PROCESS_RETRY    (MNS_RETRY_REQ_EHCISTATE,      MnsRequestEHCIState);
    PROCESS_RETRY    (MNS_RETRY_FORCE_PROTECTED,    MnsForceProtected);
    PROCESS_RETRY    (MNS_RETRY_REMOTE_ACCESS,      MnsEnforceRemoteAccess);
8000c794:	fe b0 d9 91 	rcall	80007ab6 <mns_take>
8000c798:	ed 08 00 80 	ld.sh	r8,r6[128]
8000c79c:	a7 c8       	cbr	r8,0x6
8000c79e:	30 8c       	mov	r12,8
8000c7a0:	ed 58 00 80 	st.h	r6[128],r8
8000c7a4:	fe b0 d9 8a 	rcall	80007ab8 <mns_give>
8000c7a8:	fe b0 f7 42 	rcall	8000b62c <MnsEnforceRemoteAccess>
8000c7ac:	fe 90 ff 48 	breq	8000c63c <MostService+0x42c>

    switch (event_to_handle)
    {
        case MNS_P_BUF_FREED:
            #ifndef PACKET_COMMUNICATION_ONLY
            if ((ERR_NO == MnsRetry()) &&
8000c7b0:	fe 9f fe 18 	bral	8000c3e0 <MostService+0x1d0>
8000c7b4:	30 8c       	mov	r12,8
    #ifndef MNS_AVOID_ATTACH
    PROCESS_RETRY    (MNS_RETRY_RESET_COMPLETE,     MnsResetComplete);
    PROCESS_RETRY    (MNS_RETRY_GO_SEMI_PROTECTED,  MnsEHCIGoSemiProtected);
    PROCESS_RETRY    (MNS_RETRY_CHECK_WATCHDOGMODE, MnsCheckWatchdogMode);
    PROCESS_RETRY    (MNS_RETRY_REQ_EHCISTATE,      MnsRequestEHCIState);
    PROCESS_RETRY    (MNS_RETRY_FORCE_PROTECTED,    MnsForceProtected);
8000c7b6:	fe b0 d9 80 	rcall	80007ab6 <mns_take>
8000c7ba:	ed 08 00 80 	ld.sh	r8,r6[128]
8000c7be:	a5 d8       	cbr	r8,0x5
8000c7c0:	30 8c       	mov	r12,8
8000c7c2:	ed 58 00 80 	st.h	r6[128],r8
8000c7c6:	fe b0 d9 79 	rcall	80007ab8 <mns_give>
8000c7ca:	fe b0 f7 63 	rcall	8000b690 <MnsForceProtected>
8000c7ce:	fe 90 ff 33 	breq	8000c634 <MostService+0x424>
    PROCESS_RETRY    (MNS_RETRY_REMOTE_ACCESS,      MnsEnforceRemoteAccess);
8000c7d2:	fe 9f fe 07 	bral	8000c3e0 <MostService+0x1d0>
8000c7d6:	30 8c       	mov	r12,8
    retry = mns.retry;
    GIVE_MNS();

    #ifndef MNS_AVOID_ATTACH
    PROCESS_RETRY    (MNS_RETRY_RESET_COMPLETE,     MnsResetComplete);
    PROCESS_RETRY    (MNS_RETRY_GO_SEMI_PROTECTED,  MnsEHCIGoSemiProtected);
8000c7d8:	fe b0 d9 6f 	rcall	80007ab6 <mns_take>
8000c7dc:	ed 08 00 80 	ld.sh	r8,r6[128]
8000c7e0:	a3 c8       	cbr	r8,0x2
8000c7e2:	30 8c       	mov	r12,8
8000c7e4:	ed 58 00 80 	st.h	r6[128],r8
8000c7e8:	fe b0 d9 68 	rcall	80007ab8 <mns_give>
8000c7ec:	fe b0 fb 8e 	rcall	8000bf08 <MnsEHCIGoSemiProtected>
8000c7f0:	fe 90 ff 16 	breq	8000c61c <MostService+0x40c>
    PROCESS_RETRY    (MNS_RETRY_CHECK_WATCHDOGMODE, MnsCheckWatchdogMode);
8000c7f4:	fe 9f fd f6 	bral	8000c3e0 <MostService+0x1d0>
8000c7f8:	30 8c       	mov	r12,8
    PROCESS_RETRY    (MNS_RETRY_REQ_EHCISTATE,      MnsRequestEHCIState);
8000c7fa:	fe b0 d9 5e 	rcall	80007ab6 <mns_take>
8000c7fe:	ed 08 00 80 	ld.sh	r8,r6[128]
8000c802:	a5 c8       	cbr	r8,0x4
8000c804:	30 8c       	mov	r12,8
8000c806:	ed 58 00 80 	st.h	r6[128],r8
8000c80a:	fe b0 d9 57 	rcall	80007ab8 <mns_give>
8000c80e:	fe b0 f7 75 	rcall	8000b6f8 <MnsRequestEHCIState>
8000c812:	fe 90 ff 0d 	breq	8000c62c <MostService+0x41c>
    PROCESS_RETRY    (MNS_RETRY_FORCE_PROTECTED,    MnsForceProtected);
8000c816:	fe 9f fd e5 	bral	8000c3e0 <MostService+0x1d0>
8000c81a:	30 8c       	mov	r12,8
    GIVE_MNS();

    #ifndef MNS_AVOID_ATTACH
    PROCESS_RETRY    (MNS_RETRY_RESET_COMPLETE,     MnsResetComplete);
    PROCESS_RETRY    (MNS_RETRY_GO_SEMI_PROTECTED,  MnsEHCIGoSemiProtected);
    PROCESS_RETRY    (MNS_RETRY_CHECK_WATCHDOGMODE, MnsCheckWatchdogMode);
8000c81c:	fe b0 d9 4d 	rcall	80007ab6 <mns_take>
8000c820:	ed 08 00 80 	ld.sh	r8,r6[128]
8000c824:	a3 d8       	cbr	r8,0x3
8000c826:	30 8c       	mov	r12,8
8000c828:	ed 58 00 80 	st.h	r6[128],r8
8000c82c:	fe b0 d9 46 	rcall	80007ab8 <mns_give>
8000c830:	fe b0 f7 86 	rcall	8000b73c <MnsCheckWatchdogMode>
8000c834:	fe 90 fe f8 	breq	8000c624 <MostService+0x414>
    PROCESS_RETRY    (MNS_RETRY_REQ_EHCISTATE,      MnsRequestEHCIState);
8000c838:	fe 9f fd d4 	bral	8000c3e0 <MostService+0x1d0>
8000c83c:	e8 f8 00 98 	ld.w	r8,r4[152]
            if ((ERR_NO == MnsRetry()) &&
                mns.config.general.on_buf_freed_fptr)
            {
                if (EHCISTATE_IS_ATTACHED())
                {
                    mns.config.general.on_buf_freed_fptr();
8000c840:	5d 18       	icall	r8
8000c842:	fe 9f fd cf 	bral	8000c3e0 <MostService+0x1d0>
8000c846:	d7 03       	nop
8000c848:	00 00       	add	r0,r0
8000c84a:	35 94       	mov	r4,89
8000c84c:	00 00       	add	r0,r0
8000c84e:	35 91       	mov	r1,89

8000c850 <PmsPrepareReInit>:
}
#endif

#ifdef PMS_46
void PmsPrepareReInit(void)
{
8000c850:	d4 01       	pushm	lr
    PmsFlushTxQueue(&mdpFifo.msgQ);
    PmsFlushTxQueue(&mdpFifo.pendingQ);
    #endif

    /* notify LLD to stop RX/TX */
    if( pms.ifacesStarted )
8000c852:	48 98       	lddpc	r8,8000c874 <PmsPrepareReInit+0x24>
8000c854:	70 09       	ld.w	r9,r8[0x0]
8000c856:	ed b9 00 1e 	bld	r9,0x1e
8000c85a:	c0 b1       	brne	8000c870 <PmsPrepareReInit+0x20>
    {
        pms.ifacesStarted = 0;
8000c85c:	30 0a       	mov	r10,0
8000c85e:	f3 da d3 c1 	bfins	r9,r10,0x1e,0x1
8000c862:	91 09       	st.w	r8[0x0],r9

        if (pmsInitData_ptr->stopIfaces_fptr)
8000c864:	48 58       	lddpc	r8,8000c878 <PmsPrepareReInit+0x28>
8000c866:	70 08       	ld.w	r8,r8[0x0]
8000c868:	70 68       	ld.w	r8,r8[0x18]
8000c86a:	58 08       	cp.w	r8,0
8000c86c:	c0 20       	breq	8000c870 <PmsPrepareReInit+0x20>
        {
            pmsInitData_ptr->stopIfaces_fptr();
8000c86e:	5d 18       	icall	r8
8000c870:	d8 02       	popm	pc
8000c872:	d7 03       	nop
8000c874:	00 00       	add	r0,r0
8000c876:	37 d4       	mov	r4,125
8000c878:	00 00       	add	r0,r0
8000c87a:	38 38       	mov	r8,-125

8000c87c <PmsFillDefaultHeader>:
#endif


#ifdef PMS_11
static void PmsFillDefaultHeader(HMBMBUF handle)
{
8000c87c:	eb cd 40 80 	pushm	r7,lr
    i = (word)0;
    d_ptr = NULL;
    #endif
    m_ptr = &handle->msg;

    if( MBM_TYPE_CTRL_TX == MBM_GET_TYPE(handle) )
8000c880:	98 e8       	ld.uh	r8,r12[0xc]
#endif


#ifdef PMS_11
static void PmsFillDefaultHeader(HMBMBUF handle)
{
8000c882:	18 97       	mov	r7,r12
    i = (word)0;
    d_ptr = NULL;
    #endif
    m_ptr = &handle->msg;

    if( MBM_TYPE_CTRL_TX == MBM_GET_TYPE(handle) )
8000c884:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000c888:	58 58       	cp.w	r8,5
8000c88a:	c1 20       	breq	8000c8ae <PmsFillDefaultHeader+0x32>
        d_ptr = &m_ptr->msgTx.TxHandle[0];
        i     = (word)MAX_TX_HANDLE;
        #endif
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( MBM_TYPE_DATA_TX == MBM_GET_TYPE(handle) )
8000c88c:	58 18       	cp.w	r8,1
8000c88e:	c0 b1       	brne	8000c8a4 <PmsFillDefaultHeader+0x28>
    {
        #ifdef _OS81110_PCK_LLR
        m_ptr->dataTx.Retry     = (byte)(MDP_DEFAULT_RETRY);
        #endif
        m_ptr->dataTx.Tgt_Adr_H = PMS_DEF_TGTADDR_0; /*lint !e778 high byte evaluates to '0'*/
        m_ptr->dataTx.Tgt_Adr_L = PMS_DEF_TGTADDR_1;
8000c890:	f9 68 00 1b 	st.b	r12[27],r8
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( MBM_TYPE_DATA_TX == MBM_GET_TYPE(handle) )
    {
        #ifdef _OS81110_PCK_LLR
        m_ptr->dataTx.Retry     = (byte)(MDP_DEFAULT_RETRY);
8000c894:	f9 68 00 1c 	st.b	r12[28],r8
        #endif
        m_ptr->dataTx.Tgt_Adr_H = PMS_DEF_TGTADDR_0; /*lint !e778 high byte evaluates to '0'*/
8000c898:	30 08       	mov	r8,0
8000c89a:	f9 68 00 1a 	st.b	r12[26],r8
        m_ptr->dataTx.Tgt_Adr_L = PMS_DEF_TGTADDR_1;
        m_ptr->dataTx.Length    = (word)0;
8000c89e:	30 08       	mov	r8,0
8000c8a0:	f9 58 00 18 	st.h	r12[24],r8
        i     = (word)MAX_DATA_TX_HANDLE;
        #endif
    }
    #endif

    handle->tel_id      = PMS_TELID_0;
8000c8a4:	30 08       	mov	r8,0
8000c8a6:	ef 68 00 36 	st.b	r7[54],r8

    #ifdef PMS_USE_HANDLE
    handle->handle = PMS_DEF_HANDLE;
    #endif
    T_MOD_EXIT(PMS_11);
}
8000c8aa:	e3 cd 80 80 	ldm	sp++,r7,pc
    m_ptr = &handle->msg;

    if( MBM_TYPE_CTRL_TX == MBM_GET_TYPE(handle) )
    {
        m_ptr->msgTx.Tgt_Adr   = PMS_DEF_TGTADDR;
        m_ptr->msgTx.FBlock_ID = PMS_DEF_FBLOCK_ID;
8000c8ae:	30 08       	mov	r8,0
        m_ptr->msgTx.Inst_ID   = PMS_DEF_INST_ID;
        m_ptr->msgTx.Operation = (byte)0x00;
8000c8b0:	f9 68 00 20 	st.b	r12[32],r8
    m_ptr = &handle->msg;

    if( MBM_TYPE_CTRL_TX == MBM_GET_TYPE(handle) )
    {
        m_ptr->msgTx.Tgt_Adr   = PMS_DEF_TGTADDR;
        m_ptr->msgTx.FBlock_ID = PMS_DEF_FBLOCK_ID;
8000c8b4:	f9 68 00 1e 	st.b	r12[30],r8
        m_ptr->msgTx.Inst_ID   = PMS_DEF_INST_ID;
8000c8b8:	f9 68 00 1f 	st.b	r12[31],r8
        m_ptr->msgTx.Operation = (byte)0x00;
        m_ptr->msgTx.Func_ID   = (word)0x0000;
8000c8bc:	30 08       	mov	r8,0
        m_ptr->msgTx.Length    = (word)0x0000;
8000c8be:	f9 58 00 18 	st.h	r12[24],r8
    {
        m_ptr->msgTx.Tgt_Adr   = PMS_DEF_TGTADDR;
        m_ptr->msgTx.FBlock_ID = PMS_DEF_FBLOCK_ID;
        m_ptr->msgTx.Inst_ID   = PMS_DEF_INST_ID;
        m_ptr->msgTx.Operation = (byte)0x00;
        m_ptr->msgTx.Func_ID   = (word)0x0000;
8000c8c2:	f9 58 00 1c 	st.h	r12[28],r8
    #endif
    m_ptr = &handle->msg;

    if( MBM_TYPE_CTRL_TX == MBM_GET_TYPE(handle) )
    {
        m_ptr->msgTx.Tgt_Adr   = PMS_DEF_TGTADDR;
8000c8c6:	30 18       	mov	r8,1
8000c8c8:	f9 58 00 1a 	st.h	r12[26],r8
        m_ptr->msgTx.FBlock_ID = PMS_DEF_FBLOCK_ID;
        m_ptr->msgTx.Inst_ID   = PMS_DEF_INST_ID;
        m_ptr->msgTx.Operation = (byte)0x00;
        m_ptr->msgTx.Func_ID   = (word)0x0000;
        m_ptr->msgTx.Length    = (word)0x0000;
        WAIT4MX(MX_PMS_CS);
8000c8cc:	30 2c       	mov	r12,2
8000c8ce:	fe b0 d8 f4 	rcall	80007ab6 <mns_take>
        m_ptr->msgTx.MidLevelRetries = pms.mid_level_retries;
8000c8d2:	48 78       	lddpc	r8,8000c8ec <PmsFillDefaultHeader+0x70>
8000c8d4:	f1 39 00 28 	ld.ub	r9,r8[40]
8000c8d8:	ef 69 00 21 	st.b	r7[33],r9
        m_ptr->msgTx.LowLevelRetries = pms.low_level_retries;
8000c8dc:	f1 38 00 29 	ld.ub	r8,r8[41]
        REL_MX(MX_PMS_CS);
8000c8e0:	30 2c       	mov	r12,2
        m_ptr->msgTx.Operation = (byte)0x00;
        m_ptr->msgTx.Func_ID   = (word)0x0000;
        m_ptr->msgTx.Length    = (word)0x0000;
        WAIT4MX(MX_PMS_CS);
        m_ptr->msgTx.MidLevelRetries = pms.mid_level_retries;
        m_ptr->msgTx.LowLevelRetries = pms.low_level_retries;
8000c8e2:	ef 68 00 22 	st.b	r7[34],r8
        REL_MX(MX_PMS_CS);
8000c8e6:	fe b0 d8 e9 	rcall	80007ab8 <mns_give>
8000c8ea:	cd db       	rjmp	8000c8a4 <PmsFillDefaultHeader+0x28>
8000c8ec:	00 00       	add	r0,r0
8000c8ee:	37 d4       	mov	r4,125

8000c8f0 <PmsInsertRetryValues>:
8000c8f0:	eb cd 40 80 	pushm	r7,lr
8000c8f4:	18 97       	mov	r7,r12
8000c8f6:	58 0c       	cp.w	r12,0

#ifdef PMS_58
void PmsInsertRetryValues(TMsgTx* tx_ptr)
{
    T_LIB_ENTRY(PMS_58);
    ASSERT(tx_ptr);
8000c8f8:	c1 20       	breq	8000c91c <PmsInsertRetryValues+0x2c>
    WAIT4MX(MX_PMS_CS);
8000c8fa:	30 2c       	mov	r12,2
8000c8fc:	fe b0 d8 dd 	rcall	80007ab6 <mns_take>
    tx_ptr->MidLevelRetries = pms.mid_level_retries;
8000c900:	48 c8       	lddpc	r8,8000c930 <PmsInsertRetryValues+0x40>
8000c902:	f1 39 00 28 	ld.ub	r9,r8[40]
8000c906:	ef 69 00 0d 	st.b	r7[13],r9
    tx_ptr->LowLevelRetries = pms.low_level_retries;
8000c90a:	f1 38 00 29 	ld.ub	r8,r8[41]
    REL_MX(MX_PMS_CS);
8000c90e:	30 2c       	mov	r12,2
{
    T_LIB_ENTRY(PMS_58);
    ASSERT(tx_ptr);
    WAIT4MX(MX_PMS_CS);
    tx_ptr->MidLevelRetries = pms.mid_level_retries;
    tx_ptr->LowLevelRetries = pms.low_level_retries;
8000c910:	ef 68 00 0e 	st.b	r7[14],r8
    REL_MX(MX_PMS_CS);
8000c914:	fe b0 d8 d2 	rcall	80007ab8 <mns_give>
    T_LIB_EXIT(PMS_58);
}
8000c918:	e3 cd 80 80 	ldm	sp++,r7,pc

#ifdef PMS_58
void PmsInsertRetryValues(TMsgTx* tx_ptr)
{
    T_LIB_ENTRY(PMS_58);
    ASSERT(tx_ptr);
8000c91c:	e0 68 13 e4 	mov	r8,5092
8000c920:	30 1a       	mov	r10,1
8000c922:	1a d8       	st.w	--sp,r8
8000c924:	31 0b       	mov	r11,16
8000c926:	14 9c       	mov	r12,r10
8000c928:	fe b0 d8 e2 	rcall	80007aec <mns_trace>
8000c92c:	2f fd       	sub	sp,-4
8000c92e:	ce 6b       	rjmp	8000c8fa <PmsInsertRetryValues+0xa>
8000c930:	00 00       	add	r0,r0
8000c932:	37 d4       	mov	r4,125

8000c934 <PmsHandleMidLevelRetriesStatus>:
8000c934:	eb cd 40 80 	pushm	r7,lr
8000c938:	18 97       	mov	r7,r12
8000c93a:	58 0c       	cp.w	r12,0
8000c93c:	c0 e0       	breq	8000c958 <PmsHandleMidLevelRetriesStatus+0x24>
8000c93e:	30 2c       	mov	r12,2
void PmsHandleMidLevelRetriesStatus(TMsgRx *msg_ptr)    /*lint -esym( 818, msg_ptr ) function must match TMisHandlerFuncPtr*/
{
    T_LIB_ENTRY(PMS_57);
    ASSERT(msg_ptr);

    WAIT4MX(MX_PMS_CS);
8000c940:	fe b0 d8 bb 	rcall	80007ab6 <mns_take>
    pms.mid_level_retries = msg_ptr->Data[2];
8000c944:	6e 08       	ld.w	r8,r7[0x0]
8000c946:	11 a9       	ld.ub	r9,r8[0x2]
8000c948:	48 98       	lddpc	r8,8000c96c <PmsHandleMidLevelRetriesStatus+0x38>
    REL_MX(MX_PMS_CS);
8000c94a:	30 2c       	mov	r12,2
{
    T_LIB_ENTRY(PMS_57);
    ASSERT(msg_ptr);

    WAIT4MX(MX_PMS_CS);
    pms.mid_level_retries = msg_ptr->Data[2];
8000c94c:	f1 69 00 28 	st.b	r8[40],r9
    REL_MX(MX_PMS_CS);
8000c950:	fe b0 d8 b4 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(PMS_57);
}                                                       /*lint +esym( 818, msg_ptr ) function must match TMisHandlerFuncPtr*/
8000c954:	e3 cd 80 80 	ldm	sp++,r7,pc

#ifdef PMS_57
void PmsHandleMidLevelRetriesStatus(TMsgRx *msg_ptr)    /*lint -esym( 818, msg_ptr ) function must match TMisHandlerFuncPtr*/
{
    T_LIB_ENTRY(PMS_57);
    ASSERT(msg_ptr);
8000c958:	e0 68 13 d6 	mov	r8,5078
8000c95c:	30 1a       	mov	r10,1
8000c95e:	1a d8       	st.w	--sp,r8
8000c960:	31 0b       	mov	r11,16
8000c962:	14 9c       	mov	r12,r10
8000c964:	fe b0 d8 c4 	rcall	80007aec <mns_trace>
8000c968:	2f fd       	sub	sp,-4
8000c96a:	ce ab       	rjmp	8000c93e <PmsHandleMidLevelRetriesStatus+0xa>
8000c96c:	00 00       	add	r0,r0
8000c96e:	37 d4       	mov	r4,125

8000c970 <PmsHandleRetryParamsStatus>:
8000c970:	eb cd 40 80 	pushm	r7,lr
8000c974:	18 97       	mov	r7,r12
8000c976:	58 0c       	cp.w	r12,0
8000c978:	c0 e0       	breq	8000c994 <PmsHandleRetryParamsStatus+0x24>
8000c97a:	30 2c       	mov	r12,2
void PmsHandleRetryParamsStatus(TMsgRx *msg_ptr)        /*lint -esym( 818, msg_ptr ) function must match TMisHandlerFuncPtr*/
{
    T_LIB_ENTRY(PMS_56);
    ASSERT(msg_ptr);

    WAIT4MX(MX_PMS_CS);
8000c97c:	fe b0 d8 9d 	rcall	80007ab6 <mns_take>
    pms.low_level_retries = msg_ptr->Data[1];
8000c980:	6e 08       	ld.w	r8,r7[0x0]
8000c982:	11 99       	ld.ub	r9,r8[0x1]
8000c984:	48 98       	lddpc	r8,8000c9a8 <PmsHandleRetryParamsStatus+0x38>
    REL_MX(MX_PMS_CS);
8000c986:	30 2c       	mov	r12,2
{
    T_LIB_ENTRY(PMS_56);
    ASSERT(msg_ptr);

    WAIT4MX(MX_PMS_CS);
    pms.low_level_retries = msg_ptr->Data[1];
8000c988:	f1 69 00 29 	st.b	r8[41],r9
    REL_MX(MX_PMS_CS);
8000c98c:	fe b0 d8 96 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(PMS_56);
}                                                       /*lint +esym( 818, msg_ptr ) function must match TMisHandlerFuncPtr*/
8000c990:	e3 cd 80 80 	ldm	sp++,r7,pc

#ifdef PMS_56
void PmsHandleRetryParamsStatus(TMsgRx *msg_ptr)        /*lint -esym( 818, msg_ptr ) function must match TMisHandlerFuncPtr*/
{
    T_LIB_ENTRY(PMS_56);
    ASSERT(msg_ptr);
8000c994:	e0 68 13 c8 	mov	r8,5064
8000c998:	30 1a       	mov	r10,1
8000c99a:	1a d8       	st.w	--sp,r8
8000c99c:	31 0b       	mov	r11,16
8000c99e:	14 9c       	mov	r12,r10
8000c9a0:	fe b0 d8 a6 	rcall	80007aec <mns_trace>
8000c9a4:	2f fd       	sub	sp,-4
8000c9a6:	ce ab       	rjmp	8000c97a <PmsHandleRetryParamsStatus+0xa>
8000c9a8:	00 00       	add	r0,r0
8000c9aa:	37 d4       	mov	r4,125

8000c9ac <PmsGetFifoInterface>:
8000c9ac:	eb cd 40 80 	pushm	r7,lr
8000c9b0:	3e 08       	mov	r8,-32
8000c9b2:	18 97       	mov	r7,r12
8000c9b4:	f0 0c 18 00 	cp.b	r12,r8
  */
byte PmsGetFifoInterface(byte fifomask)
{
    byte iface;
    T_API_ENTRY(PMS_3);
    ASSERT(PMS_M_FIFO_ALL != fifomask);
8000c9b8:	c1 50       	breq	8000c9e2 <PmsGetFifoInterface+0x36>

    iface = PMS_IFACE_I2C;
    WAIT4MX(MX_PMS_CS);
8000c9ba:	30 2c       	mov	r12,2
8000c9bc:	fe b0 d8 7d 	rcall	80007ab6 <mns_take>

    #ifdef MDP_MIN
    if( PMS_M_FIFO_MDP & fifomask )
8000c9c0:	ed b7 00 05 	bld	r7,0x5
8000c9c4:	c1 b0       	breq	8000c9fa <PmsGetFifoInterface+0x4e>
        iface = PMS_IFACE_I2C;
      #endif
    }
    else
    #endif
    if( PMS_M_FIFO_CTRL & fifomask )
8000c9c6:	e2 17 00 c0 	andl	r7,0xc0,COH
8000c9ca:	c0 60       	breq	8000c9d6 <PmsGetFifoInterface+0x2a>
    {
        /* ICM and MCM FIFO always use the same interface */
        iface = (icmFifo.iface_ptr == &i2c) ? PMS_IFACE_I2C : PMS_IFACE_GENERAL;
8000c9cc:	48 f8       	lddpc	r8,8000ca08 <PmsGetFifoInterface+0x5c>
8000c9ce:	70 99       	ld.w	r9,r8[0x24]
8000c9d0:	48 f8       	lddpc	r8,8000ca0c <PmsGetFifoInterface+0x60>
8000c9d2:	10 39       	cp.w	r9,r8
8000c9d4:	5f 17       	srne	r7
    }

    REL_MX(MX_PMS_CS);
8000c9d6:	30 2c       	mov	r12,2
8000c9d8:	fe b0 d8 70 	rcall	80007ab8 <mns_give>
    T_API_EXIT(PMS_3);
    return( iface );
}
8000c9dc:	0e 9c       	mov	r12,r7
8000c9de:	e3 cd 80 80 	ldm	sp++,r7,pc
  */
byte PmsGetFifoInterface(byte fifomask)
{
    byte iface;
    T_API_ENTRY(PMS_3);
    ASSERT(PMS_M_FIFO_ALL != fifomask);
8000c9e2:	e0 68 02 ae 	mov	r8,686
8000c9e6:	30 1a       	mov	r10,1
8000c9e8:	1a d8       	st.w	--sp,r8
8000c9ea:	14 9c       	mov	r12,r10
8000c9ec:	31 0b       	mov	r11,16
8000c9ee:	fe b0 d8 7f 	rcall	80007aec <mns_trace>

    iface = PMS_IFACE_I2C;
    WAIT4MX(MX_PMS_CS);
8000c9f2:	30 2c       	mov	r12,2
8000c9f4:	fe b0 d8 61 	rcall	80007ab6 <mns_take>
8000c9f8:	2f fd       	sub	sp,-4

    #ifdef MDP_MIN
    if( PMS_M_FIFO_MDP & fifomask )
    {
      #ifdef ADS_MIN /* Other interfaces only with ADS_MIN */
        iface = (mdpFifo.iface_ptr == &i2c) ? PMS_IFACE_I2C : PMS_IFACE_GENERAL;
8000c9fa:	48 68       	lddpc	r8,8000ca10 <PmsGetFifoInterface+0x64>
8000c9fc:	70 99       	ld.w	r9,r8[0x24]
8000c9fe:	48 48       	lddpc	r8,8000ca0c <PmsGetFifoInterface+0x60>
8000ca00:	10 39       	cp.w	r9,r8
8000ca02:	5f 17       	srne	r7
8000ca04:	ce 9b       	rjmp	8000c9d6 <PmsGetFifoInterface+0x2a>
8000ca06:	d7 03       	nop
8000ca08:	00 00       	add	r0,r0
8000ca0a:	39 14       	mov	r4,-111
8000ca0c:	00 00       	add	r0,r0
8000ca0e:	36 e0       	mov	r0,110
8000ca10:	00 00       	add	r0,r0
8000ca12:	37 0c       	mov	r12,112

8000ca14 <PmsSetPendingEvent>:
8000ca14:	d4 01       	pushm	lr
8000ca16:	30 19       	mov	r9,1
8000ca18:	5c 7c       	castu.h	r12
8000ca1a:	48 3a       	lddpc	r10,8000ca24 <PmsSetPendingEvent+0x10>
8000ca1c:	12 9b       	mov	r11,r9
8000ca1e:	fe b0 f4 af 	rcall	8000b37c <MnsSetPendingEventFlag>
{
    T_MOD_ENTRY(PMS_10);
    T_REQUEST(event);
    MnsSetPendingEventFlag(event, (word)MX_PMS_PE, &pmsPending, MNS_P_SRV_PMS);
    T_MOD_EXIT(PMS_10);
}
8000ca22:	d8 02       	popm	pc
8000ca24:	00 00       	add	r0,r0
8000ca26:	4a 24       	lddpc	r4,8000caac <PmsSendCommand+0x58>

8000ca28 <PmsSegErrorTxStatus>:
8000ca28:	d4 01       	pushm	lr
8000ca2a:	48 99       	lddpc	r9,8000ca4c <PmsSegErrorTxStatus+0x24>
static byte PmsSegErrorTxStatus(HMBMBUF handle, byte status)
{
    T_MOD_ENTRY(PMS_35);
    (void) handle;
    (void) status;
    MBM_CLR_STATUS_BITS(&segErrMsg, MBM_STAT_RSVD);
8000ca2c:	92 68       	ld.sh	r8,r9[0xc]
8000ca2e:	ab c8       	cbr	r8,0xa
8000ca30:	b2 68       	st.h	r9[0xc],r8
    #ifdef MSG_RX_AUTOMATIC_ERR_MSG
    if( pms.needSegErrMsg )
8000ca32:	48 88       	lddpc	r8,8000ca50 <PmsSegErrorTxStatus+0x28>
8000ca34:	70 09       	ld.w	r9,r8[0x0]
8000ca36:	ed b9 00 1c 	bld	r9,0x1c
8000ca3a:	c0 81       	brne	8000ca4a <PmsSegErrorTxStatus+0x22>
    {
        pms.needSegErrMsg = 0;
8000ca3c:	30 0a       	mov	r10,0
8000ca3e:	f3 da d3 81 	bfins	r9,r10,0x1c,0x1
        PmsSetPendingEvent(PMS_P_RETRIGGER_GBG);
8000ca42:	e0 6c 08 00 	mov	r12,2048
    (void) status;
    MBM_CLR_STATUS_BITS(&segErrMsg, MBM_STAT_RSVD);
    #ifdef MSG_RX_AUTOMATIC_ERR_MSG
    if( pms.needSegErrMsg )
    {
        pms.needSegErrMsg = 0;
8000ca46:	91 09       	st.w	r8[0x0],r9
        PmsSetPendingEvent(PMS_P_RETRIGGER_GBG);
8000ca48:	ce 6f       	rcall	8000ca14 <PmsSetPendingEvent>
8000ca4a:	d8 0a       	popm	pc,r12=0
    }
    #endif
    T_MOD_EXIT(PMS_35);

    return( PMS_RELEASE );
}
8000ca4c:	00 00       	add	r0,r0
8000ca4e:	38 48       	mov	r8,-124
8000ca50:	00 00       	add	r0,r0
8000ca52:	37 d4       	mov	r4,125

8000ca54 <PmsSendCommand>:
8000ca54:	eb cd 40 e0 	pushm	r5-r7,lr
8000ca58:	76 45       	ld.w	r5,r11[0x10]
8000ca5a:	97 a5       	st.w	r11[0x28],r5
}
#endif

#ifdef PMS_20
static void PmsSendCommand(PmsFifo *fifo_ptr, HMBMBUF handle)
{
8000ca5c:	16 97       	mov	r7,r11
8000ca5e:	18 96       	mov	r6,r12

    T_MOD_ENTRY(PMS_20);

    tgt_ptr = MBM_RESET_HDR_PTR(handle);    /* Set & Get start of buffer  */

    ASSERT(fifo_ptr);
8000ca60:	58 0c       	cp.w	r12,0
8000ca62:	c4 20       	breq	8000cae6 <PmsSendCommand+0x92>

    if( (MBM_TYPE_CMD_TX == MBM_GET_TYPE(handle))
8000ca64:	8e e8       	ld.uh	r8,r7[0xc]
8000ca66:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ca6a:	58 78       	cp.w	r8,7
8000ca6c:	c2 c0       	breq	8000cac4 <PmsSendCommand+0x70>
        handle->msg.ctrl |= PMS_M_CMD_SLOTNTF;
        #endif
        fph = (byte)(PMS_FIFONO_ALL << FPH_B_FIFONO_LSB);
    }
    #ifdef MDP_MIN
    else if( &mdpFifo == fifo_ptr )
8000ca6e:	4a 49       	lddpc	r9,8000cafc <PmsSendCommand+0xa8>
8000ca70:	12 36       	cp.w	r6,r9
8000ca72:	c3 40       	breq	8000cada <PmsSendCommand+0x86>
    {
        fph = (byte)(PMS_FIFONO_MDP << FPH_B_FIFONO_LSB);
    }
    #endif
    else if( &icmFifo == fifo_ptr )
8000ca74:	4a 39       	lddpc	r9,8000cb00 <PmsSendCommand+0xac>
8000ca76:	12 36       	cp.w	r6,r9
8000ca78:	f9 b9 00 10 	moveq	r9,16
8000ca7c:	f9 b9 01 00 	movne	r9,0
    else
    {
        fph |= FPH_MSGTYPE_STAT;
    }
    #else
    fph |= (MBM_TYPE_STATUS_TX == MBM_GET_TYPE(handle))
8000ca80:	58 38       	cp.w	r8,3
8000ca82:	c2 90       	breq	8000cad4 <PmsSendCommand+0x80>
8000ca84:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
           ? FPH_MSGTYPE_STAT : FPH_MSGTYPE_CMD;
    #endif

    tgt_ptr[3] = fph;
8000ca88:	aa b8       	st.b	r5[0x3],r8
        length += 2;                 /* requires add. fields for protocol ID and MCM channel address */
    }
    #endif

    /* Fill command/status message */
    *tgt_ptr++ = (byte)0;                   /* PML MSB */
8000ca8a:	30 08       	mov	r8,0
8000ca8c:	0a c8       	st.b	r5++,r8
    *tgt_ptr++ = (byte)(length + (word)1);  /* PML LSB */
8000ca8e:	30 38       	mov	r8,3
8000ca90:	0a c8       	st.b	r5++,r8
    *tgt_ptr++ = (byte)length;              /* PMHL    */
8000ca92:	30 28       	mov	r8,2
8000ca94:	0a c8       	st.b	r5++,r8
    }
    #else
    tgt_ptr++;
    #endif

    *tgt_ptr++ = handle->msg.ctrl; /* Command/Status 1 */
8000ca96:	ef 38 00 14 	ld.ub	r8,r7[20]
8000ca9a:	aa 98       	st.b	r5[0x1],r8
        *tgt_ptr++ = PMS_PID_OPTIMIZED;             /* Protocol ID */
        *tgt_ptr++ = (byte)PMS_RX_OPT3_CHADDR;      /* add. MCM RX channel address */
    }
    #endif

    MBM_SET_HDR_LEN(handle, (length + (word)3));
8000ca9c:	30 58       	mov	r8,5
    MbmEnqueue(&fifo_ptr->cmdQ, handle);
8000ca9e:	0e 9b       	mov	r11,r7
        *tgt_ptr++ = PMS_PID_OPTIMIZED;             /* Protocol ID */
        *tgt_ptr++ = (byte)PMS_RX_OPT3_CHADDR;      /* add. MCM RX channel address */
    }
    #endif

    MBM_SET_HDR_LEN(handle, (length + (word)3));
8000caa0:	ef 58 00 32 	st.h	r7[50],r8
    MbmEnqueue(&fifo_ptr->cmdQ, handle);
8000caa4:	ec cc ff f4 	sub	r12,r6,-12
8000caa8:	fe b0 ec 0a 	rcall	8000a2bc <MbmEnqueue>

    WAIT4MX(MX_PMS_CS);
8000caac:	30 2c       	mov	r12,2
8000caae:	fe b0 d8 04 	rcall	80007ab6 <mns_take>
    ready = PMS_IFACE_READY(*fifo_ptr->iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000cab2:	6c 98       	ld.w	r8,r6[0x24]
    REL_MX(MX_PMS_CS);
8000cab4:	30 2c       	mov	r12,2

    MBM_SET_HDR_LEN(handle, (length + (word)3));
    MbmEnqueue(&fifo_ptr->cmdQ, handle);

    WAIT4MX(MX_PMS_CS);
    ready = PMS_IFACE_READY(*fifo_ptr->iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000cab6:	70 17       	ld.w	r7,r8[0x4]
    REL_MX(MX_PMS_CS);
8000cab8:	fe b0 d8 00 	rcall	80007ab8 <mns_give>

    if( MNS_FALSE != ready )
8000cabc:	58 07       	cp.w	r7,0
8000cabe:	c1 00       	breq	8000cade <PmsSendCommand+0x8a>
8000cac0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    tgt_ptr = MBM_RESET_HDR_PTR(handle);    /* Set & Get start of buffer  */

    ASSERT(fifo_ptr);

    if( (MBM_TYPE_CMD_TX == MBM_GET_TYPE(handle))
        && (PMS_M_CMD_SYNCC & handle->msg.ctrl) )
8000cac4:	ef 3a 00 14 	ld.ub	r10,r7[20]
8000cac8:	30 09       	mov	r9,0
8000caca:	f2 0a 18 00 	cp.b	r10,r9
8000cace:	cd 04       	brge	8000ca6e <PmsSendCommand+0x1a>
8000cad0:	31 88       	mov	r8,24
8000cad2:	cd bb       	rjmp	8000ca88 <PmsSendCommand+0x34>
    else
    {
        fph |= FPH_MSGTYPE_STAT;
    }
    #else
    fph |= (MBM_TYPE_STATUS_TX == MBM_GET_TYPE(handle))
8000cad4:	12 98       	mov	r8,r9
8000cad6:	a1 b8       	sbr	r8,0x1
8000cad8:	cd 8b       	rjmp	8000ca88 <PmsSendCommand+0x34>
        handle->msg.ctrl |= PMS_M_CMD_SLOTNTF;
        #endif
        fph = (byte)(PMS_FIFONO_ALL << FPH_B_FIFONO_LSB);
    }
    #ifdef MDP_MIN
    else if( &mdpFifo == fifo_ptr )
8000cada:	30 89       	mov	r9,8
8000cadc:	cd 2b       	rjmp	8000ca80 <PmsSendCommand+0x2c>
    {
        /*!
         * Only necessary to trigger if the interface is ready for another
         * buffer, otherwise it will be retriggered when completed.
         */
        PmsSetPendingEvent(PMS_P_TX_TRIG);
8000cade:	30 8c       	mov	r12,8
8000cae0:	c9 af       	rcall	8000ca14 <PmsSetPendingEvent>
8000cae2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000cae6:	e0 68 0e 0d 	mov	r8,3597

    T_MOD_ENTRY(PMS_20);

    tgt_ptr = MBM_RESET_HDR_PTR(handle);    /* Set & Get start of buffer  */

    ASSERT(fifo_ptr);
8000caea:	30 1a       	mov	r10,1
8000caec:	1a d8       	st.w	--sp,r8
8000caee:	31 0b       	mov	r11,16
8000caf0:	14 9c       	mov	r12,r10
8000caf2:	fe b0 d7 fd 	rcall	80007aec <mns_trace>
8000caf6:	2f fd       	sub	sp,-4
8000caf8:	cb 6b       	rjmp	8000ca64 <PmsSendCommand+0x10>
8000cafa:	d7 03       	nop
8000cafc:	00 00       	add	r0,r0
8000cafe:	37 0c       	mov	r12,112
8000cb00:	00 00       	add	r0,r0
8000cb02:	39 14       	mov	r4,-111

8000cb04 <PmsSyncHandler>:
8000cb04:	d4 21       	pushm	r4-r7,lr
8000cb06:	4c 66       	lddpc	r6,8000cc1c <PmsSyncHandler+0x118>
8000cb08:	6c 08       	ld.w	r8,r6[0x0]
8000cb0a:	58 28       	cp.w	r8,2
8000cb0c:	e0 8b 00 21 	brhi	8000cb4e <PmsSyncHandler+0x4a>
8000cb10:	58 18       	cp.w	r8,1
8000cb12:	c2 13       	brcs	8000cb54 <PmsSyncHandler+0x50>
8000cb14:	ef dc c0 10 	bfextu	r7,r12,0x0,0x10
            }
            break;

        case PMS_S_PENDING:
        case PMS_S_SYNCED:
            if( events & PMS_P_SYNCS_CMD )
8000cb18:	0e 95       	mov	r5,r7
8000cb1a:	e2 15 00 04 	andl	r5,0x4,COH
8000cb1e:	c3 81       	brne	8000cb8e <PmsSyncHandler+0x8a>
                {
                    pms.initSync = 1;
                    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_PMS);
                }
            }
            if( events & (PMS_P_TIMEOUT | PMS_P_SEND_SYNCC) )
8000cb20:	e2 17 00 22 	andl	r7,0x22,COH
8000cb24:	c3 00       	breq	8000cb84 <PmsSyncHandler+0x80>
        syncCount = (word)0;
    }

    if( actions & PMS_A_SYNCC )
    {
        if( syncCount++ < PMS_MAX_SYNC_ATTEMPTS )
8000cb26:	4b f5       	lddpc	r5,8000cc20 <PmsSyncHandler+0x11c>
8000cb28:	8a 07       	ld.sh	r7,r5[0x0]
8000cb2a:	0e 98       	mov	r8,r7
8000cb2c:	2f f8       	sub	r8,-1
8000cb2e:	aa 08       	st.h	r5[0x0],r8
8000cb30:	58 07       	cp.w	r7,0
8000cb32:	c3 b0       	breq	8000cba8 <PmsSyncHandler+0xa4>

            pmsSyncState = PMS_S_PENDING;
        }
        else
        {
            pmsSyncState = PMS_S_FAILED;
8000cb34:	30 38       	mov	r8,3
8000cb36:	8d 08       	st.w	r6[0x0],r8
            PMS_EXTERNAL_EVENT(PMS_E_SYNC_FAILED);
8000cb38:	4b b8       	lddpc	r8,8000cc24 <PmsSyncHandler+0x120>
8000cb3a:	70 08       	ld.w	r8,r8[0x0]
8000cb3c:	70 08       	ld.w	r8,r8[0x0]
8000cb3e:	58 08       	cp.w	r8,0
8000cb40:	c0 40       	breq	8000cb48 <PmsSyncHandler+0x44>
8000cb42:	e0 6c 04 00 	mov	r12,1024
8000cb46:	5d 18       	icall	r8
            syncCount = (word)0;
8000cb48:	30 08       	mov	r8,0
8000cb4a:	aa 08       	st.h	r5[0x0],r8
8000cb4c:	d8 22       	popm	r4-r7,pc

    T_MOD_ENTRY(PMS_23);

    actions = PMS_A_NONE;

    switch( pmsSyncState )
8000cb4e:	58 38       	cp.w	r8,3
8000cb50:	c1 60       	breq	8000cb7c <PmsSyncHandler+0x78>
8000cb52:	d8 22       	popm	r4-r7,pc
    {
        case PMS_S_INIT:
            if( events & PMS_P_TIMEOUT )
8000cb54:	ed bc 00 01 	bld	r12,0x1
8000cb58:	cf d1       	brne	8000cb52 <PmsSyncHandler+0x4e>
            {
                pms.initSync = 0;
8000cb5a:	4b 48       	lddpc	r8,8000cc28 <PmsSyncHandler+0x124>
8000cb5c:	30 0a       	mov	r10,0
8000cb5e:	70 09       	ld.w	r9,r8[0x0]
8000cb60:	f3 da d3 e1 	bfins	r9,r10,0x1f,0x1
8000cb64:	91 09       	st.w	r8[0x0],r9
                actions = PMS_A_SYNCC | PMS_A_RESET_CNT;
                pmsSyncState = PMS_S_PENDING;
8000cb66:	30 18       	mov	r8,1
8000cb68:	8d 08       	st.w	r6[0x0],r8
            syncCount = (word)0;
        }
    }

    T_MOD_EXIT(PMS_23);
}
8000cb6a:	30 38       	mov	r8,3
            break;
    }

    if( actions & PMS_A_RESET_CNT )
    {
        syncCount = (word)0;
8000cb6c:	30 0a       	mov	r10,0
8000cb6e:	4a d9       	lddpc	r9,8000cc20 <PmsSyncHandler+0x11c>
8000cb70:	e2 18 00 02 	andl	r8,0x2,COH
8000cb74:	b2 0a       	st.h	r9[0x0],r10
    }

    if( actions & PMS_A_SYNCC )
8000cb76:	58 08       	cp.w	r8,0
8000cb78:	cd 71       	brne	8000cb26 <PmsSyncHandler+0x22>
8000cb7a:	ce cb       	rjmp	8000cb52 <PmsSyncHandler+0x4e>
                actions = PMS_A_SYNCC;
            }
            break;

        case PMS_S_FAILED:
            if( events & PMS_P_SEND_SYNCC )
8000cb7c:	ed bc 00 05 	bld	r12,0x5
8000cb80:	cf 50       	breq	8000cb6a <PmsSyncHandler+0x66>
8000cb82:	d8 22       	popm	r4-r7,pc

        default:
            break;
    }

    if( actions & PMS_A_RESET_CNT )
8000cb84:	ed b5 00 00 	bld	r5,0x0
8000cb88:	c4 61       	brne	8000cc14 <PmsSyncHandler+0x110>
8000cb8a:	30 18       	mov	r8,1
8000cb8c:	cf 0b       	rjmp	8000cb6c <PmsSyncHandler+0x68>
            if( events & PMS_P_SYNCS_CMD )
            {
                pmsSyncState = PMS_S_SYNCED;
                actions = PMS_A_RESET_CNT;

                MostClearTimer(&pmsSyncTimer);
8000cb8e:	30 0a       	mov	r10,0

        case PMS_S_PENDING:
        case PMS_S_SYNCED:
            if( events & PMS_P_SYNCS_CMD )
            {
                pmsSyncState = PMS_S_SYNCED;
8000cb90:	30 25       	mov	r5,2
                actions = PMS_A_RESET_CNT;

                MostClearTimer(&pmsSyncTimer);
8000cb92:	14 9b       	mov	r11,r10

        case PMS_S_PENDING:
        case PMS_S_SYNCED:
            if( events & PMS_P_SYNCS_CMD )
            {
                pmsSyncState = PMS_S_SYNCED;
8000cb94:	8d 05       	st.w	r6[0x0],r5
                actions = PMS_A_RESET_CNT;

                MostClearTimer(&pmsSyncTimer);
8000cb96:	4a 6c       	lddpc	r12,8000cc2c <PmsSyncHandler+0x128>
8000cb98:	fe b0 f2 88 	rcall	8000b0a8 <MostSetTimer>

                if( !pms.initSync )
8000cb9c:	4a 38       	lddpc	r8,8000cc28 <PmsSyncHandler+0x124>
8000cb9e:	70 09       	ld.w	r9,r8[0x0]
8000cba0:	58 09       	cp.w	r9,0
8000cba2:	c3 04       	brge	8000cc02 <PmsSyncHandler+0xfe>
8000cba4:	30 15       	mov	r5,1
8000cba6:	cb db       	rjmp	8000cb20 <PmsSyncHandler+0x1c>
        if( syncCount++ < PMS_MAX_SYNC_ATTEMPTS )
        {
            /* Force sending SyncC */
            HMBMBUF handle;

            WAIT4MX(MX_PMS_CS);
8000cba8:	30 2c       	mov	r12,2
8000cbaa:	fe b0 d7 86 	rcall	80007ab6 <mns_take>
            handle  = cmdFree;
8000cbae:	4a 18       	lddpc	r8,8000cc30 <PmsSyncHandler+0x12c>
            cmdFree = NULL;
            REL_MX(MX_PMS_CS);
8000cbb0:	30 2c       	mov	r12,2
        {
            /* Force sending SyncC */
            HMBMBUF handle;

            WAIT4MX(MX_PMS_CS);
            handle  = cmdFree;
8000cbb2:	70 05       	ld.w	r5,r8[0x0]
            cmdFree = NULL;
8000cbb4:	91 07       	st.w	r8[0x0],r7
            REL_MX(MX_PMS_CS);
8000cbb6:	fe b0 d7 81 	rcall	80007ab8 <mns_give>

            /* Clear any message timers to prevent premature Sync timeout */
            MostClearTimer(&icmFifo.timer);
8000cbba:	0e 9a       	mov	r10,r7
8000cbbc:	0e 9b       	mov	r11,r7
8000cbbe:	49 e4       	lddpc	r4,8000cc34 <PmsSyncHandler+0x130>
8000cbc0:	e8 cc ff d8 	sub	r12,r4,-40
8000cbc4:	fe b0 f2 72 	rcall	8000b0a8 <MostSetTimer>
            MostClearTimer(&mcmFifo.timer);
8000cbc8:	0e 9a       	mov	r10,r7
8000cbca:	0e 9b       	mov	r11,r7
8000cbcc:	49 bc       	lddpc	r12,8000cc38 <PmsSyncHandler+0x134>
8000cbce:	2d 8c       	sub	r12,-40
8000cbd0:	fe b0 f2 6c 	rcall	8000b0a8 <MostSetTimer>
            #ifdef ADS_MIN /* Not needed with MDP_MIN only, no TX */
            MostClearTimer(&mdpFifo.timer);
8000cbd4:	0e 9a       	mov	r10,r7
8000cbd6:	0e 9b       	mov	r11,r7
8000cbd8:	49 9c       	lddpc	r12,8000cc3c <PmsSyncHandler+0x138>
8000cbda:	2d 8c       	sub	r12,-40
8000cbdc:	fe b0 f2 66 	rcall	8000b0a8 <MostSetTimer>
            #endif
            MostSetTimer(&pmsSyncTimer, pmsSyncTimeout, MNS_FALSE);
8000cbe0:	49 88       	lddpc	r8,8000cc40 <PmsSyncHandler+0x13c>
8000cbe2:	0e 9a       	mov	r10,r7
8000cbe4:	90 8b       	ld.uh	r11,r8[0x0]
8000cbe6:	49 2c       	lddpc	r12,8000cc2c <PmsSyncHandler+0x128>
8000cbe8:	fe b0 f2 60 	rcall	8000b0a8 <MostSetTimer>

            if( handle )
8000cbec:	58 05       	cp.w	r5,0
8000cbee:	c0 70       	breq	8000cbfc <PmsSyncHandler+0xf8>
            {
                handle->msg.ctrl = PMS_M_CMD_SYNCC;
8000cbf0:	38 08       	mov	r8,-128
                PmsSendCommand(&icmFifo, handle);
8000cbf2:	0a 9b       	mov	r11,r5
8000cbf4:	08 9c       	mov	r12,r4
            #endif
            MostSetTimer(&pmsSyncTimer, pmsSyncTimeout, MNS_FALSE);

            if( handle )
            {
                handle->msg.ctrl = PMS_M_CMD_SYNCC;
8000cbf6:	eb 68 00 14 	st.b	r5[20],r8
                PmsSendCommand(&icmFifo, handle);
8000cbfa:	c2 df       	rcall	8000ca54 <PmsSendCommand>
8000cbfc:	30 18       	mov	r8,1
            }
            /* else a SyncC is already enqueued */

            pmsSyncState = PMS_S_PENDING;
8000cbfe:	8d 08       	st.w	r6[0x0],r8
8000cc00:	d8 22       	popm	r4-r7,pc
8000cc02:	0a 9c       	mov	r12,r5
                MostClearTimer(&pmsSyncTimer);

                if( !pms.initSync )
                {
                    pms.initSync = 1;
                    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_PMS);
8000cc04:	30 15       	mov	r5,1

                MostClearTimer(&pmsSyncTimer);

                if( !pms.initSync )
                {
                    pms.initSync = 1;
8000cc06:	f3 d5 d3 e1 	bfins	r9,r5,0x1f,0x1
8000cc0a:	0a 9b       	mov	r11,r5
                    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_PMS);
8000cc0c:	91 09       	st.w	r8[0x0],r9

                MostClearTimer(&pmsSyncTimer);

                if( !pms.initSync )
                {
                    pms.initSync = 1;
8000cc0e:	fe b0 f6 57 	rcall	8000b8bc <MnsServiceInitComplete>
                    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_PMS);
8000cc12:	c8 7b       	rjmp	8000cb20 <PmsSyncHandler+0x1c>
8000cc14:	0a 98       	mov	r8,r5

        default:
            break;
    }

    if( actions & PMS_A_RESET_CNT )
8000cc16:	e2 18 00 02 	andl	r8,0x2,COH
8000cc1a:	ca eb       	rjmp	8000cb76 <PmsSyncHandler+0x72>
8000cc1c:	00 00       	add	r0,r0
8000cc1e:	37 98       	mov	r8,121
8000cc20:	00 00       	add	r0,r0
8000cc22:	38 18       	mov	r8,-127
8000cc24:	00 00       	add	r0,r0
8000cc26:	38 38       	mov	r8,-125
8000cc28:	00 00       	add	r0,r0
8000cc2a:	37 d4       	mov	r4,125
8000cc2c:	00 00       	add	r0,r0
8000cc2e:	37 bc       	mov	r12,123
8000cc30:	00 00       	add	r0,r0
8000cc32:	37 d0       	mov	r0,125
8000cc34:	00 00       	add	r0,r0
8000cc36:	39 14       	mov	r4,-111
8000cc38:	00 00       	add	r0,r0
8000cc3a:	38 8c       	mov	r12,-120
8000cc3c:	00 00       	add	r0,r0
8000cc3e:	37 0c       	mov	r12,112
8000cc40:	00 00       	add	r0,r0
8000cc42:	38 80       	mov	r0,-120

8000cc44 <PmsRx>:
8000cc44:	eb cd 40 80 	pushm	r7,lr
8000cc48:	58 0c       	cp.w	r12,0
8000cc4a:	c1 50       	breq	8000cc74 <PmsRx+0x30>
8000cc4c:	78 a8       	ld.w	r8,r12[0x28]
8000cc4e:	49 09       	lddpc	r9,8000cc8c <PmsRx+0x48>
8000cc50:	11 b8       	ld.ub	r8,r8[0x3]
8000cc52:	e2 18 00 06 	andl	r8,0x6,COH
8000cc56:	18 9b       	mov	r11,r12
8000cc58:	e0 67 01 08 	mov	r7,264
        event = PMS_P_RX | PMS_P_RX_ACK | PMS_P_TX_TRIG;
        #else
        event = PMS_P_RX;
        #endif
    }
    MbmEnqueue(q_ptr, handle);
8000cc5c:	48 dc       	lddpc	r12,8000cc90 <PmsRx+0x4c>
        return;
    }

    PMS_LOG_RX(handle->hdr_ptr);

    if( PMS_RX_IS_STATUS(handle) )
8000cc5e:	58 28       	cp.w	r8,2
8000cc60:	f9 b7 01 09 	movne	r7,9
        event = PMS_P_RX | PMS_P_RX_ACK | PMS_P_TX_TRIG;
        #else
        event = PMS_P_RX;
        #endif
    }
    MbmEnqueue(q_ptr, handle);
8000cc64:	f2 0c 17 10 	movne	r12,r9
8000cc68:	fe b0 eb 2a 	rcall	8000a2bc <MbmEnqueue>
     * necessary to trigger TX on completion of RX.
     */
    event |= PMS_P_TX_TRIG;
    #endif

    PmsSetPendingEvent((word)event);
8000cc6c:	0e 9c       	mov	r12,r7
8000cc6e:	cd 3e       	rcall	8000ca14 <PmsSetPendingEvent>
8000cc70:	e3 cd 80 80 	ldm	sp++,r7,pc
8000cc74:	e0 68 01 0b 	mov	r8,267
    MbmQueue *q_ptr;
    word     event;

    T_API_ENTRY(PMS_0);

    ASSERT(handle);
8000cc78:	30 1a       	mov	r10,1
8000cc7a:	1a d8       	st.w	--sp,r8
8000cc7c:	31 0b       	mov	r11,16
8000cc7e:	14 9c       	mov	r12,r10
8000cc80:	fe b0 d7 36 	rcall	80007aec <mns_trace>
8000cc84:	2f fd       	sub	sp,-4
8000cc86:	e3 cd 80 80 	ldm	sp++,r7,pc
8000cc8a:	d7 03       	nop
8000cc8c:	00 00       	add	r0,r0
8000cc8e:	36 fc       	mov	r12,111
8000cc90:	00 00       	add	r0,r0
8000cc92:	37 b0       	mov	r0,123

8000cc94 <_PmsCompressHeaderMCM>:
8000cc94:	d4 31       	pushm	r0-r7,lr
8000cc96:	20 1d       	sub	sp,4
8000cc98:	4d 38       	lddpc	r8,8000cde4 <_PmsCompressHeaderMCM+0x150>
8000cc9a:	f1 18 00 28 	ld.uh	r8,r8[40]
8000cc9e:	78 84       	ld.w	r4,r12[0x20]
}
#endif

#ifdef PMS_65
static bool _PmsCompressHeaderMCM(HMBMBUF handle, bool telId4Enabled)
{
8000cca0:	18 97       	mov	r7,r12
    byte       scf0;                        /* SCF0 for final message */
    bool       success;

    T_MOD_ENTRY(PMS_65);

    cmsg_ptr    = MBM_GET_CTRL_TX_PTR(handle);
8000cca2:	e9 d4 c1 10 	bfextu	r4,r4,0x8,0x10
    if ((FPH_M_SCF0_ENABLED & fph) == FPH_M_SCF0_ENABLED)
    {
        fdh_len += (byte)1;
    }
    
    if ((word)PMS_CTRL_MAX_PAYLOAD < cmsg_ptr->Length)
8000cca6:	f9 05 00 18 	ld.sh	r5,r12[24]
    byte       scf0;                        /* SCF0 for final message */
    bool       success;

    T_MOD_ENTRY(PMS_65);

    cmsg_ptr    = MBM_GET_CTRL_TX_PTR(handle);
8000ccaa:	08 38       	cp.w	r8,r4
8000ccac:	f9 b1 00 04 	moveq	r1,4
8000ccb0:	f9 b1 01 05 	movne	r1,5
8000ccb4:	f9 b0 00 05 	moveq	r0,5
8000ccb8:	f9 b0 01 08 	movne	r0,8
8000ccbc:	f9 b9 00 0c 	moveq	r9,12
8000ccc0:	f9 b9 01 0f 	movne	r9,15
8000ccc4:	f9 b4 00 00 	moveq	r4,0
8000ccc8:	f9 b4 01 10 	movne	r4,16
    if ((FPH_M_SCF0_ENABLED & fph) == FPH_M_SCF0_ENABLED)
    {
        fdh_len += (byte)1;
    }
    
    if ((word)PMS_CTRL_MAX_PAYLOAD < cmsg_ptr->Length)
8000cccc:	32 d8       	mov	r8,45
8000ccce:	f0 05 19 00 	cp.h	r5,r8
8000ccd2:	e0 8b 00 73 	brhi	8000cdb8 <_PmsCompressHeaderMCM+0x124>
8000ccd6:	ea c8 00 02 	sub	r8,r5,2
8000ccda:	e5 d5 c0 08 	bfextu	r2,r5,0x0,0x8
8000ccde:	5c 88       	casts.h	r8
8000cce0:	30 03       	mov	r3,0
    
    if (MNS_FALSE != success)
    {
        /* calculate size of rsvd header */
        byte stuffing_bytes;
        word len = (word)PMS_PM_PRE_FDH_LEN + (word)fdh_len + (word)PMS_PM_INT_BODY_LEN + (word)int_data_len;
8000cce2:	12 03       	add	r3,r9
        
        stuffing_bytes = (byte)(PMS_ALIGN(len,(word)4) - len);      /* calculate stuffing bytes */
        tgt_ptr = MbmPush(handle, (word)(len+stuffing_bytes));      /* align header */
8000cce4:	50 08       	stdsp	sp[0x0],r8
    {
        /* calculate size of rsvd header */
        byte stuffing_bytes;
        word len = (word)PMS_PM_PRE_FDH_LEN + (word)fdh_len + (word)PMS_PM_INT_BODY_LEN + (word)int_data_len;
        
        stuffing_bytes = (byte)(PMS_ALIGN(len,(word)4) - len);      /* calculate stuffing bytes */
8000cce6:	e6 c6 ff fd 	sub	r6,r3,-3
        tgt_ptr = MbmPush(handle, (word)(len+stuffing_bytes));      /* align header */
8000ccea:	0e 9c       	mov	r12,r7
    {
        /* calculate size of rsvd header */
        byte stuffing_bytes;
        word len = (word)PMS_PM_PRE_FDH_LEN + (word)fdh_len + (word)PMS_PM_INT_BODY_LEN + (word)int_data_len;
        
        stuffing_bytes = (byte)(PMS_ALIGN(len,(word)4) - len);      /* calculate stuffing bytes */
8000ccec:	e0 16 ff fc 	andl	r6,0xfffc
8000ccf0:	06 16       	sub	r6,r3
8000ccf2:	5c 56       	castu.b	r6
        tgt_ptr = MbmPush(handle, (word)(len+stuffing_bytes));      /* align header */
8000ccf4:	ec 03 00 03 	add	r3,r6,r3
8000ccf8:	06 9b       	mov	r11,r3
8000ccfa:	fe b0 e9 39 	rcall	80009f6c <MbmPush>

        len = (len + stuffing_bytes + body_data_len) - (word)2;                      /* calculate size of PML */
8000ccfe:	40 08       	lddsp	r8,sp[0x0]
8000cd00:	10 03       	add	r3,r8
8000cd02:	5c 83       	casts.h	r3

        /* - start first quadlet - */
        *tgt_ptr++ = HB(len);
8000cd04:	f1 d3 c1 08 	bfextu	r8,r3,0x8,0x8
8000cd08:	18 c8       	st.b	r12++,r8
        *tgt_ptr++ = LB(len);
        *tgt_ptr++ = (byte)1 + fdh_len + stuffing_bytes;            /* pmhl*/
8000cd0a:	ec 00 00 00 	add	r0,r6,r0

        len = (len + stuffing_bytes + body_data_len) - (word)2;                      /* calculate size of PML */

        /* - start first quadlet - */
        *tgt_ptr++ = HB(len);
        *tgt_ptr++ = LB(len);
8000cd0e:	18 9a       	mov	r10,r12
8000cd10:	14 c3       	st.b	r10++,r3
        *tgt_ptr++ = (byte)1 + fdh_len + stuffing_bytes;            /* pmhl*/
8000cd12:	14 c0       	st.b	r10++,r0
        *tgt_ptr++ = fph;
8000cd14:	14 c1       	st.b	r10++,r1
        /* - end first quadlet - */

        if ((byte)0 != scf0)
8000cd16:	58 04       	cp.w	r4,0
8000cd18:	c0 90       	breq	8000cd2a <_PmsCompressHeaderMCM+0x96>
        {
            *tgt_ptr++ = scf0;
8000cd1a:	14 c4       	st.b	r10++,r4
        {
            *tgt_ptr++ = handle->handle;                            /* byte Handle */
        }
        #endif

        if( scf0 & PMS_M_SCF0_RETRY )
8000cd1c:	c0 70       	breq	8000cd2a <_PmsCompressHeaderMCM+0x96>
        {
            *tgt_ptr++ = cmsg_ptr->MidLevelRetries;                 /* word Retry */
8000cd1e:	ef 38 00 21 	ld.ub	r8,r7[33]
8000cd22:	14 c8       	st.b	r10++,r8
            *tgt_ptr++ = cmsg_ptr->LowLevelRetries;
8000cd24:	ef 38 00 22 	ld.ub	r8,r7[34]
8000cd28:	14 c8       	st.b	r10++,r8
        }

        *tgt_ptr++ = HB(cmsg_ptr->Tgt_Adr);                         /* word TgtDeviceID */
8000cd2a:	ef 38 00 1a 	ld.ub	r8,r7[26]
8000cd2e:	14 9b       	mov	r11,r10
8000cd30:	16 c8       	st.b	r11++,r8
        *tgt_ptr++ = LB(cmsg_ptr->Tgt_Adr);
8000cd32:	ef 08 00 1a 	ld.sh	r8,r7[26]
8000cd36:	16 c8       	st.b	r11++,r8
        *tgt_ptr++ = cmsg_ptr->FBlock_ID;                           /* word FuncAddr */
8000cd38:	ef 38 00 1e 	ld.ub	r8,r7[30]
8000cd3c:	16 c8       	st.b	r11++,r8
        *tgt_ptr++ = cmsg_ptr->Inst_ID;
8000cd3e:	ef 38 00 1f 	ld.ub	r8,r7[31]
8000cd42:	16 c8       	st.b	r11++,r8

        for (;stuffing_bytes > (byte)0; stuffing_bytes--)
8000cd44:	58 06       	cp.w	r6,0
8000cd46:	c0 d0       	breq	8000cd60 <_PmsCompressHeaderMCM+0xcc>
    return MNS_TRUE;
}
#endif

#ifdef PMS_65
static bool _PmsCompressHeaderMCM(HMBMBUF handle, bool telId4Enabled)
8000cd48:	20 16       	sub	r6,1
8000cd4a:	5c 56       	castu.b	r6
8000cd4c:	ec c9 ff fb 	sub	r9,r6,-5
8000cd50:	16 98       	mov	r8,r11
8000cd52:	12 0a       	add	r10,r9
        *tgt_ptr++ = cmsg_ptr->FBlock_ID;                           /* word FuncAddr */
        *tgt_ptr++ = cmsg_ptr->Inst_ID;

        for (;stuffing_bytes > (byte)0; stuffing_bytes--)
        {
            *tgt_ptr++ = (byte)0;
8000cd54:	30 09       	mov	r9,0
8000cd56:	10 c9       	st.b	r8++,r9
        *tgt_ptr++ = HB(cmsg_ptr->Tgt_Adr);                         /* word TgtDeviceID */
        *tgt_ptr++ = LB(cmsg_ptr->Tgt_Adr);
        *tgt_ptr++ = cmsg_ptr->FBlock_ID;                           /* word FuncAddr */
        *tgt_ptr++ = cmsg_ptr->Inst_ID;

        for (;stuffing_bytes > (byte)0; stuffing_bytes--)
8000cd58:	14 38       	cp.w	r8,r10
8000cd5a:	cf e1       	brne	8000cd56 <_PmsCompressHeaderMCM+0xc2>
8000cd5c:	2f f6       	sub	r6,-1
8000cd5e:	0c 0b       	add	r11,r6
        {
            *tgt_ptr++ = (byte)0;
        }

        *tgt_ptr++ = (byte)(cmsg_ptr->Func_ID >> 4);
8000cd60:	ef 18 00 1c 	ld.uh	r8,r7[28]
8000cd64:	a5 88       	lsr	r8,0x4
8000cd66:	16 c8       	st.b	r11++,r8
        *tgt_ptr++ = (byte)((byte)(LB(cmsg_ptr->Func_ID) << 4)  | cmsg_ptr->Operation);
8000cd68:	ef 39 00 1d 	ld.ub	r9,r7[29]
8000cd6c:	ef 38 00 20 	ld.ub	r8,r7[32]
8000cd70:	f1 e9 10 48 	or	r8,r8,r9<<0x4
8000cd74:	16 c8       	st.b	r11++,r8

        len = int_data_len + body_data_len;

        *tgt_ptr++ = HB(len) | (byte)(handle->tel_id << 4); /* Tel_ID = 0x0 or 0x1 */
8000cd76:	ef 38 00 36 	ld.ub	r8,r7[54]
8000cd7a:	a5 68       	lsl	r8,0x4
8000cd7c:	16 c8       	st.b	r11++,r8
        *tgt_ptr++ = LB(len);
8000cd7e:	b6 82       	st.b	r11[0x0],r2

        len = body_data_len;                                /* Restore Data Length */

        if(handle->type & MBM_STAT_TX_SEG)
8000cd80:	8e e8       	ld.uh	r8,r7[0xc]
8000cd82:	ed b8 00 04 	bld	r8,0x4
8000cd86:	c1 31       	brne	8000cdac <_PmsCompressHeaderMCM+0x118>
        *tgt_ptr++ = (byte)((byte)(LB(cmsg_ptr->Func_ID) << 4)  | cmsg_ptr->Operation);

        len = int_data_len + body_data_len;

        *tgt_ptr++ = HB(len) | (byte)(handle->tel_id << 4); /* Tel_ID = 0x0 or 0x1 */
        *tgt_ptr++ = LB(len);
8000cd88:	2f fb       	sub	r11,-1

        len = body_data_len;                                /* Restore Data Length */

        if(handle->type & MBM_STAT_TX_SEG)
        {
            if (PMS_TELID_4 == handle->tel_id)
8000cd8a:	ef 39 00 36 	ld.ub	r9,r7[54]
8000cd8e:	30 48       	mov	r8,4
            {
                *tgt_ptr++ = HB(cmsg_ptr->Length);          /* Message Size (TelID 0x4) */
8000cd90:	f0 09 18 00 	cp.b	r9,r8
8000cd94:	ef f8 08 18 	ld.ubeq	r8,r7[0x18]
8000cd98:	f7 f8 0e 00 	st.beq	r11[0x0],r8
                *tgt_ptr++ = LB(cmsg_ptr->Length);
8000cd9c:	ef f8 02 0c 	ld.sheq	r8,r7[0x18]
8000cda0:	f7 f8 0e 01 	st.beq	r11[0x1],r8
            }
            else
            {
                *tgt_ptr++ = (byte)0x00;                    /* Message Counter */
8000cda4:	f9 b8 01 00 	movne	r8,0
8000cda8:	f7 f8 1e 00 	st.bne	r11[0x0],r8
        }
        #endif

        tgt_ptr = cmsg_ptr->Data;                           /* Payload */

        MBM_SET_PAYLOAD_PTR(handle, tgt_ptr);
8000cdac:	6e 58       	ld.w	r8,r7[0x14]
        MBM_SET_PAYLOAD_LEN(handle, len);
8000cdae:	ef 55 00 34 	st.h	r7[52],r5
        }
        #endif

        tgt_ptr = cmsg_ptr->Data;                           /* Payload */

        MBM_SET_PAYLOAD_PTR(handle, tgt_ptr);
8000cdb2:	8f b8       	st.w	r7[0x2c],r8
    }

    T_MOD_EXIT(PMS_65);
    
    return success;
}
8000cdb4:	2f fd       	sub	sp,-4
8000cdb6:	da 3a       	popm	r0-r7,pc,r12=1
    }
    
    if ((word)PMS_CTRL_MAX_PAYLOAD < cmsg_ptr->Length)
    {
        #ifndef PMS_TX_NOSEG
        MBM_SET_STATUS_BITS(handle, MBM_STAT_TX_SEG);   /* segmented */
8000cdb8:	98 68       	ld.sh	r8,r12[0xc]
8000cdba:	a5 a8       	sbr	r8,0x4
8000cdbc:	b8 68       	st.h	r12[0xc],r8

        if (MNS_FALSE != telId4Enabled)
8000cdbe:	58 0b       	cp.w	r11,0
8000cdc0:	c0 90       	breq	8000cdd2 <_PmsCompressHeaderMCM+0x13e>
        {
            handle->tel_id = PMS_TELID_4;
8000cdc2:	30 48       	mov	r8,4
8000cdc4:	30 22       	mov	r2,2
8000cdc6:	f9 68 00 36 	st.b	r12[54],r8
8000cdca:	04 93       	mov	r3,r2
8000cdcc:	3f e8       	mov	r8,-2
8000cdce:	30 05       	mov	r5,0
8000cdd0:	c8 9b       	rjmp	8000cce2 <_PmsCompressHeaderMCM+0x4e>
            int_data_len  += (byte)2;                   /* internally add MsgSize */
            body_data_len  = (word)0;
        }
        else
        {
            handle->tel_id = PMS_TELID_1;
8000cdd2:	30 18       	mov	r8,1
8000cdd4:	32 d2       	mov	r2,45
8000cdd6:	f9 68 00 36 	st.b	r12[54],r8
8000cdda:	30 13       	mov	r3,1
8000cddc:	32 a8       	mov	r8,42
8000cdde:	32 c5       	mov	r5,44
8000cde0:	c8 1b       	rjmp	8000cce2 <_PmsCompressHeaderMCM+0x4e>
8000cde2:	d7 03       	nop
8000cde4:	00 00       	add	r0,r0
8000cde6:	37 d4       	mov	r4,125

8000cde8 <PmsGetBuf>:
8000cde8:	eb cd 40 e0 	pushm	r5-r7,lr
    HMBMBUF handle;
    word    reserved;
    bool    size_ok;

    T_LIB_ENTRY(PMS_6);
    ASSERT((word)0 == (type & (word)~MBM_TYPE_MASK)); /* parameter type must not contain status bits */
8000cdec:	16 96       	mov	r6,r11
}
#endif

#ifdef PMS_6
HMBMBUF PmsGetBuf(word size, word type)
{
8000cdee:	16 97       	mov	r7,r11
    HMBMBUF handle;
    word    reserved;
    bool    size_ok;

    T_LIB_ENTRY(PMS_6);
    ASSERT((word)0 == (type & (word)~MBM_TYPE_MASK)); /* parameter type must not contain status bits */
8000cdf0:	5c 76       	castu.h	r6
}
#endif

#ifdef PMS_6
HMBMBUF PmsGetBuf(word size, word type)
{
8000cdf2:	18 95       	mov	r5,r12
    HMBMBUF handle;
    word    reserved;
    bool    size_ok;

    T_LIB_ENTRY(PMS_6);
    ASSERT((word)0 == (type & (word)~MBM_TYPE_MASK)); /* parameter type must not contain status bits */
8000cdf4:	0c 98       	mov	r8,r6
8000cdf6:	e2 18 ff f0 	andl	r8,0xfff0,COH
8000cdfa:	c1 61       	brne	8000ce26 <PmsGetBuf+0x3e>

    handle = NULL;

    if( MBM_TYPE_CTRL_TX == type )
8000cdfc:	30 58       	mov	r8,5
8000cdfe:	f0 07 19 00 	cp.h	r7,r8
8000ce02:	c1 f0       	breq	8000ce40 <PmsGetBuf+0x58>
    {
        reserved = (word)PMS_CTRL_HDR_MAX_SIZE;
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( MBM_TYPE_DATA_TX == type )
8000ce04:	30 1b       	mov	r11,1
        reserved = (word)0;
    }

    size_ok = (size > (word)PMS_ALLOC_MAX_SIZE) ? MNS_FALSE : MNS_TRUE;

    if (MNS_FALSE != size_ok)
8000ce06:	fe 78 fa 00 	mov	r8,-1536
    if( MBM_TYPE_CTRL_TX == type )
    {
        reserved = (word)PMS_CTRL_HDR_MAX_SIZE;
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( MBM_TYPE_DATA_TX == type )
8000ce0a:	ee 0b 19 00 	cp.h	r11,r7
8000ce0e:	f9 bb 00 0a 	moveq	r11,10
8000ce12:	f9 bb 01 00 	movne	r11,0
        reserved = (word)0;
    }

    size_ok = (size > (word)PMS_ALLOC_MAX_SIZE) ? MNS_FALSE : MNS_TRUE;

    if (MNS_FALSE != size_ok)
8000ce16:	f0 05 19 00 	cp.h	r5,r8
8000ce1a:	e0 88 00 1a 	brls	8000ce4e <PmsGetBuf+0x66>
8000ce1e:	30 07       	mov	r7,0
        PmsFireBufFreed();
    }

    T_LIB_EXIT(PMS_6);
    return( handle );
}
8000ce20:	0e 9c       	mov	r12,r7
8000ce22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    HMBMBUF handle;
    word    reserved;
    bool    size_ok;

    T_LIB_ENTRY(PMS_6);
    ASSERT((word)0 == (type & (word)~MBM_TYPE_MASK)); /* parameter type must not contain status bits */
8000ce26:	e0 68 06 04 	mov	r8,1540
8000ce2a:	30 1a       	mov	r10,1
8000ce2c:	1a d8       	st.w	--sp,r8
8000ce2e:	31 0b       	mov	r11,16
8000ce30:	14 9c       	mov	r12,r10
8000ce32:	fe b0 d6 5d 	rcall	80007aec <mns_trace>

    handle = NULL;

    if( MBM_TYPE_CTRL_TX == type )
8000ce36:	30 58       	mov	r8,5
    HMBMBUF handle;
    word    reserved;
    bool    size_ok;

    T_LIB_ENTRY(PMS_6);
    ASSERT((word)0 == (type & (word)~MBM_TYPE_MASK)); /* parameter type must not contain status bits */
8000ce38:	2f fd       	sub	sp,-4

    handle = NULL;

    if( MBM_TYPE_CTRL_TX == type )
8000ce3a:	f0 07 19 00 	cp.h	r7,r8
8000ce3e:	ce 31       	brne	8000ce04 <PmsGetBuf+0x1c>
8000ce40:	31 4b       	mov	r11,20
        reserved = (word)0;
    }

    size_ok = (size > (word)PMS_ALLOC_MAX_SIZE) ? MNS_FALSE : MNS_TRUE;

    if (MNS_FALSE != size_ok)
8000ce42:	fe 78 fa 00 	mov	r8,-1536
8000ce46:	f0 05 19 00 	cp.h	r5,r8
8000ce4a:	fe 9b ff ea 	brhi	8000ce1e <PmsGetBuf+0x36>
    {
        size  += reserved;
        #ifdef MSG_RX_USER_PAYLOAD
        handle = MbmAllocate((MBM_TYPE_CTRL_RX == type) ? (word)0 : size, reserved, type);
        #else
        handle = MbmAllocate(size, reserved, type);
8000ce4e:	f6 05 00 0c 	add	r12,r11,r5
8000ce52:	0c 9a       	mov	r10,r6
8000ce54:	5c 7c       	castu.h	r12
8000ce56:	fe b0 e9 d1 	rcall	8000a1f8 <MbmAllocate>
8000ce5a:	18 97       	mov	r7,r12
        #endif
    }

    if( handle )
8000ce5c:	c0 60       	breq	8000ce68 <PmsGetBuf+0x80>
    {
        PmsFillDefaultHeader(handle);
8000ce5e:	fe b0 fd 0f 	rcall	8000c87c <PmsFillDefaultHeader>
        PmsFireBufFreed();
    }

    T_LIB_EXIT(PMS_6);
    return( handle );
}
8000ce62:	0e 9c       	mov	r12,r7
8000ce64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc


#ifdef PMS_63
static _INLINE void PmsFireBufFreed(void)
{
    pms.fire_buf_freed = MNS_TRUE;
8000ce68:	30 19       	mov	r9,1
8000ce6a:	48 38       	lddpc	r8,8000ce74 <PmsGetBuf+0x8c>
8000ce6c:	f1 69 00 2a 	st.b	r8[42],r9
8000ce70:	cd 8b       	rjmp	8000ce20 <PmsGetBuf+0x38>
8000ce72:	d7 03       	nop
8000ce74:	00 00       	add	r0,r0
8000ce76:	37 d4       	mov	r4,125

8000ce78 <PmsFifoInit>:
8000ce78:	eb cd 40 80 	pushm	r7,lr
8000ce7c:	30 3b       	mov	r11,3
8000ce7e:	18 97       	mov	r7,r12
8000ce80:	fe b0 ea 4a 	rcall	8000a314 <MbmQueueInit>
#ifdef PMS_9
static void PmsFifoInit(PmsFifo *fifo_ptr)
{
    T_MOD_ENTRY(PMS_9);
    MbmQueueInit(&fifo_ptr->msgQ, (word)MX_PMS_Q);
    MbmQueueInit(&fifo_ptr->cmdQ, (word)MX_PMS_Q);
8000ce84:	30 3b       	mov	r11,3
8000ce86:	ee cc ff f4 	sub	r12,r7,-12
8000ce8a:	fe b0 ea 45 	rcall	8000a314 <MbmQueueInit>
    MbmQueueInit(&fifo_ptr->pendingQ, (word)MX_PMS_Q);
8000ce8e:	30 3b       	mov	r11,3
8000ce90:	ee cc ff e8 	sub	r12,r7,-24
8000ce94:	fe b0 ea 40 	rcall	8000a314 <MbmQueueInit>
    fifo_ptr->syncGuard = (byte)0;
    #ifdef PMS_32
    {
        /* Initialize buffer for acknowledge messages */
        MbmBuf *buf_ptr      = &fifo_ptr->ack;
        buf_ptr->start_ptr   = fifo_ptr->ackData;
8000ce98:	ee c8 ff 88 	sub	r8,r7,-120
        buf_ptr->hdr_ptr     = fifo_ptr->ackData;
        buf_ptr->payload_ptr = fifo_ptr->ackData;
8000ce9c:	ef 48 00 6c 	st.w	r7[108],r8
    fifo_ptr->syncGuard = (byte)0;
    #ifdef PMS_32
    {
        /* Initialize buffer for acknowledge messages */
        MbmBuf *buf_ptr      = &fifo_ptr->ack;
        buf_ptr->start_ptr   = fifo_ptr->ackData;
8000cea0:	ef 48 00 50 	st.w	r7[80],r8
        buf_ptr->hdr_ptr     = fifo_ptr->ackData;
8000cea4:	ef 48 00 68 	st.w	r7[104],r8
        buf_ptr->payload_ptr = fifo_ptr->ackData;
        buf_ptr->hdr_len     = (word)0;
8000cea8:	30 08       	mov	r8,0
        buf_ptr->type      = MBM_TYPE_STATUS_TX;
        #ifdef PMS_USE_HANDLE
        buf_ptr->handle    = PMS_DEF_HANDLE;
        #endif
    }
    fifo_ptr->rxStatus = PMS_STATUS_NONE;
8000ceaa:	ef 68 00 82 	st.b	r7[130],r8
        /* Initialize buffer for acknowledge messages */
        MbmBuf *buf_ptr      = &fifo_ptr->ack;
        buf_ptr->start_ptr   = fifo_ptr->ackData;
        buf_ptr->hdr_ptr     = fifo_ptr->ackData;
        buf_ptr->payload_ptr = fifo_ptr->ackData;
        buf_ptr->hdr_len     = (word)0;
8000ceae:	ef 58 00 72 	st.h	r7[114],r8
        buf_ptr->payload_len = (word)0;
8000ceb2:	ef 58 00 74 	st.h	r7[116],r8
    T_MOD_ENTRY(PMS_9);
    MbmQueueInit(&fifo_ptr->msgQ, (word)MX_PMS_Q);
    MbmQueueInit(&fifo_ptr->cmdQ, (word)MX_PMS_Q);
    MbmQueueInit(&fifo_ptr->pendingQ, (word)MX_PMS_Q);
    fifo_ptr->txSlotsAvailable = (byte)0;                 /* Set on initial Sync */
    fifo_ptr->syncGuard = (byte)0;
8000ceb6:	ef 68 00 84 	st.b	r7[132],r8
{
    T_MOD_ENTRY(PMS_9);
    MbmQueueInit(&fifo_ptr->msgQ, (word)MX_PMS_Q);
    MbmQueueInit(&fifo_ptr->cmdQ, (word)MX_PMS_Q);
    MbmQueueInit(&fifo_ptr->pendingQ, (word)MX_PMS_Q);
    fifo_ptr->txSlotsAvailable = (byte)0;                 /* Set on initial Sync */
8000ceba:	ef 68 00 83 	st.b	r7[131],r8
        buf_ptr->start_ptr   = fifo_ptr->ackData;
        buf_ptr->hdr_ptr     = fifo_ptr->ackData;
        buf_ptr->payload_ptr = fifo_ptr->ackData;
        buf_ptr->hdr_len     = (word)0;
        buf_ptr->payload_len = (word)0;
        buf_ptr->size      = PMS_CMD_SIZE;
8000cebe:	30 a8       	mov	r8,10
8000cec0:	ef 58 00 70 	st.h	r7[112],r8
        buf_ptr->type      = MBM_TYPE_STATUS_TX;
8000cec4:	30 38       	mov	r8,3
8000cec6:	ef 58 00 4c 	st.h	r7[76],r8
    }
    fifo_ptr->rxStatus = PMS_STATUS_NONE;
    #endif

    #ifdef MDP_MIN
    if( &mdpFifo == fifo_ptr )
8000ceca:	48 d8       	lddpc	r8,8000cefc <PmsFifoInit+0x84>
8000cecc:	10 37       	cp.w	r7,r8
8000cece:	c0 40       	breq	8000ced6 <PmsFifoInit+0x5e>
    {
        fifo_ptr->timeout = PMS_T_MDP;
    }
    else
    #endif
    if( &icmFifo == fifo_ptr )
8000ced0:	48 c8       	lddpc	r8,8000cf00 <PmsFifoInit+0x88>
8000ced2:	10 37       	cp.w	r7,r8
8000ced4:	c0 e0       	breq	8000cef0 <PmsFifoInit+0x78>
    {
        fifo_ptr->timeout = PMS_T_ICM;
    }
    else
    {
        fifo_ptr->timeout = PMS_T_MCM;
8000ced6:	e0 68 07 d0 	mov	r8,2000
8000ceda:	ef 58 00 3c 	st.h	r7[60],r8

    #if defined(MDP_MIN) && !defined(ADS_MIN)
    if( &mdpFifo != fifo_ptr ) /* No need to register since it isn't used with MDP_MIN only */
    #endif
    {
        MostRegisterTimer(&fifo_ptr->timer, PmsSetPendingEvent, PMS_P_TIMEOUT);
8000cede:	ee cc ff d8 	sub	r12,r7,-40
8000cee2:	30 2a       	mov	r10,2
8000cee4:	fe cb 04 d0 	sub	r11,pc,1232
8000cee8:	fe b0 f1 56 	rcall	8000b194 <MostRegisterTimer>
    }

    T_MOD_EXIT(PMS_9);
}
8000ceec:	e3 cd 80 80 	ldm	sp++,r7,pc
    }
    else
    #endif
    if( &icmFifo == fifo_ptr )
    {
        fifo_ptr->timeout = PMS_T_ICM;
8000cef0:	e0 68 01 f4 	mov	r8,500
8000cef4:	ef 58 00 3c 	st.h	r7[60],r8
8000cef8:	cf 3b       	rjmp	8000cede <PmsFifoInit+0x66>
8000cefa:	d7 03       	nop
8000cefc:	00 00       	add	r0,r0
8000cefe:	37 0c       	mov	r12,112
8000cf00:	00 00       	add	r0,r0
8000cf02:	39 14       	mov	r4,-111

8000cf04 <PmsGetRxBuf>:
8000cf04:	eb cd 40 e0 	pushm	r5-r7,lr
8000cf08:	18 96       	mov	r6,r12
8000cf0a:	5c 7c       	castu.h	r12
    HMBMBUF handle;

    T_API_ENTRY(PMS_31);

    /* Try to allocate new buffer first */
    handle = MbmGetBuf(size);
8000cf0c:	fe b0 e9 ca 	rcall	8000a2a0 <MbmGetBuf>
8000cf10:	18 97       	mov	r7,r12

    if( !handle )
8000cf12:	c0 40       	breq	8000cf1a <PmsGetRxBuf+0x16>
        }
    }
    T_API_EXIT(PMS_31);

    return( handle );
}
8000cf14:	0e 9c       	mov	r12,r7
8000cf16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    /* Try to allocate new buffer first */
    handle = MbmGetBuf(size);

    if( !handle )
    {
        if( size <= PMS_CFG_BUFSIZE_SMALL )
8000cf1a:	34 48       	mov	r8,68
8000cf1c:	f0 06 19 00 	cp.h	r6,r8
8000cf20:	e0 88 00 07 	brls	8000cf2e <PmsGetRxBuf+0x2a>
8000cf24:	48 c6       	lddpc	r6,8000cf54 <PmsGetRxBuf+0x50>


#ifdef PMS_63
static _INLINE void PmsFireBufFreed(void)
{
    pms.fire_buf_freed = MNS_TRUE;
8000cf26:	30 18       	mov	r8,1
8000cf28:	ed 68 00 2a 	st.b	r6[42],r8
8000cf2c:	cf 4b       	rjmp	8000cf14 <PmsGetRxBuf+0x10>

    if( !handle )
    {
        if( size <= PMS_CFG_BUFSIZE_SMALL )
        {
            WAIT4MX(MX_PMS_CS);
8000cf2e:	30 2c       	mov	r12,2
8000cf30:	fe b0 d5 c3 	rcall	80007ab6 <mns_take>
            handle = pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC];
8000cf34:	48 86       	lddpc	r6,8000cf54 <PmsGetRxBuf+0x50>
            pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC] = NULL;
            pms.needPrealloc = 1;
8000cf36:	30 19       	mov	r9,1
8000cf38:	6c 08       	ld.w	r8,r6[0x0]
8000cf3a:	f1 d9 d3 41 	bfins	r8,r9,0x1a,0x1
    if( !handle )
    {
        if( size <= PMS_CFG_BUFSIZE_SMALL )
        {
            WAIT4MX(MX_PMS_CS);
            handle = pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC];
8000cf3e:	6c 65       	ld.w	r5,r6[0x18]
            pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC] = NULL;
            pms.needPrealloc = 1;
8000cf40:	8d 08       	st.w	r6[0x0],r8
    {
        if( size <= PMS_CFG_BUFSIZE_SMALL )
        {
            WAIT4MX(MX_PMS_CS);
            handle = pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC];
            pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC] = NULL;
8000cf42:	8d 67       	st.w	r6[0x18],r7
            pms.needPrealloc = 1;
            REL_MX(MX_PMS_CS);
8000cf44:	30 2c       	mov	r12,2
8000cf46:	fe b0 d5 b9 	rcall	80007ab8 <mns_give>
        {
            handle = MbmDequeue(&mdpRxPreallocQ);
        }
        #endif

        if (!handle)
8000cf4a:	58 05       	cp.w	r5,0
8000cf4c:	ce d0       	breq	8000cf26 <PmsGetRxBuf+0x22>
8000cf4e:	0a 97       	mov	r7,r5
8000cf50:	ce 2b       	rjmp	8000cf14 <PmsGetRxBuf+0x10>
8000cf52:	d7 03       	nop
8000cf54:	00 00       	add	r0,r0
8000cf56:	37 d4       	mov	r4,125

8000cf58 <MbmFree>:
8000cf58:	d4 31       	pushm	r0-r7,lr
8000cf5a:	20 4d       	sub	sp,16
8000cf5c:	18 97       	mov	r7,r12
8000cf5e:	58 0c       	cp.w	r12,0
8000cf60:	c0 40       	breq	8000cf68 <MbmFree+0x10>
8000cf62:	fe b0 e7 13 	rcall	80009d88 <MbmIsFromPool>
    timeout = (word)0;
    start_timer = MNS_FALSE;
    is_command  = MNS_FALSE;

    /*lint -e{960} right-hand operator has no side effects (read only)*/
    if( handle && (MNS_FALSE == MbmIsFromPool(handle)) )
8000cf66:	c7 40       	breq	8000d04e <MbmFree+0xf6>
        }
        /* Else it'll be freed later */
    }
    #endif

    if( pms.needPrealloc )
8000cf68:	4e d6       	lddpc	r6,8000d11c <MbmFree+0x1c4>
8000cf6a:	6c 05       	ld.w	r5,r6[0x0]
8000cf6c:	e6 15 04 00 	andh	r5,0x400,COH
8000cf70:	c4 b0       	breq	8000d006 <MbmFree+0xae>
    {
        if( handle )
8000cf72:	58 07       	cp.w	r7,0
8000cf74:	c0 c0       	breq	8000cf8c <MbmFree+0x34>
        {
            /* Only small buffers hereafter */
            if( PMS_CFG_BUFSIZE_SMALL != handle->size )
8000cf76:	ef 09 00 30 	ld.sh	r9,r7[48]
8000cf7a:	34 48       	mov	r8,68
8000cf7c:	f0 09 19 00 	cp.h	r9,r8
8000cf80:	e0 80 00 9e 	breq	8000d0bc <MbmFree+0x164>
            {
                MbmReserve(handle, (word)0);
            }
            else
            {
                MbmFree2(handle);
8000cf84:	0e 9c       	mov	r12,r7
8000cf86:	fe b0 e9 df 	rcall	8000a344 <MbmFree2>
8000cf8a:	30 07       	mov	r7,0
                handle = NULL;
            }
        }

        /* Try to preallocate all necessary RX buffers */
        WAIT4MX(MX_PMS_CS);
8000cf8c:	30 2c       	mov	r12,2
8000cf8e:	fe b0 d5 94 	rcall	80007ab6 <mns_take>
        #if (defined ADS_MIN) && !(defined PMS_RX_OPT3)  /* Not needed for MDP_MIN, only I2C */
        mdpOnMlb = (&generalData == mdpFifo.iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000cf92:	4e 48       	lddpc	r8,8000d120 <MbmFree+0x1c8>
8000cf94:	30 04       	mov	r4,0
8000cf96:	70 99       	ld.w	r9,r8[0x24]
8000cf98:	30 13       	mov	r3,1
8000cf9a:	08 95       	mov	r5,r4
8000cf9c:	08 98       	mov	r8,r4
                        break; /* quit */
                    }
                }
            }
            i++;
        } while( i < (word)PMS_RX_PREALLOC ); /* With only MDP_MIN no MDP prealloc will be included */
8000cf9e:	30 30       	mov	r0,3
                        pms.rxPreAllocPtrTab[i] = handle;
                        handle  = NULL; /* used */
                        #ifndef PMS_RX_OPT3
                        trigger = MNS_TRUE; /* Trigger the acknowledge mechanism */
                        #endif
                        if( PMS_IDX_MCM_RX_PREALLOC == i )
8000cfa0:	30 2b       	mov	r11,2
        }

        /* Try to preallocate all necessary RX buffers */
        WAIT4MX(MX_PMS_CS);
        #if (defined ADS_MIN) && !(defined PMS_RX_OPT3)  /* Not needed for MDP_MIN, only I2C */
        mdpOnMlb = (&generalData == mdpFifo.iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000cfa2:	4e 1a       	lddpc	r10,8000d124 <MbmFree+0x1cc>
8000cfa4:	08 92       	mov	r2,r4
8000cfa6:	2f f4       	sub	r4,-1
8000cfa8:	5c 82       	casts.h	r2
        {
            #if (defined ADS_MIN) && !(defined PMS_RX_OPT3) /* Not required for MDP_MIN, no preallocated buffer */
            if( (i != PMS_IDX_MDP_RX_PREALLOC) || (MNS_FALSE == mdpOnMlb) ) /* MDP over MLB does not require this buffer */
            #endif
            {
                if( NULL == pms.rxPreAllocPtrTab[i] )
8000cfaa:	e3 d2 c0 10 	bfextu	r1,r2,0x0,0x10
8000cfae:	2f a1       	sub	r1,-6
8000cfb0:	ec 01 03 2c 	ld.w	r12,r6[r1<<0x2]
8000cfb4:	58 0c       	cp.w	r12,0
8000cfb6:	c7 50       	breq	8000d0a0 <MbmFree+0x148>
                        break; /* quit */
                    }
                }
            }
            i++;
        } while( i < (word)PMS_RX_PREALLOC ); /* With only MDP_MIN no MDP prealloc will be included */
8000cfb8:	e0 03 19 00 	cp.h	r3,r0
8000cfbc:	e0 8b 00 4e 	brhi	8000d058 <MbmFree+0x100>
        i = (word)0;

        do
        {
            #if (defined ADS_MIN) && !(defined PMS_RX_OPT3) /* Not required for MDP_MIN, no preallocated buffer */
            if( (i != PMS_IDX_MDP_RX_PREALLOC) || (MNS_FALSE == mdpOnMlb) ) /* MDP over MLB does not require this buffer */
8000cfc0:	e0 03 19 00 	cp.h	r3,r0
8000cfc4:	c3 d0       	breq	8000d03e <MbmFree+0xe6>
        }

        /* Try to preallocate all necessary RX buffers */
        WAIT4MX(MX_PMS_CS);
        #if (defined ADS_MIN) && !(defined PMS_RX_OPT3)  /* Not needed for MDP_MIN, only I2C */
        mdpOnMlb = (&generalData == mdpFifo.iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000cfc6:	2f f3       	sub	r3,-1
8000cfc8:	5c 83       	casts.h	r3
8000cfca:	ce db       	rjmp	8000cfa4 <MbmFree+0x4c>
            {
                /*
                 * Check the pre-allocation failed timer exclusively for MCM.
                 * Don't care if it is already running.
                 */
                if( !pms.rxPreAllocFailedTimerStarted )
8000cfcc:	66 02       	ld.w	r2,r3[0x0]
8000cfce:	e6 12 01 00 	andh	r2,0x100,COH
8000cfd2:	c4 d1       	brne	8000d06c <MbmFree+0x114>
                        pms.rxPreAllocFailedTimerStarted = 1;
                        start_timer = MNS_TRUE;
                        timeout = PMS_T_PREALLOC_RETRY;
                    }
                    #else
                    timeout = MnsGetWatchdogKickTimeout();
8000cfd4:	fe b0 ef 0e 	rcall	8000adf0 <MnsGetWatchdogKickTimeout>

                    if( pms.rxPreAllocHasTimedOut )
8000cfd8:	66 08       	ld.w	r8,r3[0x0]
                        pms.rxPreAllocFailedTimerStarted = 1;
                        start_timer = MNS_TRUE;
                        timeout = PMS_T_PREALLOC_RETRY;
                    }
                    #else
                    timeout = MnsGetWatchdogKickTimeout();
8000cfda:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10

                    if( pms.rxPreAllocHasTimedOut )
8000cfde:	10 91       	mov	r1,r8
8000cfe0:	e6 11 02 00 	andh	r1,0x200,COH
8000cfe4:	e0 81 00 8e 	brne	8000d100 <MbmFree+0x1a8>
                         * There has been at least one timeout and the slot has not
                         * been filled yet, make next timeout short.
                         */
                        timeout = PMS_T_PREALLOC_RETRY;
                    }
                    pms.rxPreAllocFailedTimerStarted = 1;
8000cfe8:	30 19       	mov	r9,1
8000cfea:	f1 d9 d3 01 	bfins	r8,r9,0x18,0x1
                    start_timer = MNS_TRUE;
                    #endif
                }
            }
        }
        REL_MX(MX_PMS_CS);
8000cfee:	30 2c       	mov	r12,2
                         * There has been at least one timeout and the slot has not
                         * been filled yet, make next timeout short.
                         */
                        timeout = PMS_T_PREALLOC_RETRY;
                    }
                    pms.rxPreAllocFailedTimerStarted = 1;
8000cff0:	06 a8       	st.w	r3++,r8
                    start_timer = MNS_TRUE;
                    #endif
                }
            }
        }
        REL_MX(MX_PMS_CS);
8000cff2:	fe b0 d5 63 	rcall	80007ab8 <mns_give>

        if( MNS_FALSE != start_timer )
        {
            MostSetTimer(&pms.rxPreAllocFailedTimer, timeout, MNS_FALSE);
8000cff6:	08 9b       	mov	r11,r4
8000cff8:	02 9a       	mov	r10,r1
8000cffa:	06 9c       	mov	r12,r3
8000cffc:	5c 7b       	castu.h	r11
8000cffe:	fe b0 f0 55 	rcall	8000b0a8 <MostSetTimer>

            if ((word)0 == timeout)
8000d002:	58 04       	cp.w	r4,0
8000d004:	c4 10       	breq	8000d086 <MbmFree+0x12e>
                REL_MX(MX_PMS_CS);
            }
        }
    } /* if(pms.needPrealloc) */

    if( handle )
8000d006:	58 07       	cp.w	r7,0
8000d008:	c0 40       	breq	8000d010 <MbmFree+0xb8>
    {
        MbmFree2(handle);
8000d00a:	0e 9c       	mov	r12,r7
8000d00c:	fe b0 e9 9c 	rcall	8000a344 <MbmFree2>
    }

    if( MNS_FALSE != pms.fire_buf_freed )
8000d010:	ed 39 00 2a 	ld.ub	r9,r6[42]
8000d014:	30 08       	mov	r8,0
8000d016:	f0 09 18 00 	cp.b	r9,r8
8000d01a:	c0 a0       	breq	8000d02e <MbmFree+0xd6>
    {
        pms.fire_buf_freed = MNS_FALSE;
8000d01c:	4c 09       	lddpc	r9,8000d11c <MbmFree+0x1c4>
8000d01e:	f3 68 00 2a 	st.b	r9[42],r8

        if( pmsInitData_ptr->cbBufFreed_fptr )
8000d022:	4c 28       	lddpc	r8,8000d128 <MbmFree+0x1d0>
8000d024:	70 08       	ld.w	r8,r8[0x0]
8000d026:	70 b8       	ld.w	r8,r8[0x2c]
8000d028:	58 08       	cp.w	r8,0
8000d02a:	c0 20       	breq	8000d02e <MbmFree+0xd6>
        {
            pmsInitData_ptr->cbBufFreed_fptr();
8000d02c:	5d 18       	icall	r8
        }
    }

    #ifndef PMS_RX_OPT3
    if( MNS_FALSE != trigger )
8000d02e:	58 05       	cp.w	r5,0
8000d030:	c0 50       	breq	8000d03a <MbmFree+0xe2>
    {
        PmsSetPendingEvent(PMS_P_RX_ACK);
8000d032:	e0 6c 00 80 	mov	r12,128
8000d036:	fe b0 fc ef 	rcall	8000ca14 <PmsSetPendingEvent>
    }
    #endif

    T_LIB_EXIT(PMS_8);
}
8000d03a:	2f cd       	sub	sp,-16
8000d03c:	d8 32       	popm	r0-r7,pc
        }

        /* Try to preallocate all necessary RX buffers */
        WAIT4MX(MX_PMS_CS);
        #if (defined ADS_MIN) && !(defined PMS_RX_OPT3)  /* Not needed for MDP_MIN, only I2C */
        mdpOnMlb = (&generalData == mdpFifo.iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000d03e:	14 39       	cp.w	r9,r10
8000d040:	cc 31       	brne	8000cfc6 <MbmFree+0x6e>
            i++;
        } while( i < (word)PMS_RX_PREALLOC ); /* With only MDP_MIN no MDP prealloc will be included */

        if( (word)PMS_RX_PREALLOC == i )
        {
            pms.needPrealloc = 0;
8000d042:	6c 09       	ld.w	r9,r6[0x0]
8000d044:	30 0a       	mov	r10,0
8000d046:	f3 da d3 41 	bfins	r9,r10,0x1a,0x1
8000d04a:	8d 09       	st.w	r6[0x0],r9
8000d04c:	c1 08       	rjmp	8000d06c <MbmFree+0x114>

    /*lint -e{960} right-hand operator has no side effects (read only)*/
    if( handle && (MNS_FALSE == MbmIsFromPool(handle)) )
    {
        /* Statically allocated message, just clear RSVD bit to mark it available */
        MBM_CLR_STATUS_BITS(handle, MBM_STAT_RSVD);
8000d04e:	8e 68       	ld.sh	r8,r7[0xc]
8000d050:	ab c8       	cbr	r8,0xa
8000d052:	ae 68       	st.h	r7[0xc],r8
8000d054:	18 97       	mov	r7,r12
8000d056:	c8 9b       	rjmp	8000cf68 <MbmFree+0x10>
                        break; /* quit */
                    }
                }
            }
            i++;
        } while( i < (word)PMS_RX_PREALLOC ); /* With only MDP_MIN no MDP prealloc will be included */
8000d058:	e5 d3 b0 10 	bfexts	r2,r3,0x0,0x10

        if( (word)PMS_RX_PREALLOC == i )
8000d05c:	30 49       	mov	r9,4
8000d05e:	f2 02 19 00 	cp.h	r2,r9
8000d062:	cf 00       	breq	8000d042 <MbmFree+0xea>
        }
        else
        {
            /* Not all FIFOs has a pre-allocated buffer */

            if( NULL == pms.rxPreAllocPtrTab[PMS_IDX_MCM_RX_PREALLOC] )
8000d064:	4a e3       	lddpc	r3,8000d11c <MbmFree+0x1c4>
8000d066:	6c 89       	ld.w	r9,r6[0x20]
8000d068:	58 09       	cp.w	r9,0
8000d06a:	cb 10       	breq	8000cfcc <MbmFree+0x74>
                    start_timer = MNS_TRUE;
                    #endif
                }
            }
        }
        REL_MX(MX_PMS_CS);
8000d06c:	50 08       	stdsp	sp[0x0],r8
8000d06e:	30 2c       	mov	r12,2
8000d070:	fe b0 d5 24 	rcall	80007ab8 <mns_give>

        if( MNS_FALSE != start_timer )
8000d074:	40 08       	lddsp	r8,sp[0x0]
8000d076:	58 08       	cp.w	r8,0
8000d078:	cc 70       	breq	8000d006 <MbmFree+0xae>
        {
            MostSetTimer(&pms.rxPreAllocFailedTimer, timeout, MNS_FALSE);
8000d07a:	30 0a       	mov	r10,0
8000d07c:	ec cc ff fc 	sub	r12,r6,-4
8000d080:	14 9b       	mov	r11,r10
8000d082:	fe b0 f0 13 	rcall	8000b0a8 <MostSetTimer>

            if ((word)0 == timeout)
            {
                WAIT4MX(MX_PMS_CS);
8000d086:	30 2c       	mov	r12,2
8000d088:	fe b0 d5 17 	rcall	80007ab6 <mns_take>
                pms.rxPreAllocFailedTimerStarted = 0;     /* reset the rxPreAllocFailedTimerStarted flag if the timer was stopped */
8000d08c:	6c 08       	ld.w	r8,r6[0x0]
8000d08e:	30 09       	mov	r9,0
                pms.rxPreAllocHasTimedOut = 0;            /* Clear the flag, we don't need short timeouts */
8000d090:	b9 c8       	cbr	r8,0x18
8000d092:	f1 d9 d3 21 	bfins	r8,r9,0x19,0x1
                REL_MX(MX_PMS_CS);
8000d096:	30 2c       	mov	r12,2

            if ((word)0 == timeout)
            {
                WAIT4MX(MX_PMS_CS);
                pms.rxPreAllocFailedTimerStarted = 0;     /* reset the rxPreAllocFailedTimerStarted flag if the timer was stopped */
                pms.rxPreAllocHasTimedOut = 0;            /* Clear the flag, we don't need short timeouts */
8000d098:	8d 08       	st.w	r6[0x0],r8
                REL_MX(MX_PMS_CS);
8000d09a:	fe b0 d5 0f 	rcall	80007ab8 <mns_give>
8000d09e:	cb 4b       	rjmp	8000d006 <MbmFree+0xae>
            #endif
            {
                if( NULL == pms.rxPreAllocPtrTab[i] )
                {
                    /* FIFO needs buffer */
                    if( !handle )
8000d0a0:	58 07       	cp.w	r7,0
8000d0a2:	c2 10       	breq	8000d0e4 <MbmFree+0x18c>
                        handle = MbmGetBuf(PMS_CFG_BUFSIZE_SMALL);
                    }

                    if( handle )
                    {
                        pms.rxPreAllocPtrTab[i] = handle;
8000d0a4:	ec 01 09 27 	st.w	r6[r1<<0x2],r7
                        handle  = NULL; /* used */
                        #ifndef PMS_RX_OPT3
                        trigger = MNS_TRUE; /* Trigger the acknowledge mechanism */
                        #endif
                        if( PMS_IDX_MCM_RX_PREALLOC == i )
8000d0a8:	f6 02 19 00 	cp.h	r2,r11
8000d0ac:	c0 40       	breq	8000d0b4 <MbmFree+0x15c>
8000d0ae:	30 15       	mov	r5,1
8000d0b0:	30 07       	mov	r7,0
8000d0b2:	c8 3b       	rjmp	8000cfb8 <MbmFree+0x60>
        }

        /* Try to preallocate all necessary RX buffers */
        WAIT4MX(MX_PMS_CS);
        #if (defined ADS_MIN) && !(defined PMS_RX_OPT3)  /* Not needed for MDP_MIN, only I2C */
        mdpOnMlb = (&generalData == mdpFifo.iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000d0b4:	30 15       	mov	r5,1
8000d0b6:	30 07       	mov	r7,0
8000d0b8:	0a 98       	mov	r8,r5
8000d0ba:	c8 3b       	rjmp	8000cfc0 <MbmFree+0x68>
            /* Only small buffers hereafter */
            if( PMS_CFG_BUFSIZE_SMALL != handle->size )
            {
                ok = MNS_FALSE;
            }
            else if( MBM_TYPE_TX_BIT & MBM_GET_TYPE(handle) )
8000d0bc:	8e e5       	ld.uh	r5,r7[0xc]
8000d0be:	ed b5 00 00 	bld	r5,0x0
8000d0c2:	c0 60       	breq	8000d0ce <MbmFree+0x176>
                ok = MNS_TRUE;
            }

            if( MNS_FALSE != ok ) /* It is our size, use it */
            {
                MbmReserve(handle, (word)0);
8000d0c4:	30 0b       	mov	r11,0
8000d0c6:	0e 9c       	mov	r12,r7
8000d0c8:	fe b0 e7 70 	rcall	80009fa8 <MbmReserve>
8000d0cc:	c6 0b       	rjmp	8000cf8c <MbmFree+0x34>
            }
            else if( MBM_TYPE_TX_BIT & MBM_GET_TYPE(handle) )
            {
                is_command = (MBM_TYPE_CMD_TX == MBM_GET_TYPE(handle)) ? MNS_TRUE : MNS_FALSE;

                ok = MbmChangeType(handle, (word)0); /* Check reserved */
8000d0ce:	30 0b       	mov	r11,0
8000d0d0:	0e 9c       	mov	r12,r7

                if( MNS_FALSE != is_command )
8000d0d2:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
            }
            else if( MBM_TYPE_TX_BIT & MBM_GET_TYPE(handle) )
            {
                is_command = (MBM_TYPE_CMD_TX == MBM_GET_TYPE(handle)) ? MNS_TRUE : MNS_FALSE;

                ok = MbmChangeType(handle, (word)0); /* Check reserved */
8000d0d6:	fe b0 ea 1f 	rcall	8000a514 <MbmChangeType>

                if( MNS_FALSE != is_command )
8000d0da:	58 75       	cp.w	r5,7
8000d0dc:	cf 40       	breq	8000d0c4 <MbmFree+0x16c>
            else
            {
                ok = MNS_TRUE;
            }

            if( MNS_FALSE != ok ) /* It is our size, use it */
8000d0de:	58 0c       	cp.w	r12,0
8000d0e0:	cf 21       	brne	8000d0c4 <MbmFree+0x16c>
8000d0e2:	c5 1b       	rjmp	8000cf84 <MbmFree+0x2c>
                if( NULL == pms.rxPreAllocPtrTab[i] )
                {
                    /* FIFO needs buffer */
                    if( !handle )
                    {
                        handle = MbmGetBuf(PMS_CFG_BUFSIZE_SMALL);
8000d0e4:	50 2b       	stdsp	sp[0x8],r11
8000d0e6:	50 1a       	stdsp	sp[0x4],r10
8000d0e8:	50 39       	stdsp	sp[0xc],r9
8000d0ea:	50 08       	stdsp	sp[0x0],r8
8000d0ec:	34 4c       	mov	r12,68
8000d0ee:	fe b0 e8 d9 	rcall	8000a2a0 <MbmGetBuf>
                    }

                    if( handle )
8000d0f2:	40 2b       	lddsp	r11,sp[0x8]
                if( NULL == pms.rxPreAllocPtrTab[i] )
                {
                    /* FIFO needs buffer */
                    if( !handle )
                    {
                        handle = MbmGetBuf(PMS_CFG_BUFSIZE_SMALL);
8000d0f4:	18 97       	mov	r7,r12
                    }

                    if( handle )
8000d0f6:	40 1a       	lddsp	r10,sp[0x4]
8000d0f8:	40 39       	lddsp	r9,sp[0xc]
8000d0fa:	40 08       	lddsp	r8,sp[0x0]
8000d0fc:	cb 00       	breq	8000d05c <MbmFree+0x104>
8000d0fe:	cd 3b       	rjmp	8000d0a4 <MbmFree+0x14c>
                         * There has been at least one timeout and the slot has not
                         * been filled yet, make next timeout short.
                         */
                        timeout = PMS_T_PREALLOC_RETRY;
                    }
                    pms.rxPreAllocFailedTimerStarted = 1;
8000d100:	30 19       	mov	r9,1
8000d102:	f1 d9 d3 01 	bfins	r8,r9,0x18,0x1
8000d106:	06 94       	mov	r4,r3
                    start_timer = MNS_TRUE;
                    #endif
                }
            }
        }
        REL_MX(MX_PMS_CS);
8000d108:	30 2c       	mov	r12,2
                         * There has been at least one timeout and the slot has not
                         * been filled yet, make next timeout short.
                         */
                        timeout = PMS_T_PREALLOC_RETRY;
                    }
                    pms.rxPreAllocFailedTimerStarted = 1;
8000d10a:	08 a8       	st.w	r4++,r8
                    start_timer = MNS_TRUE;
                    #endif
                }
            }
        }
        REL_MX(MX_PMS_CS);
8000d10c:	fe b0 d4 d6 	rcall	80007ab8 <mns_give>

        if( MNS_FALSE != start_timer )
        {
            MostSetTimer(&pms.rxPreAllocFailedTimer, timeout, MNS_FALSE);
8000d110:	04 9a       	mov	r10,r2
8000d112:	08 9c       	mov	r12,r4
8000d114:	31 4b       	mov	r11,20
8000d116:	fe b0 ef c9 	rcall	8000b0a8 <MostSetTimer>
8000d11a:	c7 6b       	rjmp	8000d006 <MbmFree+0xae>
8000d11c:	00 00       	add	r0,r0
8000d11e:	37 d4       	mov	r4,125
8000d120:	00 00       	add	r0,r0
8000d122:	37 0c       	mov	r12,112
8000d124:	00 00       	add	r0,r0
8000d126:	38 84       	mov	r4,-120
8000d128:	00 00       	add	r0,r0
8000d12a:	38 38       	mov	r8,-125

8000d12c <PmsFlushMsgTxBuffer>:
8000d12c:	eb cd 40 fc 	pushm	r2-r7,lr
8000d130:	20 3d       	sub	sp,12
8000d132:	30 3b       	mov	r11,3
8000d134:	1a 9c       	mov	r12,sp
8000d136:	fe b0 e8 ef 	rcall	8000a314 <MbmQueueInit>
8000d13a:	30 3c       	mov	r12,3
8000d13c:	fe b0 d4 bd 	rcall	80007ab6 <mns_take>
8000d140:	4a 5c       	lddpc	r12,8000d1d4 <PmsFlushMsgTxBuffer+0xa8>
8000d142:	1a 94       	mov	r4,sp
8000d144:	fe b0 e7 88 	rcall	8000a054 <_MbmPeek>
8000d148:	18 92       	mov	r2,r12
8000d14a:	c4 20       	breq	8000d1ce <PmsFlushMsgTxBuffer+0xa2>
8000d14c:	4a 25       	lddpc	r5,8000d1d4 <PmsFlushMsgTxBuffer+0xa8>
8000d14e:	30 03       	mov	r3,0
8000d150:	30 16       	mov	r6,1
8000d152:	c0 48       	rjmp	8000d15a <PmsFlushMsgTxBuffer+0x2e>

        if(MSG_TX_FILTER_CANCEL == ConfigStateFilterV2(msg_ptr) )
        {
            ++num;
            _MbmUnlink(handle);
            _MbmEnqueue(&tempQ, handle); /* Shall be deleted */
8000d154:	0e 92       	mov	r2,r7

    WAIT4MX(MX_PMS_Q);

    handle = _MbmPeek(&(mcmFifo.msgQ));                 /* get head element of queue */

    while( NULL != handle )                             /* end of list reached? */
8000d156:	58 07       	cp.w	r7,0
8000d158:	c1 80       	breq	8000d188 <PmsFlushMsgTxBuffer+0x5c>
    {
        if (handle->next_ptr != (struct MbmBuf *)(&mcmFifo.msgQ))     /* last element of list ? */
8000d15a:	64 07       	ld.w	r7,r2[0x0]
            next = NULL;                                /* last element reached */
        }

        msg_ptr = MBM_GET_CTRL_TX_PTR(handle);          /* get pointer to msg */

        if(MSG_TX_FILTER_CANCEL == ConfigStateFilterV2(msg_ptr) )
8000d15c:	e4 cc ff ec 	sub	r12,r2,-20

    handle = _MbmPeek(&(mcmFifo.msgQ));                 /* get head element of queue */

    while( NULL != handle )                             /* end of list reached? */
    {
        if (handle->next_ptr != (struct MbmBuf *)(&mcmFifo.msgQ))     /* last element of list ? */
8000d160:	0a 37       	cp.w	r7,r5
8000d162:	f9 b7 00 00 	moveq	r7,0
            next = NULL;                                /* last element reached */
        }

        msg_ptr = MBM_GET_CTRL_TX_PTR(handle);          /* get pointer to msg */

        if(MSG_TX_FILTER_CANCEL == ConfigStateFilterV2(msg_ptr) )
8000d166:	e0 a0 3d d9 	rcall	80014d18 <ConfigStateFilterV2>
8000d16a:	ec 0c 18 00 	cp.b	r12,r6
8000d16e:	cf 31       	brne	8000d154 <PmsFlushMsgTxBuffer+0x28>
        {
            ++num;
            _MbmUnlink(handle);
8000d170:	04 9c       	mov	r12,r2
8000d172:	fe b0 e7 4d 	rcall	8000a00c <_MbmUnlink>
            _MbmEnqueue(&tempQ, handle); /* Shall be deleted */
8000d176:	04 9b       	mov	r11,r2

        msg_ptr = MBM_GET_CTRL_TX_PTR(handle);          /* get pointer to msg */

        if(MSG_TX_FILTER_CANCEL == ConfigStateFilterV2(msg_ptr) )
        {
            ++num;
8000d178:	2f f3       	sub	r3,-1
            _MbmUnlink(handle);
            _MbmEnqueue(&tempQ, handle); /* Shall be deleted */
8000d17a:	1a 9c       	mov	r12,sp

        msg_ptr = MBM_GET_CTRL_TX_PTR(handle);          /* get pointer to msg */

        if(MSG_TX_FILTER_CANCEL == ConfigStateFilterV2(msg_ptr) )
        {
            ++num;
8000d17c:	5c 83       	casts.h	r3
            _MbmUnlink(handle);
            _MbmEnqueue(&tempQ, handle); /* Shall be deleted */
8000d17e:	fe b0 e8 21 	rcall	8000a1c0 <_MbmEnqueue>
8000d182:	0e 92       	mov	r2,r7

    WAIT4MX(MX_PMS_Q);

    handle = _MbmPeek(&(mcmFifo.msgQ));                 /* get head element of queue */

    while( NULL != handle )                             /* end of list reached? */
8000d184:	58 07       	cp.w	r7,0
8000d186:	ce a1       	brne	8000d15a <PmsFlushMsgTxBuffer+0x2e>
8000d188:	f1 d3 b0 10 	bfexts	r8,r3,0x0,0x10
8000d18c:	ee 08 19 00 	cp.h	r8,r7
8000d190:	5f 12       	srne	r2
            _MbmEnqueue(&tempQ, handle); /* Shall be deleted */
        }

        handle = next;
    }
    REL_MX(MX_PMS_Q);
8000d192:	30 3c       	mov	r12,3
8000d194:	fe b0 d4 92 	rcall	80007ab8 <mns_give>
    do
    {
        /* The tempQ is local, and hence does not need to lock the semaphore, so
         * access can be optimized with _MbmDequeue.
         */
        handle = _MbmDequeue(&tempQ);
8000d198:	1a 9c       	mov	r12,sp
8000d19a:	fe b0 e7 93 	rcall	8000a0c0 <_MbmDequeue>
        if( NULL != handle )
8000d19e:	c0 60       	breq	8000d1aa <PmsFlushMsgTxBuffer+0x7e>
        {
            MbmFree(handle);
8000d1a0:	cd ce       	rcall	8000cf58 <MbmFree>
8000d1a2:	1a 9c       	mov	r12,sp
    do
    {
        /* The tempQ is local, and hence does not need to lock the semaphore, so
         * access can be optimized with _MbmDequeue.
         */
        handle = _MbmDequeue(&tempQ);
8000d1a4:	fe b0 e7 8e 	rcall	8000a0c0 <_MbmDequeue>
8000d1a8:	cf c1       	brne	8000d1a0 <PmsFlushMsgTxBuffer+0x74>
        if( NULL != handle )
8000d1aa:	48 c8       	lddpc	r8,8000d1d8 <PmsFlushMsgTxBuffer+0xac>
        {
            MbmFree(handle);
        }
    } while( NULL != handle );

    if ( pmsInitData_ptr->cbTxBufferFlushed_fptr && (num > 0) )
8000d1ac:	70 08       	ld.w	r8,r8[0x0]
8000d1ae:	70 c8       	ld.w	r8,r8[0x30]
8000d1b0:	58 08       	cp.w	r8,0
8000d1b2:	5f 1a       	srne	r10
8000d1b4:	14 62       	and	r2,r10
8000d1b6:	f8 02 18 00 	cp.b	r2,r12
8000d1ba:	c0 41       	brne	8000d1c2 <PmsFlushMsgTxBuffer+0x96>
8000d1bc:	2f dd       	sub	sp,-12
    {
        pmsInitData_ptr->cbTxBufferFlushed_fptr(num);
    }

    T_LIB_EXIT(PMS_44);
}
8000d1be:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000d1c2:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
        }
    } while( NULL != handle );

    if ( pmsInitData_ptr->cbTxBufferFlushed_fptr && (num > 0) )
    {
        pmsInitData_ptr->cbTxBufferFlushed_fptr(num);
8000d1c6:	5d 18       	icall	r8
8000d1c8:	2f dd       	sub	sp,-12
    }

    T_LIB_EXIT(PMS_44);
}
8000d1ca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000d1ce:	18 93       	mov	r3,r12

    WAIT4MX(MX_PMS_Q);

    handle = _MbmPeek(&(mcmFifo.msgQ));                 /* get head element of queue */

    while( NULL != handle )                             /* end of list reached? */
8000d1d0:	ce 1b       	rjmp	8000d192 <PmsFlushMsgTxBuffer+0x66>
8000d1d2:	d7 03       	nop
8000d1d4:	00 00       	add	r0,r0
8000d1d6:	38 8c       	mov	r12,-120
8000d1d8:	00 00       	add	r0,r0
8000d1da:	38 38       	mov	r8,-125

8000d1dc <PmsSendBypass>:
8000d1dc:	d4 21       	pushm	r4-r7,lr
8000d1de:	14 95       	mov	r5,r10
8000d1e0:	18 97       	mov	r7,r12
8000d1e2:	58 0c       	cp.w	r12,0
8000d1e4:	e0 80 01 08 	breq	8000d3f4 <PmsSendBypass+0x218>
8000d1e8:	99 9b       	st.w	r12[0x24],r11
8000d1ea:	fe b0 e5 67 	rcall	80009cb8 <MbmPullHeaders>
8000d1ee:	8e 68       	ld.sh	r8,r7[0xc]
8000d1f0:	e2 18 1c 8f 	andl	r8,0x1c8f,COH
8000d1f4:	ae 68       	st.h	r7[0xc],r8
8000d1f6:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d1fa:	58 58       	cp.w	r8,5
8000d1fc:	c5 00       	breq	8000d29c <PmsSendBypass+0xc0>
8000d1fe:	30 ab       	mov	r11,10

    fph = (byte)(PMS_FIFONO_MDP << FPH_B_FIFONO_LSB) | FPH_MSGTYPE_DATA;
    /* No SCFs allowed, only default */

    /* header length = PML + PMHL + *PMHL + Length = 10 */
    tgt_ptr = MbmPush(handle, (word)PMS_DATA_HDR_MAX_SIZE);
8000d200:	0e 9c       	mov	r12,r7
8000d202:	fe b0 e6 b5 	rcall	80009f6c <MbmPush>
                + handle->append.payloadLen);              /* additional external payload */
    }
    else
    #endif
    {
        len = (word)( (word)(PMS_DATA_HDR_MAX_SIZE-2)
8000d206:	ef 09 00 18 	ld.sh	r9,r7[24]
8000d20a:	2f 89       	sub	r9,-8
8000d20c:	5c 89       	casts.h	r9
                        + dmsg_ptr->Length);                /* Header is static 8 */
    }

    *tgt_ptr++ = HB(len);                                   /* PML */
8000d20e:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
8000d212:	18 c8       	st.b	r12++,r8
    *tgt_ptr++ = LB(len);
8000d214:	18 98       	mov	r8,r12
8000d216:	10 c9       	st.b	r8++,r9
    *tgt_ptr++ = (byte)5;                                   /* Static PMHL */
8000d218:	30 59       	mov	r9,5
8000d21a:	10 c9       	st.b	r8++,r9
    *tgt_ptr++ = fph;
8000d21c:	30 c9       	mov	r9,12
8000d21e:	10 c9       	st.b	r8++,r9

    #ifdef _OS81110_PCK_LLR
                                                            /* byte Retry */
                                                            /* byte Priority */
    *tgt_ptr++ = (byte)((dmsg_ptr->Retry & (byte)0x0F) << 4) | (PMS_DEF_PRIO & (byte)0x0F);
8000d220:	ef 39 00 1c 	ld.ub	r9,r7[28]
8000d224:	a5 69       	lsl	r9,0x4
8000d226:	10 c9       	st.b	r8++,r9
    #else
    *tgt_ptr++ = PMS_DEF_PRIO;                              /* byte Priority */
    #endif
    *tgt_ptr++ = dmsg_ptr->Tgt_Adr_H;                       /* word TgtDeviceID */
8000d228:	ef 39 00 1a 	ld.ub	r9,r7[26]
8000d22c:	10 c9       	st.b	r8++,r9
    *tgt_ptr++ = dmsg_ptr->Tgt_Adr_L;
8000d22e:	ef 39 00 1b 	ld.ub	r9,r7[27]
8000d232:	10 c9       	st.b	r8++,r9
    *tgt_ptr++ = (byte)0x00;                                /* Static filler */
8000d234:	30 09       	mov	r9,0
8000d236:	10 c9       	st.b	r8++,r9
        len = dmsg_ptr->Length + handle->append.payloadLen;
    }
    else
    #endif
    {
        len = dmsg_ptr->Length;
8000d238:	ef 06 00 18 	ld.sh	r6,r7[24]
    }

    *tgt_ptr++ = HB(len);
8000d23c:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
    *tgt_ptr++ = LB(len);
8000d240:	b0 96       	st.b	r8[0x1],r6
    #endif
    {
        len = dmsg_ptr->Length;
    }

    *tgt_ptr++ = HB(len);
8000d242:	b0 89       	st.b	r8[0x0],r9
    *tgt_ptr++ = LB(len);

    if( &i2c == mdpFifo.iface_ptr )
8000d244:	fe f8 01 d8 	ld.w	r8,pc[472]
8000d248:	70 99       	ld.w	r9,r8[0x24]
8000d24a:	4f 68       	lddpc	r8,8000d420 <PmsSendBypass+0x244>
8000d24c:	10 39       	cp.w	r9,r8
8000d24e:	e0 80 00 dd 	breq	8000d408 <PmsSendBypass+0x22c>
        {
            success = MNS_FALSE;
            FAILED_ASSERT();
        }
    }
    else if( len > (word)PMS_DATA_MAX_PAYLOAD )
8000d252:	e0 68 05 f4 	mov	r8,1524
8000d256:	f0 06 19 00 	cp.h	r6,r8
8000d25a:	e0 8b 00 b0 	brhi	8000d3ba <PmsSendBypass+0x1de>
    }
    #endif

    tgt_ptr    = dmsg_ptr->Data;            /* Payload */

    MBM_SET_PAYLOAD_PTR(handle, tgt_ptr);
8000d25e:	30 14       	mov	r4,1
    MBM_SET_PAYLOAD_LEN(handle, len);
8000d260:	6e 58       	ld.w	r8,r7[0x14]
8000d262:	ef 56 00 34 	st.h	r7[52],r6
        return;
    }

    handle->cbTxStatus_fptr = cbTxStatus_fptr;  /* Set callback for TX result */

    if (PmsCompressHeader(handle))              /* Append the headers into the TX buffer */
8000d266:	8f b8       	st.w	r7[0x2c],r8
8000d268:	58 04       	cp.w	r4,0
8000d26a:	e0 80 00 99 	breq	8000d39c <PmsSendBypass+0x1c0>
    T_MOD_ENTRY(PMS_15);

    cmsg_ptr = MBM_GET_CTRL_TX_PTR(tx_handle);

  #ifdef ADS_MIN /* Not needed for MDP_MIN only, no TX */
    if( MBM_TYPE_DATA == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK) )
8000d26e:	8e 68       	ld.sh	r8,r7[0xc]
8000d270:	10 99       	mov	r9,r8
8000d272:	e2 19 00 06 	andl	r9,0x6,COH
8000d276:	c5 e1       	brne	8000d332 <PmsSendBypass+0x156>
            }
        }

        if( !hCur )
        {
            WAIT4MX(MX_PMS_Q);
8000d278:	4e 96       	lddpc	r6,8000d41c <PmsSendBypass+0x240>
8000d27a:	30 3c       	mov	r12,3
8000d27c:	fe b0 d4 1d 	rcall	80007ab6 <mns_take>
            hCur = fifo_ptr->msgQ.prev_ptr;
        }
        _MbmEnqueueBehind(&fifo_ptr->msgQ, hCur, handle);
8000d280:	6c 1b       	ld.w	r11,r6[0x4]
8000d282:	0e 9a       	mov	r10,r7
8000d284:	0c 9c       	mov	r12,r6
8000d286:	fe b0 e5 93 	rcall	80009dac <_MbmEnqueueBehind>
        REL_MX(MX_PMS_Q);
8000d28a:	30 3c       	mov	r12,3
8000d28c:	fe b0 d4 16 	rcall	80007ab8 <mns_give>

        if( PMS_IFACE_READY(*fifo_ptr->iface_ptr) && fifo_ptr->txSlotsAvailable )
8000d290:	6c 98       	ld.w	r8,r6[0x24]
8000d292:	70 18       	ld.w	r8,r8[0x4]
8000d294:	58 08       	cp.w	r8,0
8000d296:	e0 80 00 9d 	breq	8000d3d0 <PmsSendBypass+0x1f4>
    if( MBM_TYPE_CTRL_TX == MBM_GET_TYPE(handle) )
    #endif
    {
        MbmCtrlTx *cmsg_ptr = MBM_GET_CTRL_TX_PTR(handle);              /* Control message */

        if( (MSG_TGT_INIC == cmsg_ptr->Tgt_Adr)
8000d29a:	d8 22       	popm	r4-r7,pc
8000d29c:	ef 06 00 1a 	ld.sh	r6,r7[26]
8000d2a0:	30 18       	mov	r8,1
8000d2a2:	f0 06 19 00 	cp.h	r6,r8
8000d2a6:	c6 c1       	brne	8000d37e <PmsSendBypass+0x1a2>
8000d2a8:	ef 39 00 1e 	ld.ub	r9,r7[30]
8000d2ac:	30 08       	mov	r8,0
8000d2ae:	f0 09 18 00 	cp.b	r9,r8

    /* Local INIC, use ICM */
    fph = (byte)(PMS_FIFONO_ICM << FPH_B_FIFONO_LSB) | FPH_MSGTYPE_DATA;
    /*
    */
    if( !(pmsCnt++ & (byte)0x0F) )
8000d2b2:	c6 61       	brne	8000d37e <PmsSendBypass+0x1a2>
8000d2b4:	4d c8       	lddpc	r8,8000d424 <PmsSendBypass+0x248>
8000d2b6:	e0 6a 00 94 	mov	r10,148
8000d2ba:	11 89       	ld.ub	r9,r8[0x0]
8000d2bc:	e9 d9 c0 04 	bfextu	r4,r9,0x0,0x4
8000d2c0:	2f f9       	sub	r9,-1
8000d2c2:	58 04       	cp.w	r4,0
8000d2c4:	f9 b4 01 14 	movne	r4,20
8000d2c8:	f4 04 17 00 	moveq	r4,r10
    }
    #endif
    /*           PML + PMHL + PMH + (FktID, OpType, TelID, TelLen) */
    len = ( (word)2  +  (word)1  +  (word)pmhl  +  (word)4 );

    tgt_ptr = MbmPush(handle, len); /* align header */
8000d2cc:	b0 89       	st.b	r8[0x0],r9
8000d2ce:	30 8b       	mov	r11,8
8000d2d0:	0e 9c       	mov	r12,r7
8000d2d2:	fe b0 e6 4d 	rcall	80009f6c <MbmPush>

    len -= (word)2;                 /* Subtract size of PML */

    len += (word)((cmsg_ptr->Length > (word)PMS_CTRL_MAX_PAYLOAD) ?
8000d2d6:	32 d8       	mov	r8,45
8000d2d8:	ef 09 00 18 	ld.sh	r9,r7[24]
8000d2dc:	f0 09 19 00 	cp.h	r9,r8
8000d2e0:	f0 09 17 b0 	movhi	r9,r8
8000d2e4:	2f a9       	sub	r9,-6
                  (word)PMS_CTRL_MAX_PAYLOAD : cmsg_ptr->Length);

    /* - start first quadlet - */
    *tgt_ptr++ = HB(len);
8000d2e6:	5c 89       	casts.h	r9
8000d2e8:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
    *tgt_ptr++ = LB(len);
8000d2ec:	18 c8       	st.b	r12++,r8
8000d2ee:	18 98       	mov	r8,r12
    *tgt_ptr++ = pmhl;
8000d2f0:	10 c9       	st.b	r8++,r9
    *tgt_ptr++ = fph;
8000d2f2:	10 c6       	st.b	r8++,r6
    }
    /* - end second quadlet - */
    #endif

    /* - start last quadlet - */
    *tgt_ptr++ = (byte)(cmsg_ptr->Func_ID >> 4);
8000d2f4:	10 c4       	st.b	r8++,r4
8000d2f6:	ef 19 00 1c 	ld.uh	r9,r7[28]
8000d2fa:	a5 89       	lsr	r9,0x4
    *tgt_ptr++ = (byte)((byte)(LB(cmsg_ptr->Func_ID) << 4)  | cmsg_ptr->Operation);
8000d2fc:	10 c9       	st.b	r8++,r9
8000d2fe:	ef 3a 00 1d 	ld.ub	r10,r7[29]
8000d302:	ef 39 00 20 	ld.ub	r9,r7[32]
8000d306:	f3 ea 10 49 	or	r9,r9,r10<<0x4

    len        = cmsg_ptr->Length;
8000d30a:	10 c9       	st.b	r8++,r9
8000d30c:	ef 09 00 18 	ld.sh	r9,r7[24]
    *tgt_ptr++ = HB(len) | (byte)(handle->tel_id << 4);
8000d310:	ef 3b 00 36 	ld.ub	r11,r7[54]
8000d314:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
8000d318:	b0 99       	st.b	r8[0x1],r9
8000d31a:	f5 eb 10 4a 	or	r10,r10,r11<<0x4
    /* - end last quadlet - */

    tgt_ptr    = cmsg_ptr->Data;                    /* Payload */

    MBM_SET_PAYLOAD_PTR(handle, tgt_ptr);
    MBM_SET_PAYLOAD_LEN(handle, len);
8000d31e:	b0 8a       	st.b	r8[0x0],r10
8000d320:	ef 59 00 34 	st.h	r7[52],r9
    *tgt_ptr++ = LB(len);
    /* - end last quadlet - */

    tgt_ptr    = cmsg_ptr->Data;                    /* Payload */

    MBM_SET_PAYLOAD_PTR(handle, tgt_ptr);
8000d324:	6e 58       	ld.w	r8,r7[0x14]
    T_MOD_ENTRY(PMS_15);

    cmsg_ptr = MBM_GET_CTRL_TX_PTR(tx_handle);

  #ifdef ADS_MIN /* Not needed for MDP_MIN only, no TX */
    if( MBM_TYPE_DATA == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK) )
8000d326:	8f b8       	st.w	r7[0x2c],r8
8000d328:	8e 68       	ld.sh	r8,r7[0xc]
8000d32a:	10 99       	mov	r9,r8
8000d32c:	e2 19 00 06 	andl	r9,0x6,COH
    else
  #else
    /* Only control messages are allowed */
    ASSERT(MBM_TYPE_CTRL == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK));
  #endif
    if( (MSG_TGT_INIC == cmsg_ptr->Tgt_Adr) && (FBLOCK_INIC == cmsg_ptr->FBlock_ID) )
8000d330:	ca 40       	breq	8000d278 <PmsSendBypass+0x9c>
8000d332:	ef 0a 00 1a 	ld.sh	r10,r7[26]
8000d336:	30 19       	mov	r9,1
8000d338:	f2 0a 19 00 	cp.h	r10,r9

    if (PmsCompressHeader(handle))              /* Append the headers into the TX buffer */
    {
        fifo_ptr = PmsGetTxFifo(handle);        /* Get destination FIFO       */

        if( (&mcmFifo == fifo_ptr) && (handle->msg.msgTx.Length <= pmsMaxCmsPayload) )
8000d33c:	c5 40       	breq	8000d3e4 <PmsSendBypass+0x208>
8000d33e:	4b b9       	lddpc	r9,8000d428 <PmsSendBypass+0x24c>
8000d340:	ef 0a 00 18 	ld.sh	r10,r7[24]
8000d344:	92 09       	ld.sh	r9,r9[0x0]
8000d346:	f2 0a 19 00 	cp.h	r10,r9
8000d34a:	e0 8b 00 36 	brhi	8000d3b6 <PmsSendBypass+0x1da>
        {
            #ifdef AMS_TX_BYPASS_FILTER
            if( (MNS_FALSE != auto_bypass) || (pmsInitData_ptr->cbTxBypass_fptr && (MNS_FALSE != pmsInitData_ptr->cbTxBypass_fptr(&handle->msg.msgTx))) )
            #else
            if( MNS_FALSE != auto_bypass )
8000d34e:	58 05       	cp.w	r5,0
            #endif
            {
                MBM_SET_STATUS_BITS(handle, MBM_STAT_TX_BYPASS);
8000d350:	c3 30       	breq	8000d3b6 <PmsSendBypass+0x1da>
                WAIT4MX(MX_PMS_Q);
8000d352:	a9 a8       	sbr	r8,0x8
            if( (MNS_FALSE != auto_bypass) || (pmsInitData_ptr->cbTxBypass_fptr && (MNS_FALSE != pmsInitData_ptr->cbTxBypass_fptr(&handle->msg.msgTx))) )
            #else
            if( MNS_FALSE != auto_bypass )
            #endif
            {
                MBM_SET_STATUS_BITS(handle, MBM_STAT_TX_BYPASS);
8000d354:	30 3c       	mov	r12,3
                WAIT4MX(MX_PMS_Q);
8000d356:	ae 68       	st.h	r7[0xc],r8
8000d358:	fe b0 d3 af 	rcall	80007ab6 <mns_take>
                hCur = fifo_ptr->msgQ.prev_ptr;
                /* Enqueue behind all other bypassing messages */
                while( (hCur != (HMBMBUF)&fifo_ptr->msgQ) && !(hCur->type & MBM_STAT_TX_BYPASS) )
8000d35c:	4b 48       	lddpc	r8,8000d42c <PmsSendBypass+0x250>
            if( MNS_FALSE != auto_bypass )
            #endif
            {
                MBM_SET_STATUS_BITS(handle, MBM_STAT_TX_BYPASS);
                WAIT4MX(MX_PMS_Q);
                hCur = fifo_ptr->msgQ.prev_ptr;
8000d35e:	10 99       	mov	r9,r8
                /* Enqueue behind all other bypassing messages */
                while( (hCur != (HMBMBUF)&fifo_ptr->msgQ) && !(hCur->type & MBM_STAT_TX_BYPASS) )
8000d360:	70 1b       	ld.w	r11,r8[0x4]
8000d362:	10 3b       	cp.w	r11,r8
8000d364:	c0 51       	brne	8000d36e <PmsSendBypass+0x192>
                {
                    hCur = hCur->prev_ptr;
8000d366:	c0 88       	rjmp	8000d376 <PmsSendBypass+0x19a>
            {
                MBM_SET_STATUS_BITS(handle, MBM_STAT_TX_BYPASS);
                WAIT4MX(MX_PMS_Q);
                hCur = fifo_ptr->msgQ.prev_ptr;
                /* Enqueue behind all other bypassing messages */
                while( (hCur != (HMBMBUF)&fifo_ptr->msgQ) && !(hCur->type & MBM_STAT_TX_BYPASS) )
8000d368:	76 1b       	ld.w	r11,r11[0x4]
8000d36a:	12 3b       	cp.w	r11,r9
8000d36c:	c0 50       	breq	8000d376 <PmsSendBypass+0x19a>
8000d36e:	96 e8       	ld.uh	r8,r11[0xc]
8000d370:	ed b8 00 08 	bld	r8,0x8
                {
                    hCur = hCur->prev_ptr;
                }
                /* Wherever we stopped, the message should be enqueued behind */

                ASSERT(hCur);
8000d374:	cf a1       	brne	8000d368 <PmsSendBypass+0x18c>
8000d376:	58 0b       	cp.w	r11,0
8000d378:	c1 60       	breq	8000d3a4 <PmsSendBypass+0x1c8>
8000d37a:	4a d6       	lddpc	r6,8000d42c <PmsSendBypass+0x250>
        {
            success = PmsCompressHeaderICM(handle);                     /* INIC control message */
        }
        else
        {
            WAIT4MX(MX_PMS_CS);
8000d37c:	c8 3b       	rjmp	8000d282 <PmsSendBypass+0xa6>
8000d37e:	30 2c       	mov	r12,2
8000d380:	fe b0 d3 9b 	rcall	80007ab6 <mns_take>
            success = _PmsCompressHeaderMCM(handle, pmsSupportsTelId4); /* MOST Control Message, use MCM */
8000d384:	4a b8       	lddpc	r8,8000d430 <PmsSendBypass+0x254>
8000d386:	0e 9c       	mov	r12,r7
8000d388:	11 8b       	ld.ub	r11,r8[0x0]
8000d38a:	fe b0 fc 85 	rcall	8000cc94 <_PmsCompressHeaderMCM>
            REL_MX(MX_PMS_CS);
8000d38e:	18 94       	mov	r4,r12
8000d390:	30 2c       	mov	r12,2
8000d392:	fe b0 d3 93 	rcall	80007ab8 <mns_give>
        return;
    }

    handle->cbTxStatus_fptr = cbTxStatus_fptr;  /* Set callback for TX result */

    if (PmsCompressHeader(handle))              /* Append the headers into the TX buffer */
8000d396:	58 04       	cp.w	r4,0
8000d398:	fe 91 ff 6b 	brne	8000d26e <PmsSendBypass+0x92>
            PmsSetPendingEvent(PMS_P_TX_TRIG);
        }
    }
    else
    {
        MbmFree(handle);    /* packet exceeds the maximum length */
8000d39c:	0e 9c       	mov	r12,r7
8000d39e:	fe b0 fd dd 	rcall	8000cf58 <MbmFree>
                {
                    hCur = hCur->prev_ptr;
                }
                /* Wherever we stopped, the message should be enqueued behind */

                ASSERT(hCur);
8000d3a2:	d8 22       	popm	r4-r7,pc
8000d3a4:	e0 68 06 73 	mov	r8,1651
8000d3a8:	30 1a       	mov	r10,1
8000d3aa:	1a d8       	st.w	--sp,r8
8000d3ac:	31 0b       	mov	r11,16
8000d3ae:	14 9c       	mov	r12,r10
8000d3b0:	fe b0 d3 9e 	rcall	80007aec <mns_trace>
8000d3b4:	2f fd       	sub	sp,-4
8000d3b6:	49 e6       	lddpc	r6,8000d42c <PmsSendBypass+0x250>
        }
    }
    else if( len > (word)PMS_DATA_MAX_PAYLOAD )
    {
        success = MNS_FALSE;
        FAILED_ASSERT();
8000d3b8:	c6 1b       	rjmp	8000d27a <PmsSendBypass+0x9e>
8000d3ba:	30 1a       	mov	r10,1
8000d3bc:	e0 68 08 dc 	mov	r8,2268
8000d3c0:	1a d8       	st.w	--sp,r8
8000d3c2:	31 0b       	mov	r11,16
8000d3c4:	14 9c       	mov	r12,r10
8000d3c6:	30 04       	mov	r4,0
8000d3c8:	fe b0 d3 92 	rcall	80007aec <mns_trace>
8000d3cc:	2f fd       	sub	sp,-4
            hCur = fifo_ptr->msgQ.prev_ptr;
        }
        _MbmEnqueueBehind(&fifo_ptr->msgQ, hCur, handle);
        REL_MX(MX_PMS_Q);

        if( PMS_IFACE_READY(*fifo_ptr->iface_ptr) && fifo_ptr->txSlotsAvailable )
8000d3ce:	c4 9b       	rjmp	8000d260 <PmsSendBypass+0x84>
8000d3d0:	ed 39 00 83 	ld.ub	r9,r6[131]
8000d3d4:	f0 09 18 00 	cp.b	r9,r8
8000d3d8:	fe 90 ff 61 	breq	8000d29a <PmsSendBypass+0xbe>
             * Only necessary to trigger if the interface is ready for
             * another buffer and the INIC has a FIFO slot available,
             * otherwise it will be retriggered when the interface
             * has completed or a slot becomes available.
             */
            PmsSetPendingEvent(PMS_P_TX_TRIG);
8000d3dc:	30 8c       	mov	r12,8
8000d3de:	fe b0 fb 1b 	rcall	8000ca14 <PmsSetPendingEvent>
    else
  #else
    /* Only control messages are allowed */
    ASSERT(MBM_TYPE_CTRL == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK));
  #endif
    if( (MSG_TGT_INIC == cmsg_ptr->Tgt_Adr) && (FBLOCK_INIC == cmsg_ptr->FBlock_ID) )
8000d3e2:	d8 22       	popm	r4-r7,pc
8000d3e4:	ef 3a 00 1e 	ld.ub	r10,r7[30]
8000d3e8:	30 09       	mov	r9,0
8000d3ea:	f2 0a 18 00 	cp.b	r10,r9
8000d3ee:	ca 81       	brne	8000d33e <PmsSendBypass+0x162>
8000d3f0:	49 16       	lddpc	r6,8000d434 <PmsSendBypass+0x258>
    PmsFifo *fifo_ptr;
    HMBMBUF  hCur = NULL;

    T_LIB_ENTRY(PMS_54);

    ASSERT(handle);
8000d3f2:	c4 4b       	rjmp	8000d27a <PmsSendBypass+0x9e>
8000d3f4:	e0 68 06 54 	mov	r8,1620
8000d3f8:	30 1a       	mov	r10,1
8000d3fa:	1a d8       	st.w	--sp,r8
8000d3fc:	31 0b       	mov	r11,16
8000d3fe:	14 9c       	mov	r12,r10
8000d400:	fe b0 d3 76 	rcall	80007aec <mns_trace>
8000d404:	2f fd       	sub	sp,-4
    *tgt_ptr++ = HB(len);
    *tgt_ptr++ = LB(len);

    if( &i2c == mdpFifo.iface_ptr )
    {
        if( len > (word)PMS_I2C_DATA_MAX_PAYLOAD )
8000d406:	d8 22       	popm	r4-r7,pc
8000d408:	33 28       	mov	r8,50
8000d40a:	f0 06 19 00 	cp.h	r6,r8
8000d40e:	fe 98 ff 28 	brls	8000d25e <PmsSendBypass+0x82>
        {
            success = MNS_FALSE;
            FAILED_ASSERT();
8000d412:	30 1a       	mov	r10,1
8000d414:	e0 68 08 d6 	mov	r8,2262
8000d418:	cd 4b       	rjmp	8000d3c0 <PmsSendBypass+0x1e4>
8000d41a:	d7 03       	nop
8000d41c:	00 00       	add	r0,r0
8000d41e:	37 0c       	mov	r12,112
8000d420:	00 00       	add	r0,r0
8000d422:	36 e0       	mov	r0,110
8000d424:	00 00       	add	r0,r0
8000d426:	37 94       	mov	r4,121
8000d428:	00 00       	add	r0,r0
8000d42a:	38 34       	mov	r4,-125
8000d42c:	00 00       	add	r0,r0
8000d42e:	38 8c       	mov	r12,-120
8000d430:	00 00       	add	r0,r0
8000d432:	38 44       	mov	r4,-124
8000d434:	00 00       	add	r0,r0
8000d436:	39 14       	mov	r4,-111

8000d438 <PmsSend>:
8000d438:	eb cd 40 c0 	pushm	r6-r7,lr
8000d43c:	18 97       	mov	r7,r12
8000d43e:	16 96       	mov	r6,r11
8000d440:	58 0c       	cp.w	r12,0
8000d442:	c0 70       	breq	8000d450 <PmsSend+0x18>
8000d444:	0c 9b       	mov	r11,r6
8000d446:	0e 9c       	mov	r12,r7
8000d448:	30 0a       	mov	r10,0
8000d44a:	cc 9e       	rcall	8000d1dc <PmsSendBypass>
8000d44c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000d450:	e0 68 06 45 	mov	r8,1605
8000d454:	30 1a       	mov	r10,1
8000d456:	1a d8       	st.w	--sp,r8

#ifdef PMS_7
void PmsSend(HMBMBUF handle, PmsTxStatusHandler cbTxStatus_fptr)
{
    T_LIB_ENTRY(PMS_7);
    ASSERT(handle);
8000d458:	31 0b       	mov	r11,16
8000d45a:	14 9c       	mov	r12,r10
8000d45c:	fe b0 d3 48 	rcall	80007aec <mns_trace>
8000d460:	2f fd       	sub	sp,-4
8000d462:	cf 1b       	rjmp	8000d444 <PmsSend+0xc>

8000d464 <PmsDiscardRx>:
8000d464:	eb cd 40 e0 	pushm	r5-r7,lr
8000d468:	f9 36 00 21 	ld.ub	r6,r12[33]
8000d46c:	18 97       	mov	r7,r12
8000d46e:	e2 16 00 02 	andl	r6,0x2,COH
    bool retval;
    MbmCtrlRx *rx_ptr;

    T_LIB_ENTRY(PMS_50);

    rx_ptr = MBM_GET_CTRL_RX_PTR(handle);
8000d472:	c0 f0       	breq	8000d490 <PmsDiscardRx+0x2c>
        }
    }

    if( MNS_FALSE != retval )
    {
        if( NULL != pmsInitData_ptr->cbRxErr_fptr )
8000d474:	49 d8       	lddpc	r8,8000d4e8 <PmsDiscardRx+0x84>
8000d476:	70 08       	ld.w	r8,r8[0x0]
8000d478:	70 48       	ld.w	r8,r8[0x10]
8000d47a:	58 08       	cp.w	r8,0
8000d47c:	c0 50       	breq	8000d486 <PmsDiscardRx+0x22>
        {
            pmsInitData_ptr->cbRxErr_fptr(MSG_ERR_4, rx_ptr);
8000d47e:	ee cb ff ec 	sub	r11,r7,-20
8000d482:	30 4c       	mov	r12,4
8000d484:	5d 18       	icall	r8
        }
        MbmFree(handle);
8000d486:	0e 9c       	mov	r12,r7
8000d488:	fe b0 fd 68 	rcall	8000cf58 <MbmFree>
8000d48c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
    {
        retval = MNS_TRUE; /* Broadcast, no error message */
    }
    else
    {
        WAIT4MX(MX_PMS_CS);
8000d490:	30 2c       	mov	r12,2
8000d492:	fe b0 d3 12 	rcall	80007ab6 <mns_take>
        if( !(MBM_GET_STATUS(&segErrMsg) & MBM_STAT_RSVD) )
8000d496:	49 65       	lddpc	r5,8000d4ec <PmsDiscardRx+0x88>
8000d498:	8a 68       	ld.sh	r8,r5[0xc]
8000d49a:	ed b8 00 0a 	bld	r8,0xa
8000d49e:	c1 f0       	breq	8000d4dc <PmsDiscardRx+0x78>
        {
            MBM_SET_STATUS_BITS(&segErrMsg, MBM_STAT_RSVD);
8000d4a0:	ab a8       	sbr	r8,0xa
        }
        else
        {
            retval = MNS_FALSE;
        }
        REL_MX(MX_PMS_CS);
8000d4a2:	30 2c       	mov	r12,2
    else
    {
        WAIT4MX(MX_PMS_CS);
        if( !(MBM_GET_STATUS(&segErrMsg) & MBM_STAT_RSVD) )
        {
            MBM_SET_STATUS_BITS(&segErrMsg, MBM_STAT_RSVD);
8000d4a4:	aa 68       	st.h	r5[0xc],r8
        }
        else
        {
            retval = MNS_FALSE;
        }
        REL_MX(MX_PMS_CS);
8000d4a6:	fe b0 d3 09 	rcall	80007ab8 <mns_give>

        if( MNS_FALSE != retval )
        {
            segErrMsg.msg.msgTx.Tgt_Adr   = rx_ptr->Src_Adr;
8000d4aa:	ef 08 00 1a 	ld.sh	r8,r7[26]
8000d4ae:	eb 58 00 1a 	st.h	r5[26],r8
            segErrMsg.msg.msgTx.FBlock_ID = rx_ptr->FBlock_ID;
8000d4b2:	ef 38 00 1e 	ld.ub	r8,r7[30]
8000d4b6:	eb 68 00 1e 	st.b	r5[30],r8
            segErrMsg.msg.msgTx.Inst_ID   = rx_ptr->Inst_ID;
8000d4ba:	ef 38 00 1f 	ld.ub	r8,r7[31]
8000d4be:	eb 68 00 1f 	st.b	r5[31],r8
            segErrMsg.msg.msgTx.Func_ID   = rx_ptr->Func_ID;
8000d4c2:	ef 08 00 1c 	ld.sh	r8,r7[28]
            /* Operation, Length, Retries and Data[0] already set */
            segErrMsg.msg.msgTx.Data[1]   = MSG_ERR_4;
8000d4c6:	30 49       	mov	r9,4
        if( MNS_FALSE != retval )
        {
            segErrMsg.msg.msgTx.Tgt_Adr   = rx_ptr->Src_Adr;
            segErrMsg.msg.msgTx.FBlock_ID = rx_ptr->FBlock_ID;
            segErrMsg.msg.msgTx.Inst_ID   = rx_ptr->Inst_ID;
            segErrMsg.msg.msgTx.Func_ID   = rx_ptr->Func_ID;
8000d4c8:	eb 58 00 1c 	st.h	r5[28],r8
            /* Operation, Length, Retries and Data[0] already set */
            segErrMsg.msg.msgTx.Data[1]   = MSG_ERR_4;
8000d4cc:	6a 58       	ld.w	r8,r5[0x14]

            PmsSendBypass(&segErrMsg, PmsSegErrorTxStatus, MNS_TRUE);
8000d4ce:	0a 9c       	mov	r12,r5
            segErrMsg.msg.msgTx.Tgt_Adr   = rx_ptr->Src_Adr;
            segErrMsg.msg.msgTx.FBlock_ID = rx_ptr->FBlock_ID;
            segErrMsg.msg.msgTx.Inst_ID   = rx_ptr->Inst_ID;
            segErrMsg.msg.msgTx.Func_ID   = rx_ptr->Func_ID;
            /* Operation, Length, Retries and Data[0] already set */
            segErrMsg.msg.msgTx.Data[1]   = MSG_ERR_4;
8000d4d0:	b0 99       	st.b	r8[0x1],r9

            PmsSendBypass(&segErrMsg, PmsSegErrorTxStatus, MNS_TRUE);
8000d4d2:	30 1a       	mov	r10,1
8000d4d4:	fe cb 0a ac 	sub	r11,pc,2732
8000d4d8:	c8 2e       	rcall	8000d1dc <PmsSendBypass>
8000d4da:	cc db       	rjmp	8000d474 <PmsDiscardRx+0x10>
        }
        else
        {
            retval = MNS_FALSE;
        }
        REL_MX(MX_PMS_CS);
8000d4dc:	30 2c       	mov	r12,2
8000d4de:	fe b0 d2 ed 	rcall	80007ab8 <mns_give>
8000d4e2:	0c 9c       	mov	r12,r6
8000d4e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d4e8:	00 00       	add	r0,r0
8000d4ea:	38 38       	mov	r8,-125
8000d4ec:	00 00       	add	r0,r0
8000d4ee:	38 48       	mov	r8,-124

8000d4f0 <PmsRxSegError>:
8000d4f0:	eb cd 40 80 	pushm	r7,lr
8000d4f4:	20 1d       	sub	sp,4
8000d4f6:	18 97       	mov	r7,r12
8000d4f8:	ed bb 00 05 	bld	r11,0x5
8000d4fc:	c0 80       	breq	8000d50c <PmsRxSegError+0x1c>
8000d4fe:	78 08       	ld.w	r8,r12[0x0]
8000d500:	58 08       	cp.w	r8,0
8000d502:	c0 50       	breq	8000d50c <PmsRxSegError+0x1c>

    /* Call the higher layer */

    if( !(error & NO_UNLINK) && hErr->next_ptr )
    {
        _MbmUnlink(hErr);
8000d504:	50 0b       	stdsp	sp[0x0],r11
8000d506:	fe b0 e5 83 	rcall	8000a00c <_MbmUnlink>
8000d50a:	40 0b       	lddsp	r11,sp[0x0]
    }
    if( !(error & (KEEP_MESSAGE|NO_UNLINK)) )
8000d50c:	e2 1b 00 60 	andl	r11,0x60,COH
8000d510:	c0 41       	brne	8000d518 <PmsRxSegError+0x28>
    {
        MbmFree(hErr);
8000d512:	0e 9c       	mov	r12,r7
8000d514:	fe b0 fd 22 	rcall	8000cf58 <MbmFree>
        mcmFifo.rxStatus = PMS_M_STAT_SLOTAV | PMS_XMIT_INT_FMAT_FAILURE;
    }
    #endif

    T_MOD_EXIT(PMS_29);
}
8000d518:	2f fd       	sub	sp,-4
8000d51a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000d51e:	d7 03       	nop

8000d520 <PmsFifoProcessStatus>:
8000d520:	d4 31       	pushm	r0-r7,lr
8000d522:	20 1d       	sub	sp,4
8000d524:	18 97       	mov	r7,r12
8000d526:	16 96       	mov	r6,r11
}
#endif

#ifdef PMS_19
static void PmsFifoProcessStatus(PmsFifo *fifo_ptr, byte status, HMBMBUF *h_ptr)
{
8000d528:	14 94       	mov	r4,r10

    #ifndef PMS_NO_SLOTNTF
    slots = (&mcmFifo == fifo_ptr) ? PMS_MCM_SLOTS : (byte)1;
    #endif

    ASSERT(fifo_ptr);
8000d52a:	58 0c       	cp.w	r12,0
8000d52c:	e0 80 01 42 	breq	8000d7b0 <PmsFifoProcessStatus+0x290>

    if( IS_COMPLETE_STATUS(status) )
8000d530:	0c 90       	mov	r0,r6
8000d532:	e2 10 00 bc 	andl	r0,0xbc,COH
8000d536:	c0 31       	brne	8000d53c <PmsFifoProcessStatus+0x1c>
                MostClearTimer(&fifo_ptr->timer);
            }
        }
    }
    T_MOD_EXIT(PMS_19);
}
8000d538:	2f fd       	sub	sp,-4
8000d53a:	d8 32       	popm	r0-r7,pc
    ASSERT(fifo_ptr);

    if( IS_COMPLETE_STATUS(status) )
    {
        bool ignore_status = MNS_FALSE;
        HMBMBUF txPending = MbmDequeue(&fifo_ptr->pendingQ);
8000d53c:	ee c1 ff e8 	sub	r1,r7,-24
8000d540:	02 9c       	mov	r12,r1
8000d542:	fe b0 e5 db 	rcall	8000a0f8 <MbmDequeue>
8000d546:	18 95       	mov	r5,r12

        if( txPending )
8000d548:	e0 80 01 5f 	breq	8000d806 <PmsFifoProcessStatus+0x2e6>
             */
            MbmShadow *shadow_ptr;
            MbmBuf    *prev_ptr = NULL;

            /* Shadows are used to reference the original for segmented messages */
            if( MBM_GET_TYPE(txPending) & MBM_TYPE_SHADOW )
8000d54c:	98 e8       	ld.uh	r8,r12[0xc]
8000d54e:	e2 18 00 08 	andl	r8,0x8,COH
8000d552:	e0 81 00 ae 	brne	8000d6ae <PmsFifoProcessStatus+0x18e>
8000d556:	50 08       	stdsp	sp[0x0],r8
8000d558:	10 93       	mov	r3,r8
            }

            if( txPending )
            #endif
            {
                PmsTxStatusHandler cbTxStatus_fptr = txPending->cbTxStatus_fptr;
8000d55a:	6a 92       	ld.w	r2,r5[0x24]
                byte action;
                bool notify_status = MNS_TRUE;

                if ((&mdpFifo != fifo_ptr) || (&i2c == mdpFifo.iface_ptr))  /* supervision of icm, mcm and mdp over i2c */
8000d55c:	fe f8 03 44 	ld.w	r8,pc[836]
8000d560:	10 37       	cp.w	r7,r8
8000d562:	e0 80 00 fc 	breq	8000d75a <PmsFifoProcessStatus+0x23a>
                {
                    if ((byte)0 != (PMS_M_STAT_SYNCS & status))             /* this is a sync status */
8000d566:	30 08       	mov	r8,0
8000d568:	f0 06 18 00 	cp.b	r6,r8
8000d56c:	e0 85 01 34 	brlt	8000d7d4 <PmsFifoProcessStatus+0x2b4>
                            notify_status = MNS_FALSE;
                        }
                    }
                    else                                                    /* SyncS not set */
                    {
                        if ((byte)0 != fifo_ptr->syncGuard)
8000d570:	ef 38 00 84 	ld.ub	r8,r7[132]
8000d574:	58 08       	cp.w	r8,0
8000d576:	e0 80 00 f7 	breq	8000d764 <PmsFifoProcessStatus+0x244>
                        {
                            fifo_ptr->syncGuard--;
8000d57a:	20 18       	sub	r8,1
8000d57c:	ef 68 00 84 	st.b	r7[132],r8
8000d580:	30 18       	mov	r8,1
                        }
                    }
                }

                if( cbTxStatus_fptr && notify_status)
8000d582:	58 02       	cp.w	r2,0
8000d584:	e0 80 00 e6 	breq	8000d750 <PmsFifoProcessStatus+0x230>
8000d588:	58 08       	cp.w	r8,0
8000d58a:	e0 80 00 e3 	breq	8000d750 <PmsFifoProcessStatus+0x230>
                {
                    byte userStatus;

                    /* Translate status */
                    switch( status & (PMS_M_XMIT | PMS_M_STAT_SYNCS) )
8000d58e:	20 40       	sub	r0,4
8000d590:	e0 40 00 38 	cp.w	r0,56
8000d594:	e0 88 01 29 	brls	8000d7e6 <PmsFifoProcessStatus+0x2c6>
                        case PMS_XMIT_EXT_MOST_SUCCESS | PMS_XMIT_EXT_MOST_RECV_BUF_FULL:
                            userStatus = XMIT_SUCCESS | XMIT_BUF;
                            break;

                        default:
                            userStatus = (PMS_M_STAT_SYNCS & status)
8000d598:	e0 68 00 84 	mov	r8,132
8000d59c:	e0 69 00 83 	mov	r9,131
8000d5a0:	30 0b       	mov	r11,0
8000d5a2:	ec 0b 18 00 	cp.b	r11,r6
8000d5a6:	f2 0b 17 90 	movgt	r11,r9
8000d5aa:	f0 0b 17 a0 	movle	r11,r8
                                         ? XMIT_SYNC : XMIT_INTERNAL;
                            break;
                    }
                    action = cbTxStatus_fptr(txPending, userStatus);
8000d5ae:	0a 9c       	mov	r12,r5
8000d5b0:	5d 12       	icall	r2
                    ASSERT((PMS_RELEASE == action) || (PMS_RETRY == action));
8000d5b2:	30 18       	mov	r8,1
                        default:
                            userStatus = (PMS_M_STAT_SYNCS & status)
                                         ? XMIT_SYNC : XMIT_INTERNAL;
                            break;
                    }
                    action = cbTxStatus_fptr(txPending, userStatus);
8000d5b4:	18 90       	mov	r0,r12
                    ASSERT((PMS_RELEASE == action) || (PMS_RETRY == action));
8000d5b6:	f0 0c 18 00 	cp.b	r12,r8
8000d5ba:	e0 88 00 0b 	brls	8000d5d0 <PmsFifoProcessStatus+0xb0>
8000d5be:	e0 68 0d 49 	mov	r8,3401
8000d5c2:	30 1a       	mov	r10,1
8000d5c4:	1a d8       	st.w	--sp,r8
8000d5c6:	31 0b       	mov	r11,16
8000d5c8:	14 9c       	mov	r12,r10
8000d5ca:	fe b0 d2 91 	rcall	80007aec <mns_trace>
8000d5ce:	2f fd       	sub	sp,-4
                    /* No TxStatus function, free the pending message */
                    MbmFree(txPending);
                    action = PMS_RELEASE;
                }

                if( MESSAGE_IS_ENQUEUED_IN_INIC(status) )
8000d5d0:	0c 92       	mov	r2,r6
8000d5d2:	e2 12 00 82 	andl	r2,0x82,COH
8000d5d6:	e0 81 00 8f 	brne	8000d6f4 <PmsFifoProcessStatus+0x1d4>
8000d5da:	0c 98       	mov	r8,r6
8000d5dc:	e2 18 00 38 	andl	r8,0x38,COH
8000d5e0:	e0 80 00 8a 	breq	8000d6f4 <PmsFifoProcessStatus+0x1d4>
                {
                    if( PMS_RETRY == action )
8000d5e4:	30 18       	mov	r8,1
8000d5e6:	f0 00 18 00 	cp.b	r0,r8
8000d5ea:	e0 80 00 bf 	breq	8000d768 <PmsFifoProcessStatus+0x248>
                        cmd       = PMS_M_CMD_RETRY;
                    }
                    else
                    {
                        cmd       = PMS_M_CMD_CANCEL;
                        status   |= PMS_M_STAT_AUTOCAN;   /* Message will be removed */
8000d5ee:	a1 b6       	sbr	r6,0x1
8000d5f0:	30 25       	mov	r5,2
8000d5f2:	5c 56       	castu.b	r6
8000d5f4:	0c 92       	mov	r2,r6
8000d5f6:	e2 12 00 82 	andl	r2,0x82,COH
                    PmsSend(txPending, txPending->cbTxStatus_fptr);
                }
            }

            #ifndef PMS_TX_NOSEG
            if( shadow_ptr )
8000d5fa:	58 03       	cp.w	r3,0
8000d5fc:	c3 00       	breq	8000d65c <PmsFifoProcessStatus+0x13c>
                /* A shadow to a segmented message was processed and an action that
                 * does not retry the message inside the INIC was taken, hence the
                 * whole segmented message will fail and further references are
                 * removed.
                 */
                WAIT4MX(MX_PMS_Q);
8000d5fe:	30 3c       	mov	r12,3
8000d600:	fe b0 d2 5b 	rcall	80007ab6 <mns_take>
                if( IS_FAILED(status) && shadow_ptr->real_ptr && !MESSAGE_IS_ENQUEUED_IN_INIC(status) )
8000d604:	0c 98       	mov	r8,r6
8000d606:	e2 18 00 b8 	andl	r8,0xb8,COH
8000d60a:	c1 a0       	breq	8000d63e <PmsFifoProcessStatus+0x11e>
8000d60c:	66 4b       	ld.w	r11,r3[0x10]
8000d60e:	58 0b       	cp.w	r11,0
8000d610:	c1 70       	breq	8000d63e <PmsFifoProcessStatus+0x11e>
8000d612:	58 02       	cp.w	r2,0
8000d614:	e0 80 01 01 	breq	8000d816 <PmsFifoProcessStatus+0x2f6>
{
    MbmShadow *search_ptr;

    T_MOD_ENTRY(PMS_36);

    search_ptr = (MbmShadow *)mcmFifo.pendingQ.next_ptr;
8000d618:	fe f8 02 8c 	ld.w	r8,pc[652]

    ASSERT(org_ptr);

    while( (MbmShadow *)&mcmFifo.pendingQ != search_ptr )
8000d61c:	f0 ca ff e8 	sub	r10,r8,-24
{
    MbmShadow *search_ptr;

    T_MOD_ENTRY(PMS_36);

    search_ptr = (MbmShadow *)mcmFifo.pendingQ.next_ptr;
8000d620:	70 68       	ld.w	r8,r8[0x18]

    ASSERT(org_ptr);

    while( (MbmShadow *)&mcmFifo.pendingQ != search_ptr )
8000d622:	14 38       	cp.w	r8,r10
8000d624:	c0 d0       	breq	8000d63e <PmsFifoProcessStatus+0x11e>
    {
        if( MBM_GET_TYPE(search_ptr) & MBM_TYPE_SHADOW )
        {
            if( search_ptr->real_ptr == org_ptr )
            {
                search_ptr->real_ptr = NULL;
8000d626:	30 0c       	mov	r12,0

    ASSERT(org_ptr);

    while( (MbmShadow *)&mcmFifo.pendingQ != search_ptr )
    {
        if( MBM_GET_TYPE(search_ptr) & MBM_TYPE_SHADOW )
8000d628:	90 e9       	ld.uh	r9,r8[0xc]
8000d62a:	ed b9 00 03 	bld	r9,0x3
8000d62e:	c0 51       	brne	8000d638 <PmsFifoProcessStatus+0x118>
        {
            if( search_ptr->real_ptr == org_ptr )
8000d630:	70 49       	ld.w	r9,r8[0x10]
            {
                search_ptr->real_ptr = NULL;
8000d632:	12 3b       	cp.w	r11,r9
8000d634:	f1 fc 0a 04 	st.weq	r8[0x10],r12
            }
        }
        search_ptr = (MbmShadow *)search_ptr->next_ptr;
8000d638:	70 08       	ld.w	r8,r8[0x0]

    search_ptr = (MbmShadow *)mcmFifo.pendingQ.next_ptr;

    ASSERT(org_ptr);

    while( (MbmShadow *)&mcmFifo.pendingQ != search_ptr )
8000d63a:	14 38       	cp.w	r8,r10
8000d63c:	cf 61       	brne	8000d628 <PmsFifoProcessStatus+0x108>
{
    T_MOD_ENTRY(PMS_38);

    ASSERT(shadow_ptr);

    _MbmEnqueue(&txSegShadowQ, (HMBMBUF)shadow_ptr);
8000d63e:	06 9b       	mov	r11,r3
8000d640:	fe fc 02 68 	ld.w	r12,pc[616]
8000d644:	fe b0 e5 be 	rcall	8000a1c0 <_MbmEnqueue>
    if( pms.needShadow )
8000d648:	fe f8 02 64 	ld.w	r8,pc[612]
8000d64c:	70 09       	ld.w	r9,r8[0x0]
8000d64e:	ed b9 00 1d 	bld	r9,0x1d
8000d652:	e0 80 00 b9 	breq	8000d7c4 <PmsFifoProcessStatus+0x2a4>
                if( IS_FAILED(status) && shadow_ptr->real_ptr && !MESSAGE_IS_ENQUEUED_IN_INIC(status) )
                {
                    _PmsSetReferencesToNull(shadow_ptr->real_ptr);
                }
                _PMS_FREE_SHADOW(shadow_ptr);
                REL_MX(MX_PMS_Q);
8000d656:	30 3c       	mov	r12,3
8000d658:	fe b0 d2 30 	rcall	80007ab8 <mns_give>
            }
            #endif

            if( cmd )
8000d65c:	58 05       	cp.w	r5,0
8000d65e:	e0 81 00 9b 	brne	8000d794 <PmsFifoProcessStatus+0x274>
            /*
             * If this was either a TxStatus or a SyncS and the message is NOT
             * in the INIC anymore (may be cancelled by a command), then
             * available slots has increased.
             */
            if( !MESSAGE_IS_ENQUEUED_IN_INIC(status) )
8000d662:	58 02       	cp.w	r2,0
8000d664:	c5 31       	brne	8000d70a <PmsFifoProcessStatus+0x1ea>
8000d666:	e2 16 00 38 	andl	r6,0x38,COH
8000d66a:	c5 00       	breq	8000d70a <PmsFifoProcessStatus+0x1ea>
             * INIC.
             * The check for complete status is to make sure that any timer is not
             * updated on a SlotAv.
             */
            #ifdef PMS_NO_SLOTNTF
            if( !fifo_ptr->txSlotsAvailable )
8000d66c:	ef 36 00 83 	ld.ub	r6,r7[131]
8000d670:	e4 06 18 00 	cp.b	r6,r2
8000d674:	c6 61       	brne	8000d740 <PmsFifoProcessStatus+0x220>
            {
                #ifndef PMS_DISABLE_MCM_EXT_TIMEOUT
                word fifo_timeout;
                HMBMBUF next_pending;

                WAIT4MX(MX_PMS_Q);
8000d676:	30 3c       	mov	r12,3
8000d678:	fe b0 d2 1f 	rcall	80007ab6 <mns_take>
                next_pending = _MbmPeek(&fifo_ptr->pendingQ);
8000d67c:	02 9c       	mov	r12,r1
8000d67e:	fe b0 e4 eb 	rcall	8000a054 <_MbmPeek>

                if ( (&mcmFifo == fifo_ptr) && next_pending )
8000d682:	fe f8 02 22 	ld.w	r8,pc[546]
8000d686:	58 0c       	cp.w	r12,0
8000d688:	5f 1a       	srne	r10
8000d68a:	10 37       	cp.w	r7,r8
8000d68c:	5f 09       	sreq	r9
8000d68e:	f5 e9 00 09 	and	r9,r10,r9
8000d692:	ec 09 18 00 	cp.b	r9,r6
8000d696:	e0 80 00 ab 	breq	8000d7ec <PmsFifoProcessStatus+0x2cc>
                {
                    if ( PMS_CFG_MCM_MLR_THRESHOLD < next_pending->msg.msgTx.MidLevelRetries )
8000d69a:	f9 3a 00 21 	ld.ub	r10,r12[33]
8000d69e:	32 89       	mov	r9,40
8000d6a0:	f2 0a 18 00 	cp.b	r10,r9
8000d6a4:	e0 8b 00 c4 	brhi	8000d82c <PmsFifoProcessStatus+0x30c>
8000d6a8:	f1 16 00 3c 	ld.uh	r6,r8[60]
8000d6ac:	ca 28       	rjmp	8000d7f0 <PmsFifoProcessStatus+0x2d0>
            MbmBuf    *prev_ptr = NULL;

            /* Shadows are used to reference the original for segmented messages */
            if( MBM_GET_TYPE(txPending) & MBM_TYPE_SHADOW )
            {
                shadow_ptr = (MbmShadow *)txPending;
8000d6ae:	18 93       	mov	r3,r12

                /* Get original */
                txPending = shadow_ptr->real_ptr;
8000d6b0:	78 45       	ld.w	r5,r12[0x10]

                /* txPending may be NULL if a previous segment has failed. */
                if( txPending )
8000d6b2:	58 05       	cp.w	r5,0
8000d6b4:	e0 80 00 e7 	breq	8000d882 <PmsFifoProcessStatus+0x362>
                {
                    if( IS_NOT_FAILED(status) && !IS_LAST_SEGMENT(shadow_ptr) )
8000d6b8:	0c 92       	mov	r2,r6
8000d6ba:	e2 12 00 b8 	andl	r2,0xb8,COH
8000d6be:	c0 61       	brne	8000d6ca <PmsFifoProcessStatus+0x1aa>
8000d6c0:	98 e8       	ld.uh	r8,r12[0xc]
8000d6c2:	ed b8 00 06 	bld	r8,0x6
8000d6c6:	e0 81 00 ae 	brne	8000d822 <PmsFifoProcessStatus+0x302>
                        txPending = NULL;
                    }
                    else
                    {
                        /* Message can be enqueued to Send Q. */
                        if( txPending->q_ptr )
8000d6ca:	6a 28       	ld.w	r8,r5[0x8]
8000d6cc:	58 08       	cp.w	r8,0
8000d6ce:	e0 80 00 d7 	breq	8000d87c <PmsFifoProcessStatus+0x35c>
                        {
                            WAIT4MX(MX_PMS_Q);
8000d6d2:	30 3c       	mov	r12,3
8000d6d4:	fe b0 d1 f1 	rcall	80007ab6 <mns_take>
                            if( IS_FAILED(status) )
8000d6d8:	58 02       	cp.w	r2,0
8000d6da:	fb f2 0a 00 	st.weq	sp[0x0],r2
                            {
                                /*
                                 * Message has failed, we have to store it's position
                                 * in the queue if it should be retried.
                                 */
                                prev_ptr = txPending->prev_ptr;
8000d6de:	eb f8 10 01 	ld.wne	r8,r5[0x4]
8000d6e2:	fb f8 1a 00 	st.wne	sp[0x0],r8
                            }
                            /*
                             * Unlink from send Q, cannot be enqueued in case the callback
                             * keeps the message.
                             */
                            _MbmUnlink(txPending);
8000d6e6:	0a 9c       	mov	r12,r5
8000d6e8:	fe b0 e4 92 	rcall	8000a00c <_MbmUnlink>
                            REL_MX(MX_PMS_Q);
8000d6ec:	30 3c       	mov	r12,3
8000d6ee:	fe b0 d1 e5 	rcall	80007ab8 <mns_give>
8000d6f2:	c3 4b       	rjmp	8000d55a <PmsFifoProcessStatus+0x3a>
                        status   |= PMS_M_STAT_AUTOCAN;   /* Message will be removed */
                        txPending = NULL;
                        /* For segmentation any shadow shall be deallocated. */
                    }
                }
                else if( PMS_RETRY != action )
8000d6f4:	30 18       	mov	r8,1
8000d6f6:	f0 00 18 00 	cp.b	r0,r8
8000d6fa:	c0 30       	breq	8000d700 <PmsFifoProcessStatus+0x1e0>
8000d6fc:	30 05       	mov	r5,0
8000d6fe:	c7 eb       	rjmp	8000d5fa <PmsFifoProcessStatus+0xda>
                }

                if( txPending )
                {
                    /* "Retry" of messages that could not be kept in the INIC */
                    PmsSend(txPending, txPending->cbTxStatus_fptr);
8000d700:	0a 9c       	mov	r12,r5
8000d702:	6a 9b       	ld.w	r11,r5[0x24]
8000d704:	30 05       	mov	r5,0
8000d706:	c9 9e       	rcall	8000d438 <PmsSend>
8000d708:	c7 9b       	rjmp	8000d5fa <PmsFifoProcessStatus+0xda>
8000d70a:	30 2c       	mov	r12,2
             * available slots has increased.
             */
            if( !MESSAGE_IS_ENQUEUED_IN_INIC(status) )
            {
                bool ready;
                WAIT4MX(MX_PMS_CS);
8000d70c:	fe b0 d1 d5 	rcall	80007ab6 <mns_take>
8000d710:	6e 98       	ld.w	r8,r7[0x24]
                ready = PMS_IFACE_READY(*fifo_ptr->iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000d712:	30 2c       	mov	r12,2
                REL_MX(MX_PMS_CS);
8000d714:	70 16       	ld.w	r6,r8[0x4]
             */
            if( !MESSAGE_IS_ENQUEUED_IN_INIC(status) )
            {
                bool ready;
                WAIT4MX(MX_PMS_CS);
                ready = PMS_IFACE_READY(*fifo_ptr->iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000d716:	fe b0 d1 d1 	rcall	80007ab8 <mns_give>
                REL_MX(MX_PMS_CS);
8000d71a:	ef 39 00 83 	ld.ub	r9,r7[131]
                /*
                 * Only messages need to be triggered if a new slot becomes available,
                 * status and command messages does not need any slot so they are
                 * triggered from the availablity of the LLD.
                 */
                if( !fifo_ptr->txSlotsAvailable                 /* FIFO in INIC was previously full? */
8000d71e:	30 08       	mov	r8,0
8000d720:	f0 09 18 00 	cp.b	r9,r8
8000d724:	c0 b1       	brne	8000d73a <PmsFifoProcessStatus+0x21a>
8000d726:	8e 59       	ld.sh	r9,r7[0xa]
                    && MBM_QUEUE_LENGTH(&fifo_ptr->msgQ)        /* Normal message to send?           */
8000d728:	30 08       	mov	r8,0
8000d72a:	f0 09 19 00 	cp.h	r9,r8
8000d72e:	c0 60       	breq	8000d73a <PmsFifoProcessStatus+0x21a>
8000d730:	58 06       	cp.w	r6,0
                /*
                 * Only messages need to be triggered if a new slot becomes available,
                 * status and command messages does not need any slot so they are
                 * triggered from the availablity of the LLD.
                 */
                if( !fifo_ptr->txSlotsAvailable                 /* FIFO in INIC was previously full? */
8000d732:	c0 41       	brne	8000d73a <PmsFifoProcessStatus+0x21a>
8000d734:	30 8c       	mov	r12,8
                    && MBM_QUEUE_LENGTH(&fifo_ptr->msgQ)        /* Normal message to send?           */
                    && (MNS_FALSE != ready) )                   /* Is the LLD ready?                 */
                {
                    PmsSetPendingEvent(PMS_P_TX_TRIG);          /* Ok, trigger next FIFO message     */
8000d736:	fe b0 f9 6f 	rcall	8000ca14 <PmsSetPendingEvent>
8000d73a:	30 18       	mov	r8,1
                }
                #ifdef PMS_NO_SLOTNTF
                fifo_ptr->txSlotsAvailable = 1;                 /* Now the FIFO is ready             */
8000d73c:	ef 68 00 83 	st.b	r7[131],r8
8000d740:	30 0a       	mov	r10,0
                MostSetTimer(&fifo_ptr->timer, fifo_ptr->timeout, MNS_FALSE);
                #endif
            }
            else
            {
                MostClearTimer(&fifo_ptr->timer);
8000d742:	ee cc ff d8 	sub	r12,r7,-40
8000d746:	14 9b       	mov	r11,r10
8000d748:	fe b0 ec b0 	rcall	8000b0a8 <MostSetTimer>
8000d74c:	2f fd       	sub	sp,-4
            }
        }
    }
    T_MOD_EXIT(PMS_19);
}
8000d74e:	d8 32       	popm	r0-r7,pc
8000d750:	0a 9c       	mov	r12,r5
                    ASSERT((PMS_RELEASE == action) || (PMS_RETRY == action));
                }
                else
                {
                    /* No TxStatus function, free the pending message */
                    MbmFree(txPending);
8000d752:	30 00       	mov	r0,0
8000d754:	fe b0 fc 02 	rcall	8000cf58 <MbmFree>
8000d758:	c3 cb       	rjmp	8000d5d0 <PmsFifoProcessStatus+0xb0>
8000d75a:	6e 99       	ld.w	r9,r7[0x24]
            {
                PmsTxStatusHandler cbTxStatus_fptr = txPending->cbTxStatus_fptr;
                byte action;
                bool notify_status = MNS_TRUE;

                if ((&mdpFifo != fifo_ptr) || (&i2c == mdpFifo.iface_ptr))  /* supervision of icm, mcm and mdp over i2c */
8000d75c:	4d 58       	lddpc	r8,8000d8b0 <PmsFifoProcessStatus+0x390>
8000d75e:	10 39       	cp.w	r9,r8
8000d760:	fe 90 ff 03 	breq	8000d566 <PmsFifoProcessStatus+0x46>
8000d764:	30 18       	mov	r8,1
                    }
                    else                                                    /* SyncS not set */
                    {
                        if ((byte)0 != fifo_ptr->syncGuard)
                        {
                            fifo_ptr->syncGuard--;
8000d766:	c0 eb       	rjmp	8000d582 <PmsFifoProcessStatus+0x62>
8000d768:	58 03       	cp.w	r3,0
                {
                    if( PMS_RETRY == action )
                    {
                        HMBMBUF handle;
                        #ifndef PMS_TX_NOSEG
                        if( shadow_ptr )
8000d76a:	e0 80 00 98 	breq	8000d89a <PmsFifoProcessStatus+0x37a>
8000d76e:	40 08       	lddsp	r8,sp[0x0]
                        {
                            /* It is the shadow that shall be requeued on a retry */
                            handle = (HMBMBUF)shadow_ptr;
                            shadow_ptr = NULL;  /* Prevent deallocation */

                            if( prev_ptr )
8000d770:	58 08       	cp.w	r8,0
8000d772:	c0 c0       	breq	8000d78a <PmsFifoProcessStatus+0x26a>
8000d774:	30 3c       	mov	r12,3
                            {
                                WAIT4MX(MX_PMS_Q);
8000d776:	fe b0 d1 a0 	rcall	80007ab6 <mns_take>
8000d77a:	0e 9c       	mov	r12,r7
                                /*
                                 * The original message should go back where it was, this can only
                                 * be in the message queue.
                                 */
                                _MbmEnqueueBehind(&fifo_ptr->msgQ, prev_ptr, txPending);
8000d77c:	0a 9a       	mov	r10,r5
8000d77e:	40 0b       	lddsp	r11,sp[0x0]
8000d780:	fe b0 e3 16 	rcall	80009dac <_MbmEnqueueBehind>
8000d784:	30 3c       	mov	r12,3
                                REL_MX(MX_PMS_Q);
8000d786:	fe b0 d1 99 	rcall	80007ab8 <mns_give>
8000d78a:	06 9b       	mov	r11,r3
                        else
                        #endif
                        {
                            handle = txPending;
                        }
                        MbmEnqueueFirst(&fifo_ptr->pendingQ, handle);
8000d78c:	02 9c       	mov	r12,r1
8000d78e:	30 45       	mov	r5,4
8000d790:	fe b0 e4 ec 	rcall	8000a168 <MbmEnqueueFirst>
8000d794:	30 7b       	mov	r11,7
--------------------------------------------------------------------------------
*/
static void PmsRespondCommand(PmsFifo *fifo_ptr, HMBMBUF *h_ptr, byte cmd)
{
    T_MOD_ENTRY(PMS_37);
    (void)MbmChangeType(*h_ptr, (word)MBM_TYPE_CMD_TX);
8000d796:	68 0c       	ld.w	r12,r4[0x0]
8000d798:	fe b0 e6 be 	rcall	8000a514 <MbmChangeType>
8000d79c:	68 08       	ld.w	r8,r4[0x0]
    (*h_ptr)->msg.ctrl = cmd;
8000d79e:	0e 9c       	mov	r12,r7
    PmsSendCommand(fifo_ptr, *h_ptr);
8000d7a0:	f1 65 00 14 	st.b	r8[20],r5
*/
static void PmsRespondCommand(PmsFifo *fifo_ptr, HMBMBUF *h_ptr, byte cmd)
{
    T_MOD_ENTRY(PMS_37);
    (void)MbmChangeType(*h_ptr, (word)MBM_TYPE_CMD_TX);
    (*h_ptr)->msg.ctrl = cmd;
8000d7a4:	68 0b       	ld.w	r11,r4[0x0]
    PmsSendCommand(fifo_ptr, *h_ptr);
8000d7a6:	fe b0 f9 57 	rcall	8000ca54 <PmsSendCommand>
8000d7aa:	30 08       	mov	r8,0
    *h_ptr = NULL;                          /* Used */
8000d7ac:	89 08       	st.w	r4[0x0],r8
8000d7ae:	c5 ab       	rjmp	8000d662 <PmsFifoProcessStatus+0x142>
8000d7b0:	e0 68 0c a9 	mov	r8,3241

    #ifndef PMS_NO_SLOTNTF
    slots = (&mcmFifo == fifo_ptr) ? PMS_MCM_SLOTS : (byte)1;
    #endif

    ASSERT(fifo_ptr);
8000d7b4:	30 1a       	mov	r10,1
8000d7b6:	1a d8       	st.w	--sp,r8
8000d7b8:	31 0b       	mov	r11,16
8000d7ba:	14 9c       	mov	r12,r10
8000d7bc:	fe b0 d1 98 	rcall	80007aec <mns_trace>
8000d7c0:	2f fd       	sub	sp,-4
8000d7c2:	cb 7a       	rjmp	8000d530 <PmsFifoProcessStatus+0x10>
8000d7c4:	30 0a       	mov	r10,0
    ASSERT(shadow_ptr);

    _MbmEnqueue(&txSegShadowQ, (HMBMBUF)shadow_ptr);
    if( pms.needShadow )
    {
        pms.needShadow = 0;
8000d7c6:	f3 da d3 a1 	bfins	r9,r10,0x1d,0x1
8000d7ca:	30 8c       	mov	r12,8
        PmsSetPendingEvent(PMS_P_TX_TRIG);
8000d7cc:	91 09       	st.w	r8[0x0],r9
    ASSERT(shadow_ptr);

    _MbmEnqueue(&txSegShadowQ, (HMBMBUF)shadow_ptr);
    if( pms.needShadow )
    {
        pms.needShadow = 0;
8000d7ce:	fe b0 f9 23 	rcall	8000ca14 <PmsSetPendingEvent>
        PmsSetPendingEvent(PMS_P_TX_TRIG);
8000d7d2:	c4 2b       	rjmp	8000d656 <PmsFifoProcessStatus+0x136>
8000d7d4:	0c 99       	mov	r9,r6

                if ((&mdpFifo != fifo_ptr) || (&i2c == mdpFifo.iface_ptr))  /* supervision of icm, mcm and mdp over i2c */
                {
                    if ((byte)0 != (PMS_M_STAT_SYNCS & status))             /* this is a sync status */
                    {
                        if (PMS_SYNCS_SYNC_CMD == (PMS_M_SYNCS & status))   /* Status.SyncCReceived */
8000d7d6:	e2 19 00 3c 	andl	r9,0x3c,COH
8000d7da:	59 09       	cp.w	r9,16
8000d7dc:	c2 b0       	breq	8000d832 <PmsFifoProcessStatus+0x312>
8000d7de:	ef 68 00 84 	st.b	r7[132],r8
                                MisResetInic();
                            }
                        }
                        else                                                /* any other sync status means reset */
                        {
                            fifo_ptr->syncGuard = (byte)0;
8000d7e2:	30 08       	mov	r8,0
8000d7e4:	cc fa       	rjmp	8000d582 <PmsFifoProcessStatus+0x62>
8000d7e6:	4b 48       	lddpc	r8,8000d8b4 <PmsFifoProcessStatus+0x394>
                if( cbTxStatus_fptr && notify_status)
                {
                    byte userStatus;

                    /* Translate status */
                    switch( status & (PMS_M_XMIT | PMS_M_STAT_SYNCS) )
8000d7e8:	f0 00 03 2f 	ld.w	pc,r8[r0<<0x2]
8000d7ec:	ef 16 00 3c 	ld.uh	r6,r7[60]
                WAIT4MX(MX_PMS_Q);
                next_pending = _MbmPeek(&fifo_ptr->pendingQ);

                if ( (&mcmFifo == fifo_ptr) && next_pending )
                {
                    if ( PMS_CFG_MCM_MLR_THRESHOLD < next_pending->msg.msgTx.MidLevelRetries )
8000d7f0:	30 3c       	mov	r12,3
                }
                else
                {
                    fifo_timeout = fifo_ptr->timeout;
                }
                REL_MX(MX_PMS_Q);
8000d7f2:	fe b0 d1 63 	rcall	80007ab8 <mns_give>
8000d7f6:	0c 9b       	mov	r11,r6

                /* Message pending (either a retry or next in FIFO), update timer */
                MostSetTimer(&fifo_ptr->timer, fifo_timeout, MNS_FALSE);
8000d7f8:	ee cc ff d8 	sub	r12,r7,-40
8000d7fc:	30 0a       	mov	r10,0
8000d7fe:	fe b0 ec 55 	rcall	8000b0a8 <MostSetTimer>
8000d802:	2f fd       	sub	sp,-4
                MostClearTimer(&fifo_ptr->timer);
            }
        }
    }
    T_MOD_EXIT(PMS_19);
}
8000d804:	d8 32       	popm	r0-r7,pc
8000d806:	f8 06 18 00 	cp.b	r6,r12
            if( cmd )
            {
                PmsRespondCommand(fifo_ptr, h_ptr, cmd);
            }
        }
        else if( !(PMS_M_STAT_SYNCS & status) )
8000d80a:	fe 94 fe 97 	brge	8000d538 <PmsFifoProcessStatus+0x18>
8000d80e:	0c 92       	mov	r2,r6
8000d810:	e2 12 00 82 	andl	r2,0x82,COH
8000d814:	c2 7b       	rjmp	8000d662 <PmsFifoProcessStatus+0x142>
8000d816:	0c 98       	mov	r8,r6
                 * does not retry the message inside the INIC was taken, hence the
                 * whole segmented message will fail and further references are
                 * removed.
                 */
                WAIT4MX(MX_PMS_Q);
                if( IS_FAILED(status) && shadow_ptr->real_ptr && !MESSAGE_IS_ENQUEUED_IN_INIC(status) )
8000d818:	e2 18 00 38 	andl	r8,0x38,COH
8000d81c:	fe 91 ff 11 	brne	8000d63e <PmsFifoProcessStatus+0x11e>
8000d820:	cf ca       	rjmp	8000d618 <PmsFifoProcessStatus+0xf8>
8000d822:	0c 92       	mov	r2,r6
8000d824:	30 05       	mov	r5,0
                        status   |= PMS_M_STAT_AUTOCAN;   /* Message will be removed */
                        txPending = NULL;
                        /* For segmentation any shadow shall be deallocated. */
                    }
                }
                else if( PMS_RETRY != action )
8000d826:	e2 12 00 82 	andl	r2,0x82,COH
8000d82a:	ce 8a       	rjmp	8000d5fa <PmsFifoProcessStatus+0xda>
8000d82c:	e0 66 0b b8 	mov	r6,3000
                WAIT4MX(MX_PMS_Q);
                next_pending = _MbmPeek(&fifo_ptr->pendingQ);

                if ( (&mcmFifo == fifo_ptr) && next_pending )
                {
                    if ( PMS_CFG_MCM_MLR_THRESHOLD < next_pending->msg.msgTx.MidLevelRetries )
8000d830:	ce 0b       	rjmp	8000d7f0 <PmsFifoProcessStatus+0x2d0>
8000d832:	ef 39 00 84 	ld.ub	r9,r7[132]
                {
                    if ((byte)0 != (PMS_M_STAT_SYNCS & status))             /* this is a sync status */
                    {
                        if (PMS_SYNCS_SYNC_CMD == (PMS_M_SYNCS & status))   /* Status.SyncCReceived */
                        {
                            fifo_ptr->syncGuard += (byte)2;
8000d836:	2f e9       	sub	r9,-2
8000d838:	ef 69 00 84 	st.b	r7[132],r9
8000d83c:	30 4a       	mov	r10,4

                            if ((byte)5 <= fifo_ptr->syncGuard)
8000d83e:	f4 09 18 00 	cp.b	r9,r10
8000d842:	fe 98 ff 91 	brls	8000d764 <PmsFifoProcessStatus+0x244>
8000d846:	ef 68 00 84 	st.b	r7[132],r8
                            {
                                fifo_ptr->syncGuard = (byte)0;
8000d84a:	fe b0 e8 27 	rcall	8000a898 <MisResetInic>
                                MisResetInic();
8000d84e:	30 18       	mov	r8,1
8000d850:	c9 9a       	rjmp	8000d582 <PmsFifoProcessStatus+0x62>
8000d852:	33 1b       	mov	r11,49
                        case PMS_XMIT_EXT_MOST_SUCCESS | PMS_XMIT_EXT_MOST_RECV_BUF_FULL:
                            userStatus = XMIT_SUCCESS | XMIT_BUF;
                            break;

                        default:
                            userStatus = (PMS_M_STAT_SYNCS & status)
8000d854:	ca da       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>
8000d856:	31 0b       	mov	r11,16
                if( cbTxStatus_fptr && notify_status)
                {
                    byte userStatus;

                    /* Translate status */
                    switch( status & (PMS_M_XMIT | PMS_M_STAT_SYNCS) )
8000d858:	ca ba       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>
8000d85a:	e0 6b 00 81 	mov	r11,129
8000d85e:	ca 8a       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>
                            userStatus = XMIT_FRMT;
                            break;

                        case PMS_XMIT_INT_MOST_NETWORK_OFF:
                            userStatus = XMIT_NET_OFF;
                            break;
8000d860:	e0 6b 00 82 	mov	r11,130
                if( cbTxStatus_fptr && notify_status)
                {
                    byte userStatus;

                    /* Translate status */
                    switch( status & (PMS_M_XMIT | PMS_M_STAT_SYNCS) )
8000d864:	ca 5a       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>
8000d866:	32 0b       	mov	r11,32
                            userStatus = XMIT_TIMEOUT;
                            break;

                        case PMS_XMIT_EXT_MOST_WRONG_TARGET:
                            userStatus = XMIT_WRONGTARGET;
                            break;
8000d868:	ca 3a       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>
                            userStatus = XMIT_SUCCESS | XMIT_BUF;
                            break;

                        case PMS_XMIT_EXT_MOST_BAD_CRC:
                            userStatus = XMIT_CRC;
                            break;
8000d86a:	30 0b       	mov	r11,0
                            userStatus = XMIT_NET_OFF;
                            break;

                        case PMS_XMIT_INT_MOST_TIMEOUT:
                            userStatus = XMIT_TIMEOUT;
                            break;
8000d86c:	ca 1a       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>

                        case PMS_XMIT_EXT_MOST_WRONG_TARGET:
                            userStatus = XMIT_WRONGTARGET;
                            break;
8000d86e:	e0 6b 00 80 	mov	r11,128
                            userStatus = XMIT_FRMT;
                            break;

                        case PMS_XMIT_INT_MOST_NETWORK_OFF:
                            userStatus = XMIT_NET_OFF;
                            break;
8000d872:	c9 ea       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>

                        case PMS_XMIT_INT_MOST_TIMEOUT:
                            userStatus = XMIT_TIMEOUT;
                            break;
8000d874:	32 1b       	mov	r11,33
                            userStatus = XMIT_SUCCESS | XMIT_BUF;
                            break;

                        case PMS_XMIT_EXT_MOST_BAD_CRC:
                            userStatus = XMIT_CRC;
                            break;
8000d876:	c9 ca       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>

                        case PMS_XMIT_EXT_MOST_RECV_BUF_FULL:
                            userStatus = XMIT_BUF;
                            break;
8000d878:	33 0b       	mov	r11,48
8000d87a:	c9 aa       	rjmp	8000d5ae <PmsFifoProcessStatus+0x8e>

                        case PMS_XMIT_EXT_MOST_SUCCESS | PMS_XMIT_EXT_MOST_BAD_CRC:
                            userStatus = XMIT_SUCCESS | XMIT_CRC;
                            break;
8000d87c:	50 08       	stdsp	sp[0x0],r8
                MostClearTimer(&fifo_ptr->timer);
            }
        }
    }
    T_MOD_EXIT(PMS_19);
}
8000d87e:	fe 9f fe 6e 	bral	8000d55a <PmsFifoProcessStatus+0x3a>
8000d882:	0c 92       	mov	r2,r6
                            _MbmUnlink(txPending);
                            REL_MX(MX_PMS_Q);
                        }
                    }
                }
                else if( MESSAGE_IS_ENQUEUED_IN_INIC(status) )
8000d884:	e2 12 00 82 	andl	r2,0x82,COH
8000d888:	fe 91 ff 3a 	brne	8000d6fc <PmsFifoProcessStatus+0x1dc>
8000d88c:	0c 98       	mov	r8,r6
8000d88e:	e2 18 00 38 	andl	r8,0x38,COH
8000d892:	fe 91 fe ae 	brne	8000d5ee <PmsFifoProcessStatus+0xce>
8000d896:	30 05       	mov	r5,0
                        status   |= PMS_M_STAT_AUTOCAN;   /* Message will be removed */
                        txPending = NULL;
                        /* For segmentation any shadow shall be deallocated. */
                    }
                }
                else if( PMS_RETRY != action )
8000d898:	cb 1a       	rjmp	8000d5fa <PmsFifoProcessStatus+0xda>
8000d89a:	0a 93       	mov	r3,r5
                {
                    if( PMS_RETRY == action )
                    {
                        HMBMBUF handle;
                        #ifndef PMS_TX_NOSEG
                        if( shadow_ptr )
8000d89c:	c7 7b       	rjmp	8000d78a <PmsFifoProcessStatus+0x26a>
8000d89e:	d7 03       	nop
8000d8a0:	00 00       	add	r0,r0
8000d8a2:	37 0c       	mov	r12,112
8000d8a4:	00 00       	add	r0,r0
8000d8a6:	38 8c       	mov	r12,-120
8000d8a8:	00 00       	add	r0,r0
8000d8aa:	38 28       	mov	r8,-126
8000d8ac:	00 00       	add	r0,r0
8000d8ae:	37 d4       	mov	r4,125
8000d8b0:	00 00       	add	r0,r0
8000d8b2:	36 e0       	mov	r0,110
8000d8b4:	80 06       	ld.sh	r6,r0[0x0]
8000d8b6:	fe 14       	*unknown*

8000d8b8 <PmsService>:
8000d8b8:	d4 31       	pushm	r0-r7,lr
8000d8ba:	20 8d       	sub	sp,32
8000d8bc:	30 1c       	mov	r12,1
8000d8be:	fe b0 d0 fc 	rcall	80007ab6 <mns_take>
8000d8c2:	30 08       	mov	r8,0
8000d8c4:	fe fc 10 a0 	ld.w	r12,pc[4256]
8000d8c8:	fe fe 10 9c 	ld.w	lr,pc[4252]
8000d8cc:	9c 0e       	ld.sh	lr,lr[0x0]
8000d8ce:	b8 08       	st.h	r12[0x0],r8
8000d8d0:	50 2e       	stdsp	sp[0x8],lr
8000d8d2:	30 1c       	mov	r12,1
8000d8d4:	fe b0 d0 f2 	rcall	80007ab8 <mns_give>
8000d8d8:	40 24       	lddsp	r4,sp[0x8]
8000d8da:	5c 74       	castu.h	r4
8000d8dc:	08 98       	mov	r8,r4
8000d8de:	e2 18 44 00 	andl	r8,0x4400,COH
8000d8e2:	e0 81 02 e2 	brne	8000dea6 <PmsService+0x5ee>
8000d8e6:	ed b4 00 07 	bld	r4,0x7
8000d8ea:	c5 21       	brne	8000d98e <PmsService+0xd6>
8000d8ec:	fe f3 10 7c 	ld.w	r3,pc[4220]
8000d8f0:	66 08       	ld.w	r8,r3[0x0]
8000d8f2:	ed b8 00 1a 	bld	r8,0x1a
8000d8f6:	e0 80 03 df 	breq	8000e0b4 <PmsService+0x7fc>
     * Table with pointers to FIFOs, used to arbitrate them.
     * FIFOs are in prioritized order.
     */
    static PmsFifo * _CONST fifoPtrPrioTab[] =
    {
        &icmFifo
8000d8fa:	30 16       	mov	r6,1
8000d8fc:	fe f0 10 70 	ld.w	r0,pc[4208]
8000d900:	fe f7 10 70 	ld.w	r7,pc[4208]
         * With MDP_MIN alone MDP should be acknowledged but does not need a
         * pre-allocated buffer to be ack'ed (discarded when received).
         */
        if( (PMS_STATUS_NONE != fifo_ptr->rxStatus) && (pms.rxPreAllocPtrTab[i] || (&mdpFifo == fifo_ptr)) )
        #else
        if( (PMS_STATUS_NONE != fifo_ptr->rxStatus) && pms.rxPreAllocPtrTab[i] )
8000d904:	30 05       	mov	r5,0
8000d906:	fe f2 10 62 	ld.w	r2,pc[4194]

            WAIT4MX(MX_PMS_CS);
            if( MBM_GET_STATUS(hBuf) & MBM_STAT_RSVD )      /* Already busy? */
            {
                hBuf = NULL;
                pms.needRetriggerAck = 1;                  /* retrigger PMS_P_RX_ACK in PmsTxRelease() */
8000d90a:	0c 91       	mov	r1,r6
8000d90c:	c0 d8       	rjmp	8000d926 <PmsService+0x6e>
8000d90e:	64 08       	ld.w	r8,r2[0x0]
8000d910:	f1 d1 d3 61 	bfins	r8,r1,0x1b,0x1
8000d914:	85 08       	st.w	r2[0x0],r8
            }
            else
            {
                MBM_SET_STATUS_BITS(hBuf, MBM_STAT_RSVD);   /* Available, reserve */
            }
            REL_MX(MX_PMS_CS);
8000d916:	fe b0 d0 d1 	rcall	80007ab8 <mns_give>
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
                PmsSendCommand(fifo_ptr, hBuf);
            }
        }
        i++;                /* Next corresponding preallocated buffer */
        fifoPtrTab_ptr++;   /* Next FIFO */
8000d91a:	2f c7       	sub	r7,-4
                hBuf->msg.ctrl = fifo_ptr->rxStatus;
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
                PmsSendCommand(fifo_ptr, hBuf);
            }
        }
        i++;                /* Next corresponding preallocated buffer */
8000d91c:	2f f6       	sub	r6,-1
        fifoPtrTab_ptr++;   /* Next FIFO */
    } while( *fifoPtrTab_ptr );
8000d91e:	6e 00       	ld.w	r0,r7[0x0]
                hBuf->msg.ctrl = fifo_ptr->rxStatus;
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
                PmsSendCommand(fifo_ptr, hBuf);
            }
        }
        i++;                /* Next corresponding preallocated buffer */
8000d920:	5c 86       	casts.h	r6
        fifoPtrTab_ptr++;   /* Next FIFO */
    } while( *fifoPtrTab_ptr );
8000d922:	58 00       	cp.w	r0,0
8000d924:	c3 00       	breq	8000d984 <PmsService+0xcc>
         * With MDP_MIN alone MDP should be acknowledged but does not need a
         * pre-allocated buffer to be ack'ed (discarded when received).
         */
        if( (PMS_STATUS_NONE != fifo_ptr->rxStatus) && (pms.rxPreAllocPtrTab[i] || (&mdpFifo == fifo_ptr)) )
        #else
        if( (PMS_STATUS_NONE != fifo_ptr->rxStatus) && pms.rxPreAllocPtrTab[i] )
8000d926:	e1 38 00 82 	ld.ub	r8,r0[130]
8000d92a:	ea 08 18 00 	cp.b	r8,r5
8000d92e:	cf 60       	breq	8000d91a <PmsService+0x62>
8000d930:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
8000d934:	2f a8       	sub	r8,-6
8000d936:	e6 08 03 28 	ld.w	r8,r3[r8<<0x2]
8000d93a:	58 08       	cp.w	r8,0
8000d93c:	ce f0       	breq	8000d91a <PmsService+0x62>
        #endif
        {
            HMBMBUF hBuf = &fifo_ptr->ack;   /* Dedicated acknowledge buffer */

            WAIT4MX(MX_PMS_CS);
8000d93e:	30 2c       	mov	r12,2
8000d940:	fe b0 d0 bb 	rcall	80007ab6 <mns_take>
            if( MBM_GET_STATUS(hBuf) & MBM_STAT_RSVD )      /* Already busy? */
8000d944:	e1 08 00 4c 	ld.sh	r8,r0[76]
            }
            else
            {
                MBM_SET_STATUS_BITS(hBuf, MBM_STAT_RSVD);   /* Available, reserve */
            }
            REL_MX(MX_PMS_CS);
8000d948:	30 2c       	mov	r12,2
                hBuf = NULL;
                pms.needRetriggerAck = 1;                  /* retrigger PMS_P_RX_ACK in PmsTxRelease() */
            }
            else
            {
                MBM_SET_STATUS_BITS(hBuf, MBM_STAT_RSVD);   /* Available, reserve */
8000d94a:	10 99       	mov	r9,r8
        #endif
        {
            HMBMBUF hBuf = &fifo_ptr->ack;   /* Dedicated acknowledge buffer */

            WAIT4MX(MX_PMS_CS);
            if( MBM_GET_STATUS(hBuf) & MBM_STAT_RSVD )      /* Already busy? */
8000d94c:	e2 18 04 00 	andl	r8,0x400,COH
                hBuf = NULL;
                pms.needRetriggerAck = 1;                  /* retrigger PMS_P_RX_ACK in PmsTxRelease() */
            }
            else
            {
                MBM_SET_STATUS_BITS(hBuf, MBM_STAT_RSVD);   /* Available, reserve */
8000d950:	ab a9       	sbr	r9,0xa
        #endif
        {
            HMBMBUF hBuf = &fifo_ptr->ack;   /* Dedicated acknowledge buffer */

            WAIT4MX(MX_PMS_CS);
            if( MBM_GET_STATUS(hBuf) & MBM_STAT_RSVD )      /* Already busy? */
8000d952:	58 08       	cp.w	r8,0
8000d954:	cd d1       	brne	8000d90e <PmsService+0x56>
                hBuf = NULL;
                pms.needRetriggerAck = 1;                  /* retrigger PMS_P_RX_ACK in PmsTxRelease() */
            }
            else
            {
                MBM_SET_STATUS_BITS(hBuf, MBM_STAT_RSVD);   /* Available, reserve */
8000d956:	e1 59 00 4c 	st.h	r0[76],r9
            }
            REL_MX(MX_PMS_CS);
8000d95a:	50 08       	stdsp	sp[0x0],r8
8000d95c:	fe b0 d0 ae 	rcall	80007ab8 <mns_give>

            if( hBuf )
            {
                hBuf->msg.ctrl = fifo_ptr->rxStatus;
8000d960:	e1 39 00 82 	ld.ub	r9,r0[130]
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
8000d964:	40 08       	lddsp	r8,sp[0x0]
                PmsSendCommand(fifo_ptr, hBuf);
8000d966:	00 9c       	mov	r12,r0
            REL_MX(MX_PMS_CS);

            if( hBuf )
            {
                hBuf->msg.ctrl = fifo_ptr->rxStatus;
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
8000d968:	e1 68 00 82 	st.b	r0[130],r8
            }
            REL_MX(MX_PMS_CS);

            if( hBuf )
            {
                hBuf->msg.ctrl = fifo_ptr->rxStatus;
8000d96c:	e1 69 00 54 	st.b	r0[84],r9
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
                PmsSendCommand(fifo_ptr, hBuf);
8000d970:	e0 cb ff c0 	sub	r11,r0,-64
            }
        }
        i++;                /* Next corresponding preallocated buffer */
8000d974:	2f f6       	sub	r6,-1

            if( hBuf )
            {
                hBuf->msg.ctrl = fifo_ptr->rxStatus;
                fifo_ptr->rxStatus = PMS_STATUS_NONE;
                PmsSendCommand(fifo_ptr, hBuf);
8000d976:	fe b0 f8 6f 	rcall	8000ca54 <PmsSendCommand>
            }
        }
        i++;                /* Next corresponding preallocated buffer */
8000d97a:	5c 86       	casts.h	r6
        fifoPtrTab_ptr++;   /* Next FIFO */
8000d97c:	2f c7       	sub	r7,-4
    } while( *fifoPtrTab_ptr );
8000d97e:	6e 00       	ld.w	r0,r7[0x0]
8000d980:	58 00       	cp.w	r0,0
8000d982:	cd 21       	brne	8000d926 <PmsService+0x6e>
        PmsRxHandleAck();
        #else
        MbmFree(NULL);          /* Try to pre-allocate: relevant for PMS_RX_OPT3 */
        #endif

        if( !pms.ifacesStarted )
8000d984:	66 08       	ld.w	r8,r3[0x0]
8000d986:	ed b8 00 1e 	bld	r8,0x1e
8000d98a:	e0 81 01 23 	brne	8000dbd0 <PmsService+0x318>
        success = PmsProcessRxMsgOut(NULL, &mcmFifo);
        /* If processing returns false we need to wait for PmsSetExternalBufferAvailable() */
    }
    #endif

    if( event & PMS_P_RX )
8000d98e:	ed b4 00 00 	bld	r4,0x0
8000d992:	c1 61       	brne	8000d9be <PmsService+0x106>
    HMBMBUF handle;
    word burst_num;

    T_MOD_ENTRY(PMS_18);

    burst_num = pmsInitData_ptr->rx_burst;
8000d994:	fe f0 0f e0 	ld.w	r0,pc[4064]
8000d998:	60 08       	ld.w	r8,r0[0x0]
8000d99a:	f1 33 00 34 	ld.ub	r3,r8[52]

    while( burst_num-- > (word)0 )
8000d99e:	58 03       	cp.w	r3,0
8000d9a0:	c0 70       	breq	8000d9ae <PmsService+0xf6>
    {
        handle = MbmDequeue(&rxQ);
8000d9a2:	fe fc 0f d6 	ld.w	r12,pc[4054]
8000d9a6:	fe b0 e3 a9 	rcall	8000a0f8 <MbmDequeue>
8000d9aa:	18 97       	mov	r7,r12

        if( handle )
8000d9ac:	c6 f1       	brne	8000da8a <PmsService+0x1d2>
        {
            burst_num = (word)0;
        }
    }

    if( MBM_QUEUE_LENGTH(&rxQ) )
8000d9ae:	fe f8 0f ca 	ld.w	r8,pc[4042]
8000d9b2:	90 59       	ld.sh	r9,r8[0xa]
8000d9b4:	30 08       	mov	r8,0
8000d9b6:	f0 09 19 00 	cp.h	r9,r8
8000d9ba:	e0 81 03 82 	brne	8000e0be <PmsService+0x806>
            PmsSetPendingEvent(PMS_P_TIMEOUT);
        }
    }
    #endif

    if( event & PMS_P_RX_STATUS )
8000d9be:	ed b4 00 08 	bld	r4,0x8
8000d9c2:	e0 80 02 78 	breq	8000deb2 <PmsService+0x5fa>
    {
        PmsProcessRxStatusQueue();
    }

    if( event & PMS_P_TX_TRIG )
8000d9c6:	ed b4 00 03 	bld	r4,0x3
8000d9ca:	e0 81 00 be 	brne	8000db46 <PmsService+0x28e>
            fifo_pptr = fifoPtrPrioTab;

            do
            {
                MbmQueue *q_ptr = (MbmQueue *)((byte *)*fifo_pptr + offset);
                if( MBM_QUEUE_LENGTH(q_ptr) )
8000d9ce:	30 03       	mov	r3,0
    if( event & PMS_P_RX_STATUS )
    {
        PmsProcessRxStatusQueue();
    }

    if( event & PMS_P_TX_TRIG )
8000d9d0:	30 10       	mov	r0,1
8000d9d2:	30 c7       	mov	r7,12
                     * necessary to run it on the message at the head of the queue
                     */
                    if( (word)0 == MostGetTimer(&fifo_ptr->timer) )
                    {
                        #ifndef PMS_DISABLE_MCM_EXT_TIMEOUT
                        if ( (&mcmFifo == fifo_ptr) && (PMS_CFG_MCM_MLR_THRESHOLD < handle->msg.msgTx.MidLevelRetries) )
8000d9d4:	50 34       	stdsp	sp[0xc],r4
     * Table with pointers to FIFOs, used to arbitrate them.
     * FIFOs are in prioritized order.
     */
    static PmsFifo * _CONST fifoPtrPrioTab[] =
    {
        &icmFifo
8000d9d6:	0e 94       	mov	r4,r7
8000d9d8:	fe f6 0f 98 	ld.w	r6,pc[3992]
8000d9dc:	5c 74       	castu.h	r4
8000d9de:	fe f7 0f 8e 	ld.w	r7,pc[3982]
8000d9e2:	c0 68       	rjmp	8000d9ee <PmsService+0x136>
                MbmQueue *q_ptr = (MbmQueue *)((byte *)*fifo_pptr + offset);
                if( MBM_QUEUE_LENGTH(q_ptr) )
                {
                    PmsFifoTxTrigger(*fifo_pptr, q_ptr);
                }
                fifo_pptr++;
8000d9e4:	2f c6       	sub	r6,-4
            } while( *fifo_pptr );
8000d9e6:	6c 07       	ld.w	r7,r6[0x0]
8000d9e8:	58 07       	cp.w	r7,0
8000d9ea:	e0 80 00 d6 	breq	8000db96 <PmsService+0x2de>
        {
            fifo_pptr = fifoPtrPrioTab;

            do
            {
                MbmQueue *q_ptr = (MbmQueue *)((byte *)*fifo_pptr + offset);
8000d9ee:	ee 04 00 05 	add	r5,r7,r4
                if( MBM_QUEUE_LENGTH(q_ptr) )
8000d9f2:	8a 58       	ld.sh	r8,r5[0xa]
8000d9f4:	e6 08 19 00 	cp.h	r8,r3
8000d9f8:	cf 60       	breq	8000d9e4 <PmsService+0x12c>
    T_MOD_ENTRY(PMS_17);

    add_ptr = NULL;
    add_len = (word)0;

    ASSERT(fifo_ptr);
8000d9fa:	58 07       	cp.w	r7,0
8000d9fc:	e0 80 03 6c 	breq	8000e0d4 <PmsService+0x81c>
    ASSERT(q_ptr);

    WAIT4MX(MX_PMS_CS);
8000da00:	30 2c       	mov	r12,2
8000da02:	fe b0 d0 5a 	rcall	80007ab6 <mns_take>
    /* Store interface in case we're preempted by an interface change */
    iface_ptr = fifo_ptr->iface_ptr;
    ready     = PMS_IFACE_READY(*iface_ptr) ? MNS_TRUE : MNS_FALSE;
    REL_MX(MX_PMS_CS);
8000da06:	30 2c       	mov	r12,2
    ASSERT(fifo_ptr);
    ASSERT(q_ptr);

    WAIT4MX(MX_PMS_CS);
    /* Store interface in case we're preempted by an interface change */
    iface_ptr = fifo_ptr->iface_ptr;
8000da08:	6e 92       	ld.w	r2,r7[0x24]
    ready     = PMS_IFACE_READY(*iface_ptr) ? MNS_TRUE : MNS_FALSE;
8000da0a:	64 11       	ld.w	r1,r2[0x4]
    REL_MX(MX_PMS_CS);
8000da0c:	fe b0 d0 56 	rcall	80007ab8 <mns_give>

    /* First check if the Interface might accept this */
    if( MNS_FALSE != ready )
8000da10:	58 01       	cp.w	r1,0
8000da12:	ce 91       	brne	8000d9e4 <PmsService+0x12c>

        /*
         * If it's the message Q, make sure it is possible to send, if it is
         * the command Q, just try to dequeue the frontmost message.
         */
        if( (&fifo_ptr->msgQ == q_ptr) && (!fifo_ptr->txSlotsAvailable
8000da14:	0e 35       	cp.w	r5,r7
8000da16:	e0 80 03 6a 	breq	8000e0ea <PmsService+0x832>
        {
            handle = NULL;
        }
        else
        {
            handle = MbmDequeue(q_ptr);
8000da1a:	0a 9c       	mov	r12,r5
8000da1c:	fe b0 e3 6e 	rcall	8000a0f8 <MbmDequeue>
8000da20:	18 91       	mov	r1,r12

            #ifndef PMS_TX_NOSEG

            if( (NULL != handle) && (MBM_STAT_TX_SEG == (MBM_STAT_TX_SEG & MBM_GET_STATUS(handle))) )
8000da22:	ce 10       	breq	8000d9e4 <PmsService+0x12c>
8000da24:	98 e8       	ld.uh	r8,r12[0xc]
8000da26:	ed b8 00 04 	bld	r8,0x4
8000da2a:	c0 81       	brne	8000da3a <PmsService+0x182>
            {
                /*
                 * Do not send a segment if there will be no shadow available
                 * or start a new segmented message if there is one ongoing.
                 */
                if( (word)0 == PMS_CHECK_SHADOW() )
8000da2c:	fe fe 0f 50 	ld.w	lr,pc[3920]
8000da30:	9c 58       	ld.sh	r8,lr[0xa]
8000da32:	e6 08 19 00 	cp.h	r8,r3
8000da36:	e0 80 03 a8 	breq	8000e186 <PmsService+0x8ce>
                ASSERT(0 == MbmGetExtPayloadLen(handle)); /* external payload is not allowed */
            }
            else
            #endif
            {
                add_len = MbmGetExtPayloadLen(handle);
8000da3a:	02 9c       	mov	r12,r1
8000da3c:	fe b0 e1 48 	rcall	80009ccc <MbmGetExtPayloadLen>
8000da40:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
                add_ptr = add_len ? MBM_GET_PAYLOAD_PTR(handle) : NULL;
8000da44:	e0 80 03 42 	breq	8000e0c8 <PmsService+0x810>
8000da48:	62 bb       	ld.w	r11,r1[0x2c]
             * that may call it from within the actual TX function we need to set
             * everything up before calling TX and then perform a rollback if it
             * reports false (e.g. busy LLD).
             */

            iface_ptr->active   = handle;
8000da4a:	85 11       	st.w	r2[0x4],r1

            if( iface_ptr->tx_fptr((void *)handle, add_ptr, add_len) )
8000da4c:	5c 7a       	castu.h	r10
8000da4e:	64 08       	ld.w	r8,r2[0x0]
8000da50:	02 9c       	mov	r12,r1
8000da52:	5d 18       	icall	r8
8000da54:	e0 80 03 77 	breq	8000e142 <PmsService+0x88a>
            {
                PMS_LOG_TX(handle->hdr_ptr); /* N.B. Payload will be invalid if add_ptr is used */

                if( &fifo_ptr->msgQ == q_ptr )
8000da58:	0e 35       	cp.w	r5,r7
8000da5a:	cc 51       	brne	8000d9e4 <PmsService+0x12c>
                {
                    #ifdef PMS_NO_SLOTNTF
                    /* Work only with 0 or 1 slot at a time */
                    fifo_ptr->txSlotsAvailable = 0;
8000da5c:	30 0b       	mov	r11,0

                    /*
                     * Only start the timer if it's not already running, it is only
                     * necessary to run it on the message at the head of the queue
                     */
                    if( (word)0 == MostGetTimer(&fifo_ptr->timer) )
8000da5e:	ea c2 ff d8 	sub	r2,r5,-40

                if( &fifo_ptr->msgQ == q_ptr )
                {
                    #ifdef PMS_NO_SLOTNTF
                    /* Work only with 0 or 1 slot at a time */
                    fifo_ptr->txSlotsAvailable = 0;
8000da62:	eb 6b 00 83 	st.b	r5[131],r11

                    /*
                     * Only start the timer if it's not already running, it is only
                     * necessary to run it on the message at the head of the queue
                     */
                    if( (word)0 == MostGetTimer(&fifo_ptr->timer) )
8000da66:	04 9c       	mov	r12,r2
8000da68:	fe b0 eb d0 	rcall	8000b208 <MostGetTimer>
8000da6c:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
8000da70:	cb a1       	brne	8000d9e4 <PmsService+0x12c>
                    {
                        #ifndef PMS_DISABLE_MCM_EXT_TIMEOUT
                        if ( (&mcmFifo == fifo_ptr) && (PMS_CFG_MCM_MLR_THRESHOLD < handle->msg.msgTx.MidLevelRetries) )
8000da72:	fe f9 0f 0e 	ld.w	r9,pc[3854]
8000da76:	12 35       	cp.w	r5,r9
8000da78:	e0 80 06 1a 	breq	8000e6ac <PmsService+0xdf4>
                            MostSetTimer(&fifo_ptr->timer, PMS_CFG_MCM_MAX_TIMEOUT, MNS_FALSE);
                        }
                        else
                        #endif
                        {
                            MostSetTimer(&fifo_ptr->timer, fifo_ptr->timeout, MNS_FALSE);
8000da7c:	ef 1b 00 3c 	ld.uh	r11,r7[60]
8000da80:	04 9c       	mov	r12,r2
8000da82:	30 0a       	mov	r10,0
8000da84:	fe b0 eb 12 	rcall	8000b0a8 <MostSetTimer>
8000da88:	ca eb       	rjmp	8000d9e4 <PmsService+0x12c>

    T_MOD_ENTRY(PMS_53);

    fifo_ptr = NULL;

    switch( rx_handle->hdr_ptr[FPH_INDEX] & FPH_M_FIFONO )
8000da8a:	78 a8       	ld.w	r8,r12[0x28]
8000da8c:	11 b8       	ld.ub	r8,r8[0x3]
8000da8e:	e2 18 00 38 	andl	r8,0x38,COH
8000da92:	58 88       	cp.w	r8,8
8000da94:	e0 80 01 86 	breq	8000dda0 <PmsService+0x4e8>
8000da98:	e0 89 00 84 	brgt	8000dba0 <PmsService+0x2e8>
8000da9c:	58 08       	cp.w	r8,0
8000da9e:	e0 81 00 86 	brne	8000dbaa <PmsService+0x2f2>
            /* MEP is not supported by the LLD */
            break;
        #endif

        default:
            FAILED_ASSERT(); /* Unexpected/garbled message */
8000daa2:	fe f6 0e de 	ld.w	r6,pc[3806]

    fifo_ptr = PmsGetRxFifo(handle);
    def_ptr = NULL;
    index = (word)0;

    if( fifo_ptr
8000daa6:	ed 39 00 82 	ld.ub	r9,r6[130]
8000daaa:	30 08       	mov	r8,0
8000daac:	f0 09 18 00 	cp.b	r9,r8
8000dab0:	e0 81 00 86 	brne	8000dbbc <PmsService+0x304>
        if( &icmFifo == fifo_ptr )
        {
            def_ptr = &icmDefCfg;
            index   = PMS_IDX_ICM_RX_PREALLOC;
        }
        else if( &mcmFifo == fifo_ptr )
8000dab4:	fe f2 0e cc 	ld.w	r2,pc[3788]
8000dab8:	04 36       	cp.w	r6,r2
8000daba:	e0 80 03 38 	breq	8000e12a <PmsService+0x872>
            #ifndef PMS_RX_OPT3
            index   = PMS_IDX_MCM_RX_PREALLOC;
            #endif
        }
        #ifdef ADS_MIN  /* Not needed for MDP_MIN, does not use prealloc */
        else if( &mdpFifo == fifo_ptr )
8000dabe:	fe f1 0e c6 	ld.w	r1,pc[3782]
8000dac2:	02 36       	cp.w	r6,r1
8000dac4:	e0 80 03 54 	breq	8000e16c <PmsService+0x8b4>
        /*
         * Possibly replace the default preallocated RX buffer in case we are
         * running low - this will prevent acknowledging this FIFO as ready
         * for another message from the INIC.
         */
        WAIT4MX(MX_PMS_CS);
8000dac8:	30 2c       	mov	r12,2
8000daca:	fe b0 cf f6 	rcall	80007ab6 <mns_take>
        {
            pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC] = pms.rxPreAllocPtrTab[index];
            pms.rxPreAllocPtrTab[index] = NULL;
            pms.needPrealloc = 1;
        }
        REL_MX(MX_PMS_CS);
8000dace:	30 2c       	mov	r12,2
8000dad0:	fe b0 cf f4 	rcall	80007ab8 <mns_give>
    T_MOD_ENTRY(PMS_13);
    msg_ptr = &handle->msg;
    len = (word)0;

    #if ((defined ADS_MIN) && (!defined PMS_DISABLE_ADS_LEN_CHECKS)) || (!defined PMS_DISABLE_CTRL_LEN_CHECKS)
    DECODE_WORD(&pml, MBM_GET_HDR_PTR(handle));                       /* PML */
8000dad4:	6e a8       	ld.w	r8,r7[0x28]
8000dad6:	11 8b       	ld.ub	r11,r8[0x0]
8000dad8:	11 99       	ld.ub	r9,r8[0x1]
    #endif

    src_ptr = MBM_GET_HDR_PTR(handle) + FPH_INDEX;                    /* => FPH   */
8000dada:	f0 ca ff fd 	sub	r10,r8,-3
    T_MOD_ENTRY(PMS_13);
    msg_ptr = &handle->msg;
    len = (word)0;

    #if ((defined ADS_MIN) && (!defined PMS_DISABLE_ADS_LEN_CHECKS)) || (!defined PMS_DISABLE_CTRL_LEN_CHECKS)
    DECODE_WORD(&pml, MBM_GET_HDR_PTR(handle));                       /* PML */
8000dade:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
    }
    #ifdef ADS_MIN /* Not needed with only MDP_MIN, message will be discarded */
    else
    {
        /* Async Packet (MDP) */
        MBM_SET_TYPE(handle, MBM_TYPE_DATA_RX);
8000dae2:	8e 69       	ld.sh	r9,r7[0xc]
8000dae4:	e0 19 ff f0 	andl	r9,0xfff0
        /*!
         * Header is currently static
         */

        src_ptr++;                        /* Skip FPH */
        msg_ptr->dataRx.Rcv_Type  = *src_ptr++;
8000dae8:	2f fa       	sub	r10,-1
    }
    #ifdef ADS_MIN /* Not needed with only MDP_MIN, message will be discarded */
    else
    {
        /* Async Packet (MDP) */
        MBM_SET_TYPE(handle, MBM_TYPE_DATA_RX);
8000daea:	ae 69       	st.h	r7[0xc],r9
        /*!
         * Header is currently static
         */

        src_ptr++;                        /* Skip FPH */
        msg_ptr->dataRx.Rcv_Type  = *src_ptr++;
8000daec:	15 39       	ld.ub	r9,r10++
8000daee:	ef 69 00 1a 	st.b	r7[26],r9
        msg_ptr->dataRx.Src_Adr_H = *src_ptr++;
8000daf2:	15 89       	ld.ub	r9,r10[0x0]
8000daf4:	ef 69 00 1b 	st.b	r7[27],r9
        msg_ptr->dataRx.Src_Adr_L = *src_ptr++;
8000daf8:	15 99       	ld.ub	r9,r10[0x1]
8000dafa:	ef 69 00 1c 	st.b	r7[28],r9

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers  */
8000dafe:	f0 c9 ff fe 	sub	r9,r8,-2
8000db02:	13 8a       	ld.ub	r10,r9[0x0]
8000db04:	2f fa       	sub	r10,-1
8000db06:	f2 0a 00 0a 	add	r10,r9,r10

        DECODE_WORD(&len, src_ptr);       /* Length             */
8000db0a:	15 8c       	ld.ub	r12,r10[0x0]
        src_ptr += (word)2;               /* Skips length field */
        #ifndef PMS_DISABLE_ADS_LEN_CHECKS
        if (pml == (len + (word)8))       /* plausibility check for a correct MDP message */
8000db0c:	5c 7b       	castu.h	r11
        msg_ptr->dataRx.Src_Adr_L = *src_ptr++;

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers  */

        DECODE_WORD(&len, src_ptr);       /* Length             */
        src_ptr += (word)2;               /* Skips length field */
8000db0e:	f4 c9 ff fe 	sub	r9,r10,-2
        msg_ptr->dataRx.Src_Adr_H = *src_ptr++;
        msg_ptr->dataRx.Src_Adr_L = *src_ptr++;

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers  */

        DECODE_WORD(&len, src_ptr);       /* Length             */
8000db12:	15 9a       	ld.ub	r10,r10[0x1]
8000db14:	f5 ec 10 8a 	or	r10,r10,r12<<0x8
8000db18:	5c 8a       	casts.h	r10
        src_ptr += (word)2;               /* Skips length field */
        #ifndef PMS_DISABLE_ADS_LEN_CHECKS
        if (pml == (len + (word)8))       /* plausibility check for a correct MDP message */
8000db1a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
8000db1e:	2f 8c       	sub	r12,-8
        {                                 /* pml must be exactly the data body length + 8 bytes(PMH+Length) */
            msg_ptr->dataRx.Length = len;
8000db20:	18 3b       	cp.w	r11,r12
8000db22:	ef fa 0c 0c 	st.heq	r7[0x18],r10
        }
        else
        {
            msg_ptr->dataRx.Length = PMS_INVALID_PM_LENGTH;
8000db26:	f9 bb 01 ff 	movne	r11,-1
8000db2a:	ef fb 1c 0c 	st.hne	r7[0x18],r11
        #else
        msg_ptr->dataRx.Length = len;
        #endif

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->dataRx.Data   = (src_ptr < (handle->start_ptr + handle->size))
8000db2e:	ef 1b 00 30 	ld.uh	r11,r7[48]
8000db32:	6e 4c       	ld.w	r12,r7[0x10]
8000db34:	16 0c       	add	r12,r11
8000db36:	fe fb 0e 52 	ld.w	r11,pc[3666]
8000db3a:	18 39       	cp.w	r9,r12
8000db3c:	f2 0b 17 30 	movlo	r11,r9
8000db40:	8f 5b       	st.w	r7[0x14],r11
8000db42:	cf 88       	rjmp	8000dd32 <PmsService+0x47a>
8000db44:	40 34       	lddsp	r4,sp[0xc]
            /*lint -e{413} intended use of null ptr in macro*/
            offset = PMS_OFFSETOF(PmsFifo, msgQ);   /* set offset to the message queues */
        }
    }

    if( event & (PMS_P_TIMEOUT | PMS_P_SEND_SYNCC) )
8000db46:	08 98       	mov	r8,r4
8000db48:	e2 18 00 22 	andl	r8,0x22,COH
8000db4c:	e0 81 01 2d 	brne	8000dda6 <PmsService+0x4ee>
    {
        PmsSyncHandler(event);
    }

    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    if( event & PMS_P_MDP_TXSTATUS )
8000db50:	ed b4 00 06 	bld	r4,0x6
8000db54:	e0 80 01 30 	breq	8000ddb4 <PmsService+0x4fc>
        PmsFifoProcessStatus(&mdpFifo, PMS_M_STAT_SLOTAV | PMS_XMIT_SUCCESS, NULL);
    }
    #endif

    #ifdef PMS_28
    if( event & (PMS_P_GBG_COL | PMS_P_RETRIGGER_GBG) )
8000db58:	08 98       	mov	r8,r4
8000db5a:	e2 18 0a 00 	andl	r8,0xa00,COH
8000db5e:	e0 81 01 36 	brne	8000ddca <PmsService+0x512>
        PmsRxSegGarbageCollector((event & PMS_P_GBG_COL) ? MNS_FALSE : MNS_TRUE);
    }
    #endif


    if( event & PMS_P_TIMEOUT_RX_PREALLOC )
8000db62:	e2 14 20 00 	andl	r4,0x2000,COH
8000db66:	e0 81 01 7e 	brne	8000de62 <PmsService+0x5aa>
            (void)PmsDiscardPendingRx();
            #endif
        }
    }

    if( event & PMS_P_GO_SEMI_PROTECTED )
8000db6a:	30 07       	mov	r7,0
8000db6c:	40 2a       	lddsp	r10,sp[0x8]
8000db6e:	ee 0a 19 00 	cp.h	r10,r7
8000db72:	e0 85 01 8a 	brlt	8000de86 <PmsService+0x5ce>
            pmsMaxCmsPayload = PMS_MAX_CMS_PAYLOAD_MOST50;
            pmsSupportsTelId4 = MNS_FALSE;
        }
    }

    WAIT4MX(MX_PMS_PE);
8000db76:	30 1c       	mov	r12,1
8000db78:	fe b0 cf 9f 	rcall	80007ab6 <mns_take>
    event = (PMS_P_NONE != pmsPending) ? MNS_TRUE : MNS_FALSE;
8000db7c:	fe f9 0d e8 	ld.w	r9,pc[3560]
    REL_MX(MX_PMS_PE);
8000db80:	30 1c       	mov	r12,1
            pmsSupportsTelId4 = MNS_FALSE;
        }
    }

    WAIT4MX(MX_PMS_PE);
    event = (PMS_P_NONE != pmsPending) ? MNS_TRUE : MNS_FALSE;
8000db82:	92 07       	ld.sh	r7,r9[0x0]
    REL_MX(MX_PMS_PE);
8000db84:	fe b0 cf 9a 	rcall	80007ab8 <mns_give>

    if( event )
8000db88:	58 07       	cp.w	r7,0
8000db8a:	c0 40       	breq	8000db92 <PmsService+0x2da>
    {
        MnsSetPendingService(MNS_P_SRV_PMS);
8000db8c:	30 1c       	mov	r12,1
8000db8e:	fe b0 eb bd 	rcall	8000b308 <MnsSetPendingService>
    }

    T_LIB_EXIT(PMS_5);
}
8000db92:	2f 8d       	sub	sp,-32
8000db94:	d8 32       	popm	r0-r7,pc
        /*
         * First try sending all commands/statuses (offset is set to cmdQ),
         * then try all messages (offset is set to msgQ), for a total of
         * 2 queues.
         */
        while( num_queues-- )
8000db96:	58 00       	cp.w	r0,0
8000db98:	cd 60       	breq	8000db44 <PmsService+0x28c>
8000db9a:	20 10       	sub	r0,1
8000db9c:	5c 80       	casts.h	r0
8000db9e:	c1 cb       	rjmp	8000d9d6 <PmsService+0x11e>

    T_MOD_ENTRY(PMS_53);

    fifo_ptr = NULL;

    switch( rx_handle->hdr_ptr[FPH_INDEX] & FPH_M_FIFONO )
8000dba0:	59 08       	cp.w	r8,16
8000dba2:	c2 90       	breq	8000dbf4 <PmsService+0x33c>
8000dba4:	e0 48 00 20 	cp.w	r8,32
8000dba8:	c0 a0       	breq	8000dbbc <PmsService+0x304>
            /* MEP is not supported by the LLD */
            break;
        #endif

        default:
            FAILED_ASSERT(); /* Unexpected/garbled message */
8000dbaa:	e0 68 09 d4 	mov	r8,2516
8000dbae:	30 1a       	mov	r10,1
8000dbb0:	1a d8       	st.w	--sp,r8
8000dbb2:	31 0b       	mov	r11,16
8000dbb4:	14 9c       	mov	r12,r10
8000dbb6:	fe b0 cf 9b 	rcall	80007aec <mns_trace>
8000dbba:	2f fd       	sub	sp,-4
        }
    }
    else
    {
        /* Unrecognized destination FIFO */
        MbmFree(handle);
8000dbbc:	0e 9c       	mov	r12,r7
8000dbbe:	fe b0 f9 cd 	rcall	8000cf58 <MbmFree>
        handle = NULL;
    }

    #ifdef PMS_RX_SEND_ACK     /* no need to call MbmFree(NULL) in order to start a timer etc. */
    PmsSetPendingEvent(PMS_P_RX_ACK);
8000dbc2:	e0 6c 00 80 	mov	r12,128
8000dbc6:	20 13       	sub	r3,1
8000dbc8:	fe b0 f7 26 	rcall	8000ca14 <PmsSetPendingEvent>
8000dbcc:	5c 83       	casts.h	r3
8000dbce:	ce 8a       	rjmp	8000d99e <PmsService+0xe6>
        MbmFree(NULL);          /* Try to pre-allocate: relevant for PMS_RX_OPT3 */
        #endif

        if( !pms.ifacesStarted )
        {
            pms.ifacesStarted = 1;
8000dbd0:	30 1a       	mov	r10,1
8000dbd2:	fe f9 0d 96 	ld.w	r9,pc[3478]
8000dbd6:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
8000dbda:	93 08       	st.w	r9[0x0],r8
            ASSERT(pmsInitData_ptr->startIfaces_fptr);
8000dbdc:	fe f7 0d 98 	ld.w	r7,pc[3480]
8000dbe0:	6e 08       	ld.w	r8,r7[0x0]
8000dbe2:	70 58       	ld.w	r8,r8[0x14]
8000dbe4:	58 08       	cp.w	r8,0
8000dbe6:	e0 80 04 66 	breq	8000e4b2 <PmsService+0xbfa>
            pmsInitData_ptr->startIfaces_fptr();
8000dbea:	5d 18       	icall	r8

            /* A timeout will force a SyncC, in case this was a startup */
            PmsSetPendingEvent(PMS_P_TIMEOUT);
8000dbec:	30 2c       	mov	r12,2
8000dbee:	fe b0 f7 13 	rcall	8000ca14 <PmsSetPendingEvent>
8000dbf2:	cc ea       	rjmp	8000d98e <PmsService+0xd6>

    T_MOD_ENTRY(PMS_53);

    fifo_ptr = NULL;

    switch( rx_handle->hdr_ptr[FPH_INDEX] & FPH_M_FIFONO )
8000dbf4:	fe f6 0d 78 	ld.w	r6,pc[3448]
8000dbf8:	30 12       	mov	r2,1
8000dbfa:	fe f5 0d 92 	ld.w	r5,pc[3474]
8000dbfe:	fe f1 0d 86 	ld.w	r1,pc[3462]
        /*
         * Possibly replace the default preallocated RX buffer in case we are
         * running low - this will prevent acknowledging this FIFO as ready
         * for another message from the INIC.
         */
        WAIT4MX(MX_PMS_CS);
8000dc02:	30 2c       	mov	r12,2
8000dc04:	fe b0 cf 59 	rcall	80007ab6 <mns_take>
        if( (NULL == pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC]) && index )
8000dc08:	fe f8 0d 60 	ld.w	r8,pc[3424]
8000dc0c:	70 69       	ld.w	r9,r8[0x18]
8000dc0e:	58 09       	cp.w	r9,0
8000dc10:	c0 d1       	brne	8000dc2a <PmsService+0x372>
        {
            pms.rxPreAllocPtrTab[PMS_IDX_RSVD_RX_PREALLOC] = pms.rxPreAllocPtrTab[index];
8000dc12:	2f a2       	sub	r2,-6
8000dc14:	f0 02 03 29 	ld.w	r9,r8[r2<<0x2]
8000dc18:	91 69       	st.w	r8[0x18],r9
            pms.rxPreAllocPtrTab[index] = NULL;
8000dc1a:	30 0b       	mov	r11,0
8000dc1c:	f0 02 09 2b 	st.w	r8[r2<<0x2],r11
            pms.needPrealloc = 1;
8000dc20:	30 1a       	mov	r10,1
8000dc22:	70 09       	ld.w	r9,r8[0x0]
8000dc24:	f3 da d3 41 	bfins	r9,r10,0x1a,0x1
8000dc28:	91 09       	st.w	r8[0x0],r9
        }
        REL_MX(MX_PMS_CS);
8000dc2a:	30 2c       	mov	r12,2
8000dc2c:	fe b0 cf 46 	rcall	80007ab8 <mns_give>
    T_MOD_ENTRY(PMS_13);
    msg_ptr = &handle->msg;
    len = (word)0;

    #if ((defined ADS_MIN) && (!defined PMS_DISABLE_ADS_LEN_CHECKS)) || (!defined PMS_DISABLE_CTRL_LEN_CHECKS)
    DECODE_WORD(&pml, MBM_GET_HDR_PTR(handle));                       /* PML */
8000dc30:	6e a8       	ld.w	r8,r7[0x28]
8000dc32:	11 8b       	ld.ub	r11,r8[0x0]
8000dc34:	11 99       	ld.ub	r9,r8[0x1]
    #endif

    src_ptr = MBM_GET_HDR_PTR(handle) + FPH_INDEX;                    /* => FPH   */
8000dc36:	f0 ca ff fd 	sub	r10,r8,-3
    T_MOD_ENTRY(PMS_13);
    msg_ptr = &handle->msg;
    len = (word)0;

    #if ((defined ADS_MIN) && (!defined PMS_DISABLE_ADS_LEN_CHECKS)) || (!defined PMS_DISABLE_CTRL_LEN_CHECKS)
    DECODE_WORD(&pml, MBM_GET_HDR_PTR(handle));                       /* PML */
8000dc3a:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
8000dc3e:	5c 8b       	casts.h	r11
    #endif

    src_ptr = MBM_GET_HDR_PTR(handle) + FPH_INDEX;                    /* => FPH   */

    if( def_ptr )
8000dc40:	58 05       	cp.w	r5,0
8000dc42:	fe 90 ff 50 	breq	8000dae2 <PmsService+0x22a>
        #ifndef PMS_DISABLE_CTRL_LEN_CHECKS
        byte                  pmhl;
        #endif
        byte                  scf0;
        byte                  scf1;
        MBM_SET_TYPE(handle, MBM_TYPE_CTRL_RX);
8000dc46:	8e 69       	ld.sh	r9,r7[0xc]
8000dc48:	e0 19 ff f0 	andl	r9,0xfff0
8000dc4c:	a3 a9       	sbr	r9,0x2
8000dc4e:	ae 69       	st.h	r7[0xc],r9

        /*!
         * Check SCF0 enabled bit in FPH and move to next, if bit was
         * set add the next byte as SCF0 and move to next
         */
        scf0 = (FPH_M_SCF0_ENABLED & *src_ptr++) ?
8000dc50:	f0 c9 ff fc 	sub	r9,r8,-4
8000dc54:	15 8a       	ld.ub	r10,r10[0x0]
8000dc56:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000dc5a:	e0 80 00 a1 	breq	8000dd9c <PmsService+0x4e4>
8000dc5e:	13 8c       	ld.ub	r12,r9[0x0]
               *src_ptr++ : def_ptr->rxScf0Default;
8000dc60:	f0 c9 ff fb 	sub	r9,r8,-5

        /* If SCF0 had SCF1 enabled then add this as well and move on */
        scf1 = (PMS_M_SCF0_SCF1_EN & scf0) ?
8000dc64:	ed bc 00 00 	bld	r12,0x0
8000dc68:	e0 81 00 98 	brne	8000dd98 <PmsService+0x4e0>
8000dc6c:	13 3a       	ld.ub	r10,r9++
               *src_ptr++ : def_ptr->rxScf1Default;

        if( scf0 & PMS_M_SCF0_TIMESTAMP )
8000dc6e:	30 0e       	mov	lr,0
        {
            src_ptr += 4;   /* Ignore timestamp, no destination field */
8000dc70:	fc 0c 18 00 	cp.b	r12,lr
8000dc74:	f7 b9 05 fc 	sublt	r9,-4
        handle->handle = (scf0 & PMS_M_SCF0_HANDLE) ?
                         *src_ptr++ : PMS_DEF_HANDLE;
        #else
        if( scf0 & PMS_M_SCF0_HANDLE )
        {
            src_ptr++; /* Skip */
8000dc78:	ed bc 00 06 	bld	r12,0x6
8000dc7c:	f7 b9 00 ff 	subeq	r9,-1
        }
        #endif

        msg_ptr->msgRx.Rcv_Type = (scf1 & PMS_M_SCF1_TGTDEVTYPE) ?
8000dc80:	30 0c       	mov	r12,0
8000dc82:	f8 0a 18 00 	cp.b	r10,r12
8000dc86:	e0 85 02 24 	brlt	8000e0ce <PmsService+0x816>
8000dc8a:	30 0c       	mov	r12,0
8000dc8c:	ef 6c 00 21 	st.b	r7[33],r12

        #ifdef CTRL_FILTER_ID
        msg_ptr->msgRx.Filter_ID = (byte)0x00;
        #endif

        if( scf1 & PMS_M_SCF1_SRCDEVID )
8000dc90:	ed ba 00 06 	bld	r10,0x6
8000dc94:	c7 e1       	brne	8000dd90 <PmsService+0x4d8>
        {
            DECODE_WORD(&msg_ptr->msgRx.Src_Adr, src_ptr);
8000dc96:	13 8e       	ld.ub	lr,r9[0x0]
8000dc98:	13 9c       	ld.ub	r12,r9[0x1]
            src_ptr += 2;
8000dc9a:	2f e9       	sub	r9,-2
        msg_ptr->msgRx.Filter_ID = (byte)0x00;
        #endif

        if( scf1 & PMS_M_SCF1_SRCDEVID )
        {
            DECODE_WORD(&msg_ptr->msgRx.Src_Adr, src_ptr);
8000dc9c:	f9 ee 10 8c 	or	r12,r12,lr<<0x8
8000dca0:	ef 5c 00 1a 	st.h	r7[26],r12
        else
        {
            msg_ptr->msgRx.Src_Adr = PMS_DEF_SRCADDR;
        }

        if( scf1 & PMS_M_SCF1_FUNCADDR )
8000dca4:	e2 1a 00 10 	andl	r10,0x10,COH
        {
            msg_ptr->msgRx.FBlock_ID = *src_ptr++;
8000dca8:	f3 fa 18 00 	ld.ubne	r10,r9[0x0]
8000dcac:	ef fa 1e 1e 	st.bne	r7[0x1e],r10
            msg_ptr->msgRx.Inst_ID   = *src_ptr++;
8000dcb0:	f3 f9 18 01 	ld.ubne	r9,r9[0x1]
8000dcb4:	ef f9 1e 1f 	st.bne	r7[0x1f],r9
        }
        else
        {
            msg_ptr->msgRx.FBlock_ID = PMS_DEF_FBLOCK_ID;
            msg_ptr->msgRx.Inst_ID   = PMS_DEF_INST_ID;
8000dcb8:	ef fa 0e 1f 	st.beq	r7[0x1f],r10
            msg_ptr->msgRx.FBlock_ID = *src_ptr++;
            msg_ptr->msgRx.Inst_ID   = *src_ptr++;
        }
        else
        {
            msg_ptr->msgRx.FBlock_ID = PMS_DEF_FBLOCK_ID;
8000dcbc:	ef fa 0e 1e 	st.beq	r7[0x1e],r10
            msg_ptr->msgRx.Inst_ID   = PMS_DEF_INST_ID;
        }

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers */
8000dcc0:	f0 c9 ff fe 	sub	r9,r8,-2
8000dcc4:	13 8a       	ld.ub	r10,r9[0x0]
8000dcc6:	2f fa       	sub	r10,-1
8000dcc8:	f2 0a 00 0a 	add	r10,r9,r10

        DECODE_WORD(&len, src_ptr);                       /* Length (+TelId) */
        src_ptr += 2;

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
8000dccc:	ef 1c 00 30 	ld.uh	r12,r7[48]

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers */

        /* Decode mandatory fields */
        DECODE_WORD(&msg_ptr->msgRx.Func_ID, src_ptr);    /* Func_ID */
        msg_ptr->msgRx.Func_ID >>= 4;                     /* Shift out Operation */
8000dcd0:	15 8e       	ld.ub	lr,r10[0x0]
        src_ptr++;                                        /* Operation in Low Nibble */

        msg_ptr->msgRx.Operation = *src_ptr++ & ((byte) 0x0F); /* Operation */

        DECODE_WORD(&len, src_ptr);                       /* Length (+TelId) */
        src_ptr += 2;
8000dcd2:	f4 c9 ff fc 	sub	r9,r10,-4
        }

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers */

        /* Decode mandatory fields */
        DECODE_WORD(&msg_ptr->msgRx.Func_ID, src_ptr);    /* Func_ID */
8000dcd6:	f4 c5 ff ff 	sub	r5,r10,-1
        msg_ptr->msgRx.Func_ID >>= 4;                     /* Shift out Operation */
        src_ptr++;                                        /* Operation in Low Nibble */

        msg_ptr->msgRx.Operation = *src_ptr++ & ((byte) 0x0F); /* Operation */
8000dcda:	0a 9a       	mov	r10,r5

        PMS_SKIP_HEADER(src_ptr, handle); /* Skips any fillers */

        /* Decode mandatory fields */
        DECODE_WORD(&msg_ptr->msgRx.Func_ID, src_ptr);    /* Func_ID */
        msg_ptr->msgRx.Func_ID >>= 4;                     /* Shift out Operation */
8000dcdc:	0b 85       	ld.ub	r5,r5[0x0]
8000dcde:	eb ee 10 8e 	or	lr,r5,lr<<0x8
8000dce2:	a5 8e       	lsr	lr,0x4
8000dce4:	ef 5e 00 1c 	st.h	r7[28],lr

        DECODE_WORD(&len, src_ptr);                       /* Length (+TelId) */
        src_ptr += 2;

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
8000dce8:	6e 4e       	ld.w	lr,r7[0x10]
8000dcea:	18 0e       	add	lr,r12
        /* Decode mandatory fields */
        DECODE_WORD(&msg_ptr->msgRx.Func_ID, src_ptr);    /* Func_ID */
        msg_ptr->msgRx.Func_ID >>= 4;                     /* Shift out Operation */
        src_ptr++;                                        /* Operation in Low Nibble */

        msg_ptr->msgRx.Operation = *src_ptr++ & ((byte) 0x0F); /* Operation */
8000dcec:	15 3c       	ld.ub	r12,r10++
8000dcee:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
8000dcf2:	ef 6c 00 20 	st.b	r7[32],r12

        DECODE_WORD(&len, src_ptr);                       /* Length (+TelId) */
8000dcf6:	15 9c       	ld.ub	r12,r10[0x1]
8000dcf8:	15 8a       	ld.ub	r10,r10[0x0]
        src_ptr += 2;

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
8000dcfa:	fe f5 0c 8e 	ld.w	r5,pc[3214]
        msg_ptr->msgRx.Func_ID >>= 4;                     /* Shift out Operation */
        src_ptr++;                                        /* Operation in Low Nibble */

        msg_ptr->msgRx.Operation = *src_ptr++ & ((byte) 0x0F); /* Operation */

        DECODE_WORD(&len, src_ptr);                       /* Length (+TelId) */
8000dcfe:	f9 ea 10 8c 	or	r12,r12,r10<<0x8
        src_ptr += 2;

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
8000dd02:	1c 39       	cp.w	r9,lr
8000dd04:	f2 0e 17 30 	movlo	lr,r9
8000dd08:	ea 0e 17 20 	movhs	lr,r5
        msg_ptr->msgRx.Func_ID >>= 4;                     /* Shift out Operation */
        src_ptr++;                                        /* Operation in Low Nibble */

        msg_ptr->msgRx.Operation = *src_ptr++ & ((byte) 0x0F); /* Operation */

        DECODE_WORD(&len, src_ptr);                       /* Length (+TelId) */
8000dd0c:	5c 8c       	casts.h	r12
        src_ptr += 2;

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
8000dd0e:	8f 5e       	st.w	r7[0x14],lr
                              ? src_ptr : &mbmMemArray[0];

        handle->tel_id = HB(len) >> 4;
        len &= (word)0x0FFF;                              /* Payload length */
8000dd10:	f5 dc c0 0c 	bfextu	r10,r12,0x0,0xc

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
                              ? src_ptr : &mbmMemArray[0];

        handle->tel_id = HB(len) >> 4;
8000dd14:	f9 dc c1 84 	bfextu	r12,r12,0xc,0x4
        len &= (word)0x0FFF;                              /* Payload length */
        msg_ptr->msgRx.Length = len;
8000dd18:	ef 5a 00 18 	st.h	r7[24],r10

        /* Always pass on a valid Data pointer, even without payload */
        msg_ptr->msgRx.Data = (src_ptr < (handle->start_ptr + handle->size))
                              ? src_ptr : &mbmMemArray[0];

        handle->tel_id = HB(len) >> 4;
8000dd1c:	ef 6c 00 36 	st.b	r7[54],r12
        msg_ptr->msgRx.Length = len;

        #ifndef PMS_DISABLE_CTRL_LEN_CHECKS
        pmhl = MBM_GET_HDR_PTR(handle)[2];
        /*  PML != SZ(PMHL) +   PMHL      +  SZ(FuncId_OpType,TelID_TelLen) + TelLen */
        if (pml != ((word)1 +  (word)pmhl + (word)4                         + len))
8000dd20:	5c 7b       	castu.h	r11
        handle->tel_id = HB(len) >> 4;
        len &= (word)0x0FFF;                              /* Payload length */
        msg_ptr->msgRx.Length = len;

        #ifndef PMS_DISABLE_CTRL_LEN_CHECKS
        pmhl = MBM_GET_HDR_PTR(handle)[2];
8000dd22:	11 ac       	ld.ub	r12,r8[0x2]
8000dd24:	2f bc       	sub	r12,-5
8000dd26:	14 0c       	add	r12,r10
8000dd28:	18 3b       	cp.w	r11,r12
8000dd2a:	c0 40       	breq	8000dd32 <PmsService+0x47a>
        /*  PML != SZ(PMHL) +   PMHL      +  SZ(FuncId_OpType,TelID_TelLen) + TelLen */
        if (pml != ((word)1 +  (word)pmhl + (word)4                         + len))
        {
            msg_ptr->msgRx.Length = PMS_INVALID_PM_LENGTH;
8000dd2c:	3f fb       	mov	r11,-1
8000dd2e:	ef 5b 00 18 	st.h	r7[24],r11
    }
    #endif

    MBM_SET_PAYLOAD_PTR(handle, src_ptr);
    MBM_SET_PAYLOAD_LEN(handle, len);
    MBM_SET_HDR_LEN(handle, (word)(src_ptr - MBM_GET_HDR_PTR(handle)));
8000dd32:	f2 08 01 08 	sub	r8,r9,r8
                                ? src_ptr : &mbmMemArray[0];
    }
    #endif

    MBM_SET_PAYLOAD_PTR(handle, src_ptr);
    MBM_SET_PAYLOAD_LEN(handle, len);
8000dd36:	ef 5a 00 34 	st.h	r7[52],r10
    MBM_SET_HDR_LEN(handle, (word)(src_ptr - MBM_GET_HDR_PTR(handle)));
8000dd3a:	ef 58 00 32 	st.h	r7[50],r8
        msg_ptr->dataRx.Data   = (src_ptr < (handle->start_ptr + handle->size))
                                ? src_ptr : &mbmMemArray[0];
    }
    #endif

    MBM_SET_PAYLOAD_PTR(handle, src_ptr);
8000dd3e:	8f b9       	st.w	r7[0x2c],r9

        /* Set the status response to the INIC */
        #ifdef PMS_RX_SEND_ACK
        #ifdef ADS_MIN /* No check for only MDP_MIN, just ack */
        /* Unless it is MDP over MLB */
        if( (&mdpFifo != fifo_ptr) || (&generalData != mdpFifo.iface_ptr) )
8000dd40:	02 36       	cp.w	r6,r1
8000dd42:	e0 80 01 e9 	breq	8000e114 <PmsService+0x85c>
        #endif
        {
            fifo_ptr->rxStatus = PMS_M_STAT_SLOTAV | PMS_XMIT_SUCCESS;
8000dd46:	34 48       	mov	r8,68
8000dd48:	ed 68 00 82 	st.b	r6[130],r8
        }
        #endif

        if( (&mcmFifo == fifo_ptr) || (&icmFifo == fifo_ptr))
8000dd4c:	fe f2 0c 34 	ld.w	r2,pc[3124]
8000dd50:	04 36       	cp.w	r6,r2
8000dd52:	e0 80 00 e9 	breq	8000df24 <PmsService+0x66c>
8000dd56:	fe f8 0c 16 	ld.w	r8,pc[3094]
8000dd5a:	10 36       	cp.w	r6,r8
8000dd5c:	e0 80 00 e4 	breq	8000df24 <PmsService+0x66c>
                }
                #endif
            }
        }
        #if (defined ADS_MIN) && (!defined PMS_DISABLE_ADS_LEN_CHECKS)
        else if( &mdpFifo == fifo_ptr )
8000dd60:	02 36       	cp.w	r6,r1
8000dd62:	e0 80 01 f7 	breq	8000e150 <PmsService+0x898>
8000dd66:	fe f2 0c 1a 	ld.w	r2,pc[3098]
            PmsSend(hErr, NULL);
        }
        else
        {
            MbmFree(hErr);
            FAILED_ASSERT();                    /* Information: Discarding the segmentation */
8000dd6a:	0e 95       	mov	r5,r7
        }
        #endif

        if( NULL != handle )
        {
            if( &mcmFifo == fifo_ptr )
8000dd6c:	04 36       	cp.w	r6,r2
8000dd6e:	e0 80 02 31 	breq	8000e1d0 <PmsService+0x918>
        }
        #ifdef MDP_MIN
        else if( &mdpFifo == fifo_ptr )
        {
            #ifdef ADS_MIN    /* Callback only needed with ADS */
            cbRx_fptr = pmsInitData_ptr->cbMdpRx_fptr;
8000dd72:	02 36       	cp.w	r6,r1
8000dd74:	e1 f8 00 00 	ld.weq	r8,r0[0x0]
8000dd78:	f1 f8 00 03 	ld.weq	r8,r8[0xc]
            #endif
        }
        #endif
        else
        {
            cbRx_fptr = pmsInitData_ptr->cbIcmRx_fptr;
8000dd7c:	e1 f8 10 00 	ld.wne	r8,r0[0x0]
8000dd80:	f1 f8 10 01 	ld.wne	r8,r8[0x4]
        }

        if( cbRx_fptr )
8000dd84:	58 08       	cp.w	r8,0
8000dd86:	e0 80 01 d9 	breq	8000e138 <PmsService+0x880>
        {
            cbRx_fptr(handle);
8000dd8a:	0a 9c       	mov	r12,r5
8000dd8c:	5d 18       	icall	r8
8000dd8e:	c1 ab       	rjmp	8000dbc2 <PmsService+0x30a>
            DECODE_WORD(&msg_ptr->msgRx.Src_Adr, src_ptr);
            src_ptr += 2;
        }
        else
        {
            msg_ptr->msgRx.Src_Adr = PMS_DEF_SRCADDR;
8000dd90:	30 1c       	mov	r12,1
8000dd92:	ef 5c 00 1a 	st.h	r7[26],r12
8000dd96:	c8 7b       	rjmp	8000dca4 <PmsService+0x3ec>
         */
        scf0 = (FPH_M_SCF0_ENABLED & *src_ptr++) ?
               *src_ptr++ : def_ptr->rxScf0Default;

        /* If SCF0 had SCF1 enabled then add this as well and move on */
        scf1 = (PMS_M_SCF0_SCF1_EN & scf0) ?
8000dd98:	0b 9a       	ld.ub	r10,r5[0x1]
8000dd9a:	c6 ab       	rjmp	8000dc6e <PmsService+0x3b6>

        /*!
         * Check SCF0 enabled bit in FPH and move to next, if bit was
         * set add the next byte as SCF0 and move to next
         */
        scf0 = (FPH_M_SCF0_ENABLED & *src_ptr++) ?
8000dd9c:	0b 8c       	ld.ub	r12,r5[0x0]
8000dd9e:	c6 3b       	rjmp	8000dc64 <PmsService+0x3ac>
        #ifdef ADS_MIN /* No check for only MDP_MIN, just ack */
        /* Unless it is MDP over MLB */
        if( (&mdpFifo != fifo_ptr) || (&generalData != mdpFifo.iface_ptr) )
        #endif
        {
            fifo_ptr->rxStatus = PMS_M_STAT_SLOTAV | PMS_XMIT_SUCCESS;
8000dda0:	fe f6 0b e4 	ld.w	r6,pc[3044]
8000dda4:	c8 1a       	rjmp	8000daa6 <PmsService+0x1ee>
        }
    }

    if( event & (PMS_P_TIMEOUT | PMS_P_SEND_SYNCC) )
    {
        PmsSyncHandler(event);
8000dda6:	08 9c       	mov	r12,r4
8000dda8:	fe b0 f6 ae 	rcall	8000cb04 <PmsSyncHandler>
    }

    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    if( event & PMS_P_MDP_TXSTATUS )
8000ddac:	ed b4 00 06 	bld	r4,0x6
8000ddb0:	fe 91 fe d4 	brne	8000db58 <PmsService+0x2a0>
    {
        PmsFifoProcessStatus(&mdpFifo, PMS_M_STAT_SLOTAV | PMS_XMIT_SUCCESS, NULL);
8000ddb4:	30 0a       	mov	r10,0
8000ddb6:	34 4b       	mov	r11,68
8000ddb8:	fe fc 0b cc 	ld.w	r12,pc[3020]
8000ddbc:	fe b0 fb b2 	rcall	8000d520 <PmsFifoProcessStatus>
    }
    #endif

    #ifdef PMS_28
    if( event & (PMS_P_GBG_COL | PMS_P_RETRIGGER_GBG) )
8000ddc0:	08 98       	mov	r8,r4
8000ddc2:	e2 18 0a 00 	andl	r8,0xa00,COH
8000ddc6:	fe 90 fe ce 	breq	8000db62 <PmsService+0x2aa>
static void PmsRxSegGarbageCollector(bool no_mark)
{
    HMBMBUF hCur;
    T_MOD_ENTRY(PMS_28);

    hCur = _MbmPeek(&rxSegQ);
8000ddca:	fe f5 0b c6 	ld.w	r5,pc[3014]

    #ifdef PMS_28
    if( event & (PMS_P_GBG_COL | PMS_P_RETRIGGER_GBG) )
    {
        /* If ONLY PMS_P_RETRIGGER_GBG is set, then segments should not be marked */
        PmsRxSegGarbageCollector((event & PMS_P_GBG_COL) ? MNS_FALSE : MNS_TRUE);
8000ddce:	08 91       	mov	r1,r4
static void PmsRxSegGarbageCollector(bool no_mark)
{
    HMBMBUF hCur;
    T_MOD_ENTRY(PMS_28);

    hCur = _MbmPeek(&rxSegQ);
8000ddd0:	0a 9c       	mov	r12,r5

    #ifdef PMS_28
    if( event & (PMS_P_GBG_COL | PMS_P_RETRIGGER_GBG) )
    {
        /* If ONLY PMS_P_RETRIGGER_GBG is set, then segments should not be marked */
        PmsRxSegGarbageCollector((event & PMS_P_GBG_COL) ? MNS_FALSE : MNS_TRUE);
8000ddd2:	e2 11 02 00 	andl	r1,0x200,COH
static void PmsRxSegGarbageCollector(bool no_mark)
{
    HMBMBUF hCur;
    T_MOD_ENTRY(PMS_28);

    hCur = _MbmPeek(&rxSegQ);
8000ddd6:	fe b0 e1 3f 	rcall	8000a054 <_MbmPeek>
8000ddda:	18 97       	mov	r7,r12
    while( hCur )
8000dddc:	c2 d0       	breq	8000de36 <PmsService+0x57e>
    {
        HMBMBUF hNext;
        ASSERT(&rxSegQ == hCur->q_ptr);
8000ddde:	e0 63 11 a5 	mov	r3,4517
            if( MNS_FALSE == error_sent_or_broadcast )
            {
                bool granted;

                WAIT4MX(MX_PMS_CS);
                if( !(MBM_GET_STATUS(&segErrMsg) & MBM_STAT_RSVD) )
8000dde2:	fe f2 0b b2 	ld.w	r2,pc[2994]

                    error_sent_or_broadcast = MNS_TRUE;
                }
                else
                {
                    pms.needSegErrMsg = 1;
8000dde6:	fe f0 0b 82 	ld.w	r0,pc[2946]
8000ddea:	c0 d8       	rjmp	8000de04 <PmsService+0x54c>
             * kept and delayed until the error message is available.
             * (groupcast included since = 0x03)
             */
            bool error_sent_or_broadcast = (rx_ptr->Rcv_Type & MSG_RCV_TYPE_BROADCAST) ? MNS_TRUE : MNS_FALSE;

            if( MNS_FALSE == error_sent_or_broadcast )
8000ddec:	ef 38 00 21 	ld.ub	r8,r7[33]
8000ddf0:	ed b8 00 01 	bld	r8,0x1
8000ddf4:	c7 01       	brne	8000ded4 <PmsService+0x61c>
                }
            }

            if( MNS_FALSE != error_sent_or_broadcast )
            {
                PmsRxSegError(hCur, MSG_ERR_5);
8000ddf6:	0e 9c       	mov	r12,r7
8000ddf8:	30 5b       	mov	r11,5
8000ddfa:	fe b0 fb 7b 	rcall	8000d4f0 <PmsRxSegError>
{
    HMBMBUF hCur;
    T_MOD_ENTRY(PMS_28);

    hCur = _MbmPeek(&rxSegQ);
    while( hCur )
8000ddfe:	58 06       	cp.w	r6,0
8000de00:	c1 b0       	breq	8000de36 <PmsService+0x57e>
8000de02:	0c 97       	mov	r7,r6
    {
        HMBMBUF hNext;
        ASSERT(&rxSegQ == hCur->q_ptr);
8000de04:	6e 28       	ld.w	r8,r7[0x8]
8000de06:	0a 38       	cp.w	r8,r5
8000de08:	c6 40       	breq	8000ded0 <PmsService+0x618>
8000de0a:	1a d3       	st.w	--sp,r3
8000de0c:	30 1a       	mov	r10,1
8000de0e:	31 0b       	mov	r11,16
8000de10:	14 9c       	mov	r12,r10
8000de12:	fe b0 ce 6d 	rcall	80007aec <mns_trace>
8000de16:	6e 28       	ld.w	r8,r7[0x8]
8000de18:	2f fd       	sub	sp,-4
        hNext = MBM_NEXT(hCur);
8000de1a:	6e 06       	ld.w	r6,r7[0x0]
8000de1c:	10 36       	cp.w	r6,r8
8000de1e:	f9 b6 00 00 	moveq	r6,0
        if( MBM_STAT_RX_GARBAGE_BIT & MBM_GET_STATUS(hCur) )
8000de22:	8e 68       	ld.sh	r8,r7[0xc]
8000de24:	ed b8 00 09 	bld	r8,0x9
8000de28:	ce 20       	breq	8000ddec <PmsService+0x534>
            PmsRxSegError(hCur, MSG_ERR_5);
            #endif
        }
        else
        {
            if( MNS_FALSE == no_mark )
8000de2a:	58 01       	cp.w	r1,0
8000de2c:	ce 90       	breq	8000ddfe <PmsService+0x546>
            {
                MBM_SET_STATUS_BITS(hCur, MBM_STAT_RX_GARBAGE_BIT);
8000de2e:	a9 b8       	sbr	r8,0x9
8000de30:	ae 68       	st.h	r7[0xc],r8
{
    HMBMBUF hCur;
    T_MOD_ENTRY(PMS_28);

    hCur = _MbmPeek(&rxSegQ);
    while( hCur )
8000de32:	58 06       	cp.w	r6,0
8000de34:	ce 71       	brne	8000de02 <PmsService+0x54a>
        }

        hCur = hNext;
    }
    /* Ensure that garbage collector runs if there are segments pending */
    if( MBM_QUEUE_LENGTH(&rxSegQ) && !MostGetTimer(&pmsGbgTimer) )
8000de36:	8a 59       	ld.sh	r9,r5[0xa]
8000de38:	30 08       	mov	r8,0
8000de3a:	f0 09 19 00 	cp.h	r9,r8
8000de3e:	fe 90 fe 92 	breq	8000db62 <PmsService+0x2aa>
8000de42:	fe fc 0b 56 	ld.w	r12,pc[2902]
8000de46:	fe b0 e9 e1 	rcall	8000b208 <MostGetTimer>
8000de4a:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
8000de4e:	fe 91 fe 8a 	brne	8000db62 <PmsService+0x2aa>
    {
        MostSetTimer(&pmsGbgTimer, PMS_RX_SEG_TIMEOUT, MNS_FALSE);
8000de52:	e0 6b 13 88 	mov	r11,5000
8000de56:	fe fc 0b 42 	ld.w	r12,pc[2882]
8000de5a:	fe b0 e9 27 	rcall	8000b0a8 <MostSetTimer>
8000de5e:	fe 9f fe 82 	bral	8000db62 <PmsService+0x2aa>
    #endif


    if( event & PMS_P_TIMEOUT_RX_PREALLOC )
    {
        WAIT4MX(MX_PMS_CS);
8000de62:	30 2c       	mov	r12,2
8000de64:	fe b0 ce 29 	rcall	80007ab6 <mns_take>
        if (NULL == pms.rxPreAllocPtrTab[PMS_IDX_MCM_RX_PREALLOC])
8000de68:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000de6c:	70 89       	ld.w	r9,r8[0x20]
8000de6e:	58 09       	cp.w	r9,0
8000de70:	e0 80 02 1b 	breq	8000e2a6 <PmsService+0x9ee>
        {
            discard_message = MNS_TRUE;
            pms.rxPreAllocHasTimedOut = 1;
            pms.rxPreAllocFailedTimerStarted = 0;
        }
        REL_MX(MX_PMS_CS);
8000de74:	30 2c       	mov	r12,2
8000de76:	fe b0 ce 21 	rcall	80007ab8 <mns_give>
            (void)PmsDiscardPendingRx();
            #endif
        }
    }

    if( event & PMS_P_GO_SEMI_PROTECTED )
8000de7a:	40 2a       	lddsp	r10,sp[0x8]
8000de7c:	30 07       	mov	r7,0
8000de7e:	ee 0a 19 00 	cp.h	r10,r7
8000de82:	fe 94 fe 7a 	brge	8000db76 <PmsService+0x2be>
    {
        if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
8000de86:	e0 6c 40 00 	mov	r12,16384
8000de8a:	fe b0 e8 15 	rcall	8000aeb4 <MostIsSupported>
8000de8e:	e0 80 01 73 	breq	8000e174 <PmsService+0x8bc>
        {
            pmsMaxCmsPayload = PMS_MAX_CMS_PAYLOAD_MOST150;
8000de92:	32 d9       	mov	r9,45
8000de94:	fe f8 0b 08 	ld.w	r8,pc[2824]
8000de98:	b0 09       	st.h	r8[0x0],r9
            pmsSupportsTelId4 = MNS_TRUE;
8000de9a:	30 19       	mov	r9,1
8000de9c:	fe f8 0b 04 	ld.w	r8,pc[2820]
8000dea0:	b0 89       	st.b	r8[0x0],r9
8000dea2:	fe 9f fe 6a 	bral	8000db76 <PmsService+0x2be>

    #ifndef PMS_RX_NOSEG
    if( event & (PMS_P_GO_PROTECTED | PMS_P_GO_NET_OFF ) )
    {
        /* Remove all pending segments */
        MbmFlush(&rxSegQ);
8000dea6:	fe fc 0a ea 	ld.w	r12,pc[2794]
8000deaa:	fe b0 e3 1b 	rcall	8000a4e0 <MbmFlush>
8000deae:	fe 9f fd 1c 	bral	8000d8e6 <PmsService+0x2e>
    #ifndef PMS_TX_NOSEG
    /*
     * Process status only when a segmented MCM isn't in the LLD to prevent
     * concurrency issues.
     */
    WAIT4MX(MX_PMS_CS);
8000deb2:	30 2c       	mov	r12,2
8000deb4:	fe b0 ce 01 	rcall	80007ab6 <mns_take>
    /*
     * Do not process status while any interface is busy to prevent processing one that
     * handed over by the LLD before the matching TX message has been released.
     */
    #ifdef ADS_MIN
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active
8000deb8:	fe f3 0a c8 	ld.w	r3,pc[2760]
8000debc:	66 98       	ld.w	r8,r3[0x24]
8000debe:	70 18       	ld.w	r8,r8[0x4]
8000dec0:	58 08       	cp.w	r8,0
8000dec2:	e0 80 02 0d 	breq	8000e2dc <PmsService+0xa24>
                          || ((&i2c == mdpFifo.iface_ptr) && (mdpFifo.iface_ptr->active))) ? MNS_TRUE : MNS_FALSE;
    #else
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active) ? MNS_TRUE : MNS_FALSE;
    #endif
    REL_MX(MX_PMS_CS);
8000dec6:	30 2c       	mov	r12,2
8000dec8:	fe b0 cd f8 	rcall	80007ab8 <mns_give>
8000decc:	fe 9f fd 7d 	bral	8000d9c6 <PmsService+0x10e>

    hCur = _MbmPeek(&rxSegQ);
    while( hCur )
    {
        HMBMBUF hNext;
        ASSERT(&rxSegQ == hCur->q_ptr);
8000ded0:	0a 98       	mov	r8,r5
8000ded2:	ca 4b       	rjmp	8000de1a <PmsService+0x562>

            if( MNS_FALSE == error_sent_or_broadcast )
            {
                bool granted;

                WAIT4MX(MX_PMS_CS);
8000ded4:	30 2c       	mov	r12,2
8000ded6:	fe b0 cd f0 	rcall	80007ab6 <mns_take>
                if( !(MBM_GET_STATUS(&segErrMsg) & MBM_STAT_RSVD) )
8000deda:	84 68       	ld.sh	r8,r2[0xc]
8000dedc:	ed b8 00 0a 	bld	r8,0xa
8000dee0:	e0 80 00 e1 	breq	8000e0a2 <PmsService+0x7ea>
                {
                    MBM_SET_STATUS_BITS(&segErrMsg, MBM_STAT_RSVD);
8000dee4:	ab a8       	sbr	r8,0xa
                }
                else
                {
                    granted = MNS_FALSE;
                }
                REL_MX(MX_PMS_CS);
8000dee6:	30 2c       	mov	r12,2
                bool granted;

                WAIT4MX(MX_PMS_CS);
                if( !(MBM_GET_STATUS(&segErrMsg) & MBM_STAT_RSVD) )
                {
                    MBM_SET_STATUS_BITS(&segErrMsg, MBM_STAT_RSVD);
8000dee8:	a4 68       	st.h	r2[0xc],r8
                }
                else
                {
                    granted = MNS_FALSE;
                }
                REL_MX(MX_PMS_CS);
8000deea:	fe b0 cd e7 	rcall	80007ab8 <mns_give>

                if( MNS_FALSE != granted )
                {
                    segErrMsg.msg.msgTx.Tgt_Adr   = rx_ptr->Src_Adr;
8000deee:	ef 08 00 1a 	ld.sh	r8,r7[26]
8000def2:	e5 58 00 1a 	st.h	r2[26],r8
                    segErrMsg.msg.msgTx.FBlock_ID = rx_ptr->FBlock_ID;
8000def6:	ef 38 00 1e 	ld.ub	r8,r7[30]
8000defa:	e5 68 00 1e 	st.b	r2[30],r8
                    segErrMsg.msg.msgTx.Inst_ID   = rx_ptr->Inst_ID;
8000defe:	ef 38 00 1f 	ld.ub	r8,r7[31]
8000df02:	e5 68 00 1f 	st.b	r2[31],r8
                    segErrMsg.msg.msgTx.Func_ID   = rx_ptr->Func_ID;
8000df06:	ef 08 00 1c 	ld.sh	r8,r7[28]
                    /* Operation, Length, Retries and Data[0] already set */
                    segErrMsg.msg.msgTx.Data[1]   = MSG_ERR_5;   /* Error ID           */
8000df0a:	30 5c       	mov	r12,5
                if( MNS_FALSE != granted )
                {
                    segErrMsg.msg.msgTx.Tgt_Adr   = rx_ptr->Src_Adr;
                    segErrMsg.msg.msgTx.FBlock_ID = rx_ptr->FBlock_ID;
                    segErrMsg.msg.msgTx.Inst_ID   = rx_ptr->Inst_ID;
                    segErrMsg.msg.msgTx.Func_ID   = rx_ptr->Func_ID;
8000df0c:	e5 58 00 1c 	st.h	r2[28],r8
                    /* Operation, Length, Retries and Data[0] already set */
                    segErrMsg.msg.msgTx.Data[1]   = MSG_ERR_5;   /* Error ID           */
8000df10:	64 58       	ld.w	r8,r2[0x14]

                    PmsSendBypass(&segErrMsg, PmsSegErrorTxStatus, MNS_TRUE);
8000df12:	30 1a       	mov	r10,1
                    segErrMsg.msg.msgTx.Tgt_Adr   = rx_ptr->Src_Adr;
                    segErrMsg.msg.msgTx.FBlock_ID = rx_ptr->FBlock_ID;
                    segErrMsg.msg.msgTx.Inst_ID   = rx_ptr->Inst_ID;
                    segErrMsg.msg.msgTx.Func_ID   = rx_ptr->Func_ID;
                    /* Operation, Length, Retries and Data[0] already set */
                    segErrMsg.msg.msgTx.Data[1]   = MSG_ERR_5;   /* Error ID           */
8000df14:	b0 9c       	st.b	r8[0x1],r12

                    PmsSendBypass(&segErrMsg, PmsSegErrorTxStatus, MNS_TRUE);
8000df16:	fe cb 14 ee 	sub	r11,pc,5358
8000df1a:	fe fc 0a 7a 	ld.w	r12,pc[2682]
8000df1e:	fe b0 f9 5f 	rcall	8000d1dc <PmsSendBypass>
8000df22:	c6 ab       	rjmp	8000ddf6 <PmsService+0x53e>
        {
            #ifndef PMS_DISABLE_CTRL_LEN_CHECKS
            TMsgRx *msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
            ASSERT(NULL != msg_ptr);

            if (PMS_INVALID_PM_LENGTH == msg_ptr->Length)
8000df24:	ef 08 00 18 	ld.sh	r8,r7[24]
8000df28:	3f f9       	mov	r9,-1
8000df2a:	f2 08 19 00 	cp.h	r8,r9
8000df2e:	e0 80 01 43 	breq	8000e1b4 <PmsService+0x8fc>
                handle = NULL;                              /* in PmsDecompressHeader() failed */
                FAILED_ASSERT();
            }
            #endif

            if ((&mcmFifo == fifo_ptr) && (NULL != handle))           /* segmented */
8000df32:	fe f2 0a 4e 	ld.w	r2,pc[2638]
8000df36:	04 36       	cp.w	r6,r2
8000df38:	5f 09       	sreq	r9
8000df3a:	58 09       	cp.w	r9,0
8000df3c:	fe 90 ff 17 	breq	8000dd6a <PmsService+0x4b2>
    error       = (byte)0;
    skip_alloc  = MNS_FALSE;
    old_ptr     = NULL;
    new_ptr     = MBM_GET_CTRL_RX_PTR(hNew);
    terminated  = MNS_FALSE;
    telId       = hNew->tel_id;
8000df40:	ef 39 00 36 	ld.ub	r9,r7[54]

    if (telId <= PMS_TELID_3)
8000df44:	30 3a       	mov	r10,3
8000df46:	f4 09 18 00 	cp.b	r9,r10
8000df4a:	e0 88 01 2b 	brls	8000e1a0 <PmsService+0x8e8>
        {
            terminated = MNS_TRUE;              /* Invalid segmented message, it has to be the segment counter and at       */
            telId = PMS_TELID_3;                /* least one byte.                                                          */
        }
    }
    else if ((MNS_FALSE != pmsSupportsTelId4) && (PMS_TELID_4 == telId))
8000df4e:	fe fa 0a 52 	ld.w	r10,pc[2642]
8000df52:	15 8b       	ld.ub	r11,r10[0x0]
8000df54:	30 0a       	mov	r10,0
8000df56:	f4 0b 18 00 	cp.b	r11,r10
8000df5a:	c0 60       	breq	8000df66 <PmsService+0x6ae>
8000df5c:	30 4a       	mov	r10,4
8000df5e:	f4 09 18 00 	cp.b	r9,r10
8000df62:	e0 80 03 f7 	breq	8000e750 <PmsService+0xe98>
        if ((word)2 <= new_ptr->Length)                 /* MsgSize - 2 or more bytes */
        {
            word prealloc_size;
            DECODE_WORD(&prealloc_size, new_ptr->Data);

            if (prealloc_size <= pmsMaxCmsPayload)
8000df66:	30 0e       	mov	lr,0
8000df68:	e0 69 00 ff 	mov	r9,255
8000df6c:	50 4e       	stdsp	sp[0x10],lr

    /*!
     * The rxSegQ does not need to be locked, it is only accessed from the
     * service thread.
     */
    hCur = (MNS_FALSE != forward) ? rxSegQ.next_ptr : rxSegQ.prev_ptr;
8000df6e:	fe fc 0a 22 	ld.w	r12,pc[2594]
8000df72:	78 15       	ld.w	r5,r12[0x4]
    while( ((HMBMBUF)&rxSegQ != hCur)
8000df74:	18 35       	cp.w	r5,r12
8000df76:	e0 80 01 35 	breq	8000e1e0 <PmsService+0x928>
8000df7a:	50 36       	stdsp	sp[0xc],r6
8000df7c:	c0 78       	rjmp	8000df8a <PmsService+0x6d2>
           && (MNS_FALSE == PmsRxSegMatch(new_ptr, MBM_GET_CTRL_RX_PTR(hCur))) )
    {
        hCur = (MNS_FALSE != forward) ? hCur->next_ptr : hCur->prev_ptr;
8000df7e:	6a 15       	ld.w	r5,r5[0x4]
    /*!
     * The rxSegQ does not need to be locked, it is only accessed from the
     * service thread.
     */
    hCur = (MNS_FALSE != forward) ? rxSegQ.next_ptr : rxSegQ.prev_ptr;
    while( ((HMBMBUF)&rxSegQ != hCur)
8000df80:	fe f8 0a 10 	ld.w	r8,pc[2576]
8000df84:	10 35       	cp.w	r5,r8
8000df86:	e0 80 01 2c 	breq	8000e1de <PmsService+0x926>
           && (MNS_FALSE == PmsRxSegMatch(new_ptr, MBM_GET_CTRL_RX_PTR(hCur))) )
8000df8a:	ea c6 ff ec 	sub	r6,r5,-20
8000df8e:	e0 80 01 7f 	breq	8000e28c <PmsService+0x9d4>
    T_MOD_ENTRY(PMS_33);

    ASSERT(l_ptr);
    ASSERT(r_ptr);

    if(    (l_ptr->Src_Adr   == r_ptr->Src_Adr)
8000df92:	eb 0a 00 1a 	ld.sh	r10,r5[26]
8000df96:	ef 0b 00 1a 	ld.sh	r11,r7[26]
8000df9a:	f4 0b 19 00 	cp.h	r11,r10
8000df9e:	cf 01       	brne	8000df7e <PmsService+0x6c6>
8000dfa0:	6a 7a       	ld.w	r10,r5[0x1c]
8000dfa2:	6e 7b       	ld.w	r11,r7[0x1c]
8000dfa4:	14 3b       	cp.w	r11,r10
8000dfa6:	ce c1       	brne	8000df7e <PmsService+0x6c6>
8000dfa8:	eb 3a 00 20 	ld.ub	r10,r5[32]
8000dfac:	ef 3b 00 20 	ld.ub	r11,r7[32]
8000dfb0:	f4 0b 18 00 	cp.b	r11,r10
8000dfb4:	ce 51       	brne	8000df7e <PmsService+0x6c6>
8000dfb6:	0c 98       	mov	r8,r6
    {
        hCur = (MNS_FALSE != forward) ? hCur->next_ptr : hCur->prev_ptr;
    }
    T_MOD_EXIT(PMS_25);
    /* Return NULL if search hit the head, else the first found match */
    return( ((HMBMBUF)&rxSegQ == hCur) ? NULL : hCur );
8000dfb8:	fe fa 09 d8 	ld.w	r10,pc[2520]
8000dfbc:	40 36       	lddsp	r6,sp[0xc]
8000dfbe:	0a 3a       	cp.w	r10,r5
8000dfc0:	e0 80 01 10 	breq	8000e1e0 <PmsService+0x928>
     */
    hOld = PmsRxSegFindMatch(new_ptr, MNS_FALSE);

    if (hOld)
    {
        old_ptr = MBM_GET_CTRL_RX_PTR(hOld);
8000dfc4:	50 38       	stdsp	sp[0xc],r8
    }


    if ( (PMS_TELID_1 == telId) && hOld )
8000dfc6:	30 18       	mov	r8,1
8000dfc8:	f0 09 18 00 	cp.b	r9,r8
8000dfcc:	e0 81 01 0d 	brne	8000e1e6 <PmsService+0x92e>
    {
        ASSERT(old_ptr);
        if ((word)0 == old_ptr->Length)
8000dfd0:	eb 09 00 18 	ld.sh	r9,r5[24]
8000dfd4:	30 08       	mov	r8,0
8000dfd6:	f0 09 19 00 	cp.h	r9,r8
8000dfda:	e0 80 02 78 	breq	8000e4ca <PmsService+0xc12>
    }

    if((MNS_FALSE == skip_alloc) && ((telId <= PMS_TELID_1) || (PMS_TELID_4 == telId)) )   /* Not segmented or initial */
    {
        #ifdef MSG_RX_AUTOMATIC_ERR_MSG
        if( (PMS_TELID_1 == telId) && ((byte)0 != new_ptr->Data[0]) )
8000dfde:	30 0e       	mov	lr,0
8000dfe0:	30 19       	mov	r9,1
8000dfe2:	50 5e       	stdsp	sp[0x14],lr
8000dfe4:	6e 58       	ld.w	r8,r7[0x14]
8000dfe6:	11 8a       	ld.ub	r10,r8[0x0]
8000dfe8:	30 08       	mov	r8,0
8000dfea:	f0 0a 18 00 	cp.b	r10,r8
8000dfee:	e0 80 02 8b 	breq	8000e504 <PmsService+0xc4c>
        {
            /* Initial segment with segment counter != 0 */
            if( hOld )
8000dff2:	58 05       	cp.w	r5,0
8000dff4:	c0 50       	breq	8000dffe <PmsService+0x746>
                /*
                 * Had an old message with the same segmentation handle, notify
                 * restart before end and discard since the new initial has the
                 * wrong segment counter also.
                 */
                PmsRxSegError(hOld, MSG_ERR_7);
8000dff6:	0a 9c       	mov	r12,r5
8000dff8:	30 7b       	mov	r11,7
8000dffa:	fe b0 fa 7b 	rcall	8000d4f0 <PmsRxSegError>
                hOld = NULL;
            }
            error = MSG_ERR_3 | KEEP_MESSAGE; /* Keep for hErr */
            PmsRxSegError(hNew, error);
8000dffe:	0e 9c       	mov	r12,r7
8000e000:	34 3b       	mov	r11,67
8000e002:	fe b0 fa 77 	rcall	8000d4f0 <PmsRxSegError>
8000e006:	34 3c       	mov	r12,67
8000e008:	50 37       	stdsp	sp[0xc],r7
8000e00a:	30 05       	mov	r5,0
8000e00c:	50 4c       	stdsp	sp[0x10],r12
            hNew = NULL;
        }
    }

    #ifdef MSG_RX_AUTOMATIC_ERR_MSG
    if( error && !(new_ptr->Rcv_Type & MSG_RCV_TYPE_BROADCAST) ) /* Not if broad/groupcast */
8000e00e:	ef 38 00 21 	ld.ub	r8,r7[33]
8000e012:	ed b8 00 01 	bld	r8,0x1
8000e016:	e0 80 01 2b 	breq	8000e26c <PmsService+0x9b4>
    {
        MbmCtrlTx *tx_ptr;

        ASSERT(hErr);
8000e01a:	40 38       	lddsp	r8,sp[0xc]
8000e01c:	58 08       	cp.w	r8,0
8000e01e:	e0 80 04 5c 	breq	8000e8d6 <PmsService+0x101e>
        ASSERT(hErr != hNew);
8000e022:	40 3e       	lddsp	lr,sp[0xc]
8000e024:	0a 3e       	cp.w	lr,r5
8000e026:	e0 80 04 4d 	breq	8000e8c0 <PmsService+0x1008>

        if (MNS_FALSE == MbmChangeType(hErr, (word)MBM_TYPE_CTRL_TX))
8000e02a:	30 5b       	mov	r11,5
8000e02c:	40 3c       	lddsp	r12,sp[0xc]
8000e02e:	fe b0 e2 73 	rcall	8000a514 <MbmChangeType>
8000e032:	e0 80 03 7e 	breq	8000e72e <PmsService+0xe76>
        }

        if ((byte)0 != error)
        {
            tx_ptr = MBM_GET_CTRL_TX_PTR(hErr);
            ASSERT(tx_ptr->Length >= (word)2);      /* Should be guaranteed by MbmGetBuf() */
8000e036:	40 3c       	lddsp	r12,sp[0xc]
8000e038:	30 18       	mov	r8,1
8000e03a:	f9 09 00 18 	ld.sh	r9,r12[24]
8000e03e:	f0 09 19 00 	cp.h	r9,r8
8000e042:	e0 88 04 55 	brls	8000e8ec <PmsService+0x1034>

            tx_ptr->Operation = OP_ERROR;
8000e046:	30 f8       	mov	r8,15
8000e048:	40 3b       	lddsp	r11,sp[0xc]
8000e04a:	f7 68 00 20 	st.b	r11[32],r8
            tx_ptr->Length    = (word)2;
8000e04e:	30 28       	mov	r8,2
8000e050:	f7 58 00 18 	st.h	r11[24],r8
            tx_ptr->Data[0]   = (byte)0x0C;         /* Segmentation error */
8000e054:	76 58       	ld.w	r8,r11[0x14]
8000e056:	30 c9       	mov	r9,12
8000e058:	b0 89       	st.b	r8[0x0],r9
            tx_ptr->Data[1]   = error & (byte)0xF;  /* Error ID           */
8000e05a:	76 58       	ld.w	r8,r11[0x14]
8000e05c:	40 4a       	lddsp	r10,sp[0x10]
8000e05e:	f3 da c0 04 	bfextu	r9,r10,0x0,0x4
8000e062:	b0 99       	st.b	r8[0x1],r9

            tx_ptr->LowLevelRetries = PMS_SEG_ERROR_LLR;
8000e064:	30 18       	mov	r8,1
            tx_ptr->MidLevelRetries = PMS_SEG_ERROR_MLR;

            PmsSend(hErr, NULL);
8000e066:	40 3c       	lddsp	r12,sp[0xc]
            tx_ptr->Operation = OP_ERROR;
            tx_ptr->Length    = (word)2;
            tx_ptr->Data[0]   = (byte)0x0C;         /* Segmentation error */
            tx_ptr->Data[1]   = error & (byte)0xF;  /* Error ID           */

            tx_ptr->LowLevelRetries = PMS_SEG_ERROR_LLR;
8000e068:	f7 68 00 22 	st.b	r11[34],r8
            tx_ptr->MidLevelRetries = PMS_SEG_ERROR_MLR;
8000e06c:	30 08       	mov	r8,0
8000e06e:	f7 68 00 21 	st.b	r11[33],r8

            PmsSend(hErr, NULL);
8000e072:	30 0b       	mov	r11,0
8000e074:	fe b0 f9 e2 	rcall	8000d438 <PmsSend>
    }
    #endif

    #ifdef PMS_28
    /* Ensure that the garbage collector runs if there are segments pending */
    if( MBM_QUEUE_LENGTH(&rxSegQ) > (word)0 )
8000e078:	fe f8 09 18 	ld.w	r8,pc[2328]
8000e07c:	90 59       	ld.sh	r9,r8[0xa]
8000e07e:	30 08       	mov	r8,0
8000e080:	f0 09 19 00 	cp.h	r9,r8
8000e084:	e0 80 01 fe 	breq	8000e480 <PmsService+0xbc8>
    {
        if((word)0 == MostGetTimer(&pmsGbgTimer))
8000e088:	fe fc 09 10 	ld.w	r12,pc[2320]
8000e08c:	fe b0 e8 be 	rcall	8000b208 <MostGetTimer>
8000e090:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
8000e094:	e0 80 02 ce 	breq	8000e630 <PmsService+0xd78>
                FAILED_ASSERT();
            }
        }
        #endif

        if( NULL != handle )
8000e098:	58 05       	cp.w	r5,0
8000e09a:	fe 90 fd 94 	breq	8000dbc2 <PmsService+0x30a>
8000e09e:	fe 9f fe 67 	bral	8000dd6c <PmsService+0x4b4>
                }
                else
                {
                    granted = MNS_FALSE;
                }
                REL_MX(MX_PMS_CS);
8000e0a2:	30 2c       	mov	r12,2
8000e0a4:	fe b0 cd 0a 	rcall	80007ab8 <mns_give>

                    error_sent_or_broadcast = MNS_TRUE;
                }
                else
                {
                    pms.needSegErrMsg = 1;
8000e0a8:	60 08       	ld.w	r8,r0[0x0]
8000e0aa:	30 1b       	mov	r11,1
8000e0ac:	f1 db d3 81 	bfins	r8,r11,0x1c,0x1
8000e0b0:	81 08       	st.w	r0[0x0],r8
8000e0b2:	ca 6a       	rjmp	8000ddfe <PmsService+0x546>

    T_MOD_ENTRY(PMS_32);

    if( pms.needPrealloc )
    {
        MbmFree(NULL); /* Try to pre-allocate */
8000e0b4:	30 0c       	mov	r12,0
8000e0b6:	fe b0 f7 51 	rcall	8000cf58 <MbmFree>
8000e0ba:	fe 9f fc 20 	bral	8000d8fa <PmsService+0x42>
        }
    }

    if( MBM_QUEUE_LENGTH(&rxQ) )
    {
        PmsSetPendingEvent(PMS_P_RX);
8000e0be:	30 1c       	mov	r12,1
8000e0c0:	fe b0 f4 aa 	rcall	8000ca14 <PmsSetPendingEvent>
8000e0c4:	fe 9f fc 7d 	bral	8000d9be <PmsService+0x106>
            }
            else
            #endif
            {
                add_len = MbmGetExtPayloadLen(handle);
                add_ptr = add_len ? MBM_GET_PAYLOAD_PTR(handle) : NULL;
8000e0c8:	14 9b       	mov	r11,r10
8000e0ca:	fe 9f fc c0 	bral	8000da4a <PmsService+0x192>
        {
            src_ptr++; /* Skip */
        }
        #endif

        msg_ptr->msgRx.Rcv_Type = (scf1 & PMS_M_SCF1_TGTDEVTYPE) ?
8000e0ce:	13 3c       	ld.ub	r12,r9++
8000e0d0:	fe 9f fd de 	bral	8000dc8c <PmsService+0x3d4>
    T_MOD_ENTRY(PMS_17);

    add_ptr = NULL;
    add_len = (word)0;

    ASSERT(fifo_ptr);
8000e0d4:	e0 68 0a 07 	mov	r8,2567
8000e0d8:	30 1a       	mov	r10,1
8000e0da:	1a d8       	st.w	--sp,r8
8000e0dc:	31 0b       	mov	r11,16
8000e0de:	14 9c       	mov	r12,r10
8000e0e0:	fe b0 cd 06 	rcall	80007aec <mns_trace>
8000e0e4:	2f fd       	sub	sp,-4
8000e0e6:	fe 9f fc 8d 	bral	8000da00 <PmsService+0x148>

        /*
         * If it's the message Q, make sure it is possible to send, if it is
         * the command Q, just try to dequeue the frontmost message.
         */
        if( (&fifo_ptr->msgQ == q_ptr) && (!fifo_ptr->txSlotsAvailable
8000e0ea:	eb 38 00 83 	ld.ub	r8,r5[131]
8000e0ee:	30 09       	mov	r9,0
8000e0f0:	f2 08 18 00 	cp.b	r8,r9
8000e0f4:	fe 90 fc 78 	breq	8000d9e4 <PmsService+0x12c>
8000e0f8:	fe f8 08 ac 	ld.w	r8,pc[2220]
8000e0fc:	70 08       	ld.w	r8,r8[0x0]
8000e0fe:	58 28       	cp.w	r8,2
8000e100:	fe 91 fc 72 	brne	8000d9e4 <PmsService+0x12c>
           || (PMS_S_SYNCED != pmsSyncState) || MBM_QUEUE_LENGTH(&fifo_ptr->cmdQ)) )
8000e104:	eb 08 00 16 	ld.sh	r8,r5[22]
8000e108:	e6 08 19 00 	cp.h	r8,r3
8000e10c:	fe 91 fc 6c 	brne	8000d9e4 <PmsService+0x12c>
8000e110:	fe 9f fc 85 	bral	8000da1a <PmsService+0x162>

        /* Set the status response to the INIC */
        #ifdef PMS_RX_SEND_ACK
        #ifdef ADS_MIN /* No check for only MDP_MIN, just ack */
        /* Unless it is MDP over MLB */
        if( (&mdpFifo != fifo_ptr) || (&generalData != mdpFifo.iface_ptr) )
8000e114:	6c 99       	ld.w	r9,r6[0x24]
8000e116:	fe f8 08 92 	ld.w	r8,pc[2194]
8000e11a:	10 39       	cp.w	r9,r8
8000e11c:	fe 90 fe 1d 	breq	8000dd56 <PmsService+0x49e>
        #endif
        {
            fifo_ptr->rxStatus = PMS_M_STAT_SLOTAV | PMS_XMIT_SUCCESS;
8000e120:	34 48       	mov	r8,68
8000e122:	ed 68 00 82 	st.b	r6[130],r8
8000e126:	fe 9f fe 18 	bral	8000dd56 <PmsService+0x49e>
        if( &icmFifo == fifo_ptr )
        {
            def_ptr = &icmDefCfg;
            index   = PMS_IDX_ICM_RX_PREALLOC;
        }
        else if( &mcmFifo == fifo_ptr )
8000e12a:	30 22       	mov	r2,2
8000e12c:	fe f5 08 80 	ld.w	r5,pc[2176]
8000e130:	fe f1 08 54 	ld.w	r1,pc[2132]
8000e134:	fe 9f fd 67 	bral	8000dc02 <PmsService+0x34a>
        {
            cbRx_fptr(handle);
        }
        else
        {
            MbmFree(handle);    /* No RX handler, discard */
8000e138:	0a 9c       	mov	r12,r5
8000e13a:	fe b0 f7 0f 	rcall	8000cf58 <MbmFree>
8000e13e:	fe 9f fd 42 	bral	8000dbc2 <PmsService+0x30a>
                }
            }
            else
            {
                /* LLD returned false, rollback settings for TX */
                iface_ptr->active   = NULL;      /* Unhook this from being the active one */
8000e142:	85 1c       	st.w	r2[0x4],r12

                MbmEnqueueFirst(q_ptr, handle);
8000e144:	02 9b       	mov	r11,r1
8000e146:	0a 9c       	mov	r12,r5
8000e148:	fe b0 e0 10 	rcall	8000a168 <MbmEnqueueFirst>
8000e14c:	fe 9f fc 4c 	bral	8000d9e4 <PmsService+0x12c>
        #if (defined ADS_MIN) && (!defined PMS_DISABLE_ADS_LEN_CHECKS)
        else if( &mdpFifo == fifo_ptr )
        {
            TDataRx *msg_ptr = MBM_GET_DATA_RX_PTR(handle);

            if (PMS_INVALID_PM_LENGTH == msg_ptr->Length)
8000e150:	ef 09 00 18 	ld.sh	r9,r7[24]
8000e154:	3f f8       	mov	r8,-1
8000e156:	f0 09 19 00 	cp.h	r9,r8
8000e15a:	fe 91 fe 06 	brne	8000dd66 <PmsService+0x4ae>
            {
                MbmFree(handle);                            /* discard the message if length checks */
8000e15e:	0e 9c       	mov	r12,r7
8000e160:	fe b0 f6 fc 	rcall	8000cf58 <MbmFree>
                handle = NULL;                              /* in PmsDecompressHeader() failed */
                FAILED_ASSERT();
8000e164:	30 1a       	mov	r10,1
8000e166:	e0 68 0b 96 	mov	r8,2966
8000e16a:	c2 b8       	rjmp	8000e1c0 <PmsService+0x908>
            #ifndef PMS_RX_OPT3
            index   = PMS_IDX_MCM_RX_PREALLOC;
            #endif
        }
        #ifdef ADS_MIN  /* Not needed for MDP_MIN, does not use prealloc */
        else if( &mdpFifo == fifo_ptr )
8000e16c:	30 32       	mov	r2,3
8000e16e:	30 05       	mov	r5,0
8000e170:	fe 9f fd 49 	bral	8000dc02 <PmsService+0x34a>
            pmsMaxCmsPayload = PMS_MAX_CMS_PAYLOAD_MOST150;
            pmsSupportsTelId4 = MNS_TRUE;
        }
        else
        {
            pmsMaxCmsPayload = PMS_MAX_CMS_PAYLOAD_MOST50;
8000e174:	fe f8 08 28 	ld.w	r8,pc[2088]
8000e178:	30 c9       	mov	r9,12
8000e17a:	b0 09       	st.h	r8[0x0],r9
            pmsSupportsTelId4 = MNS_FALSE;
8000e17c:	fe f8 08 24 	ld.w	r8,pc[2084]
8000e180:	b0 87       	st.b	r8[0x0],r7
8000e182:	fe 9f fc fa 	bral	8000db76 <PmsService+0x2be>
                 * Do not send a segment if there will be no shadow available
                 * or start a new segmented message if there is one ongoing.
                 */
                if( (word)0 == PMS_CHECK_SHADOW() )
                {
                    MbmEnqueueFirst(q_ptr, handle);
8000e186:	18 9b       	mov	r11,r12
8000e188:	0a 9c       	mov	r12,r5
8000e18a:	fe b0 df ef 	rcall	8000a168 <MbmEnqueueFirst>
                    handle = NULL;
                    pms.needShadow = 1;
8000e18e:	fe fc 07 da 	ld.w	r12,pc[2010]
8000e192:	30 19       	mov	r9,1
8000e194:	78 08       	ld.w	r8,r12[0x0]
8000e196:	f1 d9 d3 a1 	bfins	r8,r9,0x1d,0x1
8000e19a:	99 08       	st.w	r12[0x0],r8
8000e19c:	fe 9f fc 24 	bral	8000d9e4 <PmsService+0x12c>
    terminated  = MNS_FALSE;
    telId       = hNew->tel_id;

    if (telId <= PMS_TELID_3)
    {
        if(telId && (new_ptr->Length < (word)2))
8000e1a0:	58 09       	cp.w	r9,0
8000e1a2:	c0 60       	breq	8000e1ae <PmsService+0x8f6>
8000e1a4:	30 1a       	mov	r10,1
8000e1a6:	f4 08 19 00 	cp.h	r8,r10
8000e1aa:	e0 88 02 bd 	brls	8000e724 <PmsService+0xe6c>
        if ((word)2 <= new_ptr->Length)                 /* MsgSize - 2 or more bytes */
        {
            word prealloc_size;
            DECODE_WORD(&prealloc_size, new_ptr->Data);

            if (prealloc_size <= pmsMaxCmsPayload)
8000e1ae:	30 08       	mov	r8,0
8000e1b0:	50 48       	stdsp	sp[0x10],r8
8000e1b2:	cd ea       	rjmp	8000df6e <PmsService+0x6b6>
            TMsgRx *msg_ptr = MBM_GET_CTRL_RX_PTR(handle);
            ASSERT(NULL != msg_ptr);

            if (PMS_INVALID_PM_LENGTH == msg_ptr->Length)
            {
                MbmFree(handle);                            /* discard the message if length checks */
8000e1b4:	0e 9c       	mov	r12,r7
8000e1b6:	fe b0 f6 d1 	rcall	8000cf58 <MbmFree>
                handle = NULL;                              /* in PmsDecompressHeader() failed */
                FAILED_ASSERT();
8000e1ba:	30 1a       	mov	r10,1
8000e1bc:	e0 68 0b 77 	mov	r8,2935

            if (PMS_INVALID_PM_LENGTH == msg_ptr->Length)
            {
                MbmFree(handle);                            /* discard the message if length checks */
                handle = NULL;                              /* in PmsDecompressHeader() failed */
                FAILED_ASSERT();
8000e1c0:	1a d8       	st.w	--sp,r8
8000e1c2:	31 0b       	mov	r11,16
8000e1c4:	14 9c       	mov	r12,r10
8000e1c6:	fe b0 cc 93 	rcall	80007aec <mns_trace>
8000e1ca:	2f fd       	sub	sp,-4
8000e1cc:	fe 9f fc fb 	bral	8000dbc2 <PmsService+0x30a>

        if( NULL != handle )
        {
            if( &mcmFifo == fifo_ptr )
            {
                MisFilterMostMsg(handle);
8000e1d0:	0a 9c       	mov	r12,r5
8000e1d2:	fe b0 e2 95 	rcall	8000a6fc <MisFilterMostMsg>
    {
        PmsRxHandler cbRx_fptr;

        if( &mcmFifo == fifo_ptr )
        {
            cbRx_fptr = pmsInitData_ptr->cbMcmRx_fptr;
8000e1d6:	60 08       	ld.w	r8,r0[0x0]
8000e1d8:	70 28       	ld.w	r8,r8[0x8]
8000e1da:	fe 9f fd d5 	bral	8000dd84 <PmsService+0x4cc>
8000e1de:	40 36       	lddsp	r6,sp[0xc]
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active
                          || ((&i2c == mdpFifo.iface_ptr) && (mdpFifo.iface_ptr->active))) ? MNS_TRUE : MNS_FALSE;
    #else
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active) ? MNS_TRUE : MNS_FALSE;
    #endif
    REL_MX(MX_PMS_CS);
8000e1e0:	30 0c       	mov	r12,0
8000e1e2:	50 3c       	stdsp	sp[0xc],r12
8000e1e4:	18 95       	mov	r5,r12
            }
        }
        /* else case is new start before end */
    }

    if((MNS_FALSE == skip_alloc) && ((telId <= PMS_TELID_1) || (PMS_TELID_4 == telId)) )   /* Not segmented or initial */
8000e1e6:	30 48       	mov	r8,4
8000e1e8:	f0 09 18 00 	cp.b	r9,r8
8000e1ec:	5f 08       	sreq	r8
8000e1ee:	50 58       	stdsp	sp[0x14],r8
8000e1f0:	30 1a       	mov	r10,1
8000e1f2:	f2 0a 18 00 	cp.b	r10,r9
8000e1f6:	f9 ba 03 00 	movlo	r10,0
8000e1fa:	f1 ea 10 0a 	or	r10,r8,r10
8000e1fe:	30 08       	mov	r8,0
8000e200:	f0 0a 18 00 	cp.b	r10,r8
8000e204:	e0 81 01 7b 	brne	8000e4fa <PmsService+0xc42>
                hNew = NULL;
            }
        }
        /* Else keep hNew and return it */
    }
    else if( PMS_TELID_UNKNOWN == telId )
8000e208:	3f f8       	mov	r8,-1
8000e20a:	f0 09 18 00 	cp.b	r9,r8
8000e20e:	e0 80 01 fb 	breq	8000e604 <PmsService+0xd4c>
8000e212:	58 05       	cp.w	r5,0
8000e214:	5f 18       	srne	r8
        #ifndef MSG_RX_AUTOMATIC_ERR_MSG
        MbmFree(hNew);
        #endif
        hNew = NULL;        /* ignore unknown telegram -> return NULL (not completed) */
    }
    else if (hOld && old_ptr && (old_ptr->Length || (PMS_TELID_1 == telId) || (MNS_FALSE != terminated))) /* 0x2 <= telId <= 0x3 */
8000e216:	40 3b       	lddsp	r11,sp[0xc]
8000e218:	30 0a       	mov	r10,0
8000e21a:	58 0b       	cp.w	r11,0
8000e21c:	5f 1b       	srne	r11
8000e21e:	f1 eb 00 0b 	and	r11,r8,r11
8000e222:	f4 0b 18 00 	cp.b	r11,r10
8000e226:	e0 80 01 38 	breq	8000e496 <PmsService+0xbde>
8000e22a:	40 38       	lddsp	r8,sp[0xc]
8000e22c:	30 0b       	mov	r11,0
8000e22e:	90 2c       	ld.sh	r12,r8[0x4]
8000e230:	30 18       	mov	r8,1
8000e232:	f6 0c 19 00 	cp.h	r12,r11
8000e236:	5f 1b       	srne	r11
8000e238:	f0 09 18 00 	cp.b	r9,r8
8000e23c:	5f 08       	sreq	r8
8000e23e:	16 48       	or	r8,r11
8000e240:	f4 08 18 00 	cp.b	r8,r10
8000e244:	e0 81 01 e5 	brne	8000e60e <PmsService+0xd56>
8000e248:	40 4e       	lddsp	lr,sp[0x10]
8000e24a:	58 0e       	cp.w	lr,0
8000e24c:	e0 80 01 27 	breq	8000e49a <PmsService+0xbe2>
            #else
            MbmFree(hNew);
            /* No error to INIC on termination message */
            error = MSG_ERR_3 | ((MNS_FALSE != terminated) ? 0 : STATUS_TO_INIC);
            #endif
            PmsRxSegError(hOld, error);
8000e250:	0a 9c       	mov	r12,r5
8000e252:	32 3b       	mov	r11,35
8000e254:	fe b0 f9 4e 	rcall	8000d4f0 <PmsRxSegError>
8000e258:	32 3b       	mov	r11,35
8000e25a:	0e 95       	mov	r5,r7
8000e25c:	50 4b       	stdsp	sp[0x10],r11
    /*!
     * The rxSegQ does not need to be locked, it is only accessed from the
     * service thread.
     */
    hCur = (MNS_FALSE != forward) ? rxSegQ.next_ptr : rxSegQ.prev_ptr;
    while( ((HMBMBUF)&rxSegQ != hCur)
8000e25e:	0a 98       	mov	r8,r5
8000e260:	30 05       	mov	r5,0
            hNew = NULL;
        }
    }

    #ifdef MSG_RX_AUTOMATIC_ERR_MSG
    if( error && !(new_ptr->Rcv_Type & MSG_RCV_TYPE_BROADCAST) ) /* Not if broad/groupcast */
8000e262:	40 49       	lddsp	r9,sp[0x10]
8000e264:	58 09       	cp.w	r9,0
8000e266:	e0 81 01 15 	brne	8000e490 <PmsService+0xbd8>
            tx_ptr->Data[1]   = error & (byte)0xF;  /* Error ID           */

            tx_ptr->LowLevelRetries = PMS_SEG_ERROR_LLR;
            tx_ptr->MidLevelRetries = PMS_SEG_ERROR_MLR;

            PmsSend(hErr, NULL);
8000e26a:	50 38       	stdsp	sp[0xc],r8
            MbmFree(hErr);
            FAILED_ASSERT();                    /* Information: Discarding the segmentation */
                                                /* error message due to the lack of handles */
        }
    }
    else if( (hErr) && ((NULL == hNew) || (hErr != hNew)) )
8000e26c:	40 39       	lddsp	r9,sp[0xc]
8000e26e:	58 09       	cp.w	r9,0
8000e270:	fe 90 ff 04 	breq	8000e078 <PmsService+0x7c0>
8000e274:	0a 39       	cp.w	r9,r5
8000e276:	5f 19       	srne	r9
8000e278:	58 05       	cp.w	r5,0
8000e27a:	5f 08       	sreq	r8
8000e27c:	f3 e8 10 08 	or	r8,r9,r8
8000e280:	fe 90 fe fc 	breq	8000e078 <PmsService+0x7c0>
    {
        /*
         * Discard unused hErr if it is does not match the original buffer
         * that is returned (i.e. a non-segmented message).
         */
        MbmFree(hErr);
8000e284:	40 3c       	lddsp	r12,sp[0xc]
8000e286:	fe b0 f6 69 	rcall	8000cf58 <MbmFree>
8000e28a:	cf 7a       	rjmp	8000e078 <PmsService+0x7c0>
    bool retval;

    T_MOD_ENTRY(PMS_33);

    ASSERT(l_ptr);
    ASSERT(r_ptr);
8000e28c:	e0 6b 0f 10 	mov	r11,3856
8000e290:	30 1a       	mov	r10,1
8000e292:	1a db       	st.w	--sp,r11
8000e294:	14 9c       	mov	r12,r10
8000e296:	50 29       	stdsp	sp[0x8],r9
8000e298:	31 0b       	mov	r11,16
8000e29a:	fe b0 cc 29 	rcall	80007aec <mns_trace>
8000e29e:	2f fd       	sub	sp,-4
8000e2a0:	40 19       	lddsp	r9,sp[0x4]
8000e2a2:	fe 9f fe 78 	bral	8000df92 <PmsService+0x6da>
    {
        WAIT4MX(MX_PMS_CS);
        if (NULL == pms.rxPreAllocPtrTab[PMS_IDX_MCM_RX_PREALLOC])
        {
            discard_message = MNS_TRUE;
            pms.rxPreAllocHasTimedOut = 1;
8000e2a6:	70 0a       	ld.w	r10,r8[0x0]
            pms.rxPreAllocFailedTimerStarted = 0;
8000e2a8:	b9 ba       	sbr	r10,0x19
8000e2aa:	f5 d9 d3 01 	bfins	r10,r9,0x18,0x1
        }
        REL_MX(MX_PMS_CS);
8000e2ae:	30 2c       	mov	r12,2
        WAIT4MX(MX_PMS_CS);
        if (NULL == pms.rxPreAllocPtrTab[PMS_IDX_MCM_RX_PREALLOC])
        {
            discard_message = MNS_TRUE;
            pms.rxPreAllocHasTimedOut = 1;
            pms.rxPreAllocFailedTimerStarted = 0;
8000e2b0:	91 0a       	st.w	r8[0x0],r10
        }
        REL_MX(MX_PMS_CS);
8000e2b2:	fe b0 cc 03 	rcall	80007ab8 <mns_give>
    #ifdef PMS_RX_NOSEG
      #error This function is not needed, PMS_52 should not be defined
    #endif

    q_ptr = &rxSegQ;
    handle = MbmDequeueLast(q_ptr);
8000e2b6:	fe fc 06 da 	ld.w	r12,pc[1754]
8000e2ba:	fe b0 de e3 	rcall	8000a080 <MbmDequeueLast>
8000e2be:	18 97       	mov	r7,r12
  #endif

    if (handle)
8000e2c0:	c0 a0       	breq	8000e2d4 <PmsService+0xa1c>
    {
        result = PmsDiscardRx(handle);
8000e2c2:	fe b0 f8 d1 	rcall	8000d464 <PmsDiscardRx>

        if( MNS_FALSE == result )
8000e2c6:	fe 91 fc 52 	brne	8000db6a <PmsService+0x2b2>
        {
            MbmEnqueue(q_ptr, handle);
8000e2ca:	0e 9b       	mov	r11,r7
8000e2cc:	fe fc 06 c4 	ld.w	r12,pc[1732]
8000e2d0:	fe b0 df f6 	rcall	8000a2bc <MbmEnqueue>
        if (MNS_FALSE != discard_message)
        {
            #ifdef AMS_42
            if( MNS_FALSE == PmsDiscardPendingRx() )
            {
                (void)MsgDiscardRx();
8000e2d4:	fe b0 d5 ae 	rcall	80008e30 <MsgDiscardRx>
8000e2d8:	fe 9f fc 49 	bral	8000db6a <PmsService+0x2b2>
    /*
     * Do not process status while any interface is busy to prevent processing one that
     * handed over by the LLD before the matching TX message has been released.
     */
    #ifdef ADS_MIN
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active
8000e2dc:	fe f8 06 90 	ld.w	r8,pc[1680]
8000e2e0:	70 98       	ld.w	r8,r8[0x24]
8000e2e2:	70 18       	ld.w	r8,r8[0x4]
8000e2e4:	58 08       	cp.w	r8,0
8000e2e6:	fe 91 fd f0 	brne	8000dec6 <PmsService+0x60e>
8000e2ea:	fe f8 06 9a 	ld.w	r8,pc[1690]
                          || ((&i2c == mdpFifo.iface_ptr) && (mdpFifo.iface_ptr->active))) ? MNS_TRUE : MNS_FALSE;
8000e2ee:	fe f9 06 c2 	ld.w	r9,pc[1730]
8000e2f2:	70 98       	ld.w	r8,r8[0x24]
8000e2f4:	12 38       	cp.w	r8,r9
8000e2f6:	e0 80 02 df 	breq	8000e8b4 <PmsService+0xffc>
    #else
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active) ? MNS_TRUE : MNS_FALSE;
    #endif
    REL_MX(MX_PMS_CS);
8000e2fa:	30 2c       	mov	r12,2

                /*!
                 * Translate FIFONO into mask, so we can propagate to all affected
                 * FIFOs (Only SyncS can actually be propagated to multiple).
                 */
                fifomask = fifoNoToMaskTab[(*src_ptr >> FPH_B_FIFONO_LSB) & (byte)0x03];
8000e2fc:	fe f1 06 b8 	ld.w	r1,pc[1720]
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active
                          || ((&i2c == mdpFifo.iface_ptr) && (mdpFifo.iface_ptr->active))) ? MNS_TRUE : MNS_FALSE;
    #else
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active) ? MNS_TRUE : MNS_FALSE;
    #endif
    REL_MX(MX_PMS_CS);
8000e300:	fe b0 cb dc 	rcall	80007ab8 <mns_give>
                    if( PMS_M_FIFO_ICM & fifomask )
                    {
                        PmsFifoProcessStatus(&icmFifo, *src_ptr, &handle);
                    }

                    if( (PMS_M_FIFO_MCM & fifomask) && handle )
8000e304:	30 05       	mov	r5,0
         * timeouts.
         */
        bool finished = MNS_FALSE;
        do
        {
            HMBMBUF handle = MbmDequeue(&rxStatusQ);
8000e306:	fe fc 06 b2 	ld.w	r12,pc[1714]
8000e30a:	fe b0 de f7 	rcall	8000a0f8 <MbmDequeue>
8000e30e:	50 7c       	stdsp	sp[0x1c],r12
            if( NULL != handle )
8000e310:	fe 90 fb 5b 	breq	8000d9c6 <PmsService+0x10e>
                 * Translate FIFONO into mask, so we can propagate to all affected
                 * FIFOs (Only SyncS can actually be propagated to multiple).
                 */
                fifomask = fifoNoToMaskTab[(*src_ptr >> FPH_B_FIFONO_LSB) & (byte)0x03];

                MBM_SET_TYPE(handle, MBM_TYPE_STATUS_RX);
8000e314:	98 68       	ld.sh	r8,r12[0xc]
8000e316:	e0 18 ff f0 	andl	r8,0xfff0
        do
        {
            HMBMBUF handle = MbmDequeue(&rxStatusQ);
            if( NULL != handle )
            {
                src_ptr = &MBM_GET_HDR_PTR(handle)[2];  /* => PMHL */
8000e31a:	78 a6       	ld.w	r6,r12[0x28]
                pmhl = *src_ptr++;                      /* => FPH  */
8000e31c:	ec c9 ff fd 	sub	r9,r6,-3
8000e320:	0d a2       	ld.ub	r2,r6[0x2]

                /*!
                 * Translate FIFONO into mask, so we can propagate to all affected
                 * FIFOs (Only SyncS can actually be propagated to multiple).
                 */
                fifomask = fifoNoToMaskTab[(*src_ptr >> FPH_B_FIFONO_LSB) & (byte)0x03];
8000e322:	13 8b       	ld.ub	r11,r9[0x0]

                MBM_SET_TYPE(handle, MBM_TYPE_STATUS_RX);
8000e324:	b8 68       	st.h	r12[0xc],r8
8000e326:	40 7a       	lddsp	r10,sp[0x1c]
8000e328:	94 68       	ld.sh	r8,r10[0xc]
8000e32a:	a1 b8       	sbr	r8,0x1
8000e32c:	b4 68       	st.h	r10[0xc],r8

                /*
                 * Decode any handle and set to Status
                 */
                if( *src_ptr & FPH_M_SCF0_ENABLED )
8000e32e:	13 88       	ld.ub	r8,r9[0x0]

                /*!
                 * Translate FIFONO into mask, so we can propagate to all affected
                 * FIFOs (Only SyncS can actually be propagated to multiple).
                 */
                fifomask = fifoNoToMaskTab[(*src_ptr >> FPH_B_FIFONO_LSB) & (byte)0x03];
8000e330:	f5 db c0 62 	bfextu	r10,r11,0x3,0x2
                if( *src_ptr & FPH_M_SCF0_ENABLED )
                {
                    #ifdef PMS_USE_HANDLE
                    handle->handle = src_ptr[2];
                    #endif
                    src_ptr += 3;
8000e334:	ed b8 00 00 	bld	r8,0x0
8000e338:	f7 b6 00 fa 	subeq	r6,-6
                }
                else
                {
                    src_ptr++;
8000e33c:	f7 b6 01 fc 	subne	r6,-4

                /*!
                 * Translate FIFONO into mask, so we can propagate to all affected
                 * FIFOs (Only SyncS can actually be propagated to multiple).
                 */
                fifomask = fifoNoToMaskTab[(*src_ptr >> FPH_B_FIFONO_LSB) & (byte)0x03];
8000e340:	e2 0a 07 07 	ld.ub	r7,r1[r10]

                /*
                 * Ignore unexpected SyncS.Cmd, i.e. in state SYNCED
                 * => (Process if not SyncS.Cmd or not in state SYNCED)
                 */
                if( ((PMS_M_STAT_SYNCS | PMS_SYNCS_SYNC_CMD) != (*src_ptr & (PMS_M_STAT_SYNCS | PMS_M_SYNCS)))
8000e344:	0d 8b       	ld.ub	r11,r6[0x0]
8000e346:	16 98       	mov	r8,r11
8000e348:	16 99       	mov	r9,r11
8000e34a:	e2 18 00 bc 	andl	r8,0xbc,COH
8000e34e:	e0 48 00 90 	cp.w	r8,144
8000e352:	c1 d0       	breq	8000e38c <PmsService+0xad4>
                    || (PMS_S_SYNCED != pmsSyncState) )
                {
                    if( PMS_M_FIFO_ICM & fifomask )
8000e354:	ed b7 00 06 	bld	r7,0x6
8000e358:	c2 10       	breq	8000e39a <PmsService+0xae2>
                    {
                        PmsFifoProcessStatus(&icmFifo, *src_ptr, &handle);
                    }

                    if( (PMS_M_FIFO_MCM & fifomask) && handle )
8000e35a:	ea 07 18 00 	cp.b	r7,r5
8000e35e:	c2 95       	brlt	8000e3b0 <PmsService+0xaf8>
                    {
                        PmsFifoProcessStatus(&mcmFifo, *src_ptr, &handle);

                        /* If a SyncS is received every enqueued message shall be removed */
                        if ( PMS_M_STAT_SYNCS & *src_ptr )
8000e360:	40 7c       	lddsp	r12,sp[0x1c]
                            #endif
                        }
                    }

                    #ifdef ADS_MIN /* Not needed with MDP_MIN only, no TX */
                    if( (PMS_M_FIFO_MDP & fifomask) && handle )
8000e362:	ed b7 00 05 	bld	r7,0x5
8000e366:	c0 b1       	brne	8000e37c <PmsService+0xac4>
8000e368:	58 0c       	cp.w	r12,0
8000e36a:	c7 30       	breq	8000e450 <PmsService+0xb98>
                    {
                        PmsFifoProcessStatus(&mdpFifo, *src_ptr, &handle);
8000e36c:	fe fc 06 18 	ld.w	r12,pc[1560]
8000e370:	fa ca ff e4 	sub	r10,sp,-28
8000e374:	fe b0 f8 d6 	rcall	8000d520 <PmsFifoProcessStatus>
8000e378:	0d 89       	ld.ub	r9,r6[0x0]
8000e37a:	40 7c       	lddsp	r12,sp[0x1c]
                    }
                    #endif

                    if( (PMS_M_STAT_SYNCS & *src_ptr) && handle )
8000e37c:	ea 09 18 00 	cp.b	r9,r5
8000e380:	c5 25       	brlt	8000e424 <PmsService+0xb6c>
                                - (byte)((src_ptr - MBM_GET_HDR_PTR(handle)));
                        PmsSyncIn(src_ptr, pmhl);
                    }
                }

                if( handle )
8000e382:	58 0c       	cp.w	r12,0
8000e384:	cc 10       	breq	8000e306 <PmsService+0xa4e>
                {
                    MbmFree(handle); /* Free if not reused */
8000e386:	fe b0 f5 e9 	rcall	8000cf58 <MbmFree>
8000e38a:	cb eb       	rjmp	8000e306 <PmsService+0xa4e>

                /*
                 * Ignore unexpected SyncS.Cmd, i.e. in state SYNCED
                 * => (Process if not SyncS.Cmd or not in state SYNCED)
                 */
                if( ((PMS_M_STAT_SYNCS | PMS_SYNCS_SYNC_CMD) != (*src_ptr & (PMS_M_STAT_SYNCS | PMS_M_SYNCS)))
8000e38c:	fe f8 06 18 	ld.w	r8,pc[1560]
8000e390:	70 08       	ld.w	r8,r8[0x0]
8000e392:	58 28       	cp.w	r8,2
8000e394:	ce 01       	brne	8000e354 <PmsService+0xa9c>
        externEvent = PMS_E_SYNC_RESET;             /* Treat all other and also unexpected as a Reset */
    }

    PmsSyncHandler(PMS_P_SYNCS_CMD);

    PMS_EXTERNAL_EVENT(externEvent);
8000e396:	40 7c       	lddsp	r12,sp[0x1c]
8000e398:	cf 5b       	rjmp	8000e382 <PmsService+0xaca>
                if( ((PMS_M_STAT_SYNCS | PMS_SYNCS_SYNC_CMD) != (*src_ptr & (PMS_M_STAT_SYNCS | PMS_M_SYNCS)))
                    || (PMS_S_SYNCED != pmsSyncState) )
                {
                    if( PMS_M_FIFO_ICM & fifomask )
                    {
                        PmsFifoProcessStatus(&icmFifo, *src_ptr, &handle);
8000e39a:	fa ca ff e4 	sub	r10,sp,-28
8000e39e:	fe fc 05 ce 	ld.w	r12,pc[1486]
8000e3a2:	fe b0 f8 bf 	rcall	8000d520 <PmsFifoProcessStatus>
8000e3a6:	0d 8b       	ld.ub	r11,r6[0x0]
8000e3a8:	16 99       	mov	r9,r11
                    }

                    if( (PMS_M_FIFO_MCM & fifomask) && handle )
8000e3aa:	ea 07 18 00 	cp.b	r7,r5
8000e3ae:	cd 94       	brge	8000e360 <PmsService+0xaa8>
8000e3b0:	40 7c       	lddsp	r12,sp[0x1c]
8000e3b2:	58 0c       	cp.w	r12,0
8000e3b4:	c5 50       	breq	8000e45e <PmsService+0xba6>
                    {
                        PmsFifoProcessStatus(&mcmFifo, *src_ptr, &handle);
8000e3b6:	fe f8 05 ca 	ld.w	r8,pc[1482]
8000e3ba:	fa c0 ff e4 	sub	r0,sp,-28
8000e3be:	10 9c       	mov	r12,r8
8000e3c0:	50 08       	stdsp	sp[0x0],r8
8000e3c2:	00 9a       	mov	r10,r0
8000e3c4:	fe b0 f8 ae 	rcall	8000d520 <PmsFifoProcessStatus>

                        /* If a SyncS is received every enqueued message shall be removed */
                        if ( PMS_M_STAT_SYNCS & *src_ptr )
8000e3c8:	0d 89       	ld.ub	r9,r6[0x0]
8000e3ca:	40 08       	lddsp	r8,sp[0x0]
8000e3cc:	12 9b       	mov	r11,r9
8000e3ce:	ea 09 18 00 	cp.b	r9,r5
8000e3d2:	cc 74       	brge	8000e360 <PmsService+0xaa8>
                        {
                            while ( MbmQueueLength(&mcmFifo.pendingQ) )
8000e3d4:	f1 08 00 22 	ld.sh	r8,r8[34]
8000e3d8:	30 0c       	mov	r12,0
8000e3da:	f8 08 19 00 	cp.h	r8,r12
8000e3de:	c0 f0       	breq	8000e3fc <PmsService+0xb44>
8000e3e0:	12 9b       	mov	r11,r9
8000e3e2:	c0 28       	rjmp	8000e3e6 <PmsService+0xb2e>
8000e3e4:	0d 8b       	ld.ub	r11,r6[0x0]
                            {
                                PmsFifoProcessStatus(&mcmFifo, *src_ptr, &handle);
8000e3e6:	00 9a       	mov	r10,r0
8000e3e8:	fe fc 05 98 	ld.w	r12,pc[1432]
8000e3ec:	fe b0 f8 9a 	rcall	8000d520 <PmsFifoProcessStatus>
                        PmsFifoProcessStatus(&mcmFifo, *src_ptr, &handle);

                        /* If a SyncS is received every enqueued message shall be removed */
                        if ( PMS_M_STAT_SYNCS & *src_ptr )
                        {
                            while ( MbmQueueLength(&mcmFifo.pendingQ) )
8000e3f0:	e7 08 00 22 	ld.sh	r8,r3[34]
8000e3f4:	30 0b       	mov	r11,0
8000e3f6:	f6 08 19 00 	cp.h	r8,r11
8000e3fa:	cf 51       	brne	8000e3e4 <PmsService+0xb2c>
    PmsTxStatusHandler cbTxStatus_fptr;
    byte cb_res;

    T_MOD_ENTRY(PMS_61);

    WAIT4MX(MX_PMS_Q);
8000e3fc:	30 3c       	mov	r12,3
8000e3fe:	fe b0 cb 5c 	rcall	80007ab6 <mns_take>
    hCur = mcmFifo.msgQ.next_ptr;
8000e402:	66 00       	ld.w	r0,r3[0x0]
    {
        hCur = hCur->next_ptr;                               /* skip all bypassed messages */
    }
    #endif

    if( ((HMBMBUF)&mcmFifo.msgQ != hCur) && (MBM_STAT_TX_SEG & hCur->type)
8000e404:	06 30       	cp.w	r0,r3
8000e406:	c0 80       	breq	8000e416 <PmsService+0xb5e>
8000e408:	80 e8       	ld.uh	r8,r0[0xc]
8000e40a:	e2 18 00 30 	andl	r8,0x30,COH
8000e40e:	e0 48 00 30 	cp.w	r8,48
8000e412:	e0 80 01 5b 	breq	8000e6c8 <PmsService+0xe10>
    }
    else
    {
        hCur = NULL;
    }
    REL_MX(MX_PMS_Q);
8000e416:	30 3c       	mov	r12,3
8000e418:	fe b0 cb 50 	rcall	80007ab8 <mns_give>
8000e41c:	0d 8b       	ld.ub	r11,r6[0x0]
8000e41e:	40 7c       	lddsp	r12,sp[0x1c]
8000e420:	16 99       	mov	r9,r11
8000e422:	ca 0b       	rjmp	8000e362 <PmsService+0xaaa>
                    {
                        PmsFifoProcessStatus(&mdpFifo, *src_ptr, &handle);
                    }
                    #endif

                    if( (PMS_M_STAT_SYNCS & *src_ptr) && handle )
8000e424:	58 0c       	cp.w	r12,0
8000e426:	fe 90 ff 70 	breq	8000e306 <PmsService+0xa4e>
                    {
                        pmhl = (pmhl + (byte)PMS_PML_LEN + (byte)PMS_PMHL_LEN)
                                - (byte)((src_ptr - MBM_GET_HDR_PTR(handle)));
8000e42a:	78 a8       	ld.w	r8,r12[0x28]
static void PmsSyncIn(const byte *status_ptr, byte size)
{
    word externEvent;
    T_MOD_ENTRY(PMS_21);

    if( PMS_SYNCS_SYNC_CMD == (byte)(PMS_M_SYNCS & (*status_ptr)) )
8000e42c:	e2 19 00 3c 	andl	r9,0x3c,COH
8000e430:	59 09       	cp.w	r9,16
8000e432:	c1 80       	breq	8000e462 <PmsService+0xbaa>
8000e434:	e0 66 02 00 	mov	r6,512
    else
    {
        externEvent = PMS_E_SYNC_RESET;             /* Treat all other and also unexpected as a Reset */
    }

    PmsSyncHandler(PMS_P_SYNCS_CMD);
8000e438:	30 4c       	mov	r12,4
8000e43a:	fe b0 f3 65 	rcall	8000cb04 <PmsSyncHandler>

    PMS_EXTERNAL_EVENT(externEvent);
8000e43e:	fe fa 05 36 	ld.w	r10,pc[1334]
8000e442:	74 08       	ld.w	r8,r10[0x0]
8000e444:	70 08       	ld.w	r8,r8[0x0]
8000e446:	58 08       	cp.w	r8,0
8000e448:	ca 70       	breq	8000e396 <PmsService+0xade>
8000e44a:	0c 9c       	mov	r12,r6
8000e44c:	5d 18       	icall	r8
8000e44e:	ca 4b       	rjmp	8000e396 <PmsService+0xade>
                            #endif
                        }
                    }

                    #ifdef ADS_MIN /* Not needed with MDP_MIN only, no TX */
                    if( (PMS_M_FIFO_MDP & fifomask) && handle )
8000e450:	16 99       	mov	r9,r11
8000e452:	c9 5b       	rjmp	8000e37c <PmsService+0xac4>
                PmsSend(hCur, hCur->cbTxStatus_fptr);/* enqueue message if retry is wanted */
            }
        }
        else
        {
            MbmFree(hCur);
8000e454:	00 9c       	mov	r12,r0
8000e456:	fe b0 f5 81 	rcall	8000cf58 <MbmFree>
8000e45a:	0d 8b       	ld.ub	r11,r6[0x0]
8000e45c:	40 7c       	lddsp	r12,sp[0x1c]
8000e45e:	16 99       	mov	r9,r11
8000e460:	c8 1b       	rjmp	8000e362 <PmsService+0xaaa>
                    }
                    #endif

                    if( (PMS_M_STAT_SYNCS & *src_ptr) && handle )
                    {
                        pmhl = (pmhl + (byte)PMS_PML_LEN + (byte)PMS_PMHL_LEN)
8000e462:	e4 08 00 08 	add	r8,r2,r8
    T_MOD_ENTRY(PMS_21);

    if( PMS_SYNCS_SYNC_CMD == (byte)(PMS_M_SYNCS & (*status_ptr)) )
    {
        #ifndef PMS_RX_OPT3
        if ((byte)1 == size)
8000e466:	e0 69 01 00 	mov	r9,256
8000e46a:	f0 ca ff fe 	sub	r10,r8,-2
8000e46e:	e0 68 08 00 	mov	r8,2048
8000e472:	f4 06 18 00 	cp.b	r6,r10
8000e476:	f2 06 17 00 	moveq	r6,r9
8000e47a:	f0 06 17 10 	movne	r6,r8
8000e47e:	cd db       	rjmp	8000e438 <PmsService+0xb80>
            MostSetTimer(&pmsGbgTimer, PMS_RX_SEG_TIMEOUT, MNS_FALSE);
        }
    }
    else
    {
        MostClearTimer(&pmsGbgTimer);
8000e480:	30 0a       	mov	r10,0
8000e482:	fe fc 05 16 	ld.w	r12,pc[1302]
8000e486:	14 9b       	mov	r11,r10
8000e488:	fe b0 e6 10 	rcall	8000b0a8 <MostSetTimer>
8000e48c:	fe 9f fe 06 	bral	8000e098 <PmsService+0x7e0>
            hNew = NULL;
        }
    }

    #ifdef MSG_RX_AUTOMATIC_ERR_MSG
    if( error && !(new_ptr->Rcv_Type & MSG_RCV_TYPE_BROADCAST) ) /* Not if broad/groupcast */
8000e490:	50 38       	stdsp	sp[0xc],r8
8000e492:	fe 9f fd be 	bral	8000e00e <PmsService+0x756>
            hNew = NULL;
        }
    }
    else /* Not initial segment and nothing pending from this source */
    {
        if(hOld)
8000e496:	58 08       	cp.w	r8,0
8000e498:	c0 50       	breq	8000e4a2 <PmsService+0xbea>
        {
            PmsRxSegError(hOld, MSG_ERR_1); /* delete and unlink hOld if it was allocated by TelId 0x4 */
8000e49a:	0a 9c       	mov	r12,r5
8000e49c:	30 1b       	mov	r11,1
8000e49e:	fe b0 f8 29 	rcall	8000d4f0 <PmsRxSegError>
        error = MSG_ERR_1 | KEEP_MESSAGE;
        #else
        /* No error if it was a termination message */
        error = MSG_ERR_1 | ((MNS_FALSE != terminated) ? (byte)0 : STATUS_TO_INIC);
        #endif
        PmsRxSegError(hNew, error);
8000e4a2:	34 1b       	mov	r11,65
8000e4a4:	0e 9c       	mov	r12,r7
8000e4a6:	fe b0 f8 25 	rcall	8000d4f0 <PmsRxSegError>
8000e4aa:	34 1a       	mov	r10,65
8000e4ac:	0e 95       	mov	r5,r7
8000e4ae:	50 4a       	stdsp	sp[0x10],r10
8000e4b0:	cd 7a       	rjmp	8000e25e <PmsService+0x9a6>
        #endif

        if( !pms.ifacesStarted )
        {
            pms.ifacesStarted = 1;
            ASSERT(pmsInitData_ptr->startIfaces_fptr);
8000e4b2:	e0 68 05 67 	mov	r8,1383
8000e4b6:	31 0b       	mov	r11,16
8000e4b8:	1a d8       	st.w	--sp,r8
8000e4ba:	14 9c       	mov	r12,r10
8000e4bc:	fe b0 cb 18 	rcall	80007aec <mns_trace>
8000e4c0:	6e 08       	ld.w	r8,r7[0x0]
8000e4c2:	2f fd       	sub	sp,-4
8000e4c4:	70 58       	ld.w	r8,r8[0x14]
8000e4c6:	fe 9f fb 92 	bral	8000dbea <PmsService+0x332>
    if ( (PMS_TELID_1 == telId) && hOld )
    {
        ASSERT(old_ptr);
        if ((word)0 == old_ptr->Length)
        {
            if (PMS_TELID4_MSGCNT_ALLOC_OK == hOld->payload_ptr[0])
8000e4ca:	6a b8       	ld.w	r8,r5[0x2c]
8000e4cc:	3f f9       	mov	r9,-1
8000e4ce:	11 88       	ld.ub	r8,r8[0x0]
8000e4d0:	f2 08 18 00 	cp.b	r8,r9
8000e4d4:	e0 80 01 3a 	breq	8000e748 <PmsService+0xe90>
                 * TelID 0x4 was previous message
                 * and the payload was allocated correctly
                 */
                skip_alloc  = MNS_TRUE;
            }
            else if (PMS_TELID4_MSGCNT_ALLOC_FAILED == hOld->payload_ptr[0])
8000e4d8:	3e e9       	mov	r9,-18
8000e4da:	f2 08 18 00 	cp.b	r8,r9
8000e4de:	fe 91 fd 80 	brne	8000dfde <PmsService+0x726>
            {
                /* was not able to allocate the payload */
                PmsRxSegError(hOld, MSG_ERR_4);                     /* unlink and free hOld */
8000e4e2:	0a 9c       	mov	r12,r5
8000e4e4:	30 4b       	mov	r11,4
8000e4e6:	fe b0 f8 05 	rcall	8000d4f0 <PmsRxSegError>
                #ifdef MSG_RX_AUTOMATIC_ERR_MSG
                error = MSG_ERR_4 | KEEP_MESSAGE;                   /* use hNew to send segmentation error 0x04 */
                #else
                error = MSG_ERR_4 | KEEP_MESSAGE | STATUS_TO_INIC;  /* message is freed in section PMS_TELID_UNKNOWN */
                #endif
                PmsRxSegError(hNew, error);
8000e4ea:	34 4b       	mov	r11,68
8000e4ec:	0e 9c       	mov	r12,r7
8000e4ee:	fe b0 f8 01 	rcall	8000d4f0 <PmsRxSegError>
8000e4f2:	34 49       	mov	r9,68
8000e4f4:	0e 95       	mov	r5,r7
8000e4f6:	50 49       	stdsp	sp[0x10],r9
8000e4f8:	cb 3a       	rjmp	8000e25e <PmsService+0x9a6>
    }

    if((MNS_FALSE == skip_alloc) && ((telId <= PMS_TELID_1) || (PMS_TELID_4 == telId)) )   /* Not segmented or initial */
    {
        #ifdef MSG_RX_AUTOMATIC_ERR_MSG
        if( (PMS_TELID_1 == telId) && ((byte)0 != new_ptr->Data[0]) )
8000e4fa:	30 18       	mov	r8,1
8000e4fc:	f0 09 18 00 	cp.b	r9,r8
8000e500:	fe 90 fd 72 	breq	8000dfe4 <PmsService+0x72c>
            PmsRxSegError(hNew, error);
            hNew = NULL; /* Will be hErr for the error message */
        }
        #endif

        if( hOld )
8000e504:	58 05       	cp.w	r5,0
8000e506:	e0 80 02 19 	breq	8000e938 <PmsService+0x1080>
        {
            ASSERT(old_ptr);
8000e50a:	40 3b       	lddsp	r11,sp[0xc]
8000e50c:	58 0b       	cp.w	r11,0
8000e50e:	e0 80 01 89 	breq	8000e820 <PmsService+0xf68>
            /* Received new start before last message was completed */
            /* Keep hOld as target for restarted message (or copying unsegmented to) */
            error = MSG_ERR_7 | KEEP_MESSAGE;
            PmsRxSegError(hOld, error);
8000e512:	50 19       	stdsp	sp[0x4],r9
8000e514:	34 7b       	mov	r11,71
8000e516:	0a 9c       	mov	r12,r5
8000e518:	fe b0 f7 ec 	rcall	8000d4f0 <PmsRxSegError>
            /* hNew will be used for the error after being appended (or copied). */

            if ( PMS_TELID_1 == telId )
8000e51c:	30 18       	mov	r8,1
8000e51e:	40 19       	lddsp	r9,sp[0x4]
8000e520:	f0 09 18 00 	cp.b	r9,r8
8000e524:	e0 80 01 29 	breq	8000e776 <PmsService+0xebe>
                 */
                old_ptr->Length = (word)0;
                old_ptr->Rcv_Type = new_ptr->Rcv_Type;
                hOld->payload_ptr = old_ptr->Data;
            }
            else if (PMS_TELID_4 == telId)
8000e528:	40 5c       	lddsp	r12,sp[0x14]
8000e52a:	58 0c       	cp.w	r12,0
8000e52c:	e0 81 01 33 	brne	8000e792 <PmsService+0xeda>
                     hOld = NULL;
                }
            }
            else /* PMS_TELID_0 */
            {
                ASSERT(PMS_TELID_0 == telId);
8000e530:	58 09       	cp.w	r9,0
8000e532:	c0 c0       	breq	8000e54a <PmsService+0xc92>
8000e534:	e0 68 0f dc 	mov	r8,4060
8000e538:	30 1a       	mov	r10,1
8000e53a:	1a d8       	st.w	--sp,r8
8000e53c:	31 0b       	mov	r11,16
8000e53e:	50 29       	stdsp	sp[0x8],r9
8000e540:	14 9c       	mov	r12,r10
8000e542:	fe b0 ca d5 	rcall	80007aec <mns_trace>
8000e546:	2f fd       	sub	sp,-4
8000e548:	40 19       	lddsp	r9,sp[0x4]

                #ifdef MSG_RX_AUTOMATIC_ERR_MSG
                if (hOld->size >= new_ptr->Length)
8000e54a:	ef 0a 00 18 	ld.sh	r10,r7[24]
8000e54e:	eb 08 00 30 	ld.sh	r8,r5[48]
8000e552:	f4 08 19 00 	cp.h	r8,r10
8000e556:	e0 82 01 32 	brhs	8000e7ba <PmsService+0xf02>
8000e55a:	58 09       	cp.w	r9,0
8000e55c:	5f 1b       	srne	r11
8000e55e:	0a 98       	mov	r8,r5
8000e560:	34 7e       	mov	lr,71
8000e562:	0e 95       	mov	r5,r7
8000e564:	50 4e       	stdsp	sp[0x10],lr
8000e566:	30 0a       	mov	r10,0
                #endif
                hOld = NULL;
            }
        }

        if( telId && hNew ) /* Initial segment and no error */
8000e568:	58 0b       	cp.w	r11,0
8000e56a:	fe 90 fe 7c 	breq	8000e262 <PmsService+0x9aa>
8000e56e:	50 38       	stdsp	sp[0xc],r8
8000e570:	0a 98       	mov	r8,r5
8000e572:	14 95       	mov	r5,r10
        {
            if( !hOld )
8000e574:	58 05       	cp.w	r5,0
8000e576:	e0 80 01 73 	breq	8000e85c <PmsService+0xfa4>
            if( hOld )
            {
                #ifndef MSG_RX_USER_PAYLOAD /* Already done with user payload */
                MbmCtrlRx *tgt_ptr = MBM_GET_CTRL_RX_PTR(hOld);
                byte *data_ptr = tgt_ptr->Data;
                *tgt_ptr = *new_ptr;
8000e57a:	6e 5e       	ld.w	lr,r7[0x14]

            if( hOld )
            {
                #ifndef MSG_RX_USER_PAYLOAD /* Already done with user payload */
                MbmCtrlRx *tgt_ptr = MBM_GET_CTRL_RX_PTR(hOld);
                byte *data_ptr = tgt_ptr->Data;
8000e57c:	6a 5c       	ld.w	r12,r5[0x14]
                *tgt_ptr = *new_ptr;
8000e57e:	ea ca ff ec 	sub	r10,r5,-20
8000e582:	ee cb ff ec 	sub	r11,r7,-20
8000e586:	95 0e       	st.w	r10[0x0],lr
8000e588:	76 1e       	ld.w	lr,r11[0x4]
8000e58a:	95 1e       	st.w	r10[0x4],lr
8000e58c:	76 2e       	ld.w	lr,r11[0x8]
8000e58e:	95 2e       	st.w	r10[0x8],lr
8000e590:	76 3b       	ld.w	r11,r11[0xc]
8000e592:	95 3b       	st.w	r10[0xc],r11
                tgt_ptr->Data   = data_ptr;
8000e594:	8b 5c       	st.w	r5[0x14],r12
                tgt_ptr->Length = (word)0;          /* Nothing so far */
8000e596:	30 0a       	mov	r10,0
8000e598:	eb 5a 00 18 	st.h	r5[24],r10
                #endif

                _MbmEnqueue(&rxSegQ, hOld);
8000e59c:	50 19       	stdsp	sp[0x4],r9
8000e59e:	50 08       	stdsp	sp[0x0],r8
8000e5a0:	0a 9b       	mov	r11,r5
8000e5a2:	fe fc 03 ee 	ld.w	r12,pc[1006]
8000e5a6:	fe b0 de 0d 	rcall	8000a1c0 <_MbmEnqueue>
8000e5aa:	40 19       	lddsp	r9,sp[0x4]
8000e5ac:	40 08       	lddsp	r8,sp[0x0]

    if( hNew && telId )                     /* Only enter if segmented */
    {
        ASSERT(hOld);   /* Should not get here without hOld */

        if ( PMS_TELID_4 == telId )
8000e5ae:	30 4a       	mov	r10,4
8000e5b0:	f4 09 18 00 	cp.b	r9,r10
8000e5b4:	e0 80 01 70 	breq	8000e894 <PmsService+0xfdc>
    T_MOD_ENTRY(PMS_34);

    seg_ptr = MBM_GET_CTRL_RX_PTR(hSegment);
    rx_ptr  = MBM_GET_CTRL_RX_PTR(hAssembled);

    size_needed = seg_ptr->Length;
8000e5b8:	f1 0a 00 18 	ld.sh	r10,r8[24]
    if( PMS_TELID_3 == hSegment->tel_id )
8000e5bc:	f1 3c 00 36 	ld.ub	r12,r8[54]
8000e5c0:	30 3b       	mov	r11,3
8000e5c2:	f6 0c 18 00 	cp.b	r12,r11
8000e5c6:	c6 f0       	breq	8000e6a4 <PmsService+0xdec>
8000e5c8:	f7 da b0 10 	bfexts	r11,r10,0x0,0x10
            return_code  = MNS_FALSE;
        }
    }
    #endif

    if( MNS_FALSE != return_code )
8000e5cc:	5c 7b       	castu.h	r11
8000e5ce:	50 5b       	stdsp	sp[0x14],r11
8000e5d0:	eb 1e 00 30 	ld.uh	lr,r5[48]
    if( PMS_TELID_3 == hSegment->tel_id )
    {
        size_needed--;  /* Does not need to store segment counter */
    }

    return_code = ((hAssembled->size - rx_ptr->Length) >= size_needed) ? MNS_TRUE : MNS_FALSE;
8000e5d4:	eb 0c 00 18 	ld.sh	r12,r5[24]
            return_code  = MNS_FALSE;
        }
    }
    #endif

    if( MNS_FALSE != return_code )
8000e5d8:	f7 dc c0 10 	bfextu	r11,r12,0x0,0x10
8000e5dc:	fc 0b 01 0b 	sub	r11,lr,r11
8000e5e0:	40 5e       	lddsp	lr,sp[0x14]
8000e5e2:	1c 3b       	cp.w	r11,lr
8000e5e4:	c2 e4       	brge	8000e640 <PmsService+0xd88>
        else
        {
            /* TODO: Add real trace output, this is a configuration problem */
            /* There was not enough space left to append */

            PmsRxSegError(hOld, MSG_ERR_8);
8000e5e6:	0a 9c       	mov	r12,r5
8000e5e8:	30 8b       	mov	r11,8
8000e5ea:	50 08       	stdsp	sp[0x0],r8
8000e5ec:	fe b0 f7 82 	rcall	8000d4f0 <PmsRxSegError>
            #ifdef MSG_RX_AUTOMATIC_ERR_MSG
            error = MSG_ERR_2 | KEEP_MESSAGE;
            #else
            error = MSG_ERR_2 | STATUS_TO_INIC;
            #endif
            PmsRxSegError(hNew, error);
8000e5f0:	40 08       	lddsp	r8,sp[0x0]
8000e5f2:	34 2b       	mov	r11,66
8000e5f4:	10 9c       	mov	r12,r8
8000e5f6:	fe b0 f7 7d 	rcall	8000d4f0 <PmsRxSegError>
8000e5fa:	34 2a       	mov	r10,66
8000e5fc:	30 05       	mov	r5,0
8000e5fe:	50 4a       	stdsp	sp[0x10],r10
8000e600:	fe 9f fd 07 	bral	8000e00e <PmsService+0x756>
    /*!
     * The rxSegQ does not need to be locked, it is only accessed from the
     * service thread.
     */
    hCur = (MNS_FALSE != forward) ? rxSegQ.next_ptr : rxSegQ.prev_ptr;
    while( ((HMBMBUF)&rxSegQ != hCur)
8000e604:	30 0e       	mov	lr,0
8000e606:	0e 95       	mov	r5,r7
8000e608:	50 4e       	stdsp	sp[0x10],lr
8000e60a:	fe 9f fe 2a 	bral	8000e25e <PmsService+0x9a6>
        /*
         * Additional segment, check first if it's an ISS termination message.
         * ISS Termination has tel_id 3 and length 0.
         * If not terminated, check that the segment counter is expected.
         */
        if( (MNS_FALSE != terminated) || (((hOld->payload_ptr[0] + (byte)1) & (byte)0xFF) != new_ptr->Data[0]) )
8000e60e:	40 4c       	lddsp	r12,sp[0x10]
8000e610:	58 0c       	cp.w	r12,0
8000e612:	fe 91 fe 1f 	brne	8000e250 <PmsService+0x998>
8000e616:	6a b8       	ld.w	r8,r5[0x2c]
8000e618:	11 8a       	ld.ub	r10,r8[0x0]
8000e61a:	6e 58       	ld.w	r8,r7[0x14]
8000e61c:	2f fa       	sub	r10,-1
8000e61e:	11 88       	ld.ub	r8,r8[0x0]
8000e620:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000e624:	10 3a       	cp.w	r10,r8
8000e626:	fe 91 fe 15 	brne	8000e250 <PmsService+0x998>
        error = MSG_ERR_1 | KEEP_MESSAGE;
        #else
        /* No error if it was a termination message */
        error = MSG_ERR_1 | ((MNS_FALSE != terminated) ? (byte)0 : STATUS_TO_INIC);
        #endif
        PmsRxSegError(hNew, error);
8000e62a:	50 37       	stdsp	sp[0xc],r7
8000e62c:	0e 98       	mov	r8,r7
8000e62e:	cc 0b       	rjmp	8000e5ae <PmsService+0xcf6>
    /* Ensure that the garbage collector runs if there are segments pending */
    if( MBM_QUEUE_LENGTH(&rxSegQ) > (word)0 )
    {
        if((word)0 == MostGetTimer(&pmsGbgTimer))
        {
            MostSetTimer(&pmsGbgTimer, PMS_RX_SEG_TIMEOUT, MNS_FALSE);
8000e630:	e0 6b 13 88 	mov	r11,5000
8000e634:	fe fc 03 64 	ld.w	r12,pc[868]
8000e638:	fe b0 e5 38 	rcall	8000b0a8 <MostSetTimer>
8000e63c:	fe 9f fd 2e 	bral	8000e098 <PmsService+0x7e0>
    if( MNS_FALSE != return_code )
    {
        byte *tgt_ptr = hAssembled->payload_ptr;
        byte *src_ptr = &seg_ptr->Data[1];  /* Skip segment counter */

        size_needed = seg_ptr->Length - (word)1;  /* Skip segment counter in copy */
8000e640:	20 1a       	sub	r10,1
        rx_ptr->Length += size_needed;
8000e642:	f4 0c 00 0c 	add	r12,r10,r12

        MNS_MEM_CPY(tgt_ptr, src_ptr, size_needed);
8000e646:	5c 7a       	castu.h	r10
8000e648:	50 6a       	stdsp	sp[0x18],r10
    #endif

    if( MNS_FALSE != return_code )
    {
        byte *tgt_ptr = hAssembled->payload_ptr;
        byte *src_ptr = &seg_ptr->Data[1];  /* Skip segment counter */
8000e64a:	70 5b       	ld.w	r11,r8[0x14]

        size_needed = seg_ptr->Length - (word)1;  /* Skip segment counter in copy */
        rx_ptr->Length += size_needed;
8000e64c:	eb 5c 00 18 	st.h	r5[24],r12

        MNS_MEM_CPY(tgt_ptr, src_ptr, size_needed);
8000e650:	2f fb       	sub	r11,-1
    }
    #endif

    if( MNS_FALSE != return_code )
    {
        byte *tgt_ptr = hAssembled->payload_ptr;
8000e652:	6a bc       	ld.w	r12,r5[0x2c]
        byte *src_ptr = &seg_ptr->Data[1];  /* Skip segment counter */

        size_needed = seg_ptr->Length - (word)1;  /* Skip segment counter in copy */
        rx_ptr->Length += size_needed;

        MNS_MEM_CPY(tgt_ptr, src_ptr, size_needed);
8000e654:	40 6a       	lddsp	r10,sp[0x18]
8000e656:	50 19       	stdsp	sp[0x4],r9
8000e658:	50 08       	stdsp	sp[0x0],r8
    }
    #endif

    if( MNS_FALSE != return_code )
    {
        byte *tgt_ptr = hAssembled->payload_ptr;
8000e65a:	50 5c       	stdsp	sp[0x14],r12
        byte *src_ptr = &seg_ptr->Data[1];  /* Skip segment counter */

        size_needed = seg_ptr->Length - (word)1;  /* Skip segment counter in copy */
        rx_ptr->Length += size_needed;

        MNS_MEM_CPY(tgt_ptr, src_ptr, size_needed);
8000e65c:	fe b0 e5 4e 	rcall	8000b0f8 <MnsMemCpy>
        tgt_ptr += size_needed;

        if( PMS_TELID_3 != hSegment->tel_id )   /* Expect further segments? */
8000e660:	40 08       	lddsp	r8,sp[0x0]
8000e662:	30 3a       	mov	r10,3
8000e664:	f1 3b 00 36 	ld.ub	r11,r8[54]
8000e668:	40 19       	lddsp	r9,sp[0x4]
8000e66a:	f4 0b 18 00 	cp.b	r11,r10
8000e66e:	c0 80       	breq	8000e67e <PmsService+0xdc6>

        size_needed = seg_ptr->Length - (word)1;  /* Skip segment counter in copy */
        rx_ptr->Length += size_needed;

        MNS_MEM_CPY(tgt_ptr, src_ptr, size_needed);
        tgt_ptr += size_needed;
8000e670:	40 5a       	lddsp	r10,sp[0x14]
8000e672:	40 6b       	lddsp	r11,sp[0x18]
8000e674:	16 0a       	add	r10,r11

        if( PMS_TELID_3 != hSegment->tel_id )   /* Expect further segments? */
        {
            hAssembled->payload_ptr = tgt_ptr;  /* Position for next segment */
8000e676:	8b ba       	st.w	r5[0x2c],r10

            /* Put segment counter behind payload to compare next counter, space
             * is left since 1 was subtracted from size_needed before copying.
             */
            *tgt_ptr = seg_ptr->Data[0];
8000e678:	70 58       	ld.w	r8,r8[0x14]
8000e67a:	11 88       	ld.ub	r8,r8[0x0]
8000e67c:	b4 88       	st.b	r10[0x0],r8
            MbmFree(hNew);
            #endif
            hNew = NULL;

            /* The new segment was appended */
            if( PMS_TELID_3 == telId )
8000e67e:	30 38       	mov	r8,3
8000e680:	f0 09 18 00 	cp.b	r9,r8
8000e684:	c0 91       	brne	8000e696 <PmsService+0xdde>
            {
                /* Message completed, unlink from segmentation list */
                _MbmUnlink(hOld);
8000e686:	40 38       	lddsp	r8,sp[0xc]
8000e688:	0a 9c       	mov	r12,r5
8000e68a:	50 08       	stdsp	sp[0x0],r8
8000e68c:	fe b0 dc c0 	rcall	8000a00c <_MbmUnlink>
8000e690:	40 08       	lddsp	r8,sp[0x0]
8000e692:	fe 9f fd e8 	bral	8000e262 <PmsService+0x9aa>

                hNew = hOld; /* Return completed message */
            }
            else
            {
                MBM_CLR_STATUS_BITS(hOld, MBM_STAT_RX_GARBAGE_BIT); /* Protect from garbage collector. */
8000e696:	8a 69       	ld.sh	r9,r5[0xc]
8000e698:	40 38       	lddsp	r8,sp[0xc]
8000e69a:	a9 d9       	cbr	r9,0x9
8000e69c:	aa 69       	st.h	r5[0xc],r9
8000e69e:	30 05       	mov	r5,0
8000e6a0:	fe 9f fd e1 	bral	8000e262 <PmsService+0x9aa>
    rx_ptr  = MBM_GET_CTRL_RX_PTR(hAssembled);

    size_needed = seg_ptr->Length;
    if( PMS_TELID_3 == hSegment->tel_id )
    {
        size_needed--;  /* Does not need to store segment counter */
8000e6a4:	f4 cb 00 01 	sub	r11,r10,1
8000e6a8:	5c 8b       	casts.h	r11
8000e6aa:	c9 1b       	rjmp	8000e5cc <PmsService+0xd14>
                     * necessary to run it on the message at the head of the queue
                     */
                    if( (word)0 == MostGetTimer(&fifo_ptr->timer) )
                    {
                        #ifndef PMS_DISABLE_MCM_EXT_TIMEOUT
                        if ( (&mcmFifo == fifo_ptr) && (PMS_CFG_MCM_MLR_THRESHOLD < handle->msg.msgTx.MidLevelRetries) )
8000e6ac:	e3 38 00 21 	ld.ub	r8,r1[33]
8000e6b0:	32 8e       	mov	lr,40
8000e6b2:	fc 08 18 00 	cp.b	r8,lr
8000e6b6:	fe 98 f9 e3 	brls	8000da7c <PmsService+0x1c4>
                        {
                            MostSetTimer(&fifo_ptr->timer, PMS_CFG_MCM_MAX_TIMEOUT, MNS_FALSE);
8000e6ba:	04 9c       	mov	r12,r2
8000e6bc:	e0 6b 0b b8 	mov	r11,3000
8000e6c0:	fe b0 e4 f4 	rcall	8000b0a8 <MostSetTimer>
8000e6c4:	fe 9f f9 90 	bral	8000d9e4 <PmsService+0x12c>
    #endif

    if( ((HMBMBUF)&mcmFifo.msgQ != hCur) && (MBM_STAT_TX_SEG & hCur->type)
        && (MBM_STAT_TX_SENT & hCur->type) )
    {
        _MbmUnlink(hCur);    /* unlink next message if it is segmented and already started */
8000e6c8:	00 9c       	mov	r12,r0
8000e6ca:	fe b0 dc a1 	rcall	8000a00c <_MbmUnlink>
    }
    else
    {
        hCur = NULL;
    }
    REL_MX(MX_PMS_Q);
8000e6ce:	30 3c       	mov	r12,3
8000e6d0:	fe b0 c9 f4 	rcall	80007ab8 <mns_give>

    if (hCur)
    {
        cbTxStatus_fptr = hCur->cbTxStatus_fptr;                     /* notify application */
8000e6d4:	60 98       	ld.w	r8,r0[0x24]

        if (cbTxStatus_fptr)
8000e6d6:	58 08       	cp.w	r8,0
8000e6d8:	fe 90 fe be 	breq	8000e454 <PmsService+0xb9c>
        {
            cb_res = cbTxStatus_fptr(hCur, XMIT_SYNC);
8000e6dc:	e0 6b 00 83 	mov	r11,131
8000e6e0:	00 9c       	mov	r12,r0
8000e6e2:	5d 18       	icall	r8
            ASSERT((PMS_RELEASE == cb_res) || (PMS_RETRY == cb_res));
8000e6e4:	30 18       	mov	r8,1
8000e6e6:	f0 0c 18 00 	cp.b	r12,r8
8000e6ea:	e0 88 00 10 	brls	8000e70a <PmsService+0xe52>
8000e6ee:	e0 68 14 13 	mov	r8,5139
8000e6f2:	30 1a       	mov	r10,1
8000e6f4:	1a d8       	st.w	--sp,r8
8000e6f6:	31 0b       	mov	r11,16
8000e6f8:	14 9c       	mov	r12,r10
8000e6fa:	fe b0 c9 f9 	rcall	80007aec <mns_trace>
8000e6fe:	0d 8b       	ld.ub	r11,r6[0x0]
8000e700:	2f fd       	sub	sp,-4
8000e702:	16 99       	mov	r9,r11
8000e704:	40 7c       	lddsp	r12,sp[0x1c]
8000e706:	fe 9f fe 2e 	bral	8000e362 <PmsService+0xaaa>

            if (PMS_RETRY == cb_res)
8000e70a:	f0 0c 18 00 	cp.b	r12,r8
8000e70e:	fe 91 fe 87 	brne	8000e41c <PmsService+0xb64>
            {
                PmsSend(hCur, hCur->cbTxStatus_fptr);/* enqueue message if retry is wanted */
8000e712:	00 9c       	mov	r12,r0
8000e714:	60 9b       	ld.w	r11,r0[0x24]
8000e716:	fe b0 f6 91 	rcall	8000d438 <PmsSend>
8000e71a:	0d 8b       	ld.ub	r11,r6[0x0]
8000e71c:	40 7c       	lddsp	r12,sp[0x1c]
8000e71e:	16 99       	mov	r9,r11
8000e720:	fe 9f fe 21 	bral	8000e362 <PmsService+0xaaa>
    terminated  = MNS_FALSE;
    telId       = hNew->tel_id;

    if (telId <= PMS_TELID_3)
    {
        if(telId && (new_ptr->Length < (word)2))
8000e724:	30 1a       	mov	r10,1
8000e726:	30 39       	mov	r9,3
8000e728:	50 4a       	stdsp	sp[0x10],r10
8000e72a:	fe 9f fc 22 	bral	8000df6e <PmsService+0x6b6>
        ASSERT(hErr);
        ASSERT(hErr != hNew);

        if (MNS_FALSE == MbmChangeType(hErr, (word)MBM_TYPE_CTRL_TX))
        {
            WAIT4MX(MX_PMS_CS);
8000e72e:	30 2c       	mov	r12,2
8000e730:	fe b0 c9 c3 	rcall	80007ab6 <mns_take>
            if (NULL == pms.rxPreAllocPtrTab[PMS_IDX_MCM_RX_PREALLOC])
8000e734:	fe f8 02 34 	ld.w	r8,pc[564]
8000e738:	70 88       	ld.w	r8,r8[0x20]
8000e73a:	58 08       	cp.w	r8,0
8000e73c:	c7 f0       	breq	8000e83a <PmsService+0xf82>
            {
                error = (byte)0;
            }
            REL_MX(MX_PMS_CS);
8000e73e:	30 2c       	mov	r12,2
8000e740:	fe b0 c9 bc 	rcall	80007ab8 <mns_give>
8000e744:	fe 9f fc 79 	bral	8000e036 <PmsService+0x77e>
    if ( (PMS_TELID_1 == telId) && hOld )
    {
        ASSERT(old_ptr);
        if ((word)0 == old_ptr->Length)
        {
            if (PMS_TELID4_MSGCNT_ALLOC_OK == hOld->payload_ptr[0])
8000e748:	30 19       	mov	r9,1
8000e74a:	12 98       	mov	r8,r9
8000e74c:	fe 9f fd 65 	bral	8000e216 <PmsService+0x95e>
            telId = PMS_TELID_3;                /* least one byte.                                                          */
        }
    }
    else if ((MNS_FALSE != pmsSupportsTelId4) && (PMS_TELID_4 == telId))
    {
        if ((word)2 <= new_ptr->Length)                 /* MsgSize - 2 or more bytes */
8000e750:	30 1a       	mov	r10,1
8000e752:	f4 08 19 00 	cp.h	r8,r10
8000e756:	fe 98 fc 08 	brls	8000df66 <PmsService+0x6ae>
        {
            word prealloc_size;
            DECODE_WORD(&prealloc_size, new_ptr->Data);
8000e75a:	6e 58       	ld.w	r8,r7[0x14]

            if (prealloc_size <= pmsMaxCmsPayload)
8000e75c:	11 9a       	ld.ub	r10,r8[0x1]
8000e75e:	11 88       	ld.ub	r8,r8[0x0]
8000e760:	f5 e8 10 88 	or	r8,r10,r8<<0x8
8000e764:	fe fa 02 38 	ld.w	r10,pc[568]
8000e768:	94 0a       	ld.sh	r10,r10[0x0]
8000e76a:	f0 0a 19 00 	cp.h	r10,r8
8000e76e:	fe 92 fb fc 	brhs	8000df66 <PmsService+0x6ae>
8000e772:	fe 9f fd 1e 	bral	8000e1ae <PmsService+0x8f6>
                /*
                 * Reset structure to restart message
                 * N.B. hNew is set to NULL (used as hErr)
                 *      after appending the payload
                 */
                old_ptr->Length = (word)0;
8000e776:	30 08       	mov	r8,0
8000e778:	40 3a       	lddsp	r10,sp[0xc]
8000e77a:	b4 28       	st.h	r10[0x4],r8
                old_ptr->Rcv_Type = new_ptr->Rcv_Type;
8000e77c:	ef 38 00 21 	ld.ub	r8,r7[33]
8000e780:	f5 68 00 0d 	st.b	r10[13],r8
                hOld->payload_ptr = old_ptr->Data;
8000e784:	74 08       	ld.w	r8,r10[0x0]
8000e786:	8b b8       	st.w	r5[0x2c],r8
8000e788:	34 7e       	mov	lr,71
8000e78a:	50 37       	stdsp	sp[0xc],r7
8000e78c:	0e 98       	mov	r8,r7
8000e78e:	50 4e       	stdsp	sp[0x10],lr
8000e790:	cf 2a       	rjmp	8000e574 <PmsService+0xcbc>
            }
            else if (PMS_TELID_4 == telId)
            {
                if ((old_ptr->Length > (word)0) || (PMS_TELID4_MSGCNT_ALLOC_OK == hOld->payload_ptr[0]))
8000e792:	40 3b       	lddsp	r11,sp[0xc]
8000e794:	30 08       	mov	r8,0
8000e796:	96 2a       	ld.sh	r10,r11[0x4]
8000e798:	f0 0a 19 00 	cp.h	r10,r8
8000e79c:	c2 61       	brne	8000e7e8 <PmsService+0xf30>
8000e79e:	6a b8       	ld.w	r8,r5[0x2c]
8000e7a0:	11 8a       	ld.ub	r10,r8[0x0]
8000e7a2:	3f f8       	mov	r8,-1
8000e7a4:	f0 0a 18 00 	cp.b	r10,r8
8000e7a8:	c2 00       	breq	8000e7e8 <PmsService+0xf30>
8000e7aa:	34 7a       	mov	r10,71
8000e7ac:	58 09       	cp.w	r9,0
8000e7ae:	5f 1b       	srne	r11
8000e7b0:	0a 98       	mov	r8,r5
8000e7b2:	50 4a       	stdsp	sp[0x10],r10
8000e7b4:	0e 95       	mov	r5,r7
8000e7b6:	30 0a       	mov	r10,0
8000e7b8:	cd 8a       	rjmp	8000e568 <PmsService+0xcb0>
                {
                    /*
                     * hOld will be passed to the application (as hNew) and hNew has
                     * become hErr for the error message (top)
                     */
                    MNS_MEM_CPY(old_ptr->Data, new_ptr->Data, new_ptr->Length);
8000e7ba:	40 38       	lddsp	r8,sp[0xc]
8000e7bc:	6e 5b       	ld.w	r11,r7[0x14]
8000e7be:	70 0c       	ld.w	r12,r8[0x0]
8000e7c0:	5c 7a       	castu.h	r10
8000e7c2:	50 19       	stdsp	sp[0x4],r9
8000e7c4:	fe b0 e4 9a 	rcall	8000b0f8 <MnsMemCpy>
                    old_ptr->Length   = new_ptr->Length;
8000e7c8:	ef 08 00 18 	ld.sh	r8,r7[24]
                    old_ptr->Rcv_Type = new_ptr->Rcv_Type;
8000e7cc:	40 19       	lddsp	r9,sp[0x4]
                    /*
                     * hOld will be passed to the application (as hNew) and hNew has
                     * become hErr for the error message (top)
                     */
                    MNS_MEM_CPY(old_ptr->Data, new_ptr->Data, new_ptr->Length);
                    old_ptr->Length   = new_ptr->Length;
8000e7ce:	40 3e       	lddsp	lr,sp[0xc]
8000e7d0:	bc 28       	st.h	lr[0x4],r8
                    old_ptr->Rcv_Type = new_ptr->Rcv_Type;
8000e7d2:	ef 3a 00 21 	ld.ub	r10,r7[33]
8000e7d6:	fd 6a 00 0d 	st.b	lr[13],r10
8000e7da:	58 09       	cp.w	r9,0
8000e7dc:	5f 1b       	srne	r11
8000e7de:	34 7c       	mov	r12,71
8000e7e0:	0e 98       	mov	r8,r7
8000e7e2:	50 4c       	stdsp	sp[0x10],r12
8000e7e4:	30 0a       	mov	r10,0
8000e7e6:	cc 1a       	rjmp	8000e568 <PmsService+0xcb0>
            {
                if ((old_ptr->Length > (word)0) || (PMS_TELID4_MSGCNT_ALLOC_OK == hOld->payload_ptr[0]))
                {
                    /* hOld was allocated correctly */
                    word prealloc_size;
                    DECODE_WORD(&prealloc_size, new_ptr->Data);
8000e7e8:	6e 58       	ld.w	r8,r7[0x14]

                    if (hOld->size >= prealloc_size)
8000e7ea:	11 9a       	ld.ub	r10,r8[0x1]
8000e7ec:	11 88       	ld.ub	r8,r8[0x0]
8000e7ee:	f5 e8 10 88 	or	r8,r10,r8<<0x8
8000e7f2:	eb 0a 00 30 	ld.sh	r10,r5[48]
8000e7f6:	f0 0a 19 00 	cp.h	r10,r8
8000e7fa:	e0 83 00 a7 	brlo	8000e948 <PmsService+0x1090>
                    {
                        /* Reset structure to restart message */
                        /* hOld can be re-used, hNew will be used to send the segmentation error message */
                        old_ptr->Length = (word)0;
8000e7fe:	30 08       	mov	r8,0
8000e800:	40 3e       	lddsp	lr,sp[0xc]
8000e802:	bc 28       	st.h	lr[0x4],r8
                        old_ptr->Rcv_Type = new_ptr->Rcv_Type;
8000e804:	ef 38 00 21 	ld.ub	r8,r7[33]
8000e808:	fd 68 00 0d 	st.b	lr[13],r8
                        hOld->payload_ptr = old_ptr->Data;
8000e80c:	7c 08       	ld.w	r8,lr[0x0]
8000e80e:	8b b8       	st.w	r5[0x2c],r8
8000e810:	58 09       	cp.w	r9,0
8000e812:	5f 1b       	srne	r11
8000e814:	0a 9a       	mov	r10,r5
8000e816:	34 7c       	mov	r12,71
8000e818:	0e 98       	mov	r8,r7
8000e81a:	0e 95       	mov	r5,r7
8000e81c:	50 4c       	stdsp	sp[0x10],r12
8000e81e:	ca 5a       	rjmp	8000e568 <PmsService+0xcb0>
        }
        #endif

        if( hOld )
        {
            ASSERT(old_ptr);
8000e820:	e0 68 0f a0 	mov	r8,4000
8000e824:	30 1a       	mov	r10,1
8000e826:	1a d8       	st.w	--sp,r8
8000e828:	31 0b       	mov	r11,16
8000e82a:	50 29       	stdsp	sp[0x8],r9
8000e82c:	14 9c       	mov	r12,r10
8000e82e:	fe b0 c9 5f 	rcall	80007aec <mns_trace>
8000e832:	2f fd       	sub	sp,-4
8000e834:	40 19       	lddsp	r9,sp[0x4]
8000e836:	fe 9f fe 6e 	bral	8000e512 <PmsService+0xc5a>
            WAIT4MX(MX_PMS_CS);
            if (NULL == pms.rxPreAllocPtrTab[PMS_IDX_MCM_RX_PREALLOC])
            {
                error = (byte)0;
            }
            REL_MX(MX_PMS_CS);
8000e83a:	30 2c       	mov	r12,2
8000e83c:	fe b0 c9 3e 	rcall	80007ab8 <mns_give>

            PmsSend(hErr, NULL);
        }
        else
        {
            MbmFree(hErr);
8000e840:	40 3c       	lddsp	r12,sp[0xc]
8000e842:	fe b0 f3 8b 	rcall	8000cf58 <MbmFree>
            FAILED_ASSERT();                    /* Information: Discarding the segmentation */
8000e846:	e0 68 10 f5 	mov	r8,4341
8000e84a:	30 1a       	mov	r10,1
8000e84c:	1a d8       	st.w	--sp,r8
8000e84e:	31 0b       	mov	r11,16
8000e850:	14 9c       	mov	r12,r10
8000e852:	fe b0 c9 4d 	rcall	80007aec <mns_trace>
8000e856:	2f fd       	sub	sp,-4
8000e858:	fe 9f fc 10 	bral	8000e078 <PmsService+0x7c0>
        {
            if( !hOld )
            {
                word prealloc_size;

                if (PMS_TELID_4 == telId)
8000e85c:	40 5b       	lddsp	r11,sp[0x14]
8000e85e:	58 0b       	cp.w	r11,0
8000e860:	c6 61       	brne	8000e92c <PmsService+0x1074>
8000e862:	e0 6c 00 f0 	mov	r12,240
                            hOld = NULL;
                        }
                    }
                }
                #else
                hOld = MbmAllocate(prealloc_size, (word)0, MBM_TYPE_CTRL_RX);
8000e866:	50 19       	stdsp	sp[0x4],r9
8000e868:	50 08       	stdsp	sp[0x0],r8
8000e86a:	30 4a       	mov	r10,4
8000e86c:	30 0b       	mov	r11,0
8000e86e:	fe b0 dc c5 	rcall	8000a1f8 <MbmAllocate>
                #endif
            }

            if( hOld )
8000e872:	40 19       	lddsp	r9,sp[0x4]
                            hOld = NULL;
                        }
                    }
                }
                #else
                hOld = MbmAllocate(prealloc_size, (word)0, MBM_TYPE_CTRL_RX);
8000e874:	18 95       	mov	r5,r12
                #endif
            }

            if( hOld )
8000e876:	40 08       	lddsp	r8,sp[0x0]
8000e878:	fe 91 fe 81 	brne	8000e57a <PmsService+0xcc2>
                tgt_ptr->Length = (word)0;          /* Nothing so far */
                #endif

                _MbmEnqueue(&rxSegQ, hOld);
            }
            else if (PMS_TELID_4 == telId)
8000e87c:	40 5a       	lddsp	r10,sp[0x14]
8000e87e:	58 0a       	cp.w	r10,0
8000e880:	c4 11       	brne	8000e902 <PmsService+0x104a>
                #ifdef MSG_RX_AUTOMATIC_ERR_MSG
                error = MSG_ERR_4 | KEEP_MESSAGE;
                #else
                error = MSG_ERR_4 | STATUS_TO_INIC;
                #endif
                PmsRxSegError(hNew, error);
8000e882:	10 9c       	mov	r12,r8
8000e884:	40 35       	lddsp	r5,sp[0xc]
8000e886:	34 4b       	mov	r11,68
8000e888:	fe b0 f6 34 	rcall	8000d4f0 <PmsRxSegError>
8000e88c:	34 4c       	mov	r12,68
8000e88e:	50 4c       	stdsp	sp[0x10],r12
8000e890:	fe 9f fc e7 	bral	8000e25e <PmsService+0x9a6>
        ASSERT(hOld);   /* Should not get here without hOld */

        if ( PMS_TELID_4 == telId )
        {
            /* insert initial MsgCnt with 0xFF */
            hOld->payload_ptr[0] = PMS_TELID4_MSGCNT_ALLOC_OK;
8000e894:	6a b9       	ld.w	r9,r5[0x2c]
8000e896:	3f fa       	mov	r10,-1
8000e898:	b2 8a       	st.b	r9[0x0],r10

            #ifdef MSG_RX_AUTOMATIC_ERR_MSG
            if (hErr != hNew)
8000e89a:	40 39       	lddsp	r9,sp[0xc]
8000e89c:	12 38       	cp.w	r8,r9
8000e89e:	fe 90 ff 00 	breq	8000e69e <PmsService+0xde6>
            {
                MbmFree(hNew);      /* free hNew since hErr is the previous hOld */
8000e8a2:	10 9c       	mov	r12,r8
8000e8a4:	40 38       	lddsp	r8,sp[0xc]
8000e8a6:	50 08       	stdsp	sp[0x0],r8
8000e8a8:	fe b0 f3 58 	rcall	8000cf58 <MbmFree>
8000e8ac:	30 05       	mov	r5,0
8000e8ae:	40 08       	lddsp	r8,sp[0x0]
8000e8b0:	fe 9f fc d9 	bral	8000e262 <PmsService+0x9aa>
     * Do not process status while any interface is busy to prevent processing one that
     * handed over by the LLD before the matching TX message has been released.
     */
    #ifdef ADS_MIN
    wait_for_tx_release = (mcmFifo.iface_ptr->active || icmFifo.iface_ptr->active
                          || ((&i2c == mdpFifo.iface_ptr) && (mdpFifo.iface_ptr->active))) ? MNS_TRUE : MNS_FALSE;
8000e8b4:	70 18       	ld.w	r8,r8[0x4]
8000e8b6:	58 08       	cp.w	r8,0
8000e8b8:	fe 91 fb 07 	brne	8000dec6 <PmsService+0x60e>
8000e8bc:	fe 9f fd 1f 	bral	8000e2fa <PmsService+0xa42>
    if( error && !(new_ptr->Rcv_Type & MSG_RCV_TYPE_BROADCAST) ) /* Not if broad/groupcast */
    {
        MbmCtrlTx *tx_ptr;

        ASSERT(hErr);
        ASSERT(hErr != hNew);
8000e8c0:	e0 68 10 d7 	mov	r8,4311
8000e8c4:	30 1a       	mov	r10,1
8000e8c6:	1a d8       	st.w	--sp,r8
8000e8c8:	31 0b       	mov	r11,16
8000e8ca:	14 9c       	mov	r12,r10
8000e8cc:	fe b0 c9 10 	rcall	80007aec <mns_trace>
8000e8d0:	2f fd       	sub	sp,-4
8000e8d2:	fe 9f fb ac 	bral	8000e02a <PmsService+0x772>
    #ifdef MSG_RX_AUTOMATIC_ERR_MSG
    if( error && !(new_ptr->Rcv_Type & MSG_RCV_TYPE_BROADCAST) ) /* Not if broad/groupcast */
    {
        MbmCtrlTx *tx_ptr;

        ASSERT(hErr);
8000e8d6:	e0 68 10 d6 	mov	r8,4310
8000e8da:	30 1a       	mov	r10,1
8000e8dc:	1a d8       	st.w	--sp,r8
8000e8de:	31 0b       	mov	r11,16
8000e8e0:	14 9c       	mov	r12,r10
8000e8e2:	fe b0 c9 05 	rcall	80007aec <mns_trace>
8000e8e6:	2f fd       	sub	sp,-4
8000e8e8:	fe 9f fb 9d 	bral	8000e022 <PmsService+0x76a>
        }

        if ((byte)0 != error)
        {
            tx_ptr = MBM_GET_CTRL_TX_PTR(hErr);
            ASSERT(tx_ptr->Length >= (word)2);      /* Should be guaranteed by MbmGetBuf() */
8000e8ec:	e0 68 10 e6 	mov	r8,4326
8000e8f0:	30 1a       	mov	r10,1
8000e8f2:	1a d8       	st.w	--sp,r8
8000e8f4:	31 0b       	mov	r11,16
8000e8f6:	14 9c       	mov	r12,r10
8000e8f8:	fe b0 c8 fa 	rcall	80007aec <mns_trace>
8000e8fc:	2f fd       	sub	sp,-4
8000e8fe:	fe 9f fb a4 	bral	8000e046 <PmsService+0x78e>
                _MbmEnqueue(&rxSegQ, hOld);
            }
            else if (PMS_TELID_4 == telId)
            {
                /* Unable to allocate target buffer */
                new_ptr->Length = (word)0;          /* mark handle as initial message */
8000e902:	ef 5c 00 18 	st.h	r7[24],r12
                hNew->payload_ptr[0] = PMS_TELID4_MSGCNT_ALLOC_FAILED;
                _MbmEnqueue(&rxSegQ, hNew);         /* store hNew */

                #ifdef MSG_RX_AUTOMATIC_ERR_MSG
                if (hErr == hNew)
8000e906:	40 35       	lddsp	r5,sp[0xc]
8000e908:	0a 99       	mov	r9,r5
8000e90a:	40 4e       	lddsp	lr,sp[0x10]
            }
            else if (PMS_TELID_4 == telId)
            {
                /* Unable to allocate target buffer */
                new_ptr->Length = (word)0;          /* mark handle as initial message */
                hNew->payload_ptr[0] = PMS_TELID4_MSGCNT_ALLOC_FAILED;
8000e90c:	3e ea       	mov	r10,-18
                _MbmEnqueue(&rxSegQ, hNew);         /* store hNew */

                #ifdef MSG_RX_AUTOMATIC_ERR_MSG
                if (hErr == hNew)
8000e90e:	12 38       	cp.w	r8,r9
8000e910:	f9 be 00 00 	moveq	lr,0
8000e914:	50 4e       	stdsp	sp[0x10],lr
            }
            else if (PMS_TELID_4 == telId)
            {
                /* Unable to allocate target buffer */
                new_ptr->Length = (word)0;          /* mark handle as initial message */
                hNew->payload_ptr[0] = PMS_TELID4_MSGCNT_ALLOC_FAILED;
8000e916:	70 b9       	ld.w	r9,r8[0x2c]
                _MbmEnqueue(&rxSegQ, hNew);         /* store hNew */

                #ifdef MSG_RX_AUTOMATIC_ERR_MSG
                if (hErr == hNew)
8000e918:	0a 38       	cp.w	r8,r5
8000e91a:	f9 b5 00 00 	moveq	r5,0
            }
            else if (PMS_TELID_4 == telId)
            {
                /* Unable to allocate target buffer */
                new_ptr->Length = (word)0;          /* mark handle as initial message */
                hNew->payload_ptr[0] = PMS_TELID4_MSGCNT_ALLOC_FAILED;
8000e91e:	b2 8a       	st.b	r9[0x0],r10
                _MbmEnqueue(&rxSegQ, hNew);         /* store hNew */
8000e920:	10 9b       	mov	r11,r8
8000e922:	49 cc       	lddpc	r12,8000e990 <PmsService+0x10d8>
8000e924:	fe b0 dc 4e 	rcall	8000a1c0 <_MbmEnqueue>
8000e928:	fe 9f fc 9b 	bral	8000e25e <PmsService+0x9a6>
            {
                word prealloc_size;

                if (PMS_TELID_4 == telId)
                {
                    DECODE_WORD(&prealloc_size, new_ptr->Data);
8000e92c:	6e 5a       	ld.w	r10,r7[0x14]
8000e92e:	15 9b       	ld.ub	r11,r10[0x1]
8000e930:	15 8a       	ld.ub	r10,r10[0x0]
8000e932:	f7 ea 10 8c 	or	r12,r11,r10<<0x8
8000e936:	c9 8b       	rjmp	8000e866 <PmsService+0xfae>
            PmsRxSegError(hNew, error);
            hNew = NULL; /* Will be hErr for the error message */
        }
        #endif

        if( hOld )
8000e938:	0a 9a       	mov	r10,r5
8000e93a:	58 09       	cp.w	r9,0
8000e93c:	5f 1b       	srne	r11
8000e93e:	0e 98       	mov	r8,r7
8000e940:	0e 95       	mov	r5,r7
8000e942:	50 4a       	stdsp	sp[0x10],r10
8000e944:	fe 9f fe 12 	bral	8000e568 <PmsService+0xcb0>
                    {
                        /* Size of hOld is not big enough for the new message           */
                        /* Free hOld, we need a new allocation                          */
                        /* The error was set above -> if the allocation is successful,  */
                        /* hNew can be used for the segmentation error 0x7              */
                        MbmFree(hOld);
8000e948:	0a 9c       	mov	r12,r5
8000e94a:	50 19       	stdsp	sp[0x4],r9
8000e94c:	fe b0 f3 06 	rcall	8000cf58 <MbmFree>
8000e950:	34 7a       	mov	r10,71
8000e952:	40 19       	lddsp	r9,sp[0x4]
8000e954:	50 4a       	stdsp	sp[0x10],r10
8000e956:	58 09       	cp.w	r9,0
8000e958:	5f 1b       	srne	r11
8000e95a:	0e 98       	mov	r8,r7
8000e95c:	0e 95       	mov	r5,r7
8000e95e:	30 0a       	mov	r10,0
8000e960:	fe 9f fe 04 	bral	8000e568 <PmsService+0xcb0>
8000e964:	00 00       	add	r0,r0
8000e966:	4a 24       	lddpc	r4,8000e9ec <PmsSetFifoInterface+0x30>
8000e968:	00 00       	add	r0,r0
8000e96a:	37 d4       	mov	r4,125
8000e96c:	00 00       	add	r0,r0
8000e96e:	39 14       	mov	r4,-111
8000e970:	80 06       	ld.sh	r6,r0[0x0]
8000e972:	ff 00 00 00 	ld.sh	r0,pc[0]
8000e976:	38 38       	mov	r8,-125
8000e978:	00 00       	add	r0,r0
8000e97a:	36 fc       	mov	r12,111
8000e97c:	00 00       	add	r0,r0
8000e97e:	38 28       	mov	r8,-126
8000e980:	00 00       	add	r0,r0
8000e982:	38 8c       	mov	r12,-120
8000e984:	00 00       	add	r0,r0
8000e986:	37 0c       	mov	r12,112
8000e988:	00 00       	add	r0,r0
8000e98a:	42 24       	lddsp	r4,sp[0x88]
8000e98c:	80 06       	ld.sh	r6,r0[0x0]
8000e98e:	fe fe 00 00 	ld.w	lr,pc[0]
8000e992:	38 1c       	mov	r12,-127
8000e994:	00 00       	add	r0,r0
8000e996:	38 48       	mov	r8,-124
8000e998:	00 00       	add	r0,r0
8000e99a:	37 9c       	mov	r12,121
8000e99c:	00 00       	add	r0,r0
8000e99e:	38 34       	mov	r4,-125
8000e9a0:	00 00       	add	r0,r0
8000e9a2:	38 44       	mov	r4,-124
8000e9a4:	00 00       	add	r0,r0
8000e9a6:	37 98       	mov	r8,121
8000e9a8:	00 00       	add	r0,r0
8000e9aa:	38 84       	mov	r4,-120
8000e9ac:	80 06       	ld.sh	r6,r0[0x0]
8000e9ae:	fe fc 00 00 	ld.w	r12,pc[0]
8000e9b2:	36 e0       	mov	r0,110
8000e9b4:	80 06       	ld.sh	r6,r0[0x0]
8000e9b6:	fe f8 00 00 	ld.w	r8,pc[0]
8000e9ba:	37 b0       	mov	r0,123

8000e9bc <PmsSetFifoInterface>:
8000e9bc:	eb cd 40 c0 	pushm	r6-r7,lr
8000e9c0:	18 97       	mov	r7,r12
8000e9c2:	16 96       	mov	r6,r11
8000e9c4:	30 2c       	mov	r12,2
8000e9c6:	fe b0 c8 78 	rcall	80007ab6 <mns_take>
8000e9ca:	0e 98       	mov	r8,r7
8000e9cc:	e2 18 00 c0 	andl	r8,0xc0,COH
8000e9d0:	e0 48 00 c0 	cp.w	r8,192
8000e9d4:	c4 00       	breq	8000ea54 <PmsSetFifoInterface+0x98>
8000e9d6:	58 08       	cp.w	r8,0
8000e9d8:	c4 71       	brne	8000ea66 <PmsSetFifoInterface+0xaa>
8000e9da:	e2 17 00 20 	andl	r7,0x20,COH
8000e9de:	c0 c1       	brne	8000e9f6 <PmsSetFifoInterface+0x3a>
8000e9e0:	30 06       	mov	r6,0
8000e9e2:	30 2c       	mov	r12,2
8000e9e4:	fe b0 c8 6a 	rcall	80007ab8 <mns_give>
8000e9e8:	58 06       	cp.w	r6,0
8000e9ea:	c3 30       	breq	8000ea50 <PmsSetFifoInterface+0x94>
8000e9ec:	4a 6c       	lddpc	r12,8000ea84 <PmsSetFifoInterface+0xc8>
8000e9ee:	fe b0 dd 79 	rcall	8000a4e0 <MbmFlush>
8000e9f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000e9f6:	58 06       	cp.w	r6,0
8000e9f8:	c1 40       	breq	8000ea20 <PmsSetFifoInterface+0x64>
8000e9fa:	4a 48       	lddpc	r8,8000ea88 <PmsSetFifoInterface+0xcc>
8000e9fc:	4a 29       	lddpc	r9,8000ea84 <PmsSetFifoInterface+0xc8>
8000e9fe:	93 98       	st.w	r9[0x24],r8
8000ea00:	4a 38       	lddpc	r8,8000ea8c <PmsSetFifoInterface+0xd0>
8000ea02:	70 97       	ld.w	r7,r8[0x24]
8000ea04:	58 07       	cp.w	r7,0
8000ea06:	ce d0       	breq	8000e9e0 <PmsSetFifoInterface+0x24>
8000ea08:	30 0a       	mov	r10,0
8000ea0a:	30 2c       	mov	r12,2
8000ea0c:	f3 6a 00 82 	st.b	r9[130],r10
8000ea10:	91 9a       	st.w	r8[0x24],r10
8000ea12:	fe b0 c8 53 	rcall	80007ab8 <mns_give>
8000ea16:	0e 9c       	mov	r12,r7
8000ea18:	fe b0 f2 a0 	rcall	8000cf58 <MbmFree>
8000ea1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000ea20:	49 98       	lddpc	r8,8000ea84 <PmsSetFifoInterface+0xc8>
8000ea22:	49 c9       	lddpc	r9,8000ea90 <PmsSetFifoInterface+0xd4>
8000ea24:	70 9a       	ld.w	r10,r8[0x24]
8000ea26:	12 3a       	cp.w	r10,r9
8000ea28:	f1 f6 1e 84 	st.bne	r8[0x84],r6
8000ea2c:	f1 f9 1a 09 	st.wne	r8[0x24],r9
8000ea30:	f9 b6 01 01 	movne	r6,1
8000ea34:	49 68       	lddpc	r8,8000ea8c <PmsSetFifoInterface+0xd0>
8000ea36:	70 99       	ld.w	r9,r8[0x24]
                mdpFifo.iface_ptr = &i2c;
                mdpFifo.syncGuard = (byte)0;
            }

            /* A small buffer needs to be preallocated for the acknowledge mechanism */
            if( NULL == pms.rxPreAllocPtrTab[PMS_IDX_MDP_RX_PREALLOC] )
8000ea38:	58 09       	cp.w	r9,0
8000ea3a:	cd 41       	brne	8000e9e2 <PmsSetFifoInterface+0x26>
            {
                pms.needPrealloc = 1;
8000ea3c:	70 09       	ld.w	r9,r8[0x0]
8000ea3e:	30 1a       	mov	r10,1
8000ea40:	f3 da d3 41 	bfins	r9,r10,0x1a,0x1
                PmsSetPendingEvent(PMS_P_RX_ACK);   /* Forces preallocation attempt */
8000ea44:	e0 6c 00 80 	mov	r12,128
            }

            /* A small buffer needs to be preallocated for the acknowledge mechanism */
            if( NULL == pms.rxPreAllocPtrTab[PMS_IDX_MDP_RX_PREALLOC] )
            {
                pms.needPrealloc = 1;
8000ea48:	91 09       	st.w	r8[0x0],r9
                PmsSetPendingEvent(PMS_P_RX_ACK);   /* Forces preallocation attempt */
8000ea4a:	fe b0 ef e5 	rcall	8000ca14 <PmsSetPendingEvent>
8000ea4e:	cc ab       	rjmp	8000e9e2 <PmsSetFifoInterface+0x26>
8000ea50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    WAIT4MX(MX_PMS_CS);
    if ( (PMS_M_FIFO_CTRL & fifomask) == PMS_M_FIFO_CTRL )
    {
        #ifdef PMS_RX_SEND_ACK
        icmFifo.iface_ptr = (PMS_IFACE_I2C == iface) ? &i2c : &generalCtrl;
8000ea54:	58 06       	cp.w	r6,0
8000ea56:	c1 20       	breq	8000ea7a <PmsSetFifoInterface+0xbe>
8000ea58:	48 f9       	lddpc	r9,8000ea94 <PmsSetFifoInterface+0xd8>
8000ea5a:	49 0a       	lddpc	r10,8000ea98 <PmsSetFifoInterface+0xdc>
8000ea5c:	12 98       	mov	r8,r9
8000ea5e:	95 99       	st.w	r10[0x24],r9
        mcmFifo.iface_ptr = (PMS_IFACE_I2C == iface) ? &i2c : &generalCtrl;
8000ea60:	48 f9       	lddpc	r9,8000ea9c <PmsSetFifoInterface+0xe0>
8000ea62:	93 98       	st.w	r9[0x24],r8
8000ea64:	cb bb       	rjmp	8000e9da <PmsSetFifoInterface+0x1e>
        #endif
    }
    #if (MNS_DEBUG & NST_C_ASSERTS)
    else if (PMS_M_FIFO_CTRL & fifomask)
    {
        FAILED_ASSERT(); /* Wrong parameter: fifomask must not be PMS_M_FIFO_MCM    */
8000ea66:	e0 68 02 5d 	mov	r8,605
8000ea6a:	30 1a       	mov	r10,1
8000ea6c:	1a d8       	st.w	--sp,r8
8000ea6e:	31 0b       	mov	r11,16
8000ea70:	14 9c       	mov	r12,r10
8000ea72:	fe b0 c8 3d 	rcall	80007aec <mns_trace>
8000ea76:	2f fd       	sub	sp,-4
8000ea78:	cb 1b       	rjmp	8000e9da <PmsSetFifoInterface+0x1e>

    WAIT4MX(MX_PMS_CS);
    if ( (PMS_M_FIFO_CTRL & fifomask) == PMS_M_FIFO_CTRL )
    {
        #ifdef PMS_RX_SEND_ACK
        icmFifo.iface_ptr = (PMS_IFACE_I2C == iface) ? &i2c : &generalCtrl;
8000ea7a:	48 69       	lddpc	r9,8000ea90 <PmsSetFifoInterface+0xd4>
8000ea7c:	48 7a       	lddpc	r10,8000ea98 <PmsSetFifoInterface+0xdc>
8000ea7e:	12 98       	mov	r8,r9
8000ea80:	95 99       	st.w	r10[0x24],r9
8000ea82:	ce fb       	rjmp	8000ea60 <PmsSetFifoInterface+0xa4>
8000ea84:	00 00       	add	r0,r0
8000ea86:	37 0c       	mov	r12,112
8000ea88:	00 00       	add	r0,r0
8000ea8a:	38 84       	mov	r4,-120
8000ea8c:	00 00       	add	r0,r0
8000ea8e:	37 d4       	mov	r4,125
8000ea90:	00 00       	add	r0,r0
8000ea92:	36 e0       	mov	r0,110
8000ea94:	00 00       	add	r0,r0
8000ea96:	38 3c       	mov	r12,-125
8000ea98:	00 00       	add	r0,r0
8000ea9a:	39 14       	mov	r4,-111
8000ea9c:	00 00       	add	r0,r0
8000ea9e:	38 8c       	mov	r12,-120

8000eaa0 <PmsInit>:
8000eaa0:	eb cd 40 fc 	pushm	r2-r7,lr
8000eaa4:	18 95       	mov	r5,r12
8000eaa6:	58 0c       	cp.w	r12,0
8000eaa8:	e0 80 00 ba 	breq	8000ec1c <PmsInit+0x17c>
8000eaac:	30 0a       	mov	r10,0
8000eaae:	30 7b       	mov	r11,7
8000eab0:	30 1c       	mov	r12,1
8000eab2:	fe b0 c8 1d 	rcall	80007aec <mns_trace>
8000eab6:	4e 46       	lddpc	r6,8000ec44 <PmsInit+0x1a4>
    ASSERT(is_ptr);

    T_INIT();

    /* - Start initialization of the pms structure -------------------------- */
    MNS_MEM_SET((byte *)&pms, (byte)0, (word)sizeof(pms));    /* Default zerofill */
8000eab8:	32 ca       	mov	r10,44
8000eaba:	30 0b       	mov	r11,0
8000eabc:	0c 9c       	mov	r12,r6
8000eabe:	fe b0 e1 55 	rcall	8000ad68 <MnsMemSet>

    /* Set necessary values */
    pms.needPrealloc = 1;   /* Need to fill preallocated buffers first */
8000eac2:	6c 08       	ld.w	r8,r6[0x0]
8000eac4:	30 17       	mov	r7,1
8000eac6:	0c 93       	mov	r3,r6
8000eac8:	f1 d7 d3 41 	bfins	r8,r7,0x1a,0x1
8000eacc:	06 a8       	st.w	r3++,r8

    #ifdef AMS_TX_OUT_FILTER
    ASSERT(NULL != pmsInitData_ptr->cbTxOutFilter_fptr);
    #endif

    MostRegisterTimer(&pmsSyncTimer, PmsSetPendingEvent, PMS_P_TIMEOUT);
8000eace:	30 2a       	mov	r10,2
8000ead0:	fe cb 20 bc 	sub	r11,pc,8380

    /* Set necessary values */
    pms.needPrealloc = 1;   /* Need to fill preallocated buffers first */
    /* - End initialize of the pms structure -------------------------------- */

    pmsInitData_ptr = is_ptr;
8000ead4:	4d dc       	lddpc	r12,8000ec48 <PmsInit+0x1a8>
8000ead6:	4d e4       	lddpc	r4,8000ec4c <PmsInit+0x1ac>

    #ifdef AMS_TX_OUT_FILTER
    ASSERT(NULL != pmsInitData_ptr->cbTxOutFilter_fptr);
    #endif

    MostRegisterTimer(&pmsSyncTimer, PmsSetPendingEvent, PMS_P_TIMEOUT);
8000ead8:	89 05       	st.w	r4[0x0],r5
8000eada:	fe b0 e3 5d 	rcall	8000b194 <MostRegisterTimer>
    #ifdef PMS_28
    MostRegisterTimer(&pmsGbgTimer, PmsSetPendingEvent, PMS_P_GBG_COL);
8000eade:	e0 6a 02 00 	mov	r10,512
8000eae2:	fe cb 20 ce 	sub	r11,pc,8398
8000eae6:	4d bc       	lddpc	r12,8000ec50 <PmsInit+0x1b0>
    #endif
    MostRegisterTimer(&pms.rxPreAllocFailedTimer, PmsSetPendingEvent, PMS_P_TIMEOUT_RX_PREALLOC);
8000eae8:	fe b0 e3 56 	rcall	8000b194 <MostRegisterTimer>
8000eaec:	e0 6a 20 00 	mov	r10,8192
8000eaf0:	fe cb 20 dc 	sub	r11,pc,8412

    WAIT4MX(MX_PMS_PE);
8000eaf4:	06 9c       	mov	r12,r3
8000eaf6:	fe b0 e3 4f 	rcall	8000b194 <MostRegisterTimer>
    pmsPending        = PMS_P_NONE;
8000eafa:	0e 9c       	mov	r12,r7
8000eafc:	fe b0 c7 dd 	rcall	80007ab6 <mns_take>
8000eb00:	4d 58       	lddpc	r8,8000ec54 <PmsInit+0x1b4>
    REL_MX(MX_PMS_PE);
8000eb02:	30 02       	mov	r2,0
8000eb04:	0e 9c       	mov	r12,r7
    pmsSyncState      = PMS_S_INIT;
8000eb06:	b0 02       	st.h	r8[0x0],r2
8000eb08:	fe b0 c7 d8 	rcall	80007ab8 <mns_give>
    pmsSyncTimeout    = PMS_T_SYNC;
8000eb0c:	4d 38       	lddpc	r8,8000ec58 <PmsInit+0x1b8>
8000eb0e:	30 03       	mov	r3,0
8000eb10:	91 03       	st.w	r8[0x0],r3
8000eb12:	4d 38       	lddpc	r8,8000ec5c <PmsInit+0x1bc>
    pmsMaxCmsPayload  = PMS_MAX_CMS_PAYLOAD_MOST50;
8000eb14:	e0 69 01 2c 	mov	r9,300
8000eb18:	b0 09       	st.h	r8[0x0],r9
    pmsSupportsTelId4 = MNS_FALSE;
8000eb1a:	4d 28       	lddpc	r8,8000ec60 <PmsInit+0x1c0>
8000eb1c:	30 c9       	mov	r9,12
    pmsCnt            = (byte)1;
8000eb1e:	b0 09       	st.h	r8[0x0],r9

    WAIT4MX(MX_PMS_CS);
8000eb20:	4d 18       	lddpc	r8,8000ec64 <PmsInit+0x1c4>
    REL_MX(MX_PMS_PE);
    pmsSyncState      = PMS_S_INIT;
    pmsSyncTimeout    = PMS_T_SYNC;
    pmsMaxCmsPayload  = PMS_MAX_CMS_PAYLOAD_MOST50;
    pmsSupportsTelId4 = MNS_FALSE;
    pmsCnt            = (byte)1;
8000eb22:	b0 82       	st.b	r8[0x0],r2

    WAIT4MX(MX_PMS_CS);
8000eb24:	4d 18       	lddpc	r8,8000ec68 <PmsInit+0x1c8>
8000eb26:	30 2c       	mov	r12,2

    cmdFree = MbmAllocate(PMS_CMD_SIZE, (word)0, MBM_TYPE_CMD_TX);
8000eb28:	b0 87       	st.b	r8[0x0],r7
8000eb2a:	fe b0 c7 c6 	rcall	80007ab6 <mns_take>
8000eb2e:	06 9b       	mov	r11,r3
8000eb30:	30 7a       	mov	r10,7
8000eb32:	30 ac       	mov	r12,10
8000eb34:	fe b0 db 62 	rcall	8000a1f8 <MbmAllocate>
    cmdRsvd = cmdFree;
8000eb38:	4c d8       	lddpc	r8,8000ec6c <PmsInit+0x1cc>
    ASSERT(cmdRsvd);    /* Will not work without it */
8000eb3a:	91 0c       	st.w	r8[0x0],r12
8000eb3c:	4c d8       	lddpc	r8,8000ec70 <PmsInit+0x1d0>
8000eb3e:	91 0c       	st.w	r8[0x0],r12

    MNS_MEM_SET((byte *)&segErrMsg, (byte)0, (word)sizeof(segErrMsg));
8000eb40:	58 0c       	cp.w	r12,0
8000eb42:	c7 70       	breq	8000ec30 <PmsInit+0x190>
8000eb44:	4c c7       	lddpc	r7,8000ec74 <PmsInit+0x1d4>
8000eb46:	33 8a       	mov	r10,56
8000eb48:	0e 9c       	mov	r12,r7
8000eb4a:	30 0b       	mov	r11,0
    segErrMsg.start_ptr = segErrData;
8000eb4c:	fe b0 e1 0e 	rcall	8000ad68 <MnsMemSet>
    segErrMsg.size      = (word)PMS_BUFSIZE_SEG_ERROR;
8000eb50:	4c a8       	lddpc	r8,8000ec78 <PmsInit+0x1d8>
8000eb52:	8f 48       	st.w	r7[0x10],r8
8000eb54:	31 88       	mov	r8,24
    segErrMsg.type      = MBM_TYPE_CTRL_TX;
8000eb56:	ef 58 00 30 	st.h	r7[48],r8
8000eb5a:	30 58       	mov	r8,5
    MbmReserve(&segErrMsg, (word)PMS_CTRL_HDR_MAX_SIZE);
8000eb5c:	0e 9c       	mov	r12,r7
8000eb5e:	ae 68       	st.h	r7[0xc],r8
8000eb60:	31 4b       	mov	r11,20
    segErrMsg.msg.msgTx.Operation = OP_ERROR;
8000eb62:	fe b0 da 23 	rcall	80009fa8 <MbmReserve>
8000eb66:	30 f8       	mov	r8,15
    segErrMsg.msg.msgTx.Length    = (word)2;
8000eb68:	ef 68 00 20 	st.b	r7[32],r8
8000eb6c:	30 28       	mov	r8,2
    segErrMsg.msg.msgTx.Data[0]   = (byte)0x0C;        /* Segmentation error */
8000eb6e:	ef 58 00 18 	st.h	r7[24],r8
8000eb72:	30 c9       	mov	r9,12
    segErrMsg.msg.msgTx.MidLevelRetries = PMS_SEG_ERROR_MLR;
    segErrMsg.msg.msgTx.LowLevelRetries = PMS_SEG_ERROR_LLR;
8000eb74:	6e 58       	ld.w	r8,r7[0x14]

    /* Init Interfaces */
    PMS_IFACE_INIT(i2c);
8000eb76:	b0 89       	st.b	r8[0x0],r9
    MbmReserve(&segErrMsg, (word)PMS_CTRL_HDR_MAX_SIZE);
    segErrMsg.msg.msgTx.Operation = OP_ERROR;
    segErrMsg.msg.msgTx.Length    = (word)2;
    segErrMsg.msg.msgTx.Data[0]   = (byte)0x0C;        /* Segmentation error */
    segErrMsg.msg.msgTx.MidLevelRetries = PMS_SEG_ERROR_MLR;
    segErrMsg.msg.msgTx.LowLevelRetries = PMS_SEG_ERROR_LLR;
8000eb78:	30 1a       	mov	r10,1
8000eb7a:	30 08       	mov	r8,0

    /* Init Interfaces */
    PMS_IFACE_INIT(i2c);
8000eb7c:	ef 6a 00 22 	st.b	r7[34],r10
8000eb80:	4b f3       	lddpc	r3,8000ec7c <PmsInit+0x1dc>
    segErrMsg.type      = MBM_TYPE_CTRL_TX;
    MbmReserve(&segErrMsg, (word)PMS_CTRL_HDR_MAX_SIZE);
    segErrMsg.msg.msgTx.Operation = OP_ERROR;
    segErrMsg.msg.msgTx.Length    = (word)2;
    segErrMsg.msg.msgTx.Data[0]   = (byte)0x0C;        /* Segmentation error */
    segErrMsg.msg.msgTx.MidLevelRetries = PMS_SEG_ERROR_MLR;
8000eb82:	30 02       	mov	r2,0
8000eb84:	87 18       	st.w	r3[0x4],r8
    segErrMsg.msg.msgTx.LowLevelRetries = PMS_SEG_ERROR_LLR;

    /* Init Interfaces */
    PMS_IFACE_INIT(i2c);
    i2c.tx_fptr = is_ptr->i2cTx_fptr;
8000eb86:	ef 62 00 21 	st.b	r7[33],r2
    PMS_IFACE_INIT(generalCtrl);
8000eb8a:	6a 77       	ld.w	r7,r5[0x1c]
    segErrMsg.msg.msgTx.MidLevelRetries = PMS_SEG_ERROR_MLR;
    segErrMsg.msg.msgTx.LowLevelRetries = PMS_SEG_ERROR_LLR;

    /* Init Interfaces */
    PMS_IFACE_INIT(i2c);
    i2c.tx_fptr = is_ptr->i2cTx_fptr;
8000eb8c:	4b d9       	lddpc	r9,8000ec80 <PmsInit+0x1e0>
    PMS_IFACE_INIT(generalCtrl);
8000eb8e:	4b eb       	lddpc	r11,8000ec84 <PmsInit+0x1e4>
    generalCtrl.tx_fptr = is_ptr->ctrlTx_fptr;
8000eb90:	87 07       	st.w	r3[0x0],r7

    #ifdef ADS_MIN /* No MLB/SPI interface for MDP_MIN */
    PMS_IFACE_INIT(generalData);
8000eb92:	97 18       	st.w	r11[0x4],r8

    /* Init Interfaces */
    PMS_IFACE_INIT(i2c);
    i2c.tx_fptr = is_ptr->i2cTx_fptr;
    PMS_IFACE_INIT(generalCtrl);
    generalCtrl.tx_fptr = is_ptr->ctrlTx_fptr;
8000eb94:	6a 87       	ld.w	r7,r5[0x20]

    #ifdef ADS_MIN /* No MLB/SPI interface for MDP_MIN */
    PMS_IFACE_INIT(generalData);
    generalData.tx_fptr = is_ptr->dataTx_fptr;
8000eb96:	93 18       	st.w	r9[0x4],r8
8000eb98:	97 07       	st.w	r11[0x0],r7
    #endif

    /*
    */
    pms.mid_level_retries = (byte)DEF_MID_LEVEL_RETRIES;
8000eb9a:	6a 98       	ld.w	r8,r5[0x24]
    pms.low_level_retries = PMS_DEF_RETRY_1;
8000eb9c:	93 08       	st.w	r9[0x0],r8
8000eb9e:	30 38       	mov	r8,3
    generalData.tx_fptr = is_ptr->dataTx_fptr;
    #endif

    /*
    */
    pms.mid_level_retries = (byte)DEF_MID_LEVEL_RETRIES;
8000eba0:	ed 6a 00 29 	st.b	r6[41],r10
    pms.low_level_retries = PMS_DEF_RETRY_1;
    REL_MX(MX_PMS_CS);
8000eba4:	ed 68 00 28 	st.b	r6[40],r8
8000eba8:	30 2c       	mov	r12,2


    WAIT4MX(MX_PMS_Q);
8000ebaa:	fe b0 c7 87 	rcall	80007ab8 <mns_give>
8000ebae:	30 3c       	mov	r12,3
    MbmQueueInit(&rxQ, (word)MX_PMS_Q);
8000ebb0:	fe b0 c7 83 	rcall	80007ab6 <mns_take>
8000ebb4:	30 3b       	mov	r11,3
8000ebb6:	4b 5c       	lddpc	r12,8000ec88 <PmsInit+0x1e8>
    MbmQueueInit(&rxStatusQ, (word)MX_PMS_Q);
8000ebb8:	fe b0 db ae 	rcall	8000a314 <MbmQueueInit>
8000ebbc:	30 3b       	mov	r11,3
8000ebbe:	4b 4c       	lddpc	r12,8000ec8c <PmsInit+0x1ec>
        }
    }
    #endif

    #ifndef PMS_RX_NOSEG
    MbmQueueInit(&rxSegQ, (word)MX_PMS_Q);
8000ebc0:	fe b0 db aa 	rcall	8000a314 <MbmQueueInit>
8000ebc4:	30 3b       	mov	r11,3
8000ebc6:	4b 3c       	lddpc	r12,8000ec90 <PmsInit+0x1f0>
    #endif

    #ifndef PMS_TX_NOSEG
    MbmQueueInit(&txSegShadowQ, (word)MX_PMS_Q);
8000ebc8:	fe b0 db a6 	rcall	8000a314 <MbmQueueInit>
8000ebcc:	30 3b       	mov	r11,3
8000ebce:	4b 2c       	lddpc	r12,8000ec94 <PmsInit+0x1f4>
    for( i = (word)0; i < (word)PMS_NUM_ACTIVE_SEGMENTS; i++ )
    {
        txSegShadows[i].type = MBM_TYPE_CTRL_TX | MBM_TYPE_SHADOW;
8000ebd0:	fe b0 db a2 	rcall	8000a314 <MbmQueueInit>
        _MbmEnqueue(&txSegShadowQ, (HMBMBUF)&txSegShadows[i]);
8000ebd4:	30 d9       	mov	r9,13

    #ifndef PMS_TX_NOSEG
    MbmQueueInit(&txSegShadowQ, (word)MX_PMS_Q);
    for( i = (word)0; i < (word)PMS_NUM_ACTIVE_SEGMENTS; i++ )
    {
        txSegShadows[i].type = MBM_TYPE_CTRL_TX | MBM_TYPE_SHADOW;
8000ebd6:	4b 18       	lddpc	r8,8000ec98 <PmsInit+0x1f8>
        _MbmEnqueue(&txSegShadowQ, (HMBMBUF)&txSegShadows[i]);
8000ebd8:	4a fc       	lddpc	r12,8000ec94 <PmsInit+0x1f4>
8000ebda:	b0 69       	st.h	r8[0xc],r9
8000ebdc:	10 9b       	mov	r11,r8
    }
    #endif
    #ifdef MSG_RX_USER_PAYLOAD
    MbmQueueInit(&pms.rxPayloadWaitingQ, (word)MX_PMS_Q);
    #endif
    REL_MX(MX_PMS_Q);
8000ebde:	fe b0 da f1 	rcall	8000a1c0 <_MbmEnqueue>
8000ebe2:	30 3c       	mov	r12,3

    PmsFifoInit(&icmFifo);
8000ebe4:	fe b0 c7 6a 	rcall	80007ab8 <mns_give>
8000ebe8:	4a dc       	lddpc	r12,8000ec9c <PmsInit+0x1fc>
    PmsFifoInit(&mcmFifo);
8000ebea:	fe b0 f1 47 	rcall	8000ce78 <PmsFifoInit>
8000ebee:	4a dc       	lddpc	r12,8000eca0 <PmsInit+0x200>
    PmsSetFifoInterface(PMS_M_FIFO_CTRL, pmsInitData_ptr->icmIface);
8000ebf0:	fe b0 f1 44 	rcall	8000ce78 <PmsFifoInit>
8000ebf4:	68 08       	ld.w	r8,r4[0x0]
8000ebf6:	e0 6c 00 c0 	mov	r12,192
8000ebfa:	f1 3b 00 28 	ld.ub	r11,r8[40]

    #ifdef MDP_MIN
    PmsFifoInit(&mdpFifo);
8000ebfe:	cd fe       	rcall	8000e9bc <PmsSetFifoInterface>
8000ec00:	4a 9c       	lddpc	r12,8000eca4 <PmsInit+0x204>
8000ec02:	fe b0 f1 3b 	rcall	8000ce78 <PmsFifoInit>
      #ifdef ADS_MIN
      PmsSetFifoInterface(PMS_M_FIFO_MDP, pmsInitData_ptr->mdpIface);
8000ec06:	68 08       	ld.w	r8,r4[0x0]
8000ec08:	32 0c       	mov	r12,32
8000ec0a:	f1 3b 00 2a 	ld.ub	r11,r8[42]
8000ec0e:	cd 7e       	rcall	8000e9bc <PmsSetFifoInterface>
      #else
      PmsSetFifoInterface(PMS_M_FIFO_MDP, PMS_IFACE_I2C); /* Only I2C with MDP_MIN alone */
      #endif
    #endif

    PmsSetPendingEvent(PMS_P_RX_ACK);
8000ec10:	e0 6c 00 80 	mov	r12,128
8000ec14:	fe b0 ef 00 	rcall	8000ca14 <PmsSetPendingEvent>
    T_LIB_EXIT(PMS_4);
}
8000ec18:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    #if !defined(PMS_TX_NOSEG) || (ADS_RX_PREALLOC > 0)
    word i;
    #endif
    T_LIB_ENTRY(PMS_4);

    ASSERT(is_ptr);
8000ec1c:	e0 68 04 ba 	mov	r8,1210
8000ec20:	30 1a       	mov	r10,1
8000ec22:	1a d8       	st.w	--sp,r8
8000ec24:	31 0b       	mov	r11,16
8000ec26:	14 9c       	mov	r12,r10
8000ec28:	fe b0 c7 62 	rcall	80007aec <mns_trace>
8000ec2c:	2f fd       	sub	sp,-4
8000ec2e:	c3 fb       	rjmp	8000eaac <PmsInit+0xc>

    WAIT4MX(MX_PMS_CS);

    cmdFree = MbmAllocate(PMS_CMD_SIZE, (word)0, MBM_TYPE_CMD_TX);
    cmdRsvd = cmdFree;
    ASSERT(cmdRsvd);    /* Will not work without it */
8000ec30:	e0 68 04 e3 	mov	r8,1251
8000ec34:	0e 9a       	mov	r10,r7
8000ec36:	1a d8       	st.w	--sp,r8
8000ec38:	31 0b       	mov	r11,16
8000ec3a:	0e 9c       	mov	r12,r7
8000ec3c:	fe b0 c7 58 	rcall	80007aec <mns_trace>
8000ec40:	2f fd       	sub	sp,-4
8000ec42:	c8 1b       	rjmp	8000eb44 <PmsInit+0xa4>
8000ec44:	00 00       	add	r0,r0
8000ec46:	37 d4       	mov	r4,125
8000ec48:	00 00       	add	r0,r0
8000ec4a:	37 bc       	mov	r12,123
8000ec4c:	00 00       	add	r0,r0
8000ec4e:	38 38       	mov	r8,-125
8000ec50:	00 00       	add	r0,r0
8000ec52:	37 9c       	mov	r12,121
8000ec54:	00 00       	add	r0,r0
8000ec56:	4a 24       	lddpc	r4,8000ecdc <PmsTxRelease+0x34>
8000ec58:	00 00       	add	r0,r0
8000ec5a:	37 98       	mov	r8,121
8000ec5c:	00 00       	add	r0,r0
8000ec5e:	38 80       	mov	r0,-120
8000ec60:	00 00       	add	r0,r0
8000ec62:	38 34       	mov	r4,-125
8000ec64:	00 00       	add	r0,r0
8000ec66:	38 44       	mov	r4,-124
8000ec68:	00 00       	add	r0,r0
8000ec6a:	37 94       	mov	r4,121
8000ec6c:	00 00       	add	r0,r0
8000ec6e:	37 d0       	mov	r0,125
8000ec70:	00 00       	add	r0,r0
8000ec72:	37 08       	mov	r8,112
8000ec74:	00 00       	add	r0,r0
8000ec76:	38 48       	mov	r8,-124
8000ec78:	00 00       	add	r0,r0
8000ec7a:	38 00       	mov	r0,-128
8000ec7c:	00 00       	add	r0,r0
8000ec7e:	36 e0       	mov	r0,110
8000ec80:	00 00       	add	r0,r0
8000ec82:	38 84       	mov	r4,-120
8000ec84:	00 00       	add	r0,r0
8000ec86:	38 3c       	mov	r12,-125
8000ec88:	00 00       	add	r0,r0
8000ec8a:	36 fc       	mov	r12,111
8000ec8c:	00 00       	add	r0,r0
8000ec8e:	37 b0       	mov	r0,123
8000ec90:	00 00       	add	r0,r0
8000ec92:	38 1c       	mov	r12,-127
8000ec94:	00 00       	add	r0,r0
8000ec96:	38 28       	mov	r8,-126
8000ec98:	00 00       	add	r0,r0
8000ec9a:	36 e8       	mov	r8,110
8000ec9c:	00 00       	add	r0,r0
8000ec9e:	39 14       	mov	r4,-111
8000eca0:	00 00       	add	r0,r0
8000eca2:	38 8c       	mov	r12,-120
8000eca4:	00 00       	add	r0,r0
8000eca6:	37 0c       	mov	r12,112

8000eca8 <PmsTxRelease>:
8000eca8:	d4 31       	pushm	r0-r7,lr
8000ecaa:	18 97       	mov	r7,r12
8000ecac:	58 0c       	cp.w	r12,0
8000ecae:	e0 80 01 2b 	breq	8000ef04 <PmsTxRelease+0x25c>
8000ecb2:	30 2c       	mov	r12,2
8000ecb4:	fe b0 c7 01 	rcall	80007ab6 <mns_take>
8000ecb8:	8e 68       	ld.sh	r8,r7[0xc]
8000ecba:	a5 b8       	sbr	r8,0x5
8000ecbc:	ae 68       	st.h	r7[0xc],r8
8000ecbe:	e9 d8 c0 10 	bfextu	r4,r8,0x0,0x10
8000ecc2:	08 99       	mov	r9,r4
8000ecc4:	e2 19 00 02 	andl	r9,0x2,COH
8000ecc8:	c1 90       	breq	8000ecfa <PmsTxRelease+0x52>
8000ecca:	fe f9 02 96 	ld.w	r9,pc[662]
8000ecce:	72 09       	ld.w	r9,r9[0x0]
8000ecd0:	0e 39       	cp.w	r9,r7
8000ecd2:	e0 80 01 23 	breq	8000ef18 <PmsTxRelease+0x270>
8000ecd6:	e2 14 04 00 	andl	r4,0x400,COH
        if( cmdRsvd == handle )
        {
            /* This was the Command message dedicated to SyncC */
            cmdFree = handle; /* Or cmdRsvd... same, same... */
        }
        else if( MBM_GET_STATUS(handle) & MBM_STAT_RSVD )
8000ecda:	e0 80 00 84 	breq	8000ede2 <PmsTxRelease+0x13a>
        {
            MBM_CLR_STATUS_BITS(handle, MBM_STAT_RSVD);
8000ecde:	ab c8       	cbr	r8,0xa
8000ece0:	ae 68       	st.h	r7[0xc],r8

            #ifdef PMS_RX_SEND_ACK
            if (pms.needRetriggerAck)
8000ece2:	fe f8 02 82 	ld.w	r8,pc[642]
8000ece6:	70 09       	ld.w	r9,r8[0x0]
8000ece8:	12 93       	mov	r3,r9
8000ecea:	e6 13 08 00 	andh	r3,0x800,COH
8000ecee:	e0 81 01 03 	brne	8000eef4 <PmsTxRelease+0x24c>
8000ecf2:	fe f5 02 76 	ld.w	r5,pc[630]
8000ecf6:	06 94       	mov	r4,r3
8000ecf8:	c2 18       	rjmp	8000ed3a <PmsTxRelease+0x92>
    T_MOD_ENTRY(PMS_15);

    cmsg_ptr = MBM_GET_CTRL_TX_PTR(tx_handle);

  #ifdef ADS_MIN /* Not needed for MDP_MIN only, no TX */
    if( MBM_TYPE_DATA == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK) )
8000ecfa:	e2 14 00 06 	andl	r4,0x6,COH
8000ecfe:	c6 f0       	breq	8000eddc <PmsTxRelease+0x134>
    else
  #else
    /* Only control messages are allowed */
    ASSERT(MBM_TYPE_CTRL == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK));
  #endif
    if( (MSG_TGT_INIC == cmsg_ptr->Tgt_Adr) && (FBLOCK_INIC == cmsg_ptr->FBlock_ID) )
8000ed00:	ef 0a 00 1a 	ld.sh	r10,r7[26]
8000ed04:	30 18       	mov	r8,1
8000ed06:	f0 0a 19 00 	cp.h	r10,r8
8000ed0a:	e0 80 01 0d 	breq	8000ef24 <PmsTxRelease+0x27c>
8000ed0e:	fe f3 02 5e 	ld.w	r3,pc[606]
8000ed12:	fe f5 02 56 	ld.w	r5,pc[598]
    {
        PmsFifo *fifo_ptr = PmsGetTxFifo(handle);
        #ifndef PMS_TX_NOSEG
        MbmBuf *pending_ptr;

        WAIT4MX(MX_PMS_Q);
8000ed16:	30 3c       	mov	r12,3
8000ed18:	fe b0 c6 cf 	rcall	80007ab6 <mns_take>
        if( MBM_STAT_TX_SEG & MBM_GET_STATUS(handle) )
8000ed1c:	8e e8       	ld.uh	r8,r7[0xc]
8000ed1e:	ed b8 00 04 	bld	r8,0x4
8000ed22:	c6 f0       	breq	8000ee00 <PmsTxRelease+0x158>
8000ed24:	0e 94       	mov	r4,r7
        }
        else
        {
            pending_ptr = handle;
        }
        _MbmEnqueue(&fifo_ptr->pendingQ, pending_ptr);
8000ed26:	08 9b       	mov	r11,r4
8000ed28:	e6 cc ff e8 	sub	r12,r3,-24
8000ed2c:	fe b0 da 4a 	rcall	8000a1c0 <_MbmEnqueue>

        REL_MX(MX_PMS_Q);
8000ed30:	30 3c       	mov	r12,3
8000ed32:	30 03       	mov	r3,0
8000ed34:	fe b0 c6 c2 	rcall	80007ab8 <mns_give>
8000ed38:	06 94       	mov	r4,r3
        MbmEnqueue(&fifo_ptr->pendingQ, handle);
        #endif
    }

    /* Release from interface */
    if( i2c.active == handle )
8000ed3a:	fe f8 02 36 	ld.w	r8,pc[566]
8000ed3e:	70 19       	ld.w	r9,r8[0x4]
8000ed40:	0e 39       	cp.w	r9,r7
8000ed42:	c5 50       	breq	8000edec <PmsTxRelease+0x144>
    {
        i2c.active = NULL;
    }
    else if( generalCtrl.active == handle )
8000ed44:	fe f8 02 30 	ld.w	r8,pc[560]
8000ed48:	70 19       	ld.w	r9,r8[0x4]
8000ed4a:	0e 39       	cp.w	r9,r7
8000ed4c:	c5 00       	breq	8000edec <PmsTxRelease+0x144>
    {
        generalCtrl.active = NULL;
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( generalData.active == handle )
8000ed4e:	fe f8 02 2a 	ld.w	r8,pc[554]
8000ed52:	70 19       	ld.w	r9,r8[0x4]
8000ed54:	0e 39       	cp.w	r9,r7
8000ed56:	c4 90       	breq	8000ede8 <PmsTxRelease+0x140>
        events             |= PMS_P_MDP_TXSTATUS;
    }
    #endif

    /* Check if TX_TRIG needs to be fired for any FIFO */
    if(    (HAS_TX(&icmFifo) && PMS_IFACE_READY(*icmFifo.iface_ptr))
8000ed58:	eb 08 00 16 	ld.sh	r8,r5[22]
8000ed5c:	30 09       	mov	r9,0
8000ed5e:	f2 08 19 00 	cp.h	r8,r9
8000ed62:	c0 71       	brne	8000ed70 <PmsTxRelease+0xc8>
8000ed64:	fe f9 02 04 	ld.w	r9,pc[516]
8000ed68:	92 59       	ld.sh	r9,r9[0xa]
8000ed6a:	f0 09 19 00 	cp.h	r9,r8
8000ed6e:	c0 50       	breq	8000ed78 <PmsTxRelease+0xd0>
8000ed70:	6a 98       	ld.w	r8,r5[0x24]
8000ed72:	70 18       	ld.w	r8,r8[0x4]
8000ed74:	58 08       	cp.w	r8,0
8000ed76:	c3 e0       	breq	8000edf2 <PmsTxRelease+0x14a>
        || (HAS_TX(&mcmFifo) && PMS_IFACE_READY(*mcmFifo.iface_ptr))
8000ed78:	4f d6       	lddpc	r6,8000ef6c <PmsTxRelease+0x2c4>
8000ed7a:	30 09       	mov	r9,0
8000ed7c:	ed 08 00 16 	ld.sh	r8,r6[22]
8000ed80:	f2 08 19 00 	cp.h	r8,r9
8000ed84:	c0 51       	brne	8000ed8e <PmsTxRelease+0xe6>
        events             |= PMS_P_MDP_TXSTATUS;
    }
    #endif

    /* Check if TX_TRIG needs to be fired for any FIFO */
    if(    (HAS_TX(&icmFifo) && PMS_IFACE_READY(*icmFifo.iface_ptr))
8000ed86:	8c 59       	ld.sh	r9,r6[0xa]
8000ed88:	f0 09 19 00 	cp.h	r9,r8
8000ed8c:	c0 50       	breq	8000ed96 <PmsTxRelease+0xee>
        || (HAS_TX(&mcmFifo) && PMS_IFACE_READY(*mcmFifo.iface_ptr))
8000ed8e:	6c 98       	ld.w	r8,r6[0x24]
8000ed90:	70 18       	ld.w	r8,r8[0x4]
8000ed92:	58 08       	cp.w	r8,0
8000ed94:	c2 f0       	breq	8000edf2 <PmsTxRelease+0x14a>
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
        || (HAS_TX(&mdpFifo) && PMS_IFACE_READY(*mdpFifo.iface_ptr))
8000ed96:	4f a8       	lddpc	r8,8000ef7c <PmsTxRelease+0x2d4>
8000ed98:	30 0a       	mov	r10,0
8000ed9a:	f1 09 00 16 	ld.sh	r9,r8[22]
8000ed9e:	f4 09 19 00 	cp.h	r9,r10
8000eda2:	c0 51       	brne	8000edac <PmsTxRelease+0x104>
        events             |= PMS_P_MDP_TXSTATUS;
    }
    #endif

    /* Check if TX_TRIG needs to be fired for any FIFO */
    if(    (HAS_TX(&icmFifo) && PMS_IFACE_READY(*icmFifo.iface_ptr))
8000eda4:	90 5a       	ld.sh	r10,r8[0xa]
8000eda6:	f2 0a 19 00 	cp.h	r10,r9
8000edaa:	c0 50       	breq	8000edb4 <PmsTxRelease+0x10c>
        || (HAS_TX(&mcmFifo) && PMS_IFACE_READY(*mcmFifo.iface_ptr))
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
        || (HAS_TX(&mdpFifo) && PMS_IFACE_READY(*mdpFifo.iface_ptr))
8000edac:	70 98       	ld.w	r8,r8[0x24]
8000edae:	70 18       	ld.w	r8,r8[0x4]
8000edb0:	58 08       	cp.w	r8,0
8000edb2:	c2 00       	breq	8000edf2 <PmsTxRelease+0x14a>
    #endif
      )
    {
        events |= PMS_P_TX_TRIG;
    }
    REL_MX(MX_PMS_CS);
8000edb4:	30 2c       	mov	r12,2
8000edb6:	fe b0 c6 81 	rcall	80007ab8 <mns_give>

    if( MBM_QUEUE_LENGTH(&rxStatusQ) )
8000edba:	4f 28       	lddpc	r8,8000ef80 <PmsTxRelease+0x2d8>
8000edbc:	90 59       	ld.sh	r9,r8[0xa]
8000edbe:	30 08       	mov	r8,0
8000edc0:	f0 09 19 00 	cp.h	r9,r8
8000edc4:	c0 30       	breq	8000edca <PmsTxRelease+0x122>
    {
        /* Status processing may have been waiting for this to complete */
        events |= PMS_P_RX_STATUS;
8000edc6:	a9 a4       	sbr	r4,0x8
8000edc8:	5c 84       	casts.h	r4
    }

    if( MNS_FALSE != free )
8000edca:	58 03       	cp.w	r3,0
8000edcc:	c1 61       	brne	8000edf8 <PmsTxRelease+0x150>
    {
        MbmFree(handle);
    }

    if( events )
8000edce:	58 04       	cp.w	r4,0
8000edd0:	c0 50       	breq	8000edda <PmsTxRelease+0x132>
    {
        PmsSetPendingEvent(events);
8000edd2:	08 9c       	mov	r12,r4
8000edd4:	5c 7c       	castu.h	r12
8000edd6:	fe b0 ee 1f 	rcall	8000ca14 <PmsSetPendingEvent>
8000edda:	d8 32       	popm	r0-r7,pc
    T_MOD_ENTRY(PMS_15);

    cmsg_ptr = MBM_GET_CTRL_TX_PTR(tx_handle);

  #ifdef ADS_MIN /* Not needed for MDP_MIN only, no TX */
    if( MBM_TYPE_DATA == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK) )
8000eddc:	4e 83       	lddpc	r3,8000ef7c <PmsTxRelease+0x2d4>
8000edde:	4e 35       	lddpc	r5,8000ef68 <PmsTxRelease+0x2c0>
8000ede0:	c9 bb       	rjmp	8000ed16 <PmsTxRelease+0x6e>
        if( cmdRsvd == handle )
        {
            /* This was the Command message dedicated to SyncC */
            cmdFree = handle; /* Or cmdRsvd... same, same... */
        }
        else if( MBM_GET_STATUS(handle) & MBM_STAT_RSVD )
8000ede2:	30 13       	mov	r3,1
8000ede4:	4e 15       	lddpc	r5,8000ef68 <PmsTxRelease+0x2c0>
8000ede6:	ca ab       	rjmp	8000ed3a <PmsTxRelease+0x92>
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( generalData.active == handle )
    {
        generalData.active  = NULL;
        events             |= PMS_P_MDP_TXSTATUS;
8000ede8:	a7 a4       	sbr	r4,0x6
8000edea:	5c 84       	casts.h	r4
        generalCtrl.active = NULL;
    }
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
    else if( generalData.active == handle )
    {
        generalData.active  = NULL;
8000edec:	30 09       	mov	r9,0
8000edee:	91 19       	st.w	r8[0x4],r9
8000edf0:	cb 4b       	rjmp	8000ed58 <PmsTxRelease+0xb0>
    #ifdef ADS_MIN /* Not needed for MDP_MIN, no TX */
        || (HAS_TX(&mdpFifo) && PMS_IFACE_READY(*mdpFifo.iface_ptr))
    #endif
      )
    {
        events |= PMS_P_TX_TRIG;
8000edf2:	a3 b4       	sbr	r4,0x3
8000edf4:	5c 84       	casts.h	r4
8000edf6:	cd fb       	rjmp	8000edb4 <PmsTxRelease+0x10c>
        events |= PMS_P_RX_STATUS;
    }

    if( MNS_FALSE != free )
    {
        MbmFree(handle);
8000edf8:	0e 9c       	mov	r12,r7
8000edfa:	fe b0 f0 af 	rcall	8000cf58 <MbmFree>
8000edfe:	ce 8b       	rjmp	8000edce <PmsTxRelease+0x126>
        MbmBuf *pending_ptr;

        WAIT4MX(MX_PMS_Q);
        if( MBM_STAT_TX_SEG & MBM_GET_STATUS(handle) )
        {
            ASSERT(&mcmFifo == fifo_ptr); /* Else the message has probably been garbled */
8000ee00:	4d b6       	lddpc	r6,8000ef6c <PmsTxRelease+0x2c4>
8000ee02:	0c 33       	cp.w	r3,r6
8000ee04:	c0 a0       	breq	8000ee18 <PmsTxRelease+0x170>
8000ee06:	e0 68 01 c6 	mov	r8,454
8000ee0a:	30 1a       	mov	r10,1
8000ee0c:	1a d8       	st.w	--sp,r8
8000ee0e:	31 0b       	mov	r11,16
8000ee10:	14 9c       	mov	r12,r10
8000ee12:	fe b0 c6 6d 	rcall	80007aec <mns_trace>
8000ee16:	2f fd       	sub	sp,-4

            pending_ptr = (MbmBuf *)_PMS_ALLOC_SHADOW();
8000ee18:	4d bc       	lddpc	r12,8000ef84 <PmsTxRelease+0x2dc>
8000ee1a:	fe b0 d9 53 	rcall	8000a0c0 <_MbmDequeue>
8000ee1e:	18 94       	mov	r4,r12
             * were no shadows available and this is the only place where
             * they are allocated it is not is not possible that NULL is
             * returned unless the system is experiencing som serious
             * problem
             */
            ASSERT(pending_ptr);
8000ee20:	e0 80 00 96 	breq	8000ef4c <PmsTxRelease+0x2a4>
            ((MbmShadow *)pending_ptr)->real_ptr = handle;
8000ee24:	89 47       	st.w	r4[0x10],r7

            if( handle->type & MBM_STAT_TX_LAST_SEG )
8000ee26:	8e e2       	ld.uh	r2,r7[0xc]
8000ee28:	e2 12 00 40 	andl	r2,0x40,COH
8000ee2c:	c0 50       	breq	8000ee36 <PmsTxRelease+0x18e>
            {
                /* Shadow of the last segment */
                pending_ptr->type |= MBM_STAT_TX_LAST_SEG;
8000ee2e:	88 68       	ld.sh	r8,r4[0xc]
8000ee30:	a7 a8       	sbr	r8,0x6
8000ee32:	a8 68       	st.h	r4[0xc],r8
8000ee34:	c7 9b       	rjmp	8000ed26 <PmsTxRelease+0x7e>
            {
                /* Prepare & enqueue the next segment */
                HMBMBUF     hCur;

                /* This shadow does not reference the last segment */
                pending_ptr->type &= (word)~MBM_STAT_TX_LAST_SEG;
8000ee36:	88 68       	ld.sh	r8,r4[0xc]
8000ee38:	a7 c8       	cbr	r8,0x6
8000ee3a:	a8 68       	st.h	r4[0xc],r8

    /*
     * Check if the message is segmented by checking the telId of the
     * compressed headers (if it is 1-3 it is segmented).
     */
    head_ptr = MBM_GET_HDR_PTR(handle); /* Buffer start    */
8000ee3c:	6e a8       	ld.w	r8,r7[0x28]
    /**
     * Get index to length-field as:
     * sizeof(PML) + PMHL + sizeof(PMHL) + sizeof(FuncID + Op)
     * => PMHL + 5
     */
    i = (head_ptr[2] + (byte)5);
8000ee3e:	11 ab       	ld.ub	r11,r8[0x2]
8000ee40:	2f bb       	sub	r11,-5
8000ee42:	5c 5b       	castu.b	r11

    cmsg_ptr = MBM_GET_CTRL_TX_PTR(handle);

    if ((head_ptr[i] & (byte)0xF0) == (byte)0x40)
8000ee44:	f0 0b 00 0a 	add	r10,r8,r11
8000ee48:	15 89       	ld.ub	r9,r10[0x0]
8000ee4a:	e2 19 00 f0 	andl	r9,0xf0,COH
8000ee4e:	e0 49 00 40 	cp.w	r9,64
8000ee52:	c7 50       	breq	8000ef3c <PmsTxRelease+0x294>
        (void)_PmsCompressHeaderMCM(handle, MNS_FALSE);
    }
    else
    {
        /* 1. Set payload pointer (add max payload - 1 for Message counter) */
        MBM_GET_PAYLOAD_PTR(handle) += (PMS_CTRL_MAX_PAYLOAD - 1);
8000ee54:	6e b9       	ld.w	r9,r7[0x2c]

        /* 2. Calculate remaining length (add 1 for Message Counter) */
        len = (word)((cmsg_ptr->Length - (MBM_GET_PAYLOAD_PTR(handle) - cmsg_ptr->Data)) + (word)1);
8000ee56:	ef 02 00 18 	ld.sh	r2,r7[24]
        (void)_PmsCompressHeaderMCM(handle, MNS_FALSE);
    }
    else
    {
        /* 1. Set payload pointer (add max payload - 1 for Message counter) */
        MBM_GET_PAYLOAD_PTR(handle) += (PMS_CTRL_MAX_PAYLOAD - 1);
8000ee5a:	2d 49       	sub	r9,-44

        /* 2. Calculate remaining length (add 1 for Message Counter) */
        len = (word)((cmsg_ptr->Length - (MBM_GET_PAYLOAD_PTR(handle) - cmsg_ptr->Data)) + (word)1);
8000ee5c:	6e 5c       	ld.w	r12,r7[0x14]
        (void)_PmsCompressHeaderMCM(handle, MNS_FALSE);
    }
    else
    {
        /* 1. Set payload pointer (add max payload - 1 for Message counter) */
        MBM_GET_PAYLOAD_PTR(handle) += (PMS_CTRL_MAX_PAYLOAD - 1);
8000ee5e:	8f b9       	st.w	r7[0x2c],r9

        /* 2. Calculate remaining length (add 1 for Message Counter) */
        len = (word)((cmsg_ptr->Length - (MBM_GET_PAYLOAD_PTR(handle) - cmsg_ptr->Data)) + (word)1);
8000ee60:	e4 0c 00 0c 	add	r12,r2,r12
8000ee64:	f8 09 01 09 	sub	r9,r12,r9

        /* 3. Set tel_id & length */
        if( len > (word)PMS_CTRL_MAX_PAYLOAD )
8000ee68:	32 d2       	mov	r2,45
    {
        /* 1. Set payload pointer (add max payload - 1 for Message counter) */
        MBM_GET_PAYLOAD_PTR(handle) += (PMS_CTRL_MAX_PAYLOAD - 1);

        /* 2. Calculate remaining length (add 1 for Message Counter) */
        len = (word)((cmsg_ptr->Length - (MBM_GET_PAYLOAD_PTR(handle) - cmsg_ptr->Data)) + (word)1);
8000ee6a:	f9 d9 b0 10 	bfexts	r12,r9,0x0,0x10
8000ee6e:	f8 c9 ff ff 	sub	r9,r12,-1
8000ee72:	5c 89       	casts.h	r9

        /* 3. Set tel_id & length */
        if( len > (word)PMS_CTRL_MAX_PAYLOAD )
8000ee74:	e4 09 19 00 	cp.h	r9,r2
8000ee78:	e0 8b 00 5f 	brhi	8000ef36 <PmsTxRelease+0x28e>
            /* Last segment */
            word old_len;
            word pml;

            /* Mark as last to avoid another prepare */
            MBM_SET_STATUS_BITS(handle, MBM_STAT_TX_LAST_SEG);
8000ee7c:	8e 62       	ld.sh	r2,r7[0xc]
8000ee7e:	a7 a2       	sbr	r2,0x6
8000ee80:	ae 62       	st.h	r7[0xc],r2

            /* Calculate and possibly set different PML */
            DECODE_WORD(&pml, head_ptr);
8000ee82:	f0 c2 ff ff 	sub	r2,r8,-1
            DECODE_WORD(&old_len, &head_ptr[i]);
            old_len &= (word)0x0FFF;
            pml -= (word)(old_len - len);
8000ee86:	11 81       	ld.ub	r1,r8[0x0]
8000ee88:	05 8e       	ld.ub	lr,r2[0x0]
8000ee8a:	fd e1 10 81 	or	r1,lr,r1<<0x8
8000ee8e:	12 01       	add	r1,r9
8000ee90:	15 80       	ld.ub	r0,r10[0x0]
8000ee92:	15 9e       	ld.ub	lr,r10[0x1]
8000ee94:	fd e0 10 8e 	or	lr,lr,r0<<0x8
8000ee98:	fd de c0 0c 	bfextu	lr,lr,0x0,0xc
8000ee9c:	e2 0e 01 0e 	sub	lr,r1,lr
8000eea0:	5c 8e       	casts.h	lr
            head_ptr[0] = HB(pml);
8000eea2:	e3 de c1 08 	bfextu	r1,lr,0x8,0x8
8000eea6:	b0 81       	st.b	r8[0x0],r1
            head_ptr[1] = LB(pml);
8000eea8:	a4 8e       	st.b	r2[0x0],lr
             * Set length of additional data, subtract 1 since Message
             * Counter is located with the headers.
             */
            MBM_SET_PAYLOAD_LEN(handle, (len - (word)1));

            len |= (word)0x3000;
8000eeaa:	e8 19 30 00 	orl	r9,0x3000

            /**
             * Set length of additional data, subtract 1 since Message
             * Counter is located with the headers.
             */
            MBM_SET_PAYLOAD_LEN(handle, (len - (word)1));
8000eeae:	ef 5c 00 34 	st.h	r7[52],r12

            len |= (word)0x3000;
8000eeb2:	f9 d9 c0 08 	bfextu	r12,r9,0x0,0x8
8000eeb6:	f3 d9 c1 08 	bfextu	r9,r9,0x8,0x8
        }
        /* Write new length + tel_id directly to message buffer */
        head_ptr[i++] = HB(len);
8000eeba:	b4 89       	st.b	r10[0x0],r9
8000eebc:	2f fb       	sub	r11,-1
8000eebe:	5c 5b       	castu.b	r11
        head_ptr[i++] = LB(len);
8000eec0:	f0 0b 0b 0c 	st.b	r8[r11],r12

        /* 3. Increment Message Counter */
        head_ptr[i] += (byte)1;
8000eec4:	2f fb       	sub	r11,-1
8000eec6:	5c 5b       	castu.b	r11
8000eec8:	16 08       	add	r8,r11
8000eeca:	11 89       	ld.ub	r9,r8[0x0]
8000eecc:	2f f9       	sub	r9,-1
8000eece:	b0 89       	st.b	r8[0x0],r9
                /* This shadow does not reference the last segment */
                pending_ptr->type &= (word)~MBM_STAT_TX_LAST_SEG;

                _PmsTxNextSegment(handle);

                hCur = mcmFifo.msgQ.next_ptr;
8000eed0:	6c 08       	ld.w	r8,r6[0x0]
                /* Do not overtake messages that has bypassed */
                while( ((HMBMBUF)&mcmFifo.msgQ != hCur) && (hCur->type & MBM_STAT_TX_BYPASS) )
8000eed2:	4a 7a       	lddpc	r10,8000ef6c <PmsTxRelease+0x2c4>
8000eed4:	0c 38       	cp.w	r8,r6
8000eed6:	c0 51       	brne	8000eee0 <PmsTxRelease+0x238>
8000eed8:	c0 88       	rjmp	8000eee8 <PmsTxRelease+0x240>
                {
                    hCur = hCur->next_ptr;
8000eeda:	70 08       	ld.w	r8,r8[0x0]

                _PmsTxNextSegment(handle);

                hCur = mcmFifo.msgQ.next_ptr;
                /* Do not overtake messages that has bypassed */
                while( ((HMBMBUF)&mcmFifo.msgQ != hCur) && (hCur->type & MBM_STAT_TX_BYPASS) )
8000eedc:	14 38       	cp.w	r8,r10
8000eede:	c0 50       	breq	8000eee8 <PmsTxRelease+0x240>
8000eee0:	90 e9       	ld.uh	r9,r8[0xc]
8000eee2:	ed b9 00 08 	bld	r9,0x8
8000eee6:	cf a0       	breq	8000eeda <PmsTxRelease+0x232>
                {
                    hCur = hCur->next_ptr;
                }

                /* Enqueue before wherever we stopped... */
                _MbmEnqueueBehind(&mcmFifo.msgQ, hCur->prev_ptr, handle);
8000eee8:	70 1b       	ld.w	r11,r8[0x4]
8000eeea:	0e 9a       	mov	r10,r7
8000eeec:	4a 0c       	lddpc	r12,8000ef6c <PmsTxRelease+0x2c4>
8000eeee:	fe b0 d7 5f 	rcall	80009dac <_MbmEnqueueBehind>
8000eef2:	c1 ab       	rjmp	8000ed26 <PmsTxRelease+0x7e>
            MBM_CLR_STATUS_BITS(handle, MBM_STAT_RSVD);

            #ifdef PMS_RX_SEND_ACK
            if (pms.needRetriggerAck)
            {
                pms.needRetriggerAck = 0;
8000eef4:	30 03       	mov	r3,0
8000eef6:	e0 64 00 80 	mov	r4,128
8000eefa:	f3 d3 d3 61 	bfins	r9,r3,0x1b,0x1
8000eefe:	49 b5       	lddpc	r5,8000ef68 <PmsTxRelease+0x2c0>
8000ef00:	91 09       	st.w	r8[0x0],r9
8000ef02:	c1 cb       	rjmp	8000ed3a <PmsTxRelease+0x92>
    T_API_ENTRY(PMS_1);

    events = (word)0;
    free   = MNS_FALSE;

    ASSERT(handle);
8000ef04:	e0 68 01 98 	mov	r8,408
8000ef08:	30 1a       	mov	r10,1
8000ef0a:	1a d8       	st.w	--sp,r8
8000ef0c:	31 0b       	mov	r11,16
8000ef0e:	14 9c       	mov	r12,r10
8000ef10:	fe b0 c5 ee 	rcall	80007aec <mns_trace>
8000ef14:	2f fd       	sub	sp,-4
8000ef16:	d8 32       	popm	r0-r7,pc
    {
        /* Command message, free immediately */
        if( cmdRsvd == handle )
        {
            /* This was the Command message dedicated to SyncC */
            cmdFree = handle; /* Or cmdRsvd... same, same... */
8000ef18:	49 c8       	lddpc	r8,8000ef88 <PmsTxRelease+0x2e0>
8000ef1a:	30 03       	mov	r3,0
8000ef1c:	91 07       	st.w	r8[0x0],r7
8000ef1e:	49 35       	lddpc	r5,8000ef68 <PmsTxRelease+0x2c0>
8000ef20:	06 94       	mov	r4,r3
8000ef22:	c0 cb       	rjmp	8000ed3a <PmsTxRelease+0x92>
    else
  #else
    /* Only control messages are allowed */
    ASSERT(MBM_TYPE_CTRL == (MBM_GET_TYPE(tx_handle) & MBM_TYPE_MSG_MASK));
  #endif
    if( (MSG_TGT_INIC == cmsg_ptr->Tgt_Adr) && (FBLOCK_INIC == cmsg_ptr->FBlock_ID) )
8000ef24:	ef 38 00 1e 	ld.ub	r8,r7[30]
8000ef28:	f2 08 18 00 	cp.b	r8,r9
8000ef2c:	fe 91 fe f1 	brne	8000ed0e <PmsTxRelease+0x66>
8000ef30:	48 e5       	lddpc	r5,8000ef68 <PmsTxRelease+0x2c0>
8000ef32:	0a 93       	mov	r3,r5
8000ef34:	cf 1a       	rjmp	8000ed16 <PmsTxRelease+0x6e>

        /* 2. Calculate remaining length (add 1 for Message Counter) */
        len = (word)((cmsg_ptr->Length - (MBM_GET_PAYLOAD_PTR(handle) - cmsg_ptr->Data)) + (word)1);

        /* 3. Set tel_id & length */
        if( len > (word)PMS_CTRL_MAX_PAYLOAD )
8000ef36:	32 dc       	mov	r12,45
8000ef38:	32 09       	mov	r9,32
8000ef3a:	cc 0b       	rjmp	8000eeba <PmsTxRelease+0x212>
    cmsg_ptr = MBM_GET_CTRL_TX_PTR(handle);

    if ((head_ptr[i] & (byte)0xF0) == (byte)0x40)
    {
        /* previous message was TelID 0x4 */
        MbmPullHeaders(handle);
8000ef3c:	0e 9c       	mov	r12,r7
8000ef3e:	fe b0 d6 bd 	rcall	80009cb8 <MbmPullHeaders>
        (void)_PmsCompressHeaderMCM(handle, MNS_FALSE);
8000ef42:	04 9b       	mov	r11,r2
8000ef44:	0e 9c       	mov	r12,r7
8000ef46:	fe b0 ee a7 	rcall	8000cc94 <_PmsCompressHeaderMCM>
8000ef4a:	cc 3b       	rjmp	8000eed0 <PmsTxRelease+0x228>
             * were no shadows available and this is the only place where
             * they are allocated it is not is not possible that NULL is
             * returned unless the system is experiencing som serious
             * problem
             */
            ASSERT(pending_ptr);
8000ef4c:	e0 68 01 d0 	mov	r8,464
8000ef50:	30 1a       	mov	r10,1
8000ef52:	1a d8       	st.w	--sp,r8
8000ef54:	31 0b       	mov	r11,16
8000ef56:	14 9c       	mov	r12,r10
8000ef58:	fe b0 c5 ca 	rcall	80007aec <mns_trace>
8000ef5c:	2f fd       	sub	sp,-4
8000ef5e:	c6 3b       	rjmp	8000ee24 <PmsTxRelease+0x17c>
8000ef60:	00 00       	add	r0,r0
8000ef62:	37 08       	mov	r8,112
8000ef64:	00 00       	add	r0,r0
8000ef66:	37 d4       	mov	r4,125
8000ef68:	00 00       	add	r0,r0
8000ef6a:	39 14       	mov	r4,-111
8000ef6c:	00 00       	add	r0,r0
8000ef6e:	38 8c       	mov	r12,-120
8000ef70:	00 00       	add	r0,r0
8000ef72:	36 e0       	mov	r0,110
8000ef74:	00 00       	add	r0,r0
8000ef76:	38 3c       	mov	r12,-125
8000ef78:	00 00       	add	r0,r0
8000ef7a:	38 84       	mov	r4,-120
8000ef7c:	00 00       	add	r0,r0
8000ef7e:	37 0c       	mov	r12,112
8000ef80:	00 00       	add	r0,r0
8000ef82:	37 b0       	mov	r0,123
8000ef84:	00 00       	add	r0,r0
8000ef86:	38 28       	mov	r8,-126
8000ef88:	00 00       	add	r0,r0
8000ef8a:	37 d0       	mov	r0,125

8000ef8c <VmsvGetNCStateShutdown>:
  *
  * @return     MNS_TRUE if the mns.config.general.wakeup_query_fptr shall be
  *             called.
  */
bool VmsvGetNCStateShutdown(void)
{
8000ef8c:	48 38       	lddpc	r8,8000ef98 <VmsvGetNCStateShutdown+0xc>
8000ef8e:	f1 3c 00 2e 	ld.ub	r12,r8[46]
    T_LIB_ENTRY(VMSV_33);
    T_LIB_EXIT(VMSV_33);

    return((NCS_SHUTDOWN_MASK & vmsv.shadow.ncstate_flags) ? MNS_TRUE : MNS_FALSE);
}
8000ef92:	f9 dc c0 21 	bfextu	r12,r12,0x1,0x1
8000ef96:	5e fc       	retal	r12
8000ef98:	00 00       	add	r0,r0
8000ef9a:	39 9c       	mov	r12,-103

8000ef9c <VmsvPhysicalLayerTestActive>:
#endif


#ifdef VMSV_102
bool VmsvPhysicalLayerTestActive(void)
{
8000ef9c:	eb cd 40 80 	pushm	r7,lr

    T_LIB_ENTRY(VMSV_102);

    ret_val = MNS_FALSE;

    TAKE_VMSV();
8000efa0:	31 1c       	mov	r12,17
8000efa2:	fe b0 c5 8a 	rcall	80007ab6 <mns_take>
}
#endif


#ifdef VMSV_102
bool VmsvPhysicalLayerTestActive(void)
8000efa6:	48 78       	lddpc	r8,8000efc0 <VmsvPhysicalLayerTestActive+0x24>
8000efa8:	f1 39 00 81 	ld.ub	r9,r8[129]
8000efac:	30 08       	mov	r8,0
    TAKE_VMSV();
    if (VMSV_PLT_OFF != vmsv.plt.test_state)
    {
        ret_val = MNS_TRUE;
    }
    GIVE_VMSV();
8000efae:	31 1c       	mov	r12,17
}
#endif


#ifdef VMSV_102
bool VmsvPhysicalLayerTestActive(void)
8000efb0:	f0 09 18 00 	cp.b	r9,r8
8000efb4:	5f 17       	srne	r7
    TAKE_VMSV();
    if (VMSV_PLT_OFF != vmsv.plt.test_state)
    {
        ret_val = MNS_TRUE;
    }
    GIVE_VMSV();
8000efb6:	fe b0 c5 81 	rcall	80007ab8 <mns_give>


    T_LIB_EXIT(VMSV_102);

    return(ret_val);
}
8000efba:	0e 9c       	mov	r12,r7
8000efbc:	e3 cd 80 80 	ldm	sp++,r7,pc
8000efc0:	00 00       	add	r0,r0
8000efc2:	39 9c       	mov	r12,-103

8000efc4 <VmsvPhysicalLayerTestResult>:
8000efc4:	eb cd 40 e0 	pushm	r5-r7,lr
8000efc8:	18 97       	mov	r7,r12
8000efca:	16 95       	mov	r5,r11
{
    bool valid;

    T_LIB_ENTRY(VMSV_96);

    TAKE_VMSV();
8000efcc:	31 1c       	mov	r12,17
8000efce:	fe b0 c5 74 	rcall	80007ab6 <mns_take>
    valid =  vmsv.plt.test_done;
8000efd2:	48 a8       	lddpc	r8,8000eff8 <VmsvPhysicalLayerTestResult+0x34>
8000efd4:	f1 36 00 74 	ld.ub	r6,r8[116]
    if (MNS_FALSE != valid)
    {
        *num_errors  = (dword)vmsv.plr.err_count;
8000efd8:	58 06       	cp.w	r6,0
8000efda:	f1 f9 14 4d 	ld.uhne	r9,r8[0x9a]
8000efde:	eb f9 1a 00 	st.wne	r5[0x0],r9
        *lock_status = vmsv.plr.lock_status;
8000efe2:	f1 f8 18 98 	ld.ubne	r8,r8[0x98]
8000efe6:	ef f8 1e 00 	st.bne	r7[0x0],r8
    }
    GIVE_VMSV();
8000efea:	31 1c       	mov	r12,17
8000efec:	fe b0 c5 66 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(VMSV_96);

    return(valid);
}
8000eff0:	0c 9c       	mov	r12,r6
8000eff2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000eff6:	d7 03       	nop
8000eff8:	00 00       	add	r0,r0
8000effa:	39 9c       	mov	r12,-103

8000effc <VmsvHandleFBlockIDsGet>:
8000effc:	d4 01       	pushm	lr
8000effe:	31 1c       	mov	r12,17
8000f000:	fe b0 c5 5b 	rcall	80007ab6 <mns_take>
void VmsvHandleFBlockIDsGet(void)
{
    T_LIB_ENTRY(VMSV_36);

    TAKE_VMSV();
    if (VMSV_CP_WAITING == vmsv.check_phase.state)
8000f004:	48 98       	lddpc	r8,8000f028 <VmsvHandleFBlockIDsGet+0x2c>
8000f006:	30 29       	mov	r9,2
8000f008:	f1 3a 00 5c 	ld.ub	r10,r8[92]
    {
        vmsv.check_phase.state = VMSV_CP_DO_NOTHING;
8000f00c:	f2 0a 18 00 	cp.b	r10,r9
8000f010:	f9 b9 00 00 	moveq	r9,0
8000f014:	f1 f9 0e 5c 	st.beq	r8[0x5c],r9
    }
    vmsv.fblock_ids_get_received = MNS_TRUE;
8000f018:	30 19       	mov	r9,1
    GIVE_VMSV();
8000f01a:	31 1c       	mov	r12,17
    TAKE_VMSV();
    if (VMSV_CP_WAITING == vmsv.check_phase.state)
    {
        vmsv.check_phase.state = VMSV_CP_DO_NOTHING;
    }
    vmsv.fblock_ids_get_received = MNS_TRUE;
8000f01c:	f1 69 00 61 	st.b	r8[97],r9
    GIVE_VMSV();
8000f020:	fe b0 c5 4c 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(VMSV_36);
}
8000f024:	d8 02       	popm	pc
8000f026:	d7 03       	nop
8000f028:	00 00       	add	r0,r0
8000f02a:	39 9c       	mov	r12,-103

8000f02c <MostGetNCState>:
8000f02c:	eb cd 40 80 	pushm	r7,lr
8000f030:	31 1c       	mov	r12,17
8000f032:	fe b0 c5 42 	rcall	80007ab6 <mns_take>
{
    byte temp;
    T_API_ENTRY(VMSV_9);

    TAKE_VMSV();
    temp = vmsv.shadow.ncstate;
8000f036:	48 58       	lddpc	r8,8000f048 <MostGetNCState+0x1c>
    GIVE_VMSV();
8000f038:	31 1c       	mov	r12,17
{
    byte temp;
    T_API_ENTRY(VMSV_9);

    TAKE_VMSV();
    temp = vmsv.shadow.ncstate;
8000f03a:	f1 37 00 2d 	ld.ub	r7,r8[45]
    GIVE_VMSV();
8000f03e:	fe b0 c5 3d 	rcall	80007ab8 <mns_give>

    T_API_EXIT(VMSV_9);
    return(temp);
}
8000f042:	0e 9c       	mov	r12,r7
8000f044:	e3 cd 80 80 	ldm	sp++,r7,pc
8000f048:	00 00       	add	r0,r0
8000f04a:	39 9c       	mov	r12,-103

8000f04c <MostGetDevMode>:
8000f04c:	eb cd 40 80 	pushm	r7,lr
8000f050:	31 1c       	mov	r12,17
8000f052:	fe b0 c5 32 	rcall	80007ab6 <mns_take>
{
    byte state;

    T_API_ENTRY(VMSV_8);
    TAKE_VMSV();
    state = vmsv.shadow.devmode;
8000f056:	48 58       	lddpc	r8,8000f068 <MostGetDevMode+0x1c>
    GIVE_VMSV();
8000f058:	31 1c       	mov	r12,17
{
    byte state;

    T_API_ENTRY(VMSV_8);
    TAKE_VMSV();
    state = vmsv.shadow.devmode;
8000f05a:	f1 37 00 2c 	ld.ub	r7,r8[44]
    GIVE_VMSV();
8000f05e:	fe b0 c5 2d 	rcall	80007ab8 <mns_give>
    T_API_EXIT(VMSV_8);

    return(state);
}
8000f062:	0e 9c       	mov	r12,r7
8000f064:	e3 cd 80 80 	ldm	sp++,r7,pc
8000f068:	00 00       	add	r0,r0
8000f06a:	39 9c       	mov	r12,-103

8000f06c <VmsvRequestNIWakeUpMode>:
8000f06c:	d4 01       	pushm	lr
8000f06e:	30 0c       	mov	r12,0
8000f070:	fe b0 cf 16 	rcall	80008e9c <MsgGetTxPtrExt>
    T_MOD_ENTRY(VMSV_92);

    result  = ERR_NO;
    msg_ptr = MsgGetTxPtrExt(0);

    if (msg_ptr)
8000f074:	c0 d0       	breq	8000f08e <VmsvRequestNIWakeUpMode+0x22>
    {
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000f076:	30 09       	mov	r9,0
8000f078:	f9 69 00 0a 	st.b	r12[10],r9
        msg_ptr->Func_ID   = FUNCID_INIC_NIWAKEUPMODE;
8000f07c:	e0 69 05 0b 	mov	r9,1291
8000f080:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_GET;
8000f082:	30 19       	mov	r9,1
8000f084:	f9 69 00 0c 	st.b	r12[12],r9

        MsgSend3(msg_ptr);
8000f088:	fe b0 d2 4e 	rcall	80009524 <MsgSend3>
8000f08c:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_REQUEST_NIWAKEUPMODE);
8000f08e:	31 0c       	mov	r12,16
8000f090:	fe b0 c5 13 	rcall	80007ab6 <mns_take>
8000f094:	48 69       	lddpc	r9,8000f0ac <VmsvRequestNIWakeUpMode+0x40>
8000f096:	f3 08 00 64 	ld.sh	r8,r9[100]
8000f09a:	a7 a8       	sbr	r8,0x6
8000f09c:	31 0c       	mov	r12,16
8000f09e:	f3 58 00 64 	st.h	r9[100],r8
8000f0a2:	fe b0 c5 0b 	rcall	80007ab8 <mns_give>
8000f0a6:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(VMSV_92);
    return(result);
}
8000f0a8:	d8 02       	popm	pc
8000f0aa:	d7 03       	nop
8000f0ac:	00 00       	add	r0,r0
8000f0ae:	39 9c       	mov	r12,-103

8000f0b0 <VmsvResetINICSSOResult>:
8000f0b0:	d4 01       	pushm	lr
8000f0b2:	30 1c       	mov	r12,1
8000f0b4:	fe b0 ce f4 	rcall	80008e9c <MsgGetTxPtrExt>
8000f0b8:	c1 00       	breq	8000f0d8 <VmsvResetINICSSOResult+0x28>
8000f0ba:	30 1a       	mov	r10,1
8000f0bc:	30 09       	mov	r9,0
8000f0be:	b8 3a       	st.h	r12[0x6],r10
    /* reset SSO result in INIC */
    msg_ptr = MsgGetTxPtrExt(1);
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000f0c0:	f9 69 00 0a 	st.b	r12[10],r9
        msg_ptr->Func_ID   = FUNCID_INIC_SSORESULT;
        msg_ptr->Operation = OP_SET;
8000f0c4:	f9 69 00 0c 	st.b	r12[12],r9
        msg_ptr->Data[0]   = SDR_NO_RESULT;
8000f0c8:	78 08       	ld.w	r8,r12[0x0]
    msg_ptr = MsgGetTxPtrExt(1);
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_SSORESULT;
8000f0ca:	e0 6a 05 13 	mov	r10,1299
8000f0ce:	b8 4a       	st.h	r12[0x8],r10
        msg_ptr->Operation = OP_SET;
        msg_ptr->Data[0]   = SDR_NO_RESULT;
8000f0d0:	b0 89       	st.b	r8[0x0],r9

        MsgSend3(msg_ptr);
8000f0d2:	fe b0 d2 29 	rcall	80009524 <MsgSend3>
8000f0d6:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_SSORESULT);
8000f0d8:	31 0c       	mov	r12,16
8000f0da:	fe b0 c4 ee 	rcall	80007ab6 <mns_take>
8000f0de:	48 69       	lddpc	r9,8000f0f4 <VmsvResetINICSSOResult+0x44>
8000f0e0:	f3 08 00 64 	ld.sh	r8,r9[100]
8000f0e4:	a9 b8       	sbr	r8,0x9
8000f0e6:	31 0c       	mov	r12,16
8000f0e8:	f3 58 00 64 	st.h	r9[100],r8
8000f0ec:	fe b0 c4 e6 	rcall	80007ab8 <mns_give>
8000f0f0:	30 4c       	mov	r12,4
    }

    T_MOD_EXIT(VMSV_99);

    return(result);
}
8000f0f2:	d8 02       	popm	pc
8000f0f4:	00 00       	add	r0,r0
8000f0f6:	39 9c       	mov	r12,-103

8000f0f8 <VmsvResetSSOResult>:
8000f0f8:	eb cd 40 80 	pushm	r7,lr
8000f0fc:	31 1c       	mov	r12,17
8000f0fe:	fe b0 c4 dc 	rcall	80007ab6 <mns_take>
8000f102:	30 08       	mov	r8,0
8000f104:	48 87       	lddpc	r7,8000f124 <VmsvResetSSOResult+0x2c>
8000f106:	31 1c       	mov	r12,17
    T_API_ENTRY(VMSV_87);

    ssoresult = SDR_NO_RESULT;

    TAKE_VMSV();
    vmsv.shadow.ssoresult = ssoresult;
8000f108:	ef 68 00 2b 	st.b	r7[43],r8
    GIVE_VMSV();
8000f10c:	fe b0 c4 d6 	rcall	80007ab8 <mns_give>

    /* store ssoresult in nonvolatile memory */
    if (vmsv.cfg_ptr->sso_store_ssoresult_fptr)
8000f110:	6e f8       	ld.w	r8,r7[0x3c]
8000f112:	70 88       	ld.w	r8,r8[0x20]
8000f114:	58 08       	cp.w	r8,0
8000f116:	c0 30       	breq	8000f11c <VmsvResetSSOResult+0x24>
    {
        vmsv.cfg_ptr->sso_store_ssoresult_fptr(ssoresult);
8000f118:	30 0c       	mov	r12,0
8000f11a:	5d 18       	icall	r8
    }

    (void)VmsvResetINICSSOResult();
8000f11c:	cc af       	rcall	8000f0b0 <VmsvResetINICSSOResult>
8000f11e:	e3 cd 80 80 	ldm	sp++,r7,pc

    T_API_EXIT(VMSV_87);
}
8000f122:	d7 03       	nop
8000f124:	00 00       	add	r0,r0
8000f126:	39 9c       	mov	r12,-103

8000f128 <VmsvRequestNetOnTime>:
8000f128:	d4 01       	pushm	lr
8000f12a:	30 0c       	mov	r12,0
8000f12c:	fe b0 ce b8 	rcall	80008e9c <MsgGetTxPtrExt>
8000f130:	c0 d0       	breq	8000f14a <VmsvRequestNetOnTime+0x22>
8000f132:	30 09       	mov	r9,0

    result  = ERR_NO;
    msg_ptr = MsgGetTxPtrExt(0);
    if (msg_ptr)
    {
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000f134:	f9 69 00 0a 	st.b	r12[10],r9
        msg_ptr->Func_ID   = FUNCID_INIC_NETONTIMER;
8000f138:	e0 69 05 12 	mov	r9,1298
8000f13c:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_GET;
8000f13e:	30 19       	mov	r9,1
8000f140:	f9 69 00 0c 	st.b	r12[12],r9

        MsgSend3(msg_ptr);
8000f144:	fe b0 d1 f0 	rcall	80009524 <MsgSend3>
8000f148:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_REQUEST_NETONTIMER);
8000f14a:	31 0c       	mov	r12,16
8000f14c:	fe b0 c4 b5 	rcall	80007ab6 <mns_take>
8000f150:	48 69       	lddpc	r9,8000f168 <VmsvRequestNetOnTime+0x40>
8000f152:	f3 08 00 64 	ld.sh	r8,r9[100]
8000f156:	a5 b8       	sbr	r8,0x5
8000f158:	31 0c       	mov	r12,16
8000f15a:	f3 58 00 64 	st.h	r9[100],r8
8000f15e:	fe b0 c4 ad 	rcall	80007ab8 <mns_give>
8000f162:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(VMSV_72);
    return(result);
}
8000f164:	d8 02       	popm	pc
8000f166:	d7 03       	nop
8000f168:	00 00       	add	r0,r0
8000f16a:	39 9c       	mov	r12,-103

8000f16c <VmsvSetNIWakeUpMode>:
8000f16c:	eb cd 40 c0 	pushm	r6-r7,lr
8000f170:	31 1c       	mov	r12,17
8000f172:	fe b0 c4 a2 	rcall	80007ab6 <mns_take>
8000f176:	49 66       	lddpc	r6,8000f1cc <VmsvSetNIWakeUpMode+0x60>
8000f178:	31 1c       	mov	r12,17
8000f17a:	ed 37 00 39 	ld.ub	r7,r6[57]

    result = ERR_NO;

    TAKE_VMSV();
    mode = vmsv.shadow.ni_wakeup_mode.request;
    GIVE_VMSV();
8000f17e:	fe b0 c4 9d 	rcall	80007ab8 <mns_give>

    if (INIC_SHADOW_INVALID_BYTE != mode)
8000f182:	3e e8       	mov	r8,-18
8000f184:	f0 07 18 00 	cp.b	r7,r8
8000f188:	c1 10       	breq	8000f1aa <VmsvSetNIWakeUpMode+0x3e>
    {
        msg_ptr = MsgGetTxPtrExt(1);
8000f18a:	30 1c       	mov	r12,1
8000f18c:	fe b0 ce 88 	rcall	80008e9c <MsgGetTxPtrExt>

        if (msg_ptr)
8000f190:	c0 f0       	breq	8000f1ae <VmsvSetNIWakeUpMode+0x42>
        {
            msg_ptr->FBlock_ID = FBLOCK_INIC;
8000f192:	30 09       	mov	r9,0
            msg_ptr->Func_ID   = FUNCID_INIC_NIWAKEUPMODE;
            msg_ptr->Operation = OP_SET;
            msg_ptr->Data[0]   = mode;
8000f194:	78 08       	ld.w	r8,r12[0x0]

        if (msg_ptr)
        {
            msg_ptr->FBlock_ID = FBLOCK_INIC;
            msg_ptr->Func_ID   = FUNCID_INIC_NIWAKEUPMODE;
            msg_ptr->Operation = OP_SET;
8000f196:	f9 69 00 0c 	st.b	r12[12],r9
    {
        msg_ptr = MsgGetTxPtrExt(1);

        if (msg_ptr)
        {
            msg_ptr->FBlock_ID = FBLOCK_INIC;
8000f19a:	f9 69 00 0a 	st.b	r12[10],r9
            msg_ptr->Func_ID   = FUNCID_INIC_NIWAKEUPMODE;
8000f19e:	e0 69 05 0b 	mov	r9,1291
8000f1a2:	b8 49       	st.h	r12[0x8],r9
            msg_ptr->Operation = OP_SET;
            msg_ptr->Data[0]   = mode;
8000f1a4:	b0 87       	st.b	r8[0x0],r7
            MsgSend3(msg_ptr);
8000f1a6:	fe b0 d1 bf 	rcall	80009524 <MsgSend3>
8000f1aa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
        }
        else
        {
            SCHEDULE_RETRY(VMSV_RETRY_SET_NIWAKEUPMODE);
8000f1ae:	31 0c       	mov	r12,16
8000f1b0:	fe b0 c4 83 	rcall	80007ab6 <mns_take>
8000f1b4:	ed 08 00 64 	ld.sh	r8,r6[100]
8000f1b8:	a7 b8       	sbr	r8,0x7
8000f1ba:	31 0c       	mov	r12,16
8000f1bc:	ed 58 00 64 	st.h	r6[100],r8
8000f1c0:	fe b0 c4 7c 	rcall	80007ab8 <mns_give>
8000f1c4:	30 4c       	mov	r12,4

    }

    T_MOD_EXIT(VMSV_93);
    return(result);
}
8000f1c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000f1ca:	d7 03       	nop
8000f1cc:	00 00       	add	r0,r0
8000f1ce:	39 9c       	mov	r12,-103

8000f1d0 <VmsvRequestSysErrMonitor>:
8000f1d0:	d4 01       	pushm	lr
8000f1d2:	30 0c       	mov	r12,0
8000f1d4:	fe b0 ce 64 	rcall	80008e9c <MsgGetTxPtrExt>
8000f1d8:	c0 e0       	breq	8000f1f4 <VmsvRequestSysErrMonitor+0x24>
8000f1da:	30 19       	mov	r9,1
8000f1dc:	f9 69 00 0c 	st.b	r12[12],r9

    result  = ERR_NO;
    msg_ptr = MsgGetTxPtrExt(0);
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000f1e0:	b8 39       	st.h	r12[0x6],r9
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000f1e2:	30 09       	mov	r9,0
8000f1e4:	f9 69 00 0a 	st.b	r12[10],r9
        msg_ptr->Func_ID   = FUNCID_INIC_SYSERRMONITOR;
8000f1e8:	e0 69 05 11 	mov	r9,1297
8000f1ec:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_GET;

        MsgSend3(msg_ptr);
8000f1ee:	fe b0 d1 9b 	rcall	80009524 <MsgSend3>
8000f1f2:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_SYSERRMONITOR);
8000f1f4:	31 0c       	mov	r12,16
8000f1f6:	fe b0 c4 60 	rcall	80007ab6 <mns_take>
8000f1fa:	48 69       	lddpc	r9,8000f210 <VmsvRequestSysErrMonitor+0x40>
8000f1fc:	f3 08 00 64 	ld.sh	r8,r9[100]
8000f200:	a3 a8       	sbr	r8,0x2
8000f202:	31 0c       	mov	r12,16
8000f204:	f3 58 00 64 	st.h	r9[100],r8
8000f208:	fe b0 c4 58 	rcall	80007ab8 <mns_give>
8000f20c:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(VMSV_55);
    return(result);
}
8000f20e:	d8 02       	popm	pc
8000f210:	00 00       	add	r0,r0
8000f212:	39 9c       	mov	r12,-103

8000f214 <MostSetDevMode>:
8000f214:	eb cd 40 80 	pushm	r7,lr
8000f218:	30 18       	mov	r8,1
8000f21a:	18 97       	mov	r7,r12
8000f21c:	f0 0c 18 00 	cp.b	r12,r8
8000f220:	e0 88 00 04 	brls	8000f228 <MostSetDevMode+0x14>

    T_API_ENTRY(VMSV_22);

    result  = ERR_NO;

    if ((MNS_SLAVE == mode)||(MNS_MASTER == mode))
8000f224:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
    {
        msg_ptr = MsgGetTxPtrExt(1);
8000f228:	30 1c       	mov	r12,1
8000f22a:	fe b0 ce 39 	rcall	80008e9c <MsgGetTxPtrExt>
        if (msg_ptr)
8000f22e:	c1 20       	breq	8000f252 <MostSetDevMode+0x3e>
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
8000f230:	30 0a       	mov	r10,0
    if ((MNS_SLAVE == mode)||(MNS_MASTER == mode))
    {
        msg_ptr = MsgGetTxPtrExt(1);
        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
8000f232:	30 19       	mov	r9,1
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_DEVICEMODE;
            msg_ptr->Operation  = OP_SET;
8000f234:	f9 6a 00 0c 	st.b	r12[12],r10
    if ((MNS_SLAVE == mode)||(MNS_MASTER == mode))
    {
        msg_ptr = MsgGetTxPtrExt(1);
        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
8000f238:	b8 39       	st.h	r12[0x6],r9
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
8000f23a:	f9 6a 00 0a 	st.b	r12[10],r10
            msg_ptr->Func_ID    = FUNCID_INIC_DEVICEMODE;
8000f23e:	e0 6a 05 02 	mov	r10,1282
8000f242:	b8 4a       	st.h	r12[0x8],r10
            msg_ptr->Operation  = OP_SET;
            msg_ptr->Data[0]    = mode;
8000f244:	78 0a       	ld.w	r10,r12[0x0]
8000f246:	b4 87       	st.b	r10[0x0],r7
            msg_ptr->Length     = (word)1;
8000f248:	b8 29       	st.h	r12[0x4],r9

            MsgSend3(msg_ptr);
8000f24a:	fe b0 d1 6d 	rcall	80009524 <MsgSend3>
8000f24e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    result  = ERR_NO;

    if ((MNS_SLAVE == mode)||(MNS_MASTER == mode))
    {
        msg_ptr = MsgGetTxPtrExt(1);
        if (msg_ptr)
8000f252:	30 4c       	mov	r12,4
8000f254:	e3 cd 80 80 	ldm	sp++,r7,pc

8000f258 <VmsvHandleCodingErrorsStatus>:
8000f258:	eb cd 40 80 	pushm	r7,lr
8000f25c:	18 97       	mov	r7,r12
8000f25e:	58 0c       	cp.w	r12,0
void VmsvHandleCodingErrorsStatus(TMsgRx *msg_ptr)
{

    T_LIB_ENTRY(VMSV_97);

    ASSERT(msg_ptr);
8000f260:	c1 70       	breq	8000f28e <VmsvHandleCodingErrorsStatus+0x36>

    TAKE_VMSV();
8000f262:	31 1c       	mov	r12,17
8000f264:	fe b0 c4 29 	rcall	80007ab6 <mns_take>
    if (VMSV_PLT_LEAD_OUT == vmsv.plt.test_state)
8000f268:	48 f8       	lddpc	r8,8000f2a4 <VmsvHandleCodingErrorsStatus+0x4c>
8000f26a:	30 69       	mov	r9,6
8000f26c:	f1 3a 00 81 	ld.ub	r10,r8[129]
8000f270:	f2 0a 18 00 	cp.b	r10,r9
8000f274:	c0 81       	brne	8000f284 <VmsvHandleCodingErrorsStatus+0x2c>
    {
        vmsv.plr.err_count = (word)((msg_ptr->Data[0] << 8) | (msg_ptr->Data[1]));
8000f276:	6e 09       	ld.w	r9,r7[0x0]
8000f278:	13 9a       	ld.ub	r10,r9[0x1]
8000f27a:	13 89       	ld.ub	r9,r9[0x0]
8000f27c:	f5 e9 10 89 	or	r9,r10,r9<<0x8
8000f280:	f1 59 00 9a 	st.h	r8[154],r9
    }
    GIVE_VMSV();
8000f284:	31 1c       	mov	r12,17
8000f286:	fe b0 c4 19 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(VMSV_97);
}
8000f28a:	e3 cd 80 80 	ldm	sp++,r7,pc
void VmsvHandleCodingErrorsStatus(TMsgRx *msg_ptr)
{

    T_LIB_ENTRY(VMSV_97);

    ASSERT(msg_ptr);
8000f28e:	e0 68 0e 5f 	mov	r8,3679
8000f292:	30 1a       	mov	r10,1
8000f294:	1a d8       	st.w	--sp,r8
8000f296:	31 0b       	mov	r11,16
8000f298:	34 0c       	mov	r12,64
8000f29a:	fe b0 c4 29 	rcall	80007aec <mns_trace>
8000f29e:	2f fd       	sub	sp,-4
8000f2a0:	ce 1b       	rjmp	8000f262 <VmsvHandleCodingErrorsStatus+0xa>
8000f2a2:	d7 03       	nop
8000f2a4:	00 00       	add	r0,r0
8000f2a6:	39 9c       	mov	r12,-103

8000f2a8 <VmsvHandleNIWakeupModeError>:
8000f2a8:	eb cd 40 80 	pushm	r7,lr
8000f2ac:	18 97       	mov	r7,r12
8000f2ae:	58 0c       	cp.w	r12,0
8000f2b0:	c1 50       	breq	8000f2da <VmsvHandleNIWakeupModeError+0x32>
8000f2b2:	6e 08       	ld.w	r8,r7[0x0]
void VmsvHandleNIWakeupModeError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_91);
    ASSERT(msg_ptr);

    if(ERR_NOTAVAILABLE == msg_ptr->Data[1])
8000f2b4:	11 99       	ld.ub	r9,r8[0x1]
8000f2b6:	34 18       	mov	r8,65
8000f2b8:	f0 09 18 00 	cp.b	r9,r8
8000f2bc:	c0 c0       	breq	8000f2d4 <VmsvHandleNIWakeupModeError+0x2c>
    {
        (void)VmsvRequestNIWakeUpMode();
    }
    else
    {
        FAILED_ASSERT();
8000f2be:	e0 68 0c bd 	mov	r8,3261
8000f2c2:	30 1a       	mov	r10,1
8000f2c4:	1a d8       	st.w	--sp,r8
8000f2c6:	31 0b       	mov	r11,16
8000f2c8:	34 0c       	mov	r12,64
8000f2ca:	fe b0 c4 11 	rcall	80007aec <mns_trace>
8000f2ce:	2f fd       	sub	sp,-4
8000f2d0:	e3 cd 80 80 	ldm	sp++,r7,pc
    T_LIB_ENTRY(VMSV_91);
    ASSERT(msg_ptr);

    if(ERR_NOTAVAILABLE == msg_ptr->Data[1])
    {
        (void)VmsvRequestNIWakeUpMode();
8000f2d4:	cc ce       	rcall	8000f06c <VmsvRequestNIWakeUpMode>
8000f2d6:	e3 cd 80 80 	ldm	sp++,r7,pc
8000f2da:	e0 68 0c b5 	mov	r8,3253
  * @return     void
  */
void VmsvHandleNIWakeupModeError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_91);
    ASSERT(msg_ptr);
8000f2de:	30 1a       	mov	r10,1
8000f2e0:	1a d8       	st.w	--sp,r8
8000f2e2:	31 0b       	mov	r11,16
8000f2e4:	34 0c       	mov	r12,64
8000f2e6:	fe b0 c4 03 	rcall	80007aec <mns_trace>
8000f2ea:	2f fd       	sub	sp,-4
8000f2ec:	ce 3b       	rjmp	8000f2b2 <VmsvHandleNIWakeupModeError+0xa>
8000f2ee:	d7 03       	nop

8000f2f0 <VmsvHandleNIWakeupModeStatus>:
8000f2f0:	eb cd 40 80 	pushm	r7,lr
8000f2f4:	18 97       	mov	r7,r12
8000f2f6:	58 0c       	cp.w	r12,0
  */
void VmsvHandleNIWakeupModeStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_90);

    ASSERT(msg_ptr);
8000f2f8:	c0 e0       	breq	8000f314 <VmsvHandleNIWakeupModeStatus+0x24>

    TAKE_VMSV();
8000f2fa:	31 1c       	mov	r12,17
8000f2fc:	fe b0 c3 dd 	rcall	80007ab6 <mns_take>
    vmsv.shadow.ni_wakeup_mode.mode = msg_ptr->Data[0];
8000f300:	6e 08       	ld.w	r8,r7[0x0]
8000f302:	11 89       	ld.ub	r9,r8[0x0]
8000f304:	48 98       	lddpc	r8,8000f328 <VmsvHandleNIWakeupModeStatus+0x38>
    GIVE_VMSV();
8000f306:	31 1c       	mov	r12,17
    T_LIB_ENTRY(VMSV_90);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.ni_wakeup_mode.mode = msg_ptr->Data[0];
8000f308:	f1 69 00 38 	st.b	r8[56],r9
    GIVE_VMSV();
8000f30c:	fe b0 c3 d6 	rcall	80007ab8 <mns_give>

    T_LIB_EXIT(VMSV_90);
}
8000f310:	e3 cd 80 80 	ldm	sp++,r7,pc
  */
void VmsvHandleNIWakeupModeStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_90);

    ASSERT(msg_ptr);
8000f314:	e0 68 0c 9e 	mov	r8,3230
8000f318:	30 1a       	mov	r10,1
8000f31a:	1a d8       	st.w	--sp,r8
8000f31c:	31 0b       	mov	r11,16
8000f31e:	34 0c       	mov	r12,64
8000f320:	fe b0 c3 e6 	rcall	80007aec <mns_trace>
8000f324:	2f fd       	sub	sp,-4
8000f326:	ce ab       	rjmp	8000f2fa <VmsvHandleNIWakeupModeStatus+0xa>
8000f328:	00 00       	add	r0,r0
8000f32a:	39 9c       	mov	r12,-103

8000f32c <VmsvHandleSSOResultError>:
8000f32c:	d4 01       	pushm	lr
8000f32e:	58 0c       	cp.w	r12,0
8000f330:	c0 20       	breq	8000f334 <VmsvHandleSSOResultError+0x8>
8000f332:	d8 02       	popm	pc
8000f334:	e0 68 0b fe 	mov	r8,3070
  */
void VmsvHandleSSOResultError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_86);
    #if (MNS_DEBUG & NST_C_ASSERTS)
    ASSERT(msg_ptr);
8000f338:	30 1a       	mov	r10,1
8000f33a:	1a d8       	st.w	--sp,r8
8000f33c:	31 0b       	mov	r11,16
8000f33e:	34 0c       	mov	r12,64
8000f340:	fe b0 c3 d6 	rcall	80007aec <mns_trace>
8000f344:	2f fd       	sub	sp,-4
8000f346:	d8 02       	popm	pc

8000f348 <VmsvHandleSSOResultStatus>:
8000f348:	eb cd 40 c0 	pushm	r6-r7,lr
  * @version    2.5.0
  *
  * @param      msg_ptr points to the actual received message.
  */
void VmsvHandleSSOResultStatus(TMsgRx *msg_ptr)
{
8000f34c:	18 97       	mov	r7,r12
    byte ssoresult;
    byte store;

    T_LIB_ENTRY(VMSV_85);

    ASSERT(msg_ptr);
8000f34e:	58 0c       	cp.w	r12,0
8000f350:	c3 20       	breq	8000f3b4 <VmsvHandleSSOResultStatus+0x6c>

    store     = MNS_FALSE;
    ssoresult = msg_ptr->Data[0];
8000f352:	6e 08       	ld.w	r8,r7[0x0]

    TAKE_VMSV();
8000f354:	31 1c       	mov	r12,17
    T_LIB_ENTRY(VMSV_85);

    ASSERT(msg_ptr);

    store     = MNS_FALSE;
    ssoresult = msg_ptr->Data[0];
8000f356:	11 87       	ld.ub	r7,r8[0x0]

    TAKE_VMSV();
8000f358:	fe b0 c3 af 	rcall	80007ab6 <mns_take>
    if (   ((SDR_NO_RESULT       == vmsv.shadow.ssoresult) && (vmsv.shadow.ssoresult <  ssoresult))
8000f35c:	49 b6       	lddpc	r6,8000f3c8 <VmsvHandleSSOResultStatus+0x80>
8000f35e:	30 19       	mov	r9,1
8000f360:	ed 38 00 2b 	ld.ub	r8,r6[43]
8000f364:	f2 08 18 00 	cp.b	r8,r9
8000f368:	e0 88 00 1f 	brls	8000f3a6 <VmsvHandleSSOResultStatus+0x5e>
8000f36c:	30 29       	mov	r9,2
8000f36e:	30 3a       	mov	r10,3
8000f370:	f2 07 18 00 	cp.b	r7,r9
8000f374:	5f 09       	sreq	r9
8000f376:	f4 08 18 00 	cp.b	r8,r10
8000f37a:	5f 08       	sreq	r8
8000f37c:	f3 e8 00 08 	and	r8,r9,r8
8000f380:	c0 e0       	breq	8000f39c <VmsvHandleSSOResultStatus+0x54>
        || ((SDR_NO_FAULT_SAVED  == vmsv.shadow.ssoresult) && (vmsv.shadow.ssoresult <  ssoresult))
        || ((SDR_CRITICAL_UNLOCK == vmsv.shadow.ssoresult) && (SDR_SUDDEN_SIGNAL_OFF == ssoresult)) )
    {
        vmsv.shadow.ssoresult = ssoresult;
8000f382:	ed 67 00 2b 	st.b	r6[43],r7
        store                 = MNS_TRUE;
    }
    GIVE_VMSV();
8000f386:	31 1c       	mov	r12,17
8000f388:	fe b0 c3 98 	rcall	80007ab8 <mns_give>

    /* store ssoresult in nonvolatile memory */
    if (store &&  vmsv.cfg_ptr->sso_store_ssoresult_fptr)
8000f38c:	6c f8       	ld.w	r8,r6[0x3c]
8000f38e:	70 88       	ld.w	r8,r8[0x20]
8000f390:	58 08       	cp.w	r8,0
8000f392:	c0 f0       	breq	8000f3b0 <VmsvHandleSSOResultStatus+0x68>
    {
        vmsv.cfg_ptr->sso_store_ssoresult_fptr(ssoresult);
8000f394:	0e 9c       	mov	r12,r7
8000f396:	5d 18       	icall	r8
8000f398:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        || ((SDR_CRITICAL_UNLOCK == vmsv.shadow.ssoresult) && (SDR_SUDDEN_SIGNAL_OFF == ssoresult)) )
    {
        vmsv.shadow.ssoresult = ssoresult;
        store                 = MNS_TRUE;
    }
    GIVE_VMSV();
8000f39c:	31 1c       	mov	r12,17
8000f39e:	fe b0 c3 8d 	rcall	80007ab8 <mns_give>
8000f3a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    store     = MNS_FALSE;
    ssoresult = msg_ptr->Data[0];

    TAKE_VMSV();
    if (   ((SDR_NO_RESULT       == vmsv.shadow.ssoresult) && (vmsv.shadow.ssoresult <  ssoresult))
8000f3a6:	f0 07 18 00 	cp.b	r7,r8
8000f3aa:	fe 9b ff ec 	brhi	8000f382 <VmsvHandleSSOResultStatus+0x3a>
8000f3ae:	cd fb       	rjmp	8000f36c <VmsvHandleSSOResultStatus+0x24>
8000f3b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    byte ssoresult;
    byte store;

    T_LIB_ENTRY(VMSV_85);

    ASSERT(msg_ptr);
8000f3b4:	e0 68 0b d7 	mov	r8,3031
8000f3b8:	30 1a       	mov	r10,1
8000f3ba:	1a d8       	st.w	--sp,r8
8000f3bc:	31 0b       	mov	r11,16
8000f3be:	34 0c       	mov	r12,64
8000f3c0:	fe b0 c3 96 	rcall	80007aec <mns_trace>
8000f3c4:	2f fd       	sub	sp,-4
8000f3c6:	cc 6b       	rjmp	8000f352 <VmsvHandleSSOResultStatus+0xa>
8000f3c8:	00 00       	add	r0,r0
8000f3ca:	39 9c       	mov	r12,-103

8000f3cc <VmsvHandleNetOnTimerError>:
8000f3cc:	eb cd 40 e0 	pushm	r5-r7,lr
8000f3d0:	18 97       	mov	r7,r12
8000f3d2:	58 0c       	cp.w	r12,0
8000f3d4:	c1 60       	breq	8000f400 <VmsvHandleNetOnTimerError+0x34>
8000f3d6:	31 1c       	mov	r12,17

    T_LIB_ENTRY(VMSV_74);

    ASSERT(msg_ptr);

    TAKE_VMSV();
8000f3d8:	fe b0 c3 6f 	rcall	80007ab6 <mns_take>
    cb_ptr = vmsv.net_on_cb_ptr;
8000f3dc:	48 e8       	lddpc	r8,8000f414 <VmsvHandleNetOnTimerError+0x48>
    vmsv.net_on_cb_ptr = NULL;
8000f3de:	30 05       	mov	r5,0
    T_LIB_ENTRY(VMSV_74);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    cb_ptr = vmsv.net_on_cb_ptr;
8000f3e0:	71 c6       	ld.w	r6,r8[0x70]
    vmsv.net_on_cb_ptr = NULL;
    GIVE_VMSV();
8000f3e2:	31 1c       	mov	r12,17

    ASSERT(msg_ptr);

    TAKE_VMSV();
    cb_ptr = vmsv.net_on_cb_ptr;
    vmsv.net_on_cb_ptr = NULL;
8000f3e4:	f1 45 00 70 	st.w	r8[112],r5
    GIVE_VMSV();
8000f3e8:	fe b0 c3 68 	rcall	80007ab8 <mns_give>

    if (cb_ptr)
8000f3ec:	58 06       	cp.w	r6,0
8000f3ee:	c0 70       	breq	8000f3fc <VmsvHandleNetOnTimerError+0x30>
    {
        cb_ptr(NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]), 0);
8000f3f0:	6e 08       	ld.w	r8,r7[0x0]
8000f3f2:	0a 9b       	mov	r11,r5
8000f3f4:	11 8c       	ld.ub	r12,r8[0x0]
8000f3f6:	e8 1c a0 00 	orl	r12,0xa000
8000f3fa:	5d 16       	icall	r6
8000f3fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TVmsvNetOnCB *cb_ptr;

    T_LIB_ENTRY(VMSV_74);

    ASSERT(msg_ptr);
8000f400:	e0 68 0b 97 	mov	r8,2967
8000f404:	30 1a       	mov	r10,1
8000f406:	1a d8       	st.w	--sp,r8
8000f408:	31 0b       	mov	r11,16
8000f40a:	34 0c       	mov	r12,64
8000f40c:	fe b0 c3 70 	rcall	80007aec <mns_trace>
8000f410:	2f fd       	sub	sp,-4
8000f412:	ce 2b       	rjmp	8000f3d6 <VmsvHandleNetOnTimerError+0xa>
8000f414:	00 00       	add	r0,r0
8000f416:	39 9c       	mov	r12,-103

8000f418 <VmsvHandleNetOnTimerStatus>:
8000f418:	eb cd 40 e0 	pushm	r5-r7,lr
8000f41c:	18 97       	mov	r7,r12
8000f41e:	58 0c       	cp.w	r12,0
8000f420:	c1 d0       	breq	8000f45a <VmsvHandleNetOnTimerStatus+0x42>
8000f422:	31 1c       	mov	r12,17

    T_LIB_ENTRY(VMSV_73);

    ASSERT(msg_ptr);

    TAKE_VMSV();
8000f424:	fe b0 c3 49 	rcall	80007ab6 <mns_take>
    cb_ptr             = vmsv.net_on_cb_ptr;
8000f428:	49 28       	lddpc	r8,8000f470 <VmsvHandleNetOnTimerStatus+0x58>
    vmsv.net_on_cb_ptr = NULL;
8000f42a:	30 05       	mov	r5,0
    T_LIB_ENTRY(VMSV_73);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    cb_ptr             = vmsv.net_on_cb_ptr;
8000f42c:	71 c6       	ld.w	r6,r8[0x70]
    vmsv.net_on_cb_ptr = NULL;
    GIVE_VMSV();
8000f42e:	31 1c       	mov	r12,17

    ASSERT(msg_ptr);

    TAKE_VMSV();
    cb_ptr             = vmsv.net_on_cb_ptr;
    vmsv.net_on_cb_ptr = NULL;
8000f430:	f1 45 00 70 	st.w	r8[112],r5
    GIVE_VMSV();
8000f434:	fe b0 c3 42 	rcall	80007ab8 <mns_give>

    if (cb_ptr)
8000f438:	58 06       	cp.w	r6,0
8000f43a:	c0 e0       	breq	8000f456 <VmsvHandleNetOnTimerStatus+0x3e>
    {
        dword time = (dword)(((dword)msg_ptr->Data[0] << 24) |
8000f43c:	6e 08       	ld.w	r8,r7[0x0]
                             ((dword)msg_ptr->Data[1] << 16) |
                             ((dword)msg_ptr->Data[2] <<  8) |
                             ((dword)msg_ptr->Data[3]));

        cb_ptr(NSR_S_OK, time);
8000f43e:	11 ab       	ld.ub	r11,r8[0x2]
8000f440:	11 b9       	ld.ub	r9,r8[0x3]
8000f442:	11 8a       	ld.ub	r10,r8[0x0]
8000f444:	11 98       	ld.ub	r8,r8[0x1]
8000f446:	f3 ea 11 89 	or	r9,r9,r10<<0x18
8000f44a:	f3 e8 11 08 	or	r8,r9,r8<<0x10
8000f44e:	0a 9c       	mov	r12,r5
8000f450:	f1 eb 10 8b 	or	r11,r8,r11<<0x8
8000f454:	5d 16       	icall	r6
8000f456:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TVmsvNetOnCB *cb_ptr;

    T_LIB_ENTRY(VMSV_73);

    ASSERT(msg_ptr);
8000f45a:	e0 68 0b 71 	mov	r8,2929
8000f45e:	30 1a       	mov	r10,1
8000f460:	1a d8       	st.w	--sp,r8
8000f462:	31 0b       	mov	r11,16
8000f464:	34 0c       	mov	r12,64
8000f466:	fe b0 c3 43 	rcall	80007aec <mns_trace>
8000f46a:	2f fd       	sub	sp,-4
8000f46c:	cd bb       	rjmp	8000f422 <VmsvHandleNetOnTimerStatus+0xa>
8000f46e:	d7 03       	nop
8000f470:	00 00       	add	r0,r0
8000f472:	39 9c       	mov	r12,-103

8000f474 <VmsvHandleDiagResult>:
8000f474:	eb cd 40 c0 	pushm	r6-r7,lr
8000f478:	18 96       	mov	r6,r12
8000f47a:	58 0c       	cp.w	r12,0
8000f47c:	c3 e0       	breq	8000f4f8 <VmsvHandleDiagResult+0x84>
8000f47e:	31 1c       	mov	r12,17
    react            = MNS_FALSE;
    send_wakeup_mode = MNS_FALSE;

    ASSERT(msg_ptr);

    TAKE_VMSV();
8000f480:	fe b0 c3 1b 	rcall	80007ab6 <mns_take>
    react = (VMSV_COMM_WAIT_FOR_MSG == vmsv.nwstartup.comm_state) ?
            MNS_TRUE : MNS_FALSE;
    if (MNS_FALSE != react)
8000f484:	30 58       	mov	r8,5
8000f486:	4a 27       	lddpc	r7,8000f50c <VmsvHandleDiagResult+0x98>
8000f488:	0f f9       	ld.ub	r9,r7[0x7]
8000f48a:	f0 09 18 00 	cp.b	r9,r8
8000f48e:	c1 a1       	brne	8000f4c2 <VmsvHandleDiagResult+0x4e>
    {
        vmsv.nwstartup.comm_state = VMSV_COMM_OFF;
8000f490:	30 08       	mov	r8,0
    }
    GIVE_VMSV();
8000f492:	31 1c       	mov	r12,17
    TAKE_VMSV();
    react = (VMSV_COMM_WAIT_FOR_MSG == vmsv.nwstartup.comm_state) ?
            MNS_TRUE : MNS_FALSE;
    if (MNS_FALSE != react)
    {
        vmsv.nwstartup.comm_state = VMSV_COMM_OFF;
8000f494:	ae f8       	st.b	r7[0x7],r8
    }
    GIVE_VMSV();
8000f496:	fe b0 c3 11 	rcall	80007ab8 <mns_give>
    ASSERT(react);

    if (MNS_FALSE != react)
    {
        /* call the callback */
        if(vmsv.cfg_ptr->rbd_store_rbd_result_fptr)
8000f49a:	6e f8       	ld.w	r8,r7[0x3c]
8000f49c:	70 58       	ld.w	r8,r8[0x14]
8000f49e:	58 08       	cp.w	r8,0
8000f4a0:	c0 80       	breq	8000f4b0 <VmsvHandleDiagResult+0x3c>
        {
            vmsv.cfg_ptr->rbd_store_rbd_result_fptr(msg_ptr->Data[0], msg_ptr->Length - 1, &(msg_ptr->Data[1]));
8000f4a2:	6c 0a       	ld.w	r10,r6[0x0]
8000f4a4:	8c 2b       	ld.sh	r11,r6[0x4]
8000f4a6:	15 8c       	ld.ub	r12,r10[0x0]
8000f4a8:	20 1b       	sub	r11,1
8000f4aa:	2f fa       	sub	r10,-1
8000f4ac:	5c 5b       	castu.b	r11
8000f4ae:	5d 18       	icall	r8
        }
        if (MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
8000f4b0:	ef 39 00 1c 	ld.ub	r9,r7[28]
8000f4b4:	49 6a       	lddpc	r10,8000f50c <VmsvHandleDiagResult+0x98>
8000f4b6:	30 18       	mov	r8,1
8000f4b8:	f0 09 18 00 	cp.b	r9,r8
8000f4bc:	c1 10       	breq	8000f4de <VmsvHandleDiagResult+0x6a>
8000f4be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            MNS_TRUE : MNS_FALSE;
    if (MNS_FALSE != react)
    {
        vmsv.nwstartup.comm_state = VMSV_COMM_OFF;
    }
    GIVE_VMSV();
8000f4c2:	31 1c       	mov	r12,17
8000f4c4:	fe b0 c2 fa 	rcall	80007ab8 <mns_give>
    ASSERT(react);
8000f4c8:	e0 68 0a e0 	mov	r8,2784
8000f4cc:	30 1a       	mov	r10,1
8000f4ce:	1a d8       	st.w	--sp,r8
8000f4d0:	31 0b       	mov	r11,16
8000f4d2:	34 0c       	mov	r12,64
8000f4d4:	fe b0 c3 0c 	rcall	80007aec <mns_trace>
8000f4d8:	2f fd       	sub	sp,-4
8000f4da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        {
            vmsv.cfg_ptr->rbd_store_rbd_result_fptr(msg_ptr->Data[0], msg_ptr->Length - 1, &(msg_ptr->Data[1]));
        }
        if (MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
        {
            if (    (INIC_SHADOW_INVALID_BYTE != vmsv.shadow.ni_wakeup_mode.mode)
8000f4de:	f5 38 00 38 	ld.ub	r8,r10[56]
8000f4e2:	3e e9       	mov	r9,-18
8000f4e4:	f2 08 18 00 	cp.b	r8,r9
8000f4e8:	ce b0       	breq	8000f4be <VmsvHandleDiagResult+0x4a>
8000f4ea:	ed b8 00 01 	bld	r8,0x1
8000f4ee:	ce 81       	brne	8000f4be <VmsvHandleDiagResult+0x4a>
                 && (VMSV_NIWAKEUPMODE_WAKEUPBAN == (vmsv.shadow.ni_wakeup_mode.mode & VMSV_NIWAKEUPMODE_WAKEUPBAN)) )
            {
                vmsv.shadow.ni_wakeup_mode.request = vmsv.shadow.ni_wakeup_mode.mode;
8000f4f0:	f5 68 00 39 	st.b	r10[57],r8
            }
        }

        if (MNS_FALSE != send_wakeup_mode)
        {
            VmsvSetNIWakeUpMode();
8000f4f4:	c3 ce       	rcall	8000f16c <VmsvSetNIWakeUpMode>
8000f4f6:	ce 4b       	rjmp	8000f4be <VmsvHandleDiagResult+0x4a>
8000f4f8:	e0 68 0a d6 	mov	r8,2774
    T_LIB_ENTRY(VMSV_70);

    react            = MNS_FALSE;
    send_wakeup_mode = MNS_FALSE;

    ASSERT(msg_ptr);
8000f4fc:	30 1a       	mov	r10,1
8000f4fe:	1a d8       	st.w	--sp,r8
8000f500:	31 0b       	mov	r11,16
8000f502:	34 0c       	mov	r12,64
8000f504:	fe b0 c2 f4 	rcall	80007aec <mns_trace>
8000f508:	2f fd       	sub	sp,-4
8000f50a:	cb ab       	rjmp	8000f47e <VmsvHandleDiagResult+0xa>
8000f50c:	00 00       	add	r0,r0
8000f50e:	39 9c       	mov	r12,-103

8000f510 <VmsvHandleNWShutdownError>:
8000f510:	eb cd 40 80 	pushm	r7,lr
8000f514:	18 97       	mov	r7,r12
8000f516:	58 0c       	cp.w	r12,0
8000f518:	c1 60       	breq	8000f544 <VmsvHandleNWShutdownError+0x34>
8000f51a:	49 08       	lddpc	r8,8000f558 <VmsvHandleNWShutdownError+0x48>
8000f51c:	70 f8       	ld.w	r8,r8[0x3c]
8000f51e:	70 18       	ld.w	r8,r8[0x4]
8000f520:	58 08       	cp.w	r8,0
8000f522:	c0 a0       	breq	8000f536 <VmsvHandleNWShutdownError+0x26>

    ASSERT(msg_ptr);

    if (vmsv.cfg_ptr->msval_error_fptr)
    {
        if (ERR_BUSY == msg_ptr->Data[0])
8000f524:	6e 09       	ld.w	r9,r7[0x0]
8000f526:	13 8a       	ld.ub	r10,r9[0x0]
8000f528:	34 09       	mov	r9,64
8000f52a:	f2 0a 18 00 	cp.b	r10,r9
8000f52e:	c0 60       	breq	8000f53a <VmsvHandleNWShutdownError+0x2a>
        {
            vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_SHUTDOWN_BUSY, NULL);
        }
        else
        {
            vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_SHUTDOWN_FAILED, NULL);
8000f530:	30 0b       	mov	r11,0
8000f532:	31 2c       	mov	r12,18
8000f534:	5d 18       	icall	r8
8000f536:	e3 cd 80 80 	ldm	sp++,r7,pc

    if (vmsv.cfg_ptr->msval_error_fptr)
    {
        if (ERR_BUSY == msg_ptr->Data[0])
        {
            vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_SHUTDOWN_BUSY, NULL);
8000f53a:	30 0b       	mov	r11,0
8000f53c:	31 3c       	mov	r12,19
8000f53e:	5d 18       	icall	r8
8000f540:	e3 cd 80 80 	ldm	sp++,r7,pc
  */
void VmsvHandleNWShutdownError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_41);

    ASSERT(msg_ptr);
8000f544:	e0 68 07 87 	mov	r8,1927
8000f548:	30 1a       	mov	r10,1
8000f54a:	1a d8       	st.w	--sp,r8
8000f54c:	31 0b       	mov	r11,16
8000f54e:	34 0c       	mov	r12,64
8000f550:	fe b0 c2 ce 	rcall	80007aec <mns_trace>
8000f554:	2f fd       	sub	sp,-4
8000f556:	ce 2b       	rjmp	8000f51a <VmsvHandleNWShutdownError+0xa>
8000f558:	00 00       	add	r0,r0
8000f55a:	39 9c       	mov	r12,-103

8000f55c <VmsvHandleNWStartupError>:
8000f55c:	eb cd 40 80 	pushm	r7,lr
  * @version    2.0.4
  *
  * @param      msg_ptr holds the telegram
  */
void VmsvHandleNWStartupError(TMsgRx *msg_ptr)
{
8000f560:	18 97       	mov	r7,r12
    T_LIB_ENTRY(VMSV_41);

    ASSERT(msg_ptr);
8000f562:	58 0c       	cp.w	r12,0
8000f564:	c1 60       	breq	8000f590 <VmsvHandleNWStartupError+0x34>

    if (vmsv.cfg_ptr->msval_error_fptr)
8000f566:	49 08       	lddpc	r8,8000f5a4 <VmsvHandleNWStartupError+0x48>
8000f568:	70 f8       	ld.w	r8,r8[0x3c]
8000f56a:	70 18       	ld.w	r8,r8[0x4]
8000f56c:	58 08       	cp.w	r8,0
8000f56e:	c0 a0       	breq	8000f582 <VmsvHandleNWStartupError+0x26>
    {
        if (ERR_BUSY == msg_ptr->Data[0])
8000f570:	6e 09       	ld.w	r9,r7[0x0]
8000f572:	13 8a       	ld.ub	r10,r9[0x0]
8000f574:	34 09       	mov	r9,64
8000f576:	f2 0a 18 00 	cp.b	r10,r9
8000f57a:	c0 60       	breq	8000f586 <VmsvHandleNWStartupError+0x2a>
        {
            vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_STARTUP_BUSY, NULL);
        }
        else
        {
            vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_STARTUP_FAILED, NULL);
8000f57c:	30 0b       	mov	r11,0
8000f57e:	31 0c       	mov	r12,16
8000f580:	5d 18       	icall	r8
8000f582:	e3 cd 80 80 	ldm	sp++,r7,pc

    if (vmsv.cfg_ptr->msval_error_fptr)
    {
        if (ERR_BUSY == msg_ptr->Data[0])
        {
            vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_STARTUP_BUSY, NULL);
8000f586:	30 0b       	mov	r11,0
8000f588:	31 1c       	mov	r12,17
8000f58a:	5d 18       	icall	r8
8000f58c:	e3 cd 80 80 	ldm	sp++,r7,pc
  */
void VmsvHandleNWStartupError(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_41);

    ASSERT(msg_ptr);
8000f590:	e0 68 07 66 	mov	r8,1894
8000f594:	30 1a       	mov	r10,1
8000f596:	1a d8       	st.w	--sp,r8
8000f598:	31 0b       	mov	r11,16
8000f59a:	34 0c       	mov	r12,64
8000f59c:	fe b0 c2 a8 	rcall	80007aec <mns_trace>
8000f5a0:	2f fd       	sub	sp,-4
8000f5a2:	ce 2b       	rjmp	8000f566 <VmsvHandleNWStartupError+0xa>
8000f5a4:	00 00       	add	r0,r0
8000f5a6:	39 9c       	mov	r12,-103

8000f5a8 <VmsvRegisterInternalHooks>:
8000f5a8:	eb cd 40 80 	pushm	r7,lr
  * @param      cbs_ptr points to an instance of TVmsvInternalHooks, containing
  *             callback definitions used by Layer2.
  */
#ifdef VMSV_32
void VmsvRegisterInternalHooks(TVmsvInternalHooks *cbs_ptr)
{
8000f5ac:	18 97       	mov	r7,r12
    T_LIB_ENTRY(VMSV_32);
    ASSERT(cbs_ptr);
8000f5ae:	58 0c       	cp.w	r12,0
8000f5b0:	c1 00       	breq	8000f5d0 <VmsvRegisterInternalHooks+0x28>
    TAKE_VMSV();
8000f5b2:	31 1c       	mov	r12,17
8000f5b4:	fe b0 c2 81 	rcall	80007ab6 <mns_take>
    vmsv.update_nwm_address_fptr = cbs_ptr->update_nwm_address_fptr;
8000f5b8:	6e 09       	ld.w	r9,r7[0x0]
8000f5ba:	48 b8       	lddpc	r8,8000f5e4 <VmsvRegisterInternalHooks+0x3c>
8000f5bc:	f1 49 00 40 	st.w	r8[64],r9
    vmsv.store_error_info2_fptr = cbs_ptr->store_error_info2_fptr;
8000f5c0:	6e 19       	ld.w	r9,r7[0x4]
    GIVE_VMSV();
8000f5c2:	31 1c       	mov	r12,17
{
    T_LIB_ENTRY(VMSV_32);
    ASSERT(cbs_ptr);
    TAKE_VMSV();
    vmsv.update_nwm_address_fptr = cbs_ptr->update_nwm_address_fptr;
    vmsv.store_error_info2_fptr = cbs_ptr->store_error_info2_fptr;
8000f5c4:	f1 49 00 44 	st.w	r8[68],r9
    GIVE_VMSV();
8000f5c8:	fe b0 c2 78 	rcall	80007ab8 <mns_give>
    T_LIB_EXIT(VMSV_32);
}
8000f5cc:	e3 cd 80 80 	ldm	sp++,r7,pc
  */
#ifdef VMSV_32
void VmsvRegisterInternalHooks(TVmsvInternalHooks *cbs_ptr)
{
    T_LIB_ENTRY(VMSV_32);
    ASSERT(cbs_ptr);
8000f5d0:	e0 68 06 01 	mov	r8,1537
8000f5d4:	30 1a       	mov	r10,1
8000f5d6:	1a d8       	st.w	--sp,r8
8000f5d8:	31 0b       	mov	r11,16
8000f5da:	34 0c       	mov	r12,64
8000f5dc:	fe b0 c2 88 	rcall	80007aec <mns_trace>
8000f5e0:	2f fd       	sub	sp,-4
8000f5e2:	ce 8b       	rjmp	8000f5b2 <VmsvRegisterInternalHooks+0xa>
8000f5e4:	00 00       	add	r0,r0
8000f5e6:	39 9c       	mov	r12,-103

8000f5e8 <VmsvHandleNCEDelayedChange>:
8000f5e8:	eb cd 40 f8 	pushm	r3-r7,lr
8000f5ec:	20 1d       	sub	sp,4
8000f5ee:	30 08       	mov	r8,0
8000f5f0:	31 1c       	mov	r12,17
8000f5f2:	ba a8       	st.b	sp[0x2],r8
    byte info[3];
    bool reported;

    T_MOD_ENTRY(VMSV_28);

    info[0] = (byte)0;
8000f5f4:	ba 88       	st.b	sp[0x0],r8
    info[1] = (byte)0;
8000f5f6:	ba 98       	st.b	sp[0x1],r8
    info[2] = (byte)0;

    TAKE_VMSV();
8000f5f8:	fe b0 c2 5f 	rcall	80007ab6 <mns_take>
    ncedelayed[0] = vmsv.shadow.ncedelayed[0];
    ncedelayed[1] = vmsv.shadow.ncedelayed[1];
    state = vmsv.shadow.nistate;
    reported = vmsv.shadow.neton_reported;
    GIVE_VMSV();
8000f5fc:	31 1c       	mov	r12,17
    info[0] = (byte)0;
    info[1] = (byte)0;
    info[2] = (byte)0;

    TAKE_VMSV();
    ncedelayed[0] = vmsv.shadow.ncedelayed[0];
8000f5fe:	4a a7       	lddpc	r7,8000f6a4 <VmsvHandleNCEDelayedChange+0xbc>
8000f600:	ef 36 00 27 	ld.ub	r6,r7[39]
    ncedelayed[1] = vmsv.shadow.ncedelayed[1];
8000f604:	ef 35 00 28 	ld.ub	r5,r7[40]
    state = vmsv.shadow.nistate;
8000f608:	ef 34 00 21 	ld.ub	r4,r7[33]
    reported = vmsv.shadow.neton_reported;
8000f60c:	ef 33 00 22 	ld.ub	r3,r7[34]
    GIVE_VMSV();
8000f610:	fe b0 c2 54 	rcall	80007ab8 <mns_give>

    ASSERT((INIC_SHADOW_INVALID_BYTE != ncedelayed[0]) &&
8000f614:	3e e8       	mov	r8,-18
8000f616:	f0 06 18 00 	cp.b	r6,r8
8000f61a:	c3 60       	breq	8000f686 <VmsvHandleNCEDelayedChange+0x9e>
8000f61c:	f0 05 18 00 	cp.b	r5,r8
8000f620:	c3 30       	breq	8000f686 <VmsvHandleNCEDelayedChange+0x9e>
           (INIC_SHADOW_INVALID_BYTE != ncedelayed[1]));

    /* "net on" needs to be already reported, before MSVAL_E_MPR* can be */
    if (vmsv.cfg_ptr->msval_event_fptr)
8000f622:	6e f8       	ld.w	r8,r7[0x3c]
8000f624:	70 28       	ld.w	r8,r8[0x8]
8000f626:	58 08       	cp.w	r8,0
8000f628:	c0 e0       	breq	8000f644 <VmsvHandleNCEDelayedChange+0x5c>
    {
        if ((MSVAL_S_ON == state) && (MNS_FALSE != reported))
8000f62a:	30 38       	mov	r8,3
8000f62c:	f0 04 18 00 	cp.b	r4,r8
8000f630:	c0 d0       	breq	8000f64a <VmsvHandleNCEDelayedChange+0x62>

            vmsv.cfg_ptr->msval_event_fptr(event, info);
        }
        else
        {
            TAKE_VMSV();
8000f632:	31 1c       	mov	r12,17
8000f634:	fe b0 c2 41 	rcall	80007ab6 <mns_take>
            vmsv.shadow.delayed_nce = MNS_TRUE;
8000f638:	30 18       	mov	r8,1
            GIVE_VMSV();
8000f63a:	31 1c       	mov	r12,17
            vmsv.cfg_ptr->msval_event_fptr(event, info);
        }
        else
        {
            TAKE_VMSV();
            vmsv.shadow.delayed_nce = MNS_TRUE;
8000f63c:	ef 68 00 24 	st.b	r7[36],r8
            GIVE_VMSV();
8000f640:	fe b0 c2 3c 	rcall	80007ab8 <mns_give>
        }
    }

    T_MOD_EXIT(VMSV_28);
}
8000f644:	2f fd       	sub	sp,-4
8000f646:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
           (INIC_SHADOW_INVALID_BYTE != ncedelayed[1]));

    /* "net on" needs to be already reported, before MSVAL_E_MPR* can be */
    if (vmsv.cfg_ptr->msval_event_fptr)
    {
        if ((MSVAL_S_ON == state) && (MNS_FALSE != reported))
8000f64a:	58 03       	cp.w	r3,0
8000f64c:	cf 30       	breq	8000f632 <VmsvHandleNCEDelayedChange+0x4a>
        {
            byte event;

            TAKE_VMSV();
8000f64e:	31 1c       	mov	r12,17
8000f650:	fe b0 c2 33 	rcall	80007ab6 <mns_take>
            vmsv.shadow.delayed_nce = MNS_FALSE;
8000f654:	49 48       	lddpc	r8,8000f6a4 <VmsvHandleNCEDelayedChange+0xbc>
8000f656:	30 09       	mov	r9,0
            GIVE_VMSV();
8000f658:	31 1c       	mov	r12,17
        if ((MSVAL_S_ON == state) && (MNS_FALSE != reported))
        {
            byte event;

            TAKE_VMSV();
            vmsv.shadow.delayed_nce = MNS_FALSE;
8000f65a:	f1 69 00 24 	st.b	r8[36],r9
            GIVE_VMSV();
8000f65e:	fe b0 c2 2d 	rcall	80007ab8 <mns_give>

            info[0] = (byte)2;
8000f662:	30 28       	mov	r8,2
            info[1] = ncedelayed[0];                /* ... new MPR */
8000f664:	ba 96       	st.b	sp[0x1],r6
            info[2] = ncedelayed[1];                /* ... old MPR */
8000f666:	ba a5       	st.b	sp[0x2],r5

            TAKE_VMSV();
            vmsv.shadow.delayed_nce = MNS_FALSE;
            GIVE_VMSV();

            info[0] = (byte)2;
8000f668:	ba 88       	st.b	sp[0x0],r8
            info[1] = ncedelayed[0];                /* ... new MPR */
            info[2] = ncedelayed[1];                /* ... old MPR */

            if (info[1] == info[2])
8000f66a:	ea 06 18 00 	cp.b	r6,r5
8000f66e:	c1 60       	breq	8000f69a <VmsvHandleNCEDelayedChange+0xb2>
                info[0] = (byte)1;                  /* length = 1 */
                event   = MSVAL_E_MPRDEL_EQUAL;
            }
            else
            {
                event = (info[1] < info[2]) ?
8000f670:	f9 bc 03 12 	movlo	r12,18
8000f674:	f9 bc 02 11 	movhs	r12,17
                        MSVAL_E_MPRDEL_DEC : MSVAL_E_MPRDEL_INC;
            }

            vmsv.cfg_ptr->msval_event_fptr(event, info);
8000f678:	6e f8       	ld.w	r8,r7[0x3c]
8000f67a:	1a 9b       	mov	r11,sp
8000f67c:	70 28       	ld.w	r8,r8[0x8]
8000f67e:	5d 18       	icall	r8
            GIVE_VMSV();
        }
    }

    T_MOD_EXIT(VMSV_28);
}
8000f680:	2f fd       	sub	sp,-4
8000f682:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    ncedelayed[1] = vmsv.shadow.ncedelayed[1];
    state = vmsv.shadow.nistate;
    reported = vmsv.shadow.neton_reported;
    GIVE_VMSV();

    ASSERT((INIC_SHADOW_INVALID_BYTE != ncedelayed[0]) &&
8000f686:	e0 68 05 53 	mov	r8,1363
8000f68a:	30 1a       	mov	r10,1
8000f68c:	1a d8       	st.w	--sp,r8
8000f68e:	31 0b       	mov	r11,16
8000f690:	34 0c       	mov	r12,64
8000f692:	fe b0 c2 2d 	rcall	80007aec <mns_trace>
8000f696:	2f fd       	sub	sp,-4
8000f698:	cc 5b       	rjmp	8000f622 <VmsvHandleNCEDelayedChange+0x3a>
            info[1] = ncedelayed[0];                /* ... new MPR */
            info[2] = ncedelayed[1];                /* ... old MPR */

            if (info[1] == info[2])
            {
                info[0] = (byte)1;                  /* length = 1 */
8000f69a:	30 18       	mov	r8,1
8000f69c:	31 3c       	mov	r12,19
8000f69e:	ba 88       	st.b	sp[0x0],r8
8000f6a0:	ce cb       	rjmp	8000f678 <VmsvHandleNCEDelayedChange+0x90>
8000f6a2:	d7 03       	nop
8000f6a4:	00 00       	add	r0,r0
8000f6a6:	39 9c       	mov	r12,-103

8000f6a8 <VmsvReportNetOn>:
8000f6a8:	d4 21       	pushm	r4-r7,lr
8000f6aa:	20 1d       	sub	sp,4
8000f6ac:	30 04       	mov	r4,0
8000f6ae:	30 16       	mov	r6,1
8000f6b0:	31 1c       	mov	r12,17
8000f6b2:	ba 86       	st.b	sp[0x0],r6
    bool delayed_nce;

    T_MOD_ENTRY(VMSV_46);

    info[0] = (byte)1;
    info[1] = (byte)0;
8000f6b4:	ba 94       	st.b	sp[0x1],r4
    info[2] = (byte)0;
8000f6b6:	ba a4       	st.b	sp[0x2],r4

    TAKE_VMSV();
8000f6b8:	fe b0 c1 ff 	rcall	80007ab6 <mns_take>
    info[1]                    = vmsv.shadow.devmode;
8000f6bc:	49 47       	lddpc	r7,8000f70c <VmsvReportNetOn+0x64>
8000f6be:	ef 38 00 2c 	ld.ub	r8,r7[44]
    vmsv.shadow.neton_reported = MNS_TRUE;
8000f6c2:	ef 66 00 22 	st.b	r7[34],r6
    info[0] = (byte)1;
    info[1] = (byte)0;
    info[2] = (byte)0;

    TAKE_VMSV();
    info[1]                    = vmsv.shadow.devmode;
8000f6c6:	ba 98       	st.b	sp[0x1],r8
    vmsv.shadow.neton_reported = MNS_TRUE;
    delayed_mpr                = vmsv.shadow.delayed_mpr;
8000f6c8:	ef 35 00 23 	ld.ub	r5,r7[35]
    vmsv.shadow.delayed_mpr    = MNS_FALSE;
    delayed_nce                = vmsv.shadow.delayed_nce;
8000f6cc:	ef 36 00 24 	ld.ub	r6,r7[36]

    TAKE_VMSV();
    info[1]                    = vmsv.shadow.devmode;
    vmsv.shadow.neton_reported = MNS_TRUE;
    delayed_mpr                = vmsv.shadow.delayed_mpr;
    vmsv.shadow.delayed_mpr    = MNS_FALSE;
8000f6d0:	ef 64 00 23 	st.b	r7[35],r4
    delayed_nce                = vmsv.shadow.delayed_nce;
    vmsv.shadow.delayed_nce    = MNS_FALSE;
8000f6d4:	ef 64 00 24 	st.b	r7[36],r4
    GIVE_VMSV();
8000f6d8:	31 1c       	mov	r12,17
8000f6da:	fe b0 c1 ef 	rcall	80007ab8 <mns_give>

    if (vmsv.cfg_ptr->msval_event_fptr)
8000f6de:	6e f8       	ld.w	r8,r7[0x3c]
8000f6e0:	70 28       	ld.w	r8,r8[0x8]
8000f6e2:	58 08       	cp.w	r8,0
8000f6e4:	c0 80       	breq	8000f6f4 <VmsvReportNetOn+0x4c>
    {
        vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NETON, info);
8000f6e6:	1a 9b       	mov	r11,sp
8000f6e8:	32 0c       	mov	r12,32
8000f6ea:	5d 18       	icall	r8

        if (MNS_FALSE != delayed_mpr)
8000f6ec:	58 05       	cp.w	r5,0
8000f6ee:	c0 81       	brne	8000f6fe <VmsvReportNetOn+0x56>
        {
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_MPR, NULL);
        }
        if (MNS_FALSE != delayed_nce)
8000f6f0:	58 06       	cp.w	r6,0
8000f6f2:	c0 31       	brne	8000f6f8 <VmsvReportNetOn+0x50>
            VmsvHandleNCEDelayedChange();
        }
    }

    T_MOD_EXIT(VMSV_46);
}
8000f6f4:	2f fd       	sub	sp,-4
8000f6f6:	d8 22       	popm	r4-r7,pc
        {
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_MPR, NULL);
        }
        if (MNS_FALSE != delayed_nce)
        {
            VmsvHandleNCEDelayedChange();
8000f6f8:	c7 8f       	rcall	8000f5e8 <VmsvHandleNCEDelayedChange>
8000f6fa:	2f fd       	sub	sp,-4
        }
    }

    T_MOD_EXIT(VMSV_46);
}
8000f6fc:	d8 22       	popm	r4-r7,pc
8000f6fe:	6e f8       	ld.w	r8,r7[0x3c]
    {
        vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NETON, info);

        if (MNS_FALSE != delayed_mpr)
        {
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_MPR, NULL);
8000f700:	30 0b       	mov	r11,0
8000f702:	70 28       	ld.w	r8,r8[0x8]
8000f704:	31 0c       	mov	r12,16
8000f706:	5d 18       	icall	r8
8000f708:	cf 4b       	rjmp	8000f6f0 <VmsvReportNetOn+0x48>
8000f70a:	d7 03       	nop
8000f70c:	00 00       	add	r0,r0
8000f70e:	39 9c       	mov	r12,-103

8000f710 <VmsvPhysicalLayerTestStart>:
8000f710:	eb cd 40 fc 	pushm	r2-r7,lr
8000f714:	16 97       	mov	r7,r11
8000f716:	14 95       	mov	r5,r10
8000f718:	12 94       	mov	r4,r9
8000f71a:	10 92       	mov	r2,r8
#endif


#ifdef VMSV_94
byte VmsvPhysicalLayerTestStart(pTMsgRx rx_ptr, byte type, word lead_in, dword duration, word lead_out)
{
8000f71c:	18 93       	mov	r3,r12

    T_LIB_ENTRY(VMSV_94);

    retval = ERR_NO;

    TAKE_VMSV();
8000f71e:	31 1c       	mov	r12,17
8000f720:	fe b0 c1 cb 	rcall	80007ab6 <mns_take>
    vmsv.plt.type       = type;
8000f724:	4a 96       	lddpc	r6,8000f7c8 <VmsvPhysicalLayerTestStart+0xb8>
    vmsv.plt.lead_in    = lead_in;
    vmsv.plt.lead_out   = lead_out;
    vmsv.plt.duration   = duration;
    test_state          = vmsv.plt.test_state;
    GIVE_VMSV();
8000f726:	31 1c       	mov	r12,17
    T_LIB_ENTRY(VMSV_94);

    retval = ERR_NO;

    TAKE_VMSV();
    vmsv.plt.type       = type;
8000f728:	ed 67 00 75 	st.b	r6[117],r7
    vmsv.plt.lead_in    = lead_in;
8000f72c:	ed 55 00 76 	st.h	r6[118],r5
    vmsv.plt.lead_out   = lead_out;
8000f730:	ed 52 00 78 	st.h	r6[120],r2
    vmsv.plt.duration   = duration;
8000f734:	ed 44 00 7c 	st.w	r6[124],r4
    test_state          = vmsv.plt.test_state;
8000f738:	ed 37 00 81 	ld.ub	r7,r6[129]
    GIVE_VMSV();
8000f73c:	fe b0 c1 be 	rcall	80007ab8 <mns_give>

    msg_ptr = MsgGetTxPtrExt(2);
8000f740:	30 2c       	mov	r12,2
8000f742:	fe b0 cb ad 	rcall	80008e9c <MsgGetTxPtrExt>
    ASSERT(msg_ptr);
8000f746:	c3 40       	breq	8000f7ae <VmsvPhysicalLayerTestStart+0x9e>

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = rx_ptr->Src_Adr;
8000f748:	86 39       	ld.sh	r9,r3[0x6]
8000f74a:	b8 39       	st.h	r12[0x6],r9
        msg_ptr->FBlock_ID = rx_ptr->FBlock_ID;
8000f74c:	e7 39 00 0a 	ld.ub	r9,r3[10]
8000f750:	f9 69 00 0a 	st.b	r12[10],r9
        msg_ptr->Inst_ID   = rx_ptr->Inst_ID;
8000f754:	e7 39 00 0b 	ld.ub	r9,r3[11]
8000f758:	f9 69 00 0b 	st.b	r12[11],r9
        msg_ptr->Func_ID   = rx_ptr->Func_ID;
8000f75c:	86 49       	ld.sh	r9,r3[0x8]
8000f75e:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_RESULTACK;
        msg_ptr->Length    = (word)2;
8000f760:	30 29       	mov	r9,2
    {
        msg_ptr->Tgt_Adr   = rx_ptr->Src_Adr;
        msg_ptr->FBlock_ID = rx_ptr->FBlock_ID;
        msg_ptr->Inst_ID   = rx_ptr->Inst_ID;
        msg_ptr->Func_ID   = rx_ptr->Func_ID;
        msg_ptr->Operation = OP_RESULTACK;
8000f762:	30 da       	mov	r10,13
        msg_ptr->Length    = (word)2;
8000f764:	b8 29       	st.h	r12[0x4],r9
    {
        msg_ptr->Tgt_Adr   = rx_ptr->Src_Adr;
        msg_ptr->FBlock_ID = rx_ptr->FBlock_ID;
        msg_ptr->Inst_ID   = rx_ptr->Inst_ID;
        msg_ptr->Func_ID   = rx_ptr->Func_ID;
        msg_ptr->Operation = OP_RESULTACK;
8000f766:	f9 6a 00 0c 	st.b	r12[12],r10
        msg_ptr->Length    = (word)2;
        msg_ptr->Data[0]   = rx_ptr->Data[0];
8000f76a:	78 09       	ld.w	r9,r12[0x0]
8000f76c:	66 0a       	ld.w	r10,r3[0x0]
8000f76e:	15 8a       	ld.ub	r10,r10[0x0]
8000f770:	b2 8a       	st.b	r9[0x0],r10
        msg_ptr->Data[1]   = rx_ptr->Data[1];
8000f772:	66 09       	ld.w	r9,r3[0x0]
8000f774:	78 08       	ld.w	r8,r12[0x0]
8000f776:	13 99       	ld.ub	r9,r9[0x1]
8000f778:	b0 99       	st.b	r8[0x1],r9

        handle = MbmGetHandleByMsgPtr(msg_ptr);
8000f77a:	fe b0 d3 17 	rcall	80009da8 <MbmGetHandleByMsgPtr>
        PmsSend(handle, VmsvPhysicalLayerTestTxFinal);
8000f77e:	fe cb f8 d2 	sub	r11,pc,-1838
8000f782:	fe b0 ee 5b 	rcall	8000d438 <PmsSend>

        /* stop test if already running */
        if (VMSV_PLT_OFF != test_state)
8000f786:	58 07       	cp.w	r7,0
        {
            MostClearTimer(&vmsv.plt.state_timer);
        }

        TAKE_VMSV();
8000f788:	c0 c1       	brne	8000f7a0 <VmsvPhysicalLayerTestStart+0x90>
8000f78a:	31 1c       	mov	r12,17
8000f78c:	fe b0 c1 95 	rcall	80007ab6 <mns_take>
        vmsv.plt.test_state = VMSV_PLT_WAIT_TX;
        GIVE_VMSV();
8000f790:	30 18       	mov	r8,1
        {
            MostClearTimer(&vmsv.plt.state_timer);
        }

        TAKE_VMSV();
        vmsv.plt.test_state = VMSV_PLT_WAIT_TX;
8000f792:	31 1c       	mov	r12,17
8000f794:	ed 68 00 81 	st.b	r6[129],r8
        GIVE_VMSV();
8000f798:	fe b0 c1 90 	rcall	80007ab8 <mns_give>
8000f79c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
        PmsSend(handle, VmsvPhysicalLayerTestTxFinal);

        /* stop test if already running */
        if (VMSV_PLT_OFF != test_state)
        {
            MostClearTimer(&vmsv.plt.state_timer);
8000f7a0:	30 0a       	mov	r10,0
8000f7a2:	ec cc ff 7c 	sub	r12,r6,-132
8000f7a6:	14 9b       	mov	r11,r10
8000f7a8:	fe b0 dc 80 	rcall	8000b0a8 <MostSetTimer>
    vmsv.plt.duration   = duration;
    test_state          = vmsv.plt.test_state;
    GIVE_VMSV();

    msg_ptr = MsgGetTxPtrExt(2);
    ASSERT(msg_ptr);
8000f7ac:	ce fb       	rjmp	8000f78a <VmsvPhysicalLayerTestStart+0x7a>
8000f7ae:	e0 68 0d 30 	mov	r8,3376
8000f7b2:	34 0c       	mov	r12,64
8000f7b4:	1a d8       	st.w	--sp,r8
8000f7b6:	30 1a       	mov	r10,1
8000f7b8:	31 0b       	mov	r11,16
8000f7ba:	fe b0 c1 99 	rcall	80007aec <mns_trace>
8000f7be:	30 4c       	mov	r12,4
8000f7c0:	2f fd       	sub	sp,-4
8000f7c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000f7c6:	d7 03       	nop
8000f7c8:	00 00       	add	r0,r0
8000f7ca:	39 9c       	mov	r12,-103

8000f7cc <VmsvGetSSOResult>:
8000f7cc:	d4 21       	pushm	r4-r7,lr
8000f7ce:	18 97       	mov	r7,r12
8000f7d0:	58 0c       	cp.w	r12,0
8000f7d2:	c3 d0       	breq	8000f84c <VmsvGetSSOResult+0x80>
8000f7d4:	31 1c       	mov	r12,17
8000f7d6:	fe b0 c1 70 	rcall	80007ab6 <mns_take>
8000f7da:	4a 28       	lddpc	r8,8000f860 <VmsvGetSSOResult+0x94>
8000f7dc:	70 f9       	ld.w	r9,r8[0x3c]
8000f7de:	31 1c       	mov	r12,17
8000f7e0:	72 65       	ld.w	r5,r9[0x18]
8000f7e2:	f3 34 00 1c 	ld.ub	r4,r9[28]
8000f7e6:	f1 36 00 2b 	ld.ub	r6,r8[43]

    TAKE_VMSV();
    ssoresult = vmsv.shadow.ssoresult;
    diag_id   = vmsv.cfg_ptr->diag_id.stream;
    len       = vmsv.cfg_ptr->diag_id.length;
    GIVE_VMSV();
8000f7ea:	fe b0 c1 67 	rcall	80007ab8 <mns_give>


    if (NULL == diag_id)            /* prevent copying from NULL pointer */
8000f7ee:	58 05       	cp.w	r5,0
8000f7f0:	c2 80       	breq	8000f840 <VmsvGetSSOResult+0x74>
    {
        len = (byte)0;
    }
    else if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
8000f7f2:	e0 6c 40 00 	mov	r12,16384
8000f7f6:	fe b0 db 5f 	rcall	8000aeb4 <MostIsSupported>
8000f7fa:	c1 a0       	breq	8000f82e <VmsvGetSSOResult+0x62>
    {
        len = (byte)0;
        FAILED_ASSERT();
    }

    msg_ptr->Data[0] = ssoresult;
8000f7fc:	6e 08       	ld.w	r8,r7[0x0]
8000f7fe:	b0 86       	st.b	r8[0x0],r6
    {
        len = (byte)0;
    }
    else if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
    {
        len = (len < CTRL_MAX_PAYLOAD_OS81110 ) ? len : CTRL_MAX_PAYLOAD_OS81110 - 1;
8000f800:	32 c8       	mov	r8,44
8000f802:	e8 08 18 00 	cp.b	r8,r4
8000f806:	f9 b4 03 2c 	movlo	r4,44
        len = (byte)0;
        FAILED_ASSERT();
    }

    msg_ptr->Data[0] = ssoresult;
    for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
8000f80a:	58 04       	cp.w	r4,0
8000f80c:	c1 c0       	breq	8000f844 <VmsvGetSSOResult+0x78>
        len = (len < CTRL_MAX_PAYLOAD_OS81110 ) ? len : CTRL_MAX_PAYLOAD_OS81110 - 1;
    }
    else
    {
        len = (byte)0;
        FAILED_ASSERT();
8000f80e:	30 18       	mov	r8,1
    }

    msg_ptr->Data[0] = ssoresult;
    for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
    {
        msg_ptr->Data[i] = *diag_id++; /*lint !e613 suppress "len is always 0 if diag_id is NULL" */
8000f810:	6e 09       	ld.w	r9,r7[0x0]
8000f812:	0b 3a       	ld.ub	r10,r5++
8000f814:	f2 08 0b 0a 	st.b	r9[r8],r10
        len = (byte)0;
        FAILED_ASSERT();
    }

    msg_ptr->Data[0] = ssoresult;
    for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
8000f818:	2f f8       	sub	r8,-1
8000f81a:	5c 58       	castu.b	r8
8000f81c:	f0 04 18 00 	cp.b	r4,r8
8000f820:	cf 82       	brcc	8000f810 <VmsvGetSSOResult+0x44>
8000f822:	08 9c       	mov	r12,r4
8000f824:	2f f4       	sub	r4,-1
8000f826:	2f fc       	sub	r12,-1
    {
        msg_ptr->Data[i] = *diag_id++; /*lint !e613 suppress "len is always 0 if diag_id is NULL" */
    }
    msg_ptr->Length = len+1;
8000f828:	ae 24       	st.h	r7[0x4],r4
        len = (byte)0;
        FAILED_ASSERT();
    }

    msg_ptr->Data[0] = ssoresult;
    for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
8000f82a:	5c 5c       	castu.b	r12
    msg_ptr->Length = len+1;

    T_API_EXIT(VMSV_88);

    return(len+1);
}
8000f82c:	d8 22       	popm	r4-r7,pc
        len = (len < CTRL_MAX_PAYLOAD_OS81110 ) ? len : CTRL_MAX_PAYLOAD_OS81110 - 1;
    }
    else
    {
        len = (byte)0;
        FAILED_ASSERT();
8000f82e:	e0 68 0c 7f 	mov	r8,3199
8000f832:	30 1a       	mov	r10,1
8000f834:	1a d8       	st.w	--sp,r8
8000f836:	31 0b       	mov	r11,16
8000f838:	34 0c       	mov	r12,64
8000f83a:	fe b0 c1 59 	rcall	80007aec <mns_trace>
8000f83e:	2f fd       	sub	sp,-4
    }

    msg_ptr->Data[0] = ssoresult;
8000f840:	6e 08       	ld.w	r8,r7[0x0]
8000f842:	b0 86       	st.b	r8[0x0],r6
8000f844:	30 1c       	mov	r12,1
8000f846:	18 94       	mov	r4,r12
    for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
    {
        msg_ptr->Data[i] = *diag_id++; /*lint !e613 suppress "len is always 0 if diag_id is NULL" */
    }
    msg_ptr->Length = len+1;
8000f848:	ae 24       	st.h	r7[0x4],r4

    T_API_EXIT(VMSV_88);

    return(len+1);
}
8000f84a:	d8 22       	popm	r4-r7,pc
    byte len;
    byte *diag_id;


    T_API_ENTRY(VMSV_88);
    ASSERT(msg_ptr);
8000f84c:	e0 68 0c 6b 	mov	r8,3179
8000f850:	30 1a       	mov	r10,1
8000f852:	1a d8       	st.w	--sp,r8
8000f854:	31 0b       	mov	r11,16
8000f856:	34 0c       	mov	r12,64
8000f858:	fe b0 c1 4a 	rcall	80007aec <mns_trace>
8000f85c:	2f fd       	sub	sp,-4
8000f85e:	cb bb       	rjmp	8000f7d4 <VmsvGetSSOResult+0x8>
8000f860:	00 00       	add	r0,r0
8000f862:	39 9c       	mov	r12,-103

8000f864 <VmsvBroadcastRBDResult>:
8000f864:	eb cd 40 f8 	pushm	r3-r7,lr
8000f868:	31 1c       	mov	r12,17
8000f86a:	fe b0 c1 26 	rcall	80007ab6 <mns_take>
8000f86e:	4c 04       	lddpc	r4,8000f96c <VmsvBroadcastRBDResult+0x108>
8000f870:	68 f8       	ld.w	r8,r4[0x3c]
8000f872:	31 1c       	mov	r12,17
    T_MOD_ENTRY(VMSV_69);

    result = ERR_NO;

    TAKE_VMSV();
    diag_id = vmsv.cfg_ptr->diag_id.stream;
8000f874:	70 67       	ld.w	r7,r8[0x18]
    len     = vmsv.cfg_ptr->diag_id.length;
8000f876:	f1 36 00 1c 	ld.ub	r6,r8[28]
    GIVE_VMSV();
8000f87a:	fe b0 c1 1f 	rcall	80007ab8 <mns_give>

    if (NULL == diag_id)            /* prevent copying from NULL pointer */
8000f87e:	58 07       	cp.w	r7,0
8000f880:	c6 b0       	breq	8000f956 <VmsvBroadcastRBDResult+0xf2>
    {
        len = (byte)0;
    }
    else if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
8000f882:	e0 6c 40 00 	mov	r12,16384
8000f886:	fe b0 db 17 	rcall	8000aeb4 <MostIsSupported>
8000f88a:	c4 90       	breq	8000f91c <VmsvBroadcastRBDResult+0xb8>
    {
        len = (len < CTRL_MAX_PAYLOAD_OS81110 ) ? len : CTRL_MAX_PAYLOAD_OS81110 - 1;
8000f88c:	32 c5       	mov	r5,44
8000f88e:	ec 05 18 00 	cp.b	r5,r6
8000f892:	ec 05 17 20 	movhs	r5,r6
8000f896:	f9 b5 03 2c 	movlo	r5,44
8000f89a:	ea cc ff ff 	sub	r12,r5,-1
    {
        len = (byte)0;
        FAILED_ASSERT();
    }

    msg_ptr = MsgGetTxPtrExt(1 + len);
8000f89e:	fe b0 ca ff 	rcall	80008e9c <MsgGetTxPtrExt>
8000f8a2:	18 96       	mov	r6,r12

    if (msg_ptr)
8000f8a4:	c4 b0       	breq	8000f93a <VmsvBroadcastRBDResult+0xd6>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_BROADCAST;
8000f8a6:	e0 68 03 c8 	mov	r8,968
8000f8aa:	b8 38       	st.h	r12[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = (byte)0x00;
8000f8ac:	30 08       	mov	r8,0
8000f8ae:	f9 68 00 0b 	st.b	r12[11],r8
        msg_ptr->Func_ID   = FUNC_NB_RBDRESULT;
8000f8b2:	e0 68 04 05 	mov	r8,1029
8000f8b6:	b8 48       	st.h	r12[0x8],r8
        msg_ptr->Operation = OP_STATUS;
8000f8b8:	30 c8       	mov	r8,12
    msg_ptr = MsgGetTxPtrExt(1 + len);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_BROADCAST;
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
8000f8ba:	30 13       	mov	r3,1
        msg_ptr->Inst_ID   = (byte)0x00;
        msg_ptr->Func_ID   = FUNC_NB_RBDRESULT;
        msg_ptr->Operation = OP_STATUS;
8000f8bc:	f9 68 00 0c 	st.b	r12[12],r8
    msg_ptr = MsgGetTxPtrExt(1 + len);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_BROADCAST;
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
8000f8c0:	f9 63 00 0a 	st.b	r12[10],r3
        msg_ptr->Inst_ID   = (byte)0x00;
        msg_ptr->Func_ID   = FUNC_NB_RBDRESULT;
        msg_ptr->Operation = OP_STATUS;


        TAKE_VMSV();
8000f8c4:	31 1c       	mov	r12,17
8000f8c6:	fe b0 c0 f8 	rcall	80007ab6 <mns_take>
        switch (vmsv.shadow.rbdresult[0])
8000f8ca:	e9 38 00 29 	ld.ub	r8,r4[41]
8000f8ce:	e6 08 18 00 	cp.b	r8,r3
8000f8d2:	c4 80       	breq	8000f962 <VmsvBroadcastRBDResult+0xfe>
8000f8d4:	30 39       	mov	r9,3
8000f8d6:	f2 08 18 00 	cp.b	r8,r9
8000f8da:	c4 10       	breq	8000f95c <VmsvBroadcastRBDResult+0xf8>
            case MSVAL_DIAG_SIGNAL_NO_LOCK:                 /* activity but no lock */
                msg_ptr->Data[0] = RBD_ACTIVITY_NO_LOCK;
                break;

            default:
                msg_ptr->Data[0] = INIC_SHADOW_INVALID_BYTE;     /* indicates SW Error */
8000f8dc:	6c 08       	ld.w	r8,r6[0x0]
8000f8de:	3e e9       	mov	r9,-18
8000f8e0:	b0 89       	st.b	r8[0x0],r9
                FAILED_ASSERT();
8000f8e2:	e0 68 0a aa 	mov	r8,2730
8000f8e6:	30 1a       	mov	r10,1
8000f8e8:	1a d8       	st.w	--sp,r8
8000f8ea:	31 0b       	mov	r11,16
8000f8ec:	34 0c       	mov	r12,64
8000f8ee:	fe b0 c0 ff 	rcall	80007aec <mns_trace>
8000f8f2:	2f fd       	sub	sp,-4
                break;
        }
        GIVE_VMSV();
8000f8f4:	31 1c       	mov	r12,17
8000f8f6:	fe b0 c0 e1 	rcall	80007ab8 <mns_give>

        for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
8000f8fa:	58 05       	cp.w	r5,0
8000f8fc:	c0 b0       	breq	8000f912 <VmsvBroadcastRBDResult+0xae>
8000f8fe:	30 18       	mov	r8,1
        {
            msg_ptr->Data[i] = *diag_id++;
8000f900:	6c 09       	ld.w	r9,r6[0x0]
8000f902:	0f 3a       	ld.ub	r10,r7++
8000f904:	f2 08 0b 0a 	st.b	r9[r8],r10
                FAILED_ASSERT();
                break;
        }
        GIVE_VMSV();

        for (i=(byte)1; i <= len; ++i)     /* copy diag_id into message */
8000f908:	2f f8       	sub	r8,-1
8000f90a:	5c 58       	castu.b	r8
8000f90c:	f0 05 18 00 	cp.b	r5,r8
8000f910:	cf 82       	brcc	8000f900 <VmsvBroadcastRBDResult+0x9c>
        {
            msg_ptr->Data[i] = *diag_id++;
        }

        MsgSend3(msg_ptr);
8000f912:	0c 9c       	mov	r12,r6
8000f914:	fe b0 ce 08 	rcall	80009524 <MsgSend3>
8000f918:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
        len = (len < CTRL_MAX_PAYLOAD_OS81110 ) ? len : CTRL_MAX_PAYLOAD_OS81110 - 1;
    }
    else
    {
        len = (byte)0;
        FAILED_ASSERT();
8000f91c:	e0 68 0a 8f 	mov	r8,2703
8000f920:	30 1a       	mov	r10,1
8000f922:	1a d8       	st.w	--sp,r8
8000f924:	31 0b       	mov	r11,16
8000f926:	18 95       	mov	r5,r12
8000f928:	34 0c       	mov	r12,64
8000f92a:	fe b0 c0 e1 	rcall	80007aec <mns_trace>
8000f92e:	30 1c       	mov	r12,1
8000f930:	2f fd       	sub	sp,-4
    }

    msg_ptr = MsgGetTxPtrExt(1 + len);
8000f932:	fe b0 ca b5 	rcall	80008e9c <MsgGetTxPtrExt>
8000f936:	18 96       	mov	r6,r12

    if (msg_ptr)
8000f938:	cb 71       	brne	8000f8a6 <VmsvBroadcastRBDResult+0x42>

        MsgSend3(msg_ptr);
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_RBDRESULT);
8000f93a:	31 0c       	mov	r12,16
8000f93c:	fe b0 c0 bd 	rcall	80007ab6 <mns_take>
8000f940:	e9 08 00 64 	ld.sh	r8,r4[100]
8000f944:	31 0c       	mov	r12,16
8000f946:	18 48       	or	r8,r12
8000f948:	e9 58 00 64 	st.h	r4[100],r8
8000f94c:	fe b0 c0 b6 	rcall	80007ab8 <mns_give>
8000f950:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(VMSV_69);
    return(result);
}
8000f952:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    TAKE_VMSV();
    diag_id = vmsv.cfg_ptr->diag_id.stream;
    len     = vmsv.cfg_ptr->diag_id.length;
    GIVE_VMSV();

    if (NULL == diag_id)            /* prevent copying from NULL pointer */
8000f956:	30 1c       	mov	r12,1
8000f958:	0e 95       	mov	r5,r7
8000f95a:	ca 2b       	rjmp	8000f89e <VmsvBroadcastRBDResult+0x3a>
            case MSVAL_DIAG_POS:
                msg_ptr->Data[0] = RBD_NO_ACTIVITY;         /* ring break */
                break;

            case MSVAL_DIAG_SIGNAL_NO_LOCK:                 /* activity but no lock */
                msg_ptr->Data[0] = RBD_ACTIVITY_NO_LOCK;
8000f95c:	6c 08       	ld.w	r8,r6[0x0]
8000f95e:	b0 83       	st.b	r8[0x0],r3
                break;
8000f960:	cc ab       	rjmp	8000f8f4 <VmsvBroadcastRBDResult+0x90>

        TAKE_VMSV();
        switch (vmsv.shadow.rbdresult[0])
        {
            case MSVAL_DIAG_POS:
                msg_ptr->Data[0] = RBD_NO_ACTIVITY;         /* ring break */
8000f962:	6c 08       	ld.w	r8,r6[0x0]
8000f964:	30 29       	mov	r9,2
8000f966:	b0 89       	st.b	r8[0x0],r9
                break;
8000f968:	cc 6b       	rjmp	8000f8f4 <VmsvBroadcastRBDResult+0x90>
8000f96a:	d7 03       	nop
8000f96c:	00 00       	add	r0,r0
8000f96e:	39 9c       	mov	r12,-103

8000f970 <VmsvInjectCfgState>:
8000f970:	eb cd 40 80 	pushm	r7,lr
8000f974:	30 1c       	mov	r12,1
8000f976:	fe b0 ca 81 	rcall	80008e78 <MsgGetRxInPtrExt>
8000f97a:	18 97       	mov	r7,r12
8000f97c:	c2 90       	breq	8000f9ce <VmsvInjectCfgState+0x5e>
8000f97e:	31 1c       	mov	r12,17
8000f980:	fe b0 c0 9b 	rcall	80007ab6 <mns_take>
8000f984:	49 a8       	lddpc	r8,8000f9ec <VmsvInjectCfgState+0x7c>
8000f986:	f1 09 00 30 	ld.sh	r9,r8[48]
    msg_ptr = MsgGetRxInPtrExt(1);

    if (msg_ptr)
    {
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
8000f98a:	ae 39       	st.h	r7[0x6],r9
        if (NCS_NWMINST_MASK & vmsv.shadow.ncstate_flags)
8000f98c:	f1 39 00 2e 	ld.ub	r9,r8[46]
        {
            /* InstID is not 0x01 */
            msg_ptr->Inst_ID   = VMSV_NWM_INST_ID;
8000f990:	ed b9 00 02 	bld	r9,0x2
8000f994:	f9 b9 00 00 	moveq	r9,0
8000f998:	ef f9 0e 0b 	st.beq	r7[0xb],r9
        }
        else
        {
            /* InstID is 0x01 or NCFlags is not supported */
            msg_ptr->Inst_ID   = VMSV_NWM_STD_INST_ID; /* 0x01 */
8000f99c:	f9 b9 01 01 	movne	r9,1
8000f9a0:	ef f9 1e 0b 	st.bne	r7[0xb],r9
        }
        msg_ptr->FBlock_ID = FBLOCK_NETWORKMASTER;
8000f9a4:	30 29       	mov	r9,2
8000f9a6:	ef 69 00 0a 	st.b	r7[10],r9
        msg_ptr->Func_ID   = FUNCID_NWM_CONFIGURATION;
8000f9aa:	e0 69 0a 00 	mov	r9,2560
8000f9ae:	ae 49       	st.h	r7[0x8],r9
        msg_ptr->Operation = OP_STATUS;
8000f9b0:	30 c9       	mov	r9,12
8000f9b2:	ef 69 00 0c 	st.b	r7[12],r9
        msg_ptr->Data[0]   = vmsv.shadow.ncstate;
8000f9b6:	f1 39 00 2d 	ld.ub	r9,r8[45]
8000f9ba:	6e 08       	ld.w	r8,r7[0x0]
        GIVE_VMSV();
8000f9bc:	31 1c       	mov	r12,17
            msg_ptr->Inst_ID   = VMSV_NWM_STD_INST_ID; /* 0x01 */
        }
        msg_ptr->FBlock_ID = FBLOCK_NETWORKMASTER;
        msg_ptr->Func_ID   = FUNCID_NWM_CONFIGURATION;
        msg_ptr->Operation = OP_STATUS;
        msg_ptr->Data[0]   = vmsv.shadow.ncstate;
8000f9be:	b0 89       	st.b	r8[0x0],r9
        GIVE_VMSV();
8000f9c0:	fe b0 c0 7c 	rcall	80007ab8 <mns_give>

        MsgRxInReady(msg_ptr);
8000f9c4:	0e 9c       	mov	r12,r7
8000f9c6:	fe b0 cc a9 	rcall	80009318 <MsgRxInReady>
8000f9ca:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_CFG_STATE);
8000f9ce:	31 0c       	mov	r12,16
8000f9d0:	fe b0 c0 73 	rcall	80007ab6 <mns_take>
8000f9d4:	48 69       	lddpc	r9,8000f9ec <VmsvInjectCfgState+0x7c>
8000f9d6:	f3 08 00 64 	ld.sh	r8,r9[100]
8000f9da:	a3 b8       	sbr	r8,0x3
8000f9dc:	31 0c       	mov	r12,16
8000f9de:	f3 58 00 64 	st.h	r9[100],r8
8000f9e2:	fe b0 c0 6b 	rcall	80007ab8 <mns_give>
8000f9e6:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(VMSV_59);
    return(result);
}
8000f9e8:	e3 cd 80 80 	ldm	sp++,r7,pc
8000f9ec:	00 00       	add	r0,r0
8000f9ee:	39 9c       	mov	r12,-103

8000f9f0 <VmsvTxFilter>:
8000f9f0:	eb cd 40 80 	pushm	r7,lr
8000f9f4:	18 97       	mov	r7,r12
8000f9f6:	58 0c       	cp.w	r12,0
8000f9f8:	c7 00       	breq	8000fad8 <VmsvTxFilter+0xe8>
8000f9fa:	6e 28       	ld.w	r8,r7[0x8]
8000f9fc:	e0 18 ff 00 	andl	r8,0xff00
    check  = MNS_FALSE;
    inject = MNS_FALSE;

    ASSERT(msg_ptr);

    if ((FBLOCK_NETBLOCK == msg_ptr->FBlock_ID) &&
8000fa00:	e0 48 01 00 	cp.w	r8,256
8000fa04:	c4 20       	breq	8000fa88 <VmsvTxFilter+0x98>
        if (MNS_FALSE != inject)
        {
            VmsvInjectCfgState();
        }
    }
    else if ((FBLOCK_NETWORKMASTER      == msg_ptr->FBlock_ID) &&
8000fa06:	e0 69 02 00 	mov	r9,512
8000fa0a:	ea 19 0a 00 	orh	r9,0xa00
8000fa0e:	12 38       	cp.w	r8,r9
8000fa10:	c0 71       	brne	8000fa1e <VmsvTxFilter+0x2e>
             (FUNCID_NWM_CONFIGURATION  == msg_ptr->Func_ID)   &&
             (OP_STATUS                 == msg_ptr->Operation) )
8000fa12:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000fa16:	30 c8       	mov	r8,12
8000fa18:	f0 09 18 00 	cp.b	r9,r8
8000fa1c:	c1 f0       	breq	8000fa5a <VmsvTxFilter+0x6a>
            }
            GIVE_VMSV();
        }
    else
    {
        TAKE_VMSV();
8000fa1e:	31 1c       	mov	r12,17
8000fa20:	fe b0 c0 4b 	rcall	80007ab6 <mns_take>
        check = ((NCS_INVALID_NWM != vmsv.shadow.nwm_addr) &&
8000fa24:	4b 28       	lddpc	r8,8000faec <VmsvTxFilter+0xfc>
8000fa26:	3f f9       	mov	r9,-1
8000fa28:	f1 0a 00 30 	ld.sh	r10,r8[48]
8000fa2c:	f2 0a 19 00 	cp.h	r10,r9
8000fa30:	c2 70       	breq	8000fa7e <VmsvTxFilter+0x8e>
8000fa32:	f1 39 00 2d 	ld.ub	r9,r8[45]
8000fa36:	30 08       	mov	r8,0
8000fa38:	f0 09 18 00 	cp.b	r9,r8
8000fa3c:	c2 11       	brne	8000fa7e <VmsvTxFilter+0x8e>
                 (NCS_NOT_OK == vmsv.shadow.ncstate)) ? MNS_TRUE : MNS_FALSE;
        GIVE_VMSV();
8000fa3e:	31 1c       	mov	r12,17
8000fa40:	fe b0 c0 3c 	rcall	80007ab8 <mns_give>

        if( (MNS_FALSE != check) && (FBLOCK_NETWORKMASTER == msg_ptr->FBlock_ID) &&
8000fa44:	6e 28       	ld.w	r8,r7[0x8]
8000fa46:	e0 69 02 00 	mov	r9,512
8000fa4a:	ea 19 0a 00 	orh	r9,0xa00
8000fa4e:	e0 18 ff 00 	andl	r8,0xff00
8000fa52:	12 38       	cp.w	r8,r9
8000fa54:	c3 a0       	breq	8000fac8 <VmsvTxFilter+0xd8>
                               (FUNCID_NWM_CONFIGURATION  == msg_ptr->Func_ID)   &&
                               (OP_GET                    == msg_ptr->Operation))
        {
            (void)VmsvInjectCfgState();
8000fa56:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    }
    else if ((FBLOCK_NETWORKMASTER      == msg_ptr->FBlock_ID) &&
             (FUNCID_NWM_CONFIGURATION  == msg_ptr->Func_ID)   &&
             (OP_STATUS                 == msg_ptr->Operation) )
        {
            TAKE_VMSV();
8000fa5a:	31 1c       	mov	r12,17
8000fa5c:	fe b0 c0 2d 	rcall	80007ab6 <mns_take>
            if (NISTATE_NET_ON == vmsv.shadow.nistate)
8000fa60:	4a 38       	lddpc	r8,8000faec <VmsvTxFilter+0xfc>
8000fa62:	30 39       	mov	r9,3
8000fa64:	f1 3a 00 21 	ld.ub	r10,r8[33]
8000fa68:	f2 0a 18 00 	cp.b	r10,r9
8000fa6c:	c0 91       	brne	8000fa7e <VmsvTxFilter+0x8e>
            {
                vmsv.shadow.ncstate  = (0x00 != msg_ptr->Data[0]) ? NCS_OK : NCS_NOT_OK;
8000fa6e:	6e 09       	ld.w	r9,r7[0x0]
8000fa70:	13 8a       	ld.ub	r10,r9[0x0]
8000fa72:	30 09       	mov	r9,0
8000fa74:	f2 0a 18 00 	cp.b	r10,r9
8000fa78:	5f 19       	srne	r9
8000fa7a:	f1 69 00 2d 	st.b	r8[45],r9
    else
    {
        TAKE_VMSV();
        check = ((NCS_INVALID_NWM != vmsv.shadow.nwm_addr) &&
                 (NCS_NOT_OK == vmsv.shadow.ncstate)) ? MNS_TRUE : MNS_FALSE;
        GIVE_VMSV();
8000fa7e:	31 1c       	mov	r12,17
8000fa80:	fe b0 c0 1c 	rcall	80007ab8 <mns_give>
8000fa84:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

    ASSERT(msg_ptr);

    if ((FBLOCK_NETBLOCK == msg_ptr->FBlock_ID) &&
        (FUNC_FBLOCKIDS  == msg_ptr->Func_ID)   &&
        (OP_STATUS       == msg_ptr->Operation))
8000fa88:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000fa8c:	30 c8       	mov	r8,12
8000fa8e:	f0 09 18 00 	cp.b	r9,r8
8000fa92:	cc 61       	brne	8000fa1e <VmsvTxFilter+0x2e>
    {
        TAKE_VMSV();
8000fa94:	31 1c       	mov	r12,17
8000fa96:	fe b0 c0 10 	rcall	80007ab6 <mns_take>

        vmsv.fblock_ids_status_sent = MNS_TRUE;
8000fa9a:	49 58       	lddpc	r8,8000faec <VmsvTxFilter+0xfc>
8000fa9c:	30 19       	mov	r9,1
8000fa9e:	f1 69 00 62 	st.b	r8[98],r9
        if (VMSV_CP_INJECTED == vmsv.check_phase.state)
8000faa2:	f1 3a 00 5c 	ld.ub	r10,r8[92]
8000faa6:	f2 0a 18 00 	cp.b	r10,r9
8000faaa:	ce a1       	brne	8000fa7e <VmsvTxFilter+0x8e>
        {
            vmsv.check_phase.state = VMSV_CP_DO_NOTHING;
8000faac:	30 09       	mov	r9,0
8000faae:	f1 69 00 5c 	st.b	r8[92],r9

            if (0 == msg_ptr->Length)
8000fab2:	30 08       	mov	r8,0
8000fab4:	8e 29       	ld.sh	r9,r7[0x4]
8000fab6:	f0 09 19 00 	cp.h	r9,r8
8000faba:	ce 21       	brne	8000fa7e <VmsvTxFilter+0x8e>
                result = MSG_TX_FILTER_CANCEL;
                inject = MNS_TRUE;
            }
        }

        GIVE_VMSV();
8000fabc:	31 1c       	mov	r12,17
8000fabe:	fe b0 bf fd 	rcall	80007ab8 <mns_give>

        if (MNS_FALSE != inject)
        {
            VmsvInjectCfgState();
8000fac2:	c5 7f       	rcall	8000f970 <VmsvInjectCfgState>
8000fac4:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000fac8:	ef 39 00 0c 	ld.ub	r9,r7[12]
                 (NCS_NOT_OK == vmsv.shadow.ncstate)) ? MNS_TRUE : MNS_FALSE;
        GIVE_VMSV();

        if( (MNS_FALSE != check) && (FBLOCK_NETWORKMASTER == msg_ptr->FBlock_ID) &&
                               (FUNCID_NWM_CONFIGURATION  == msg_ptr->Func_ID)   &&
                               (OP_GET                    == msg_ptr->Operation))
8000facc:	30 18       	mov	r8,1
8000face:	f0 09 18 00 	cp.b	r9,r8
8000fad2:	cf 80       	breq	8000fac2 <VmsvTxFilter+0xd2>
8000fad4:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
        {
            (void)VmsvInjectCfgState();
8000fad8:	e0 68 06 fb 	mov	r8,1787

    result = MSG_TX_FILTER_DEFAULT;
    check  = MNS_FALSE;
    inject = MNS_FALSE;

    ASSERT(msg_ptr);
8000fadc:	30 1a       	mov	r10,1
8000fade:	1a d8       	st.w	--sp,r8
8000fae0:	31 0b       	mov	r11,16
8000fae2:	34 0c       	mov	r12,64
8000fae4:	fe b0 c0 04 	rcall	80007aec <mns_trace>
8000fae8:	2f fd       	sub	sp,-4
8000faea:	c8 8b       	rjmp	8000f9fa <VmsvTxFilter+0xa>
8000faec:	00 00       	add	r0,r0
8000faee:	39 9c       	mov	r12,-103

8000faf0 <VmsvInjectFBlockIDsGet>:
8000faf0:	eb cd 40 80 	pushm	r7,lr
8000faf4:	30 0c       	mov	r12,0
8000faf6:	fe b0 c9 c1 	rcall	80008e78 <MsgGetRxInPtrExt>
8000fafa:	18 97       	mov	r7,r12
8000fafc:	c1 b0       	breq	8000fb32 <VmsvInjectFBlockIDsGet+0x42>
8000fafe:	31 1c       	mov	r12,17
8000fb00:	fe b0 bf db 	rcall	80007ab6 <mns_take>

    msg_ptr = MsgGetRxInPtrExt(0);
    if (msg_ptr)
    {
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
8000fb04:	49 38       	lddpc	r8,8000fb50 <VmsvInjectFBlockIDsGet+0x60>
8000fb06:	f1 08 00 30 	ld.sh	r8,r8[48]
        GIVE_VMSV();
8000fb0a:	31 1c       	mov	r12,17

    msg_ptr = MsgGetRxInPtrExt(0);
    if (msg_ptr)
    {
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
8000fb0c:	ae 38       	st.h	r7[0x6],r8
        GIVE_VMSV();
8000fb0e:	fe b0 bf d5 	rcall	80007ab8 <mns_give>
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
8000fb12:	30 18       	mov	r8,1
        msg_ptr->Inst_ID   = (byte)0xFF;
        msg_ptr->Func_ID   = FUNC_FBLOCKIDS;
        msg_ptr->Operation = OP_GET;
8000fb14:	ef 68 00 0c 	st.b	r7[12],r8
    if (msg_ptr)
    {
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
        GIVE_VMSV();
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
8000fb18:	ef 68 00 0a 	st.b	r7[10],r8
        msg_ptr->Inst_ID   = (byte)0xFF;
        msg_ptr->Func_ID   = FUNC_FBLOCKIDS;
8000fb1c:	30 08       	mov	r8,0
        msg_ptr->Operation = OP_GET;
        msg_ptr->Length    = (word)0;
8000fb1e:	ae 28       	st.h	r7[0x4],r8
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
        GIVE_VMSV();
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = (byte)0xFF;
        msg_ptr->Func_ID   = FUNC_FBLOCKIDS;
8000fb20:	ae 48       	st.h	r7[0x8],r8
    {
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
        GIVE_VMSV();
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = (byte)0xFF;
8000fb22:	3f f8       	mov	r8,-1
        msg_ptr->Func_ID   = FUNC_FBLOCKIDS;
        msg_ptr->Operation = OP_GET;
        msg_ptr->Length    = (word)0;

        MsgRxInReady(msg_ptr);
8000fb24:	0e 9c       	mov	r12,r7
    {
        TAKE_VMSV();
        msg_ptr->Src_Adr   = vmsv.shadow.nwm_addr;
        GIVE_VMSV();
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = (byte)0xFF;
8000fb26:	ef 68 00 0b 	st.b	r7[11],r8
        msg_ptr->Func_ID   = FUNC_FBLOCKIDS;
        msg_ptr->Operation = OP_GET;
        msg_ptr->Length    = (word)0;

        MsgRxInReady(msg_ptr);
8000fb2a:	fe b0 cb f7 	rcall	80009318 <MsgRxInReady>
8000fb2e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(VMSV_RETRY_FBLOCKIDS_GET);
8000fb32:	31 0c       	mov	r12,16
8000fb34:	fe b0 bf c1 	rcall	80007ab6 <mns_take>
8000fb38:	48 69       	lddpc	r9,8000fb50 <VmsvInjectFBlockIDsGet+0x60>
8000fb3a:	f3 08 00 64 	ld.sh	r8,r9[100]
8000fb3e:	a1 a8       	sbr	r8,0x0
8000fb40:	31 0c       	mov	r12,16
8000fb42:	f3 58 00 64 	st.h	r9[100],r8
8000fb46:	fe b0 bf b9 	rcall	80007ab8 <mns_give>
8000fb4a:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(VMSV_37);
    return(result);
}
8000fb4c:	e3 cd 80 80 	ldm	sp++,r7,pc
8000fb50:	00 00       	add	r0,r0
8000fb52:	39 9c       	mov	r12,-103

8000fb54 <VmsvHandleNCStateChange>:
8000fb54:	d4 01       	pushm	lr
8000fb56:	31 1c       	mov	r12,17
8000fb58:	fe b0 bf af 	rcall	80007ab6 <mns_take>
8000fb5c:	49 39       	lddpc	r9,8000fba8 <VmsvHandleNCStateChange+0x54>
8000fb5e:	30 2a       	mov	r10,2
8000fb60:	f3 38 00 5c 	ld.ub	r8,r9[92]
    T_MOD_ENTRY(VMSV_35);

    inject = MNS_FALSE;

    TAKE_VMSV();
    if ( ((VMSV_CP_WAITING == vmsv.check_phase.state) ||
8000fb64:	f4 08 18 00 	cp.b	r8,r10
8000fb68:	c0 d0       	breq	8000fb82 <VmsvHandleNCStateChange+0x2e>
8000fb6a:	58 08       	cp.w	r8,0
8000fb6c:	c1 11       	brne	8000fb8e <VmsvHandleNCStateChange+0x3a>
8000fb6e:	f3 3a 00 62 	ld.ub	r10,r9[98]
8000fb72:	f0 0a 18 00 	cp.b	r10,r8
8000fb76:	c0 c1       	brne	8000fb8e <VmsvHandleNCStateChange+0x3a>
8000fb78:	f3 38 00 60 	ld.ub	r8,r9[96]
8000fb7c:	f4 08 18 00 	cp.b	r8,r10
8000fb80:	c0 70       	breq	8000fb8e <VmsvHandleNCStateChange+0x3a>
8000fb82:	f3 38 00 2d 	ld.ub	r8,r9[45]
8000fb86:	30 19       	mov	r9,1
8000fb88:	f2 08 18 00 	cp.b	r8,r9
8000fb8c:	c0 50       	breq	8000fb96 <VmsvHandleNCStateChange+0x42>
         (NCS_OK == vmsv.shadow.ncstate) )
    {
        inject = MNS_TRUE;
        vmsv.check_phase.state = VMSV_CP_INJECTED;
    }
    GIVE_VMSV();
8000fb8e:	31 1c       	mov	r12,17
8000fb90:	fe b0 bf 94 	rcall	80007ab8 <mns_give>
8000fb94:	d8 02       	popm	pc
         ((VMSV_CP_DO_NOTHING == vmsv.check_phase.state) &&
         (MNS_FALSE == vmsv.fblock_ids_status_sent) && (MNS_FALSE != vmsv.attached))) &&
         (NCS_OK == vmsv.shadow.ncstate) )
    {
        inject = MNS_TRUE;
        vmsv.check_phase.state = VMSV_CP_INJECTED;
8000fb96:	48 59       	lddpc	r9,8000fba8 <VmsvHandleNCStateChange+0x54>
    }
    GIVE_VMSV();
8000fb98:	31 1c       	mov	r12,17
         ((VMSV_CP_DO_NOTHING == vmsv.check_phase.state) &&
         (MNS_FALSE == vmsv.fblock_ids_status_sent) && (MNS_FALSE != vmsv.attached))) &&
         (NCS_OK == vmsv.shadow.ncstate) )
    {
        inject = MNS_TRUE;
        vmsv.check_phase.state = VMSV_CP_INJECTED;
8000fb9a:	f3 68 00 5c 	st.b	r9[92],r8
    }
    GIVE_VMSV();
8000fb9e:	fe b0 bf 8d 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != inject)
    {
        (void)VmsvInjectFBlockIDsGet();
8000fba2:	ca 7f       	rcall	8000faf0 <VmsvInjectFBlockIDsGet>
8000fba4:	d8 02       	popm	pc
8000fba6:	d7 03       	nop
8000fba8:	00 00       	add	r0,r0
8000fbaa:	39 9c       	mov	r12,-103

8000fbac <VmsvHandleConfigStatus>:
8000fbac:	eb cd 40 c0 	pushm	r6-r7,lr
8000fbb0:	18 97       	mov	r7,r12
8000fbb2:	58 0c       	cp.w	r12,0
8000fbb4:	c2 40       	breq	8000fbfc <VmsvHandleConfigStatus+0x50>
8000fbb6:	fe b0 d9 9d 	rcall	8000aef0 <MnsGetEHCIState>
{
    T_LIB_ENTRY(VMSV_34);

    ASSERT(msg_ptr);

    if (EHCISTATE_IS_ATTACHED())
8000fbba:	30 28       	mov	r8,2
8000fbbc:	f0 0c 18 00 	cp.b	r12,r8
8000fbc0:	c0 30       	breq	8000fbc6 <VmsvHandleConfigStatus+0x1a>
8000fbc2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    {
        MostClearTimer(&(vmsv.check_phase.timer));
8000fbc6:	30 0a       	mov	r10,0
8000fbc8:	49 26       	lddpc	r6,8000fc10 <VmsvHandleConfigStatus+0x64>
8000fbca:	14 9b       	mov	r11,r10
8000fbcc:	ec cc ff b8 	sub	r12,r6,-72
8000fbd0:	fe b0 da 6c 	rcall	8000b0a8 <MostSetTimer>

        TAKE_VMSV();
8000fbd4:	31 1c       	mov	r12,17
8000fbd6:	fe b0 bf 70 	rcall	80007ab6 <mns_take>
        vmsv.shadow.ncstate  = msg_ptr->Data[0] ? NCS_OK : NCS_NOT_OK;
8000fbda:	6e 08       	ld.w	r8,r7[0x0]
8000fbdc:	11 89       	ld.ub	r9,r8[0x0]
8000fbde:	30 08       	mov	r8,0
8000fbe0:	f0 09 18 00 	cp.b	r9,r8
8000fbe4:	5f 18       	srne	r8
        vmsv.shadow.nwm_addr = msg_ptr->Src_Adr;
        GIVE_VMSV();
8000fbe6:	31 1c       	mov	r12,17
    if (EHCISTATE_IS_ATTACHED())
    {
        MostClearTimer(&(vmsv.check_phase.timer));

        TAKE_VMSV();
        vmsv.shadow.ncstate  = msg_ptr->Data[0] ? NCS_OK : NCS_NOT_OK;
8000fbe8:	ed 68 00 2d 	st.b	r6[45],r8
        vmsv.shadow.nwm_addr = msg_ptr->Src_Adr;
8000fbec:	8e 38       	ld.sh	r8,r7[0x6]
8000fbee:	ed 58 00 30 	st.h	r6[48],r8
        GIVE_VMSV();
8000fbf2:	fe b0 bf 63 	rcall	80007ab8 <mns_give>

        VmsvHandleNCStateChange();
8000fbf6:	ca ff       	rcall	8000fb54 <VmsvHandleNCStateChange>
8000fbf8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000fbfc:	e0 68 06 35 	mov	r8,1589
  */
void VmsvHandleConfigStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_34);

    ASSERT(msg_ptr);
8000fc00:	30 1a       	mov	r10,1
8000fc02:	1a d8       	st.w	--sp,r8
8000fc04:	31 0b       	mov	r11,16
8000fc06:	34 0c       	mov	r12,64
8000fc08:	fe b0 bf 72 	rcall	80007aec <mns_trace>
8000fc0c:	2f fd       	sub	sp,-4
8000fc0e:	cd 4b       	rjmp	8000fbb6 <VmsvHandleConfigStatus+0xa>
8000fc10:	00 00       	add	r0,r0
8000fc12:	39 9c       	mov	r12,-103

8000fc14 <VmsvRxFilter>:
8000fc14:	eb cd 40 80 	pushm	r7,lr
8000fc18:	18 97       	mov	r7,r12
8000fc1a:	58 0c       	cp.w	r12,0
8000fc1c:	c2 20       	breq	8000fc60 <VmsvRxFilter+0x4c>
8000fc1e:	6e 28       	ld.w	r8,r7[0x8]
8000fc20:	e0 69 02 00 	mov	r9,512
8000fc24:	ea 19 0a 00 	orh	r9,0xa00
8000fc28:	e0 18 ff 00 	andl	r8,0xff00
8000fc2c:	12 38       	cp.w	r8,r9
8000fc2e:	c0 c0       	breq	8000fc46 <VmsvRxFilter+0x32>
        (FUNCID_NWM_CONFIGURATION == msg_ptr->Func_ID) &&
        (OP_STATUS == msg_ptr->Operation))
    {
        VmsvHandleConfigStatus(msg_ptr);
    }
    else if ((FBLOCK_NETBLOCK == msg_ptr->FBlock_ID) &&
8000fc30:	e0 48 01 00 	cp.w	r8,256
8000fc34:	c0 71       	brne	8000fc42 <VmsvRxFilter+0x2e>
             (FUNC_FBLOCKIDS == msg_ptr->Func_ID) &&
             (OP_GET == msg_ptr->Operation))
8000fc36:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000fc3a:	30 18       	mov	r8,1
8000fc3c:	f0 09 18 00 	cp.b	r9,r8
8000fc40:	c0 d0       	breq	8000fc5a <VmsvRxFilter+0x46>
8000fc42:	e3 cd 80 80 	ldm	sp++,r7,pc

    ASSERT(msg_ptr);

    if ((FBLOCK_NETWORKMASTER == msg_ptr->FBlock_ID) &&
        (FUNCID_NWM_CONFIGURATION == msg_ptr->Func_ID) &&
        (OP_STATUS == msg_ptr->Operation))
8000fc46:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000fc4a:	30 c8       	mov	r8,12
8000fc4c:	f0 09 18 00 	cp.b	r9,r8
8000fc50:	cf 91       	brne	8000fc42 <VmsvRxFilter+0x2e>
    {
        VmsvHandleConfigStatus(msg_ptr);
8000fc52:	0e 9c       	mov	r12,r7
8000fc54:	ca cf       	rcall	8000fbac <VmsvHandleConfigStatus>
8000fc56:	e3 cd 80 80 	ldm	sp++,r7,pc
{
    T_LIB_ENTRY(VMSV_40);

    ASSERT(msg_ptr);

    if ((FBLOCK_NETWORKMASTER == msg_ptr->FBlock_ID) &&
8000fc5a:	fe b0 f9 d1 	rcall	8000effc <VmsvHandleFBlockIDsGet>
    }
    else if ((FBLOCK_NETBLOCK == msg_ptr->FBlock_ID) &&
             (FUNC_FBLOCKIDS == msg_ptr->Func_ID) &&
             (OP_GET == msg_ptr->Operation))
    {
        VmsvHandleFBlockIDsGet();
8000fc5e:	cf 2b       	rjmp	8000fc42 <VmsvRxFilter+0x2e>
8000fc60:	e0 68 07 44 	mov	r8,1860
  */
void VmsvRxFilter(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_40);

    ASSERT(msg_ptr);
8000fc64:	30 1a       	mov	r10,1
8000fc66:	1a d8       	st.w	--sp,r8
8000fc68:	31 0b       	mov	r11,16
8000fc6a:	34 0c       	mov	r12,64
8000fc6c:	fe b0 bf 40 	rcall	80007aec <mns_trace>
8000fc70:	2f fd       	sub	sp,-4
8000fc72:	cd 6b       	rjmp	8000fc1e <VmsvRxFilter+0xa>

8000fc74 <VmsvHandleNCStateStatus>:
8000fc74:	eb cd 40 e0 	pushm	r5-r7,lr
8000fc78:	18 97       	mov	r7,r12
8000fc7a:	58 0c       	cp.w	r12,0
8000fc7c:	c3 f0       	breq	8000fcfa <VmsvHandleNCStateStatus+0x86>
8000fc7e:	31 1c       	mov	r12,17
8000fc80:	fe b0 bf 1b 	rcall	80007ab6 <mns_take>

    ASSERT(msg_ptr);

    TAKE_VMSV();
    attached = vmsv.attached;
    GIVE_VMSV();
8000fc84:	31 1c       	mov	r12,17
    T_LIB_ENTRY(VMSV_20);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    attached = vmsv.attached;
8000fc86:	4a 36       	lddpc	r6,8000fd10 <VmsvHandleNCStateStatus+0x9c>
8000fc88:	ed 35 00 60 	ld.ub	r5,r6[96]
    GIVE_VMSV();
8000fc8c:	fe b0 bf 16 	rcall	80007ab8 <mns_give>

    if (!EHCISTATE_IS_ATTACHED() ||
8000fc90:	fe b0 d9 30 	rcall	8000aef0 <MnsGetEHCIState>
8000fc94:	30 28       	mov	r8,2
8000fc96:	f0 0c 18 00 	cp.b	r12,r8
8000fc9a:	c2 10       	breq	8000fcdc <VmsvHandleNCStateStatus+0x68>
        (MostGetTimer(&vmsv.check_phase.timer) > (word)0) ||
        (MNS_FALSE == attached) )
    {
        TAKE_VMSV();
8000fc9c:	31 1c       	mov	r12,17
8000fc9e:	fe b0 bf 0c 	rcall	80007ab6 <mns_take>
        vmsv.shadow.ncstate         = msg_ptr->Data[0];
8000fca2:	6e 08       	ld.w	r8,r7[0x0]
8000fca4:	11 88       	ld.ub	r8,r8[0x0]
8000fca6:	ed 68 00 2d 	st.b	r6[45],r8
        vmsv.shadow.nwm_addr        = (word)(((word)msg_ptr->Data[1] << 8) |
8000fcaa:	6e 08       	ld.w	r8,r7[0x0]
8000fcac:	11 a9       	ld.ub	r9,r8[0x2]
8000fcae:	11 98       	ld.ub	r8,r8[0x1]
8000fcb0:	f3 e8 10 88 	or	r8,r9,r8<<0x8
8000fcb4:	ed 58 00 30 	st.h	r6[48],r8
                                              (word)msg_ptr->Data[2]);
        vmsv.shadow.ncstate_flags   = msg_ptr->Data[3];
8000fcb8:	6e 08       	ld.w	r8,r7[0x0]
8000fcba:	11 b8       	ld.ub	r8,r8[0x3]
        GIVE_VMSV();
8000fcbc:	31 1c       	mov	r12,17
    {
        TAKE_VMSV();
        vmsv.shadow.ncstate         = msg_ptr->Data[0];
        vmsv.shadow.nwm_addr        = (word)(((word)msg_ptr->Data[1] << 8) |
                                              (word)msg_ptr->Data[2]);
        vmsv.shadow.ncstate_flags   = msg_ptr->Data[3];
8000fcbe:	ed 68 00 2e 	st.b	r6[46],r8
        GIVE_VMSV();
8000fcc2:	fe b0 be fb 	rcall	80007ab8 <mns_give>

        if (!EHCISTATE_IS_ATTACHED() && (MNS_FALSE == attached))
8000fcc6:	fe b0 d9 15 	rcall	8000aef0 <MnsGetEHCIState>
8000fcca:	30 28       	mov	r8,2
8000fccc:	f0 0c 18 00 	cp.b	r12,r8
8000fcd0:	c0 30       	breq	8000fcd6 <VmsvHandleNCStateStatus+0x62>
8000fcd2:	58 05       	cp.w	r5,0
8000fcd4:	c0 d0       	breq	8000fcee <VmsvHandleNCStateStatus+0x7a>
        {
            MnsNtfCheck(NTF_NCSTATE);
        }
        else
        {
            VmsvHandleNCStateChange();
8000fcd6:	c3 ff       	rcall	8000fb54 <VmsvHandleNCStateChange>
8000fcd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000fcdc:	ec cc ff b8 	sub	r12,r6,-72
    TAKE_VMSV();
    attached = vmsv.attached;
    GIVE_VMSV();

    if (!EHCISTATE_IS_ATTACHED() ||
        (MostGetTimer(&vmsv.check_phase.timer) > (word)0) ||
8000fce0:	fe b0 da 94 	rcall	8000b208 <MostGetTimer>
8000fce4:	5c 8c       	casts.h	r12
8000fce6:	cd b1       	brne	8000fc9c <VmsvHandleNCStateStatus+0x28>

    TAKE_VMSV();
    attached = vmsv.attached;
    GIVE_VMSV();

    if (!EHCISTATE_IS_ATTACHED() ||
8000fce8:	58 05       	cp.w	r5,0
8000fcea:	cd 90       	breq	8000fc9c <VmsvHandleNCStateStatus+0x28>
8000fcec:	cf 6b       	rjmp	8000fcd8 <VmsvHandleNCStateStatus+0x64>
8000fcee:	e0 6c 01 00 	mov	r12,256
        vmsv.shadow.ncstate_flags   = msg_ptr->Data[3];
        GIVE_VMSV();

        if (!EHCISTATE_IS_ATTACHED() && (MNS_FALSE == attached))
        {
            MnsNtfCheck(NTF_NCSTATE);
8000fcf2:	fe b0 d8 bd 	rcall	8000ae6c <MnsNtfCheck>
8000fcf6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        vmsv.shadow.nwm_addr        = (word)(((word)msg_ptr->Data[1] << 8) |
                                              (word)msg_ptr->Data[2]);
        vmsv.shadow.ncstate_flags   = msg_ptr->Data[3];
        GIVE_VMSV();

        if (!EHCISTATE_IS_ATTACHED() && (MNS_FALSE == attached))
8000fcfa:	e0 68 03 ab 	mov	r8,939
{
    bool attached;

    T_LIB_ENTRY(VMSV_20);

    ASSERT(msg_ptr);
8000fcfe:	30 1a       	mov	r10,1
8000fd00:	1a d8       	st.w	--sp,r8
8000fd02:	31 0b       	mov	r11,16
8000fd04:	34 0c       	mov	r12,64
8000fd06:	fe b0 be f3 	rcall	80007aec <mns_trace>
8000fd0a:	2f fd       	sub	sp,-4
8000fd0c:	cb 9b       	rjmp	8000fc7e <VmsvHandleNCStateStatus+0xa>
8000fd0e:	d7 03       	nop
8000fd10:	00 00       	add	r0,r0
8000fd12:	39 9c       	mov	r12,-103

8000fd14 <VmsvCheckForNpr>:
8000fd14:	d4 21       	pushm	r4-r7,lr
8000fd16:	20 1d       	sub	sp,4
8000fd18:	18 94       	mov	r4,r12
8000fd1a:	31 1c       	mov	r12,17
8000fd1c:	fe b0 be cd 	rcall	80007ab6 <mns_take>
8000fd20:	49 66       	lddpc	r6,8000fd78 <VmsvCheckForNpr+0x64>
8000fd22:	ed 07 00 34 	ld.sh	r7,r6[52]
8000fd26:	0e 95       	mov	r5,r7
8000fd28:	f1 d7 c0 08 	bfextu	r8,r7,0x0,0x8
8000fd2c:	5c 55       	castu.b	r5
8000fd2e:	f1 e5 10 88 	or	r8,r8,r5<<0x8
    TAKE_VMSV();
    old_val = (byte) ((vmsv.shadow.node_pos_check & 0xFF00) >> 8);
    new_val = (byte) (vmsv.shadow.node_pos_check & 0x00FF);
    vmsv.shadow.node_pos_check &= (word) 0x00FF;
    vmsv.shadow.node_pos_check |= (word)(new_val << 8);
    GIVE_VMSV();
8000fd32:	31 1c       	mov	r12,17

    TAKE_VMSV();
    old_val = (byte) ((vmsv.shadow.node_pos_check & 0xFF00) >> 8);
    new_val = (byte) (vmsv.shadow.node_pos_check & 0x00FF);
    vmsv.shadow.node_pos_check &= (word) 0x00FF;
    vmsv.shadow.node_pos_check |= (word)(new_val << 8);
8000fd34:	ed 58 00 34 	st.h	r6[52],r8
    GIVE_VMSV();
8000fd38:	fe b0 be c0 	rcall	80007ab8 <mns_give>

    if ((new_val != old_val) || (MNS_FALSE != force))
8000fd3c:	ee 08 16 08 	lsr	r8,r7,0x8
8000fd40:	10 97       	mov	r7,r8
8000fd42:	ea 08 18 00 	cp.b	r8,r5
8000fd46:	c1 40       	breq	8000fd6e <VmsvCheckForNpr+0x5a>
    {
        #ifdef NS_MSV_NB
        NbRefreshNodePos();
8000fd48:	e0 a0 29 06 	rcall	80014f54 <NbRefreshNodePos>
        #endif

        if(vmsv.cfg_ptr->msval_event_fptr)
8000fd4c:	6c f8       	ld.w	r8,r6[0x3c]
8000fd4e:	70 28       	ld.w	r8,r8[0x8]
8000fd50:	58 08       	cp.w	r8,0
8000fd52:	c0 c0       	breq	8000fd6a <VmsvCheckForNpr+0x56>
        {
            byte info[2];
            info[0] = (byte)1;
8000fd54:	30 18       	mov	r8,1
8000fd56:	ba 88       	st.b	sp[0x0],r8
            info[1] = MostGetNodePos();
8000fd58:	e0 a0 0d d2 	rcall	800118fc <MostGetNodePos>
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NPR, info);
8000fd5c:	48 78       	lddpc	r8,8000fd78 <VmsvCheckForNpr+0x64>

        if(vmsv.cfg_ptr->msval_event_fptr)
        {
            byte info[2];
            info[0] = (byte)1;
            info[1] = MostGetNodePos();
8000fd5e:	ba 9c       	st.b	sp[0x1],r12
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NPR, info);
8000fd60:	70 f8       	ld.w	r8,r8[0x3c]
8000fd62:	1a 9b       	mov	r11,sp
8000fd64:	70 28       	ld.w	r8,r8[0x8]
8000fd66:	36 0c       	mov	r12,96
8000fd68:	5d 18       	icall	r8
        }
    }
}
8000fd6a:	2f fd       	sub	sp,-4
8000fd6c:	d8 22       	popm	r4-r7,pc
    new_val = (byte) (vmsv.shadow.node_pos_check & 0x00FF);
    vmsv.shadow.node_pos_check &= (word) 0x00FF;
    vmsv.shadow.node_pos_check |= (word)(new_val << 8);
    GIVE_VMSV();

    if ((new_val != old_val) || (MNS_FALSE != force))
8000fd6e:	58 04       	cp.w	r4,0
8000fd70:	ce c1       	brne	8000fd48 <VmsvCheckForNpr+0x34>
            info[0] = (byte)1;
            info[1] = MostGetNodePos();
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NPR, info);
        }
    }
}
8000fd72:	2f fd       	sub	sp,-4
8000fd74:	d8 22       	popm	r4-r7,pc
8000fd76:	d7 03       	nop
8000fd78:	00 00       	add	r0,r0
8000fd7a:	39 9c       	mov	r12,-103

8000fd7c <VmsvRefreshNodePos>:
8000fd7c:	eb cd 40 80 	pushm	r7,lr
8000fd80:	18 97       	mov	r7,r12
8000fd82:	31 1c       	mov	r12,17
8000fd84:	fe b0 be 99 	rcall	80007ab6 <mns_take>
8000fd88:	48 c9       	lddpc	r9,8000fdb8 <VmsvRefreshNodePos+0x3c>
8000fd8a:	f3 08 00 34 	ld.sh	r8,r9[52]
{
    T_LIB_ENTRY(VMSV_58);

    TAKE_VMSV();
    vmsv.shadow.node_pos_check &= (word) 0xFF00;
    vmsv.shadow.node_pos_check |= pos;
8000fd8e:	e0 18 ff 00 	andl	r8,0xff00
    GIVE_VMSV();
8000fd92:	31 1c       	mov	r12,17
{
    T_LIB_ENTRY(VMSV_58);

    TAKE_VMSV();
    vmsv.shadow.node_pos_check &= (word) 0xFF00;
    vmsv.shadow.node_pos_check |= pos;
8000fd94:	10 47       	or	r7,r8
8000fd96:	f3 57 00 34 	st.h	r9[52],r7
    GIVE_VMSV();
8000fd9a:	fe b0 be 8f 	rcall	80007ab8 <mns_give>

    if (EHCISTATE_IS_ATTACHED())
8000fd9e:	fe b0 d8 a9 	rcall	8000aef0 <MnsGetEHCIState>
8000fda2:	30 28       	mov	r8,2
8000fda4:	f0 0c 18 00 	cp.b	r12,r8
8000fda8:	c0 30       	breq	8000fdae <VmsvRefreshNodePos+0x32>
8000fdaa:	e3 cd 80 80 	ldm	sp++,r7,pc
    {
        VmsvCheckForNpr(MNS_FALSE);
8000fdae:	30 0c       	mov	r12,0
8000fdb0:	cb 2f       	rcall	8000fd14 <VmsvCheckForNpr>
8000fdb2:	e3 cd 80 80 	ldm	sp++,r7,pc
8000fdb6:	d7 03       	nop
8000fdb8:	00 00       	add	r0,r0
8000fdba:	39 9c       	mov	r12,-103

8000fdbc <MostGetState>:
8000fdbc:	eb cd 40 c0 	pushm	r6-r7,lr
8000fdc0:	31 1c       	mov	r12,17
8000fdc2:	fe b0 be 7a 	rcall	80007ab6 <mns_take>
8000fdc6:	49 d8       	lddpc	r8,8000fe38 <MostGetState+0x7c>
8000fdc8:	31 1c       	mov	r12,17
8000fdca:	f1 36 00 22 	ld.ub	r6,r8[34]
    byte state;
    bool reported;

    T_API_ENTRY(VMSV_7);
    TAKE_VMSV();
    state = vmsv.shadow.nistate;
8000fdce:	f1 37 00 21 	ld.ub	r7,r8[33]
    reported = vmsv.shadow.neton_reported;
    GIVE_VMSV();
8000fdd2:	fe b0 be 73 	rcall	80007ab8 <mns_give>

    if(MSVAL_S_ON == state)
8000fdd6:	30 38       	mov	r8,3
8000fdd8:	f0 07 18 00 	cp.b	r7,r8
8000fddc:	c0 50       	breq	8000fde6 <MostGetState+0x2a>
8000fdde:	e0 6c 00 ff 	mov	r12,255
8000fde2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    {
        if (MNS_FALSE == reported)
8000fde6:	58 06       	cp.w	r6,0
8000fde8:	c0 40       	breq	8000fdf0 <MostGetState+0x34>
            */
            if (EHCISTATE_IS_ATTACHED() && (MNS_FALSE != bdvalid))
            {
                MnsSignalNetOn();
                VmsvReportNetOn();
                MnsDistribEvent(MNS_P_SRV_VMSV, VMSV_P_SRV_CHECK);
8000fdea:	30 4c       	mov	r12,4
        state = MNS_NET_NOTAVAIL;
    }

    T_API_EXIT(VMSV_7);
    return(state);
}
8000fdec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    if(MSVAL_S_ON == state)
    {
        if (MNS_FALSE == reported)
        {
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
8000fdf0:	e0 a0 14 18 	rcall	80012620 <ScmGetBoundary>
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000fdf4:	3e e8       	mov	r8,-18
    if(MSVAL_S_ON == state)
    {
        if (MNS_FALSE == reported)
        {
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
8000fdf6:	18 97       	mov	r7,r12
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000fdf8:	f0 0c 18 00 	cp.b	r12,r8
8000fdfc:	c1 c0       	breq	8000fe34 <MostGetState+0x78>
8000fdfe:	30 8c       	mov	r12,8
8000fe00:	fe b0 d8 5a 	rcall	8000aeb4 <MostIsSupported>
8000fe04:	c1 61       	brne	8000fe30 <MostGetState+0x74>
8000fe06:	30 17       	mov	r7,1

           /* MSVAL_E_NETON shall only be communicated when the
            * boundary is valid
            * see also VmsvHandleNIStateChange() and ScmHandleBandwidthStatus()
            */
            if (EHCISTATE_IS_ATTACHED() && (MNS_FALSE != bdvalid))
8000fe08:	fe b0 d8 74 	rcall	8000aef0 <MnsGetEHCIState>
8000fe0c:	30 28       	mov	r8,2
8000fe0e:	f0 0c 18 00 	cp.b	r12,r8
8000fe12:	ce c1       	brne	8000fdea <MostGetState+0x2e>
8000fe14:	58 07       	cp.w	r7,0
8000fe16:	ce a0       	breq	8000fdea <MostGetState+0x2e>
            {
                MnsSignalNetOn();
8000fe18:	fe b0 d8 04 	rcall	8000ae20 <MnsSignalNetOn>
                VmsvReportNetOn();
8000fe1c:	fe b0 fc 46 	rcall	8000f6a8 <VmsvReportNetOn>
                MnsDistribEvent(MNS_P_SRV_VMSV, VMSV_P_SRV_CHECK);
8000fe20:	34 0c       	mov	r12,64
8000fe22:	e0 6b 08 00 	mov	r11,2048
8000fe26:	fe b0 d7 6b 	rcall	8000acfc <MnsDistribEvent>
8000fe2a:	30 4c       	mov	r12,4
8000fe2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    {
        if (MNS_FALSE == reported)
        {
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8000fe30:	58 07       	cp.w	r7,0
8000fe32:	ce a1       	brne	8000fe06 <MostGetState+0x4a>
8000fe34:	30 07       	mov	r7,0
8000fe36:	ce 9b       	rjmp	8000fe08 <MostGetState+0x4c>
8000fe38:	00 00       	add	r0,r0
8000fe3a:	39 9c       	mov	r12,-103

8000fe3c <VmsvSetPendingEvent>:
8000fe3c:	d4 01       	pushm	lr
8000fe3e:	34 09       	mov	r9,64
8000fe40:	5c 7c       	castu.h	r12
8000fe42:	48 3a       	lddpc	r10,8000fe4c <VmsvSetPendingEvent+0x10>
8000fe44:	31 0b       	mov	r11,16
8000fe46:	fe b0 da 9b 	rcall	8000b37c <MnsSetPendingEventFlag>
8000fe4a:	d8 02       	popm	pc
8000fe4c:	00 00       	add	r0,r0
8000fe4e:	39 9c       	mov	r12,-103

8000fe50 <MostEmergencyCondition>:
8000fe50:	eb cd 40 80 	pushm	r7,lr
8000fe54:	18 97       	mov	r7,r12
8000fe56:	31 1c       	mov	r12,17
8000fe58:	fe b0 be 2f 	rcall	80007ab6 <mns_take>
    TMsgTx *msg_ptr;

    T_API_ENTRY(VMSV_100);

    TAKE_VMSV();
    vmsv.emergency_state = state;
8000fe5c:	49 38       	lddpc	r8,8000fea8 <MostEmergencyCondition+0x58>
    GIVE_VMSV();
8000fe5e:	31 1c       	mov	r12,17
    TMsgTx *msg_ptr;

    T_API_ENTRY(VMSV_100);

    TAKE_VMSV();
    vmsv.emergency_state = state;
8000fe60:	f1 67 00 9c 	st.b	r8[156],r7
    GIVE_VMSV();
8000fe64:	fe b0 be 2a 	rcall	80007ab8 <mns_give>

    msg_ptr = MsgGetTxPtrExt(1);
8000fe68:	30 1c       	mov	r12,1
8000fe6a:	fe b0 c8 19 	rcall	80008e9c <MsgGetTxPtrExt>

    if (msg_ptr)
8000fe6e:	c1 80       	breq	8000fe9e <MostEmergencyCondition+0x4e>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000fe70:	30 08       	mov	r8,0
        msg_ptr->Func_ID   = FUNCID_INIC_PMISTATE;
8000fe72:	e0 69 05 0e 	mov	r9,1294
        msg_ptr->Operation = OP_SET;
8000fe76:	f9 68 00 0c 	st.b	r12[12],r8
    msg_ptr = MsgGetTxPtrExt(1);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
8000fe7a:	f9 68 00 0a 	st.b	r12[10],r8
        msg_ptr->Func_ID   = FUNCID_INIC_PMISTATE;
8000fe7e:	b8 49       	st.h	r12[0x8],r9

    msg_ptr = MsgGetTxPtrExt(1);

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8000fe80:	30 18       	mov	r8,1
8000fe82:	b8 38       	st.h	r12[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_PMISTATE;
        msg_ptr->Operation = OP_SET;
        if (MNS_FALSE != state)
        {
            msg_ptr->Data[0]   = PMI_SHUTDOWN;
8000fe84:	58 07       	cp.w	r7,0
8000fe86:	f9 f9 10 00 	ld.wne	r9,r12[0x0]
8000fe8a:	f3 f8 1e 00 	st.bne	r9[0x0],r8
        }
        else
        {
            msg_ptr->Data[0]   = PMI_CLEAR;
8000fe8e:	f9 f8 00 00 	ld.weq	r8,r12[0x0]
8000fe92:	f1 f7 0e 00 	st.beq	r8[0x0],r7
        }
        MsgSend3(msg_ptr);
8000fe96:	fe b0 cb 47 	rcall	80009524 <MsgSend3>
8000fe9a:	e3 cd 80 80 	ldm	sp++,r7,pc
    }
    else
    {
        VmsvSetPendingEvent(VMSV_P_EMERGENCYCONDITION_RETRY);
8000fe9e:	e0 6c 20 00 	mov	r12,8192
8000fea2:	cc df       	rcall	8000fe3c <VmsvSetPendingEvent>
8000fea4:	e3 cd 80 80 	ldm	sp++,r7,pc
8000fea8:	00 00       	add	r0,r0
8000feaa:	39 9c       	mov	r12,-103

8000feac <VmsvPhysicalLayerTestTxFinal>:
8000feac:	eb cd 40 80 	pushm	r7,lr
8000feb0:	31 08       	mov	r8,16
8000feb2:	18 97       	mov	r7,r12
8000feb4:	f0 0b 18 00 	cp.b	r11,r8
8000feb8:	c0 e1       	brne	8000fed4 <VmsvPhysicalLayerTestTxFinal+0x28>
8000feba:	31 1c       	mov	r12,17
8000febc:	fe b0 bd fd 	rcall	80007ab6 <mns_take>
8000fec0:	30 29       	mov	r9,2
8000fec2:	48 88       	lddpc	r8,8000fee0 <VmsvPhysicalLayerTestTxFinal+0x34>
    {
        case XMIT_SUCCESS:
            /* start PLT state machine */
            TAKE_VMSV();
            vmsv.plt.test_state = VMSV_PLT_START;
            GIVE_VMSV();
8000fec4:	31 1c       	mov	r12,17
    switch (status)
    {
        case XMIT_SUCCESS:
            /* start PLT state machine */
            TAKE_VMSV();
            vmsv.plt.test_state = VMSV_PLT_START;
8000fec6:	f1 69 00 81 	st.b	r8[129],r9
            GIVE_VMSV();
8000feca:	fe b0 bd f7 	rcall	80007ab8 <mns_give>

            VmsvSetPendingEvent(VMSV_P_PHYSICAL_LAYER_TEST);
8000fece:	e0 6c 10 00 	mov	r12,4096
8000fed2:	cb 5f       	rcall	8000fe3c <VmsvSetPendingEvent>
8000fed4:	0e 9c       	mov	r12,r7

        default:            /* FAILED */
            break;
    }

    MbmFree(handle);
8000fed6:	fe b0 e8 41 	rcall	8000cf58 <MbmFree>
8000feda:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    T_MOD_EXIT(VMSV_98);

    return(PMS_RELEASE);
}
8000fede:	d7 03       	nop
8000fee0:	00 00       	add	r0,r0
8000fee2:	39 9c       	mov	r12,-103

8000fee4 <VmsvHandleSysErrMonitorStatus>:
8000fee4:	eb cd 40 e0 	pushm	r5-r7,lr
8000fee8:	18 97       	mov	r7,r12
8000feea:	58 0c       	cp.w	r12,0
8000feec:	c2 b0       	breq	8000ff42 <VmsvHandleSysErrMonitorStatus+0x5e>
8000feee:	31 1c       	mov	r12,17
8000fef0:	fe b0 bd e3 	rcall	80007ab6 <mns_take>
    T_LIB_ENTRY(VMSV_56);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    cb_ptr = vmsv.sys_err_monitor.cb_ptr;
8000fef4:	49 96       	lddpc	r6,8000ff58 <VmsvHandleSysErrMonitorStatus+0x74>
    GIVE_VMSV();
8000fef6:	31 1c       	mov	r12,17
    T_LIB_ENTRY(VMSV_56);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    cb_ptr = vmsv.sys_err_monitor.cb_ptr;
8000fef8:	6d a5       	ld.w	r5,r6[0x68]
    GIVE_VMSV();
8000fefa:	fe b0 bd df 	rcall	80007ab8 <mns_give>

    if (cb_ptr)
8000fefe:	58 05       	cp.w	r5,0
8000ff00:	c1 20       	breq	8000ff24 <VmsvHandleSysErrMonitorStatus+0x40>
    {
        byte bit_mask = msg_ptr->Data[0];
8000ff02:	6e 08       	ld.w	r8,r7[0x0]
8000ff04:	11 87       	ld.ub	r7,r8[0x0]

        if (bit_mask)
8000ff06:	58 07       	cp.w	r7,0
8000ff08:	c1 01       	brne	8000ff28 <VmsvHandleSysErrMonitorStatus+0x44>

            VmsvSetPendingEvent(VMSV_P_REPORT_EM);
        }
        else
        {
            TAKE_VMSV();
8000ff0a:	31 1c       	mov	r12,17
8000ff0c:	fe b0 bd d5 	rcall	80007ab6 <mns_take>
            vmsv.sys_err_monitor.bit_mask = (byte)0;
            vmsv.sys_err_monitor.cb_ptr   = NULL;
            GIVE_VMSV();
8000ff10:	31 1c       	mov	r12,17
        }
        else
        {
            TAKE_VMSV();
            vmsv.sys_err_monitor.bit_mask = (byte)0;
            vmsv.sys_err_monitor.cb_ptr   = NULL;
8000ff12:	ed 47 00 68 	st.w	r6[104],r7
            VmsvSetPendingEvent(VMSV_P_REPORT_EM);
        }
        else
        {
            TAKE_VMSV();
            vmsv.sys_err_monitor.bit_mask = (byte)0;
8000ff16:	ed 67 00 6c 	st.b	r6[108],r7
            vmsv.sys_err_monitor.cb_ptr   = NULL;
            GIVE_VMSV();
8000ff1a:	fe b0 bd cf 	rcall	80007ab8 <mns_give>

            cb_ptr(NSR_EM_NONE);
8000ff1e:	e0 6c 45 00 	mov	r12,17664
8000ff22:	5d 15       	icall	r5
8000ff24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    {
        byte bit_mask = msg_ptr->Data[0];

        if (bit_mask)
        {
            TAKE_VMSV();
8000ff28:	31 1c       	mov	r12,17
8000ff2a:	fe b0 bd c6 	rcall	80007ab6 <mns_take>
            vmsv.sys_err_monitor.bit_mask = bit_mask;
            GIVE_VMSV();
8000ff2e:	31 1c       	mov	r12,17
        byte bit_mask = msg_ptr->Data[0];

        if (bit_mask)
        {
            TAKE_VMSV();
            vmsv.sys_err_monitor.bit_mask = bit_mask;
8000ff30:	ed 67 00 6c 	st.b	r6[108],r7
            GIVE_VMSV();
8000ff34:	fe b0 bd c2 	rcall	80007ab8 <mns_give>

            VmsvSetPendingEvent(VMSV_P_REPORT_EM);
8000ff38:	e0 6c 02 00 	mov	r12,512
8000ff3c:	c8 0f       	rcall	8000fe3c <VmsvSetPendingEvent>
8000ff3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ff42:	e0 68 08 da 	mov	r8,2266
{
    TMnsStdCB *cb_ptr;

    T_LIB_ENTRY(VMSV_56);

    ASSERT(msg_ptr);
8000ff46:	30 1a       	mov	r10,1
8000ff48:	1a d8       	st.w	--sp,r8
8000ff4a:	31 0b       	mov	r11,16
8000ff4c:	34 0c       	mov	r12,64
8000ff4e:	fe b0 bd cf 	rcall	80007aec <mns_trace>
8000ff52:	2f fd       	sub	sp,-4
8000ff54:	cc db       	rjmp	8000feee <VmsvHandleSysErrMonitorStatus+0xa>
8000ff56:	d7 03       	nop
8000ff58:	00 00       	add	r0,r0
8000ff5a:	39 9c       	mov	r12,-103

8000ff5c <VmsvHandlePMIStateStatus>:
8000ff5c:	eb cd 40 80 	pushm	r7,lr
8000ff60:	18 97       	mov	r7,r12
8000ff62:	58 0c       	cp.w	r12,0
8000ff64:	c2 50       	breq	8000ffae <VmsvHandlePMIStateStatus+0x52>
8000ff66:	31 1c       	mov	r12,17
8000ff68:	fe b0 bd a7 	rcall	80007ab6 <mns_take>
    T_LIB_ENTRY(VMSV_47);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed    |= VMSV_SHADOW_PMISTATE_CHANGED;
8000ff6c:	49 68       	lddpc	r8,8000ffc4 <VmsvHandlePMIStateStatus+0x68>
8000ff6e:	f1 39 00 20 	ld.ub	r9,r8[32]
8000ff72:	a5 b9       	sbr	r9,0x5
8000ff74:	f1 69 00 20 	st.b	r8[32],r9
    vmsv.shadow.pmi.state   = msg_ptr->Data[0];
8000ff78:	6e 09       	ld.w	r9,r7[0x0]
8000ff7a:	13 89       	ld.ub	r9,r9[0x0]
8000ff7c:	f1 69 00 36 	st.b	r8[54],r9
    vmsv.shadow.pmi.events  = msg_ptr->Data[1];
8000ff80:	6e 09       	ld.w	r9,r7[0x0]
8000ff82:	13 99       	ld.ub	r9,r9[0x1]
    GIVE_VMSV();
8000ff84:	31 1c       	mov	r12,17
    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed    |= VMSV_SHADOW_PMISTATE_CHANGED;
    vmsv.shadow.pmi.state   = msg_ptr->Data[0];
    vmsv.shadow.pmi.events  = msg_ptr->Data[1];
8000ff86:	f1 69 00 37 	st.b	r8[55],r9
    GIVE_VMSV();
8000ff8a:	fe b0 bd 97 	rcall	80007ab8 <mns_give>

    if (EHCISTATE_IS_ATTACHED())
8000ff8e:	fe b0 d7 b1 	rcall	8000aef0 <MnsGetEHCIState>
8000ff92:	30 28       	mov	r8,2
8000ff94:	f0 0c 18 00 	cp.b	r12,r8
8000ff98:	c0 70       	breq	8000ffa6 <VmsvHandlePMIStateStatus+0x4a>
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
    }
    else
    {
        MnsNtfCheck(NTF_PMISTATE);
8000ff9a:	e0 6c 80 00 	mov	r12,32768
8000ff9e:	fe b0 d7 67 	rcall	8000ae6c <MnsNtfCheck>
8000ffa2:	e3 cd 80 80 	ldm	sp++,r7,pc
    vmsv.shadow.pmi.events  = msg_ptr->Data[1];
    GIVE_VMSV();

    if (EHCISTATE_IS_ATTACHED())
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
8000ffa6:	31 0c       	mov	r12,16
8000ffa8:	c4 af       	rcall	8000fe3c <VmsvSetPendingEvent>
8000ffaa:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ffae:	e0 68 08 03 	mov	r8,2051
  */
void VmsvHandlePMIStateStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_47);

    ASSERT(msg_ptr);
8000ffb2:	30 1a       	mov	r10,1
8000ffb4:	1a d8       	st.w	--sp,r8
8000ffb6:	31 0b       	mov	r11,16
8000ffb8:	34 0c       	mov	r12,64
8000ffba:	fe b0 bd 99 	rcall	80007aec <mns_trace>
8000ffbe:	2f fd       	sub	sp,-4
8000ffc0:	cd 3b       	rjmp	8000ff66 <VmsvHandlePMIStateStatus+0xa>
8000ffc2:	d7 03       	nop
8000ffc4:	00 00       	add	r0,r0
8000ffc6:	39 9c       	mov	r12,-103

8000ffc8 <VmsvHandleRBDResultStatus>:
8000ffc8:	eb cd 40 80 	pushm	r7,lr
8000ffcc:	18 97       	mov	r7,r12
8000ffce:	58 0c       	cp.w	r12,0
8000ffd0:	c2 b0       	breq	80010026 <VmsvHandleRBDResultStatus+0x5e>
8000ffd2:	31 1c       	mov	r12,17
8000ffd4:	fe b0 bd 71 	rcall	80007ab6 <mns_take>
8000ffd8:	49 98       	lddpc	r8,8001003c <VmsvHandleRBDResultStatus+0x74>
8000ffda:	f1 39 00 20 	ld.ub	r9,r8[32]
8000ffde:	a5 a9       	sbr	r9,0x4
    T_LIB_ENTRY(VMSV_23);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed |= VMSV_SHADOW_RBDRESULT_CHANGED;
8000ffe0:	f1 69 00 20 	st.b	r8[32],r9
    vmsv.shadow.rbdresult[0] = msg_ptr->Data[0];
8000ffe4:	6e 09       	ld.w	r9,r7[0x0]
8000ffe6:	13 89       	ld.ub	r9,r9[0x0]
8000ffe8:	f1 69 00 29 	st.b	r8[41],r9
    if (msg_ptr->Length > 1)
8000ffec:	30 19       	mov	r9,1
8000ffee:	8e 2a       	ld.sh	r10,r7[0x4]
    {
        vmsv.shadow.rbdresult[1] = msg_ptr->Data[1];
8000fff0:	f2 0a 19 00 	cp.h	r10,r9
8000fff4:	ef f9 b0 00 	ld.whi	r9,r7[0x0]
8000fff8:	f3 f9 b8 01 	ld.ubhi	r9,r9[0x1]
8000fffc:	f1 f9 be 2a 	st.bhi	r8[0x2a],r9
    }
    else
    {
        /* set to 0 if not used */
        vmsv.shadow.rbdresult[1] = (byte)0;
80010000:	f9 b9 08 00 	movls	r9,0
80010004:	f1 f9 8e 2a 	st.bls	r8[0x2a],r9
    }
    GIVE_VMSV();
80010008:	31 1c       	mov	r12,17
8001000a:	fe b0 bd 57 	rcall	80007ab8 <mns_give>

    if (EHCISTATE_IS_ATTACHED())
8001000e:	fe b0 d7 71 	rcall	8000aef0 <MnsGetEHCIState>
80010012:	30 28       	mov	r8,2
80010014:	f0 0c 18 00 	cp.b	r12,r8
80010018:	c0 30       	breq	8001001e <VmsvHandleRBDResultStatus+0x56>
8001001a:	e3 cd 80 80 	ldm	sp++,r7,pc
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
8001001e:	31 0c       	mov	r12,16
80010020:	c0 ef       	rcall	8000fe3c <VmsvSetPendingEvent>
80010022:	e3 cd 80 80 	ldm	sp++,r7,pc
80010026:	e0 68 04 0f 	mov	r8,1039
#ifdef VMSV_23
void VmsvHandleRBDResultStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_23);

    ASSERT(msg_ptr);
8001002a:	30 1a       	mov	r10,1
8001002c:	1a d8       	st.w	--sp,r8
8001002e:	31 0b       	mov	r11,16
80010030:	34 0c       	mov	r12,64
80010032:	fe b0 bd 5d 	rcall	80007aec <mns_trace>
80010036:	2f fd       	sub	sp,-4
80010038:	cc db       	rjmp	8000ffd2 <VmsvHandleRBDResultStatus+0xa>
8001003a:	d7 03       	nop
8001003c:	00 00       	add	r0,r0
8001003e:	39 9c       	mov	r12,-103

80010040 <VmsvHandleNCEDelayedStatus>:
80010040:	eb cd 40 80 	pushm	r7,lr
80010044:	18 97       	mov	r7,r12
80010046:	58 0c       	cp.w	r12,0
80010048:	c2 10       	breq	8001008a <VmsvHandleNCEDelayedStatus+0x4a>
8001004a:	31 1c       	mov	r12,17
8001004c:	fe b0 bd 35 	rcall	80007ab6 <mns_take>
80010050:	49 48       	lddpc	r8,800100a0 <VmsvHandleNCEDelayedStatus+0x60>
80010052:	f1 39 00 20 	ld.ub	r9,r8[32]
    T_LIB_ENTRY(VMSV_18);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed       |= VMSV_SHADOW_NCEDELAYED_CHANGED;
80010056:	a3 b9       	sbr	r9,0x3
80010058:	f1 69 00 20 	st.b	r8[32],r9
    vmsv.shadow.ncedelayed[0]  = msg_ptr->Data[0];
8001005c:	6e 09       	ld.w	r9,r7[0x0]
8001005e:	13 89       	ld.ub	r9,r9[0x0]
80010060:	f1 69 00 27 	st.b	r8[39],r9
    vmsv.shadow.ncedelayed[1]  = msg_ptr->Data[1];
80010064:	6e 09       	ld.w	r9,r7[0x0]
80010066:	13 99       	ld.ub	r9,r9[0x1]
    GIVE_VMSV();
80010068:	31 1c       	mov	r12,17
    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed       |= VMSV_SHADOW_NCEDELAYED_CHANGED;
    vmsv.shadow.ncedelayed[0]  = msg_ptr->Data[0];
    vmsv.shadow.ncedelayed[1]  = msg_ptr->Data[1];
8001006a:	f1 69 00 28 	st.b	r8[40],r9
    GIVE_VMSV();
8001006e:	fe b0 bd 25 	rcall	80007ab8 <mns_give>

    if (EHCISTATE_IS_ATTACHED())
80010072:	fe b0 d7 3f 	rcall	8000aef0 <MnsGetEHCIState>
80010076:	30 28       	mov	r8,2
80010078:	f0 0c 18 00 	cp.b	r12,r8
8001007c:	c0 30       	breq	80010082 <VmsvHandleNCEDelayedStatus+0x42>
8001007e:	e3 cd 80 80 	ldm	sp++,r7,pc
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
80010082:	31 0c       	mov	r12,16
80010084:	cd ce       	rcall	8000fe3c <VmsvSetPendingEvent>
80010086:	e3 cd 80 80 	ldm	sp++,r7,pc
8001008a:	e0 68 03 80 	mov	r8,896
#ifdef VMSV_18
void VmsvHandleNCEDelayedStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_18);

    ASSERT(msg_ptr);
8001008e:	30 1a       	mov	r10,1
80010090:	1a d8       	st.w	--sp,r8
80010092:	31 0b       	mov	r11,16
80010094:	34 0c       	mov	r12,64
80010096:	fe b0 bd 2b 	rcall	80007aec <mns_trace>
8001009a:	2f fd       	sub	sp,-4
8001009c:	cd 7b       	rjmp	8001004a <VmsvHandleNCEDelayedStatus+0xa>
8001009e:	d7 03       	nop
800100a0:	00 00       	add	r0,r0
800100a2:	39 9c       	mov	r12,-103

800100a4 <VmsvHandleNIStateStatus>:
800100a4:	eb cd 40 e0 	pushm	r5-r7,lr
800100a8:	18 97       	mov	r7,r12
800100aa:	fe b0 d7 23 	rcall	8000aef0 <MnsGetEHCIState>
800100ae:	30 28       	mov	r8,2
800100b0:	f0 0c 18 00 	cp.b	r12,r8
800100b4:	5f 06       	sreq	r6
800100b6:	58 07       	cp.w	r7,0

    T_LIB_ENTRY(VMSV_17);

    attached = EHCISTATE_IS_ATTACHED() ? MNS_TRUE : MNS_FALSE;

    ASSERT(msg_ptr);
800100b8:	c7 00       	breq	80010198 <VmsvHandleNIStateStatus+0xf4>

    TAKE_VMSV();
800100ba:	31 1c       	mov	r12,17
800100bc:	fe b0 bc fd 	rcall	80007ab6 <mns_take>
    vmsv.shadow.changed       |= VMSV_SHADOW_NISTATE_CHANGED;
800100c0:	4b f8       	lddpc	r8,800101bc <VmsvHandleNIStateStatus+0x118>
800100c2:	f1 39 00 20 	ld.ub	r9,r8[32]
800100c6:	a1 a9       	sbr	r9,0x0
800100c8:	f1 69 00 20 	st.b	r8[32],r9
    vmsv.shadow.late_nistate  =  vmsv.shadow.nistate;
800100cc:	f1 39 00 21 	ld.ub	r9,r8[33]
800100d0:	f1 69 00 25 	st.b	r8[37],r9
    vmsv.shadow.nistate       = msg_ptr->Data[0];
800100d4:	6e 09       	ld.w	r9,r7[0x0]
800100d6:	13 89       	ld.ub	r9,r9[0x0]
800100d8:	f1 69 00 21 	st.b	r8[33],r9

    if (NISTATE_NET_OFF == msg_ptr->Data[0])
800100dc:	6e 09       	ld.w	r9,r7[0x0]
800100de:	13 89       	ld.ub	r9,r9[0x0]
    {
        vmsv.shadow.ncstate  = NCS_NOT_OK;
800100e0:	58 09       	cp.w	r9,0
800100e2:	f1 f9 0e 2d 	st.beq	r8[0x2d],r9
        vmsv.shadow.nwm_addr = NCS_INVALID_NWM;
800100e6:	f9 b9 00 ff 	moveq	r9,-1
800100ea:	f1 f9 0c 18 	st.heq	r8[0x30],r9
    }

    GIVE_VMSV();
800100ee:	31 1c       	mov	r12,17
800100f0:	fe b0 bc e4 	rcall	80007ab8 <mns_give>

    MnsDistribEvent(MNS_P_SRV_VMSV, VMSV_P_SRV_CHECK);
800100f4:	e0 6b 08 00 	mov	r11,2048
800100f8:	34 0c       	mov	r12,64
800100fa:	fe b0 d6 01 	rcall	8000acfc <MnsDistribEvent>

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached))
800100fe:	6e 08       	ld.w	r8,r7[0x0]
80010100:	30 39       	mov	r9,3
80010102:	11 88       	ld.ub	r8,r8[0x0]
80010104:	f2 08 18 00 	cp.b	r8,r9
80010108:	c3 20       	breq	8001016c <VmsvHandleNIStateStatus+0xc8>
            {
                MnsSignalNetOn();
            }
        #endif
    }
    else if (NISTATE_NET_INIT != msg_ptr->Data[0])
8001010a:	30 19       	mov	r9,1
8001010c:	f2 08 18 00 	cp.b	r8,r9
80010110:	c2 b0       	breq	80010166 <VmsvHandleNIStateStatus+0xc2>
    {
        #ifdef AMS_MIN
            MsgNIStateNetOn(MNS_FALSE);
80010112:	30 0c       	mov	r12,0
80010114:	fe b0 c7 84 	rcall	8000901c <MsgNIStateNetOn>
        #ifdef AMS_53
            MsgNIStateNetInit();
        #endif
    }

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached) && (MNS_FALSE != MnsPMReady()))
80010118:	6e 08       	ld.w	r8,r7[0x0]
8001011a:	30 39       	mov	r9,3
8001011c:	11 88       	ld.ub	r8,r8[0x0]
8001011e:	f2 08 18 00 	cp.b	r8,r9
80010122:	c0 c0       	breq	8001013a <VmsvHandleNIStateStatus+0x96>
    {
        #ifdef ADS_10
            DataNIStateNetOn(MNS_TRUE);
        #endif
    }
    else if (NISTATE_NET_INIT != msg_ptr->Data[0])
80010124:	30 19       	mov	r9,1
80010126:	f2 08 18 00 	cp.b	r8,r9
8001012a:	c0 a1       	brne	8001013e <VmsvHandleNIStateStatus+0x9a>
    if (NISTATE_NET_OFF == msg_ptr->Data[0])
    {
        MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_AS_GO_NET_OFF);
    }

    if (MNS_FALSE != attached)
8001012c:	58 06       	cp.w	r6,0
8001012e:	c1 81       	brne	8001015e <VmsvHandleNIStateStatus+0xba>
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
    }
    else
    {
        MnsNtfCheck(NTF_NISTATE);
80010130:	32 0c       	mov	r12,32
80010132:	fe b0 d6 9d 	rcall	8000ae6c <MnsNtfCheck>
80010136:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        #ifdef AMS_53
            MsgNIStateNetInit();
        #endif
    }

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached) && (MNS_FALSE != MnsPMReady()))
8001013a:	58 06       	cp.w	r6,0
8001013c:	c2 81       	brne	8001018c <VmsvHandleNIStateStatus+0xe8>
        #endif
    }
    else if (NISTATE_NET_INIT != msg_ptr->Data[0])
    {
        #ifdef ADS_10
            DataNIStateNetOn(MNS_FALSE);
8001013e:	30 0c       	mov	r12,0
80010140:	e0 a0 08 e8 	rcall	80011310 <DataNIStateNetOn>
        #endif
    }

    if (NISTATE_NET_OFF == msg_ptr->Data[0])
80010144:	6e 08       	ld.w	r8,r7[0x0]
80010146:	11 89       	ld.ub	r9,r8[0x0]
80010148:	30 08       	mov	r8,0
8001014a:	f0 09 18 00 	cp.b	r9,r8
8001014e:	ce f1       	brne	8001012c <VmsvHandleNIStateStatus+0x88>
    {
        MnsDistribEvent(MNS_P_SRV_MNS, MNS_P_AS_GO_NET_OFF);
80010150:	e0 6b 40 00 	mov	r11,16384
80010154:	30 4c       	mov	r12,4
80010156:	fe b0 d5 d3 	rcall	8000acfc <MnsDistribEvent>
    }

    if (MNS_FALSE != attached)
8001015a:	58 06       	cp.w	r6,0
8001015c:	ce a0       	breq	80010130 <VmsvHandleNIStateStatus+0x8c>
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
8001015e:	31 0c       	mov	r12,16
80010160:	c6 ee       	rcall	8000fe3c <VmsvSetPendingEvent>
80010162:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80010166:	fe b0 c5 a3 	rcall	80008cac <MsgNIStateNetInit>
        #endif
    }
    else    /* (NET_INIT == msg_ptr->Data[0]) */
    {
        #ifdef AMS_53
            MsgNIStateNetInit();
8001016a:	cd 7b       	rjmp	80010118 <VmsvHandleNIStateStatus+0x74>
8001016c:	58 06       	cp.w	r6,0

    GIVE_VMSV();

    MnsDistribEvent(MNS_P_SRV_VMSV, VMSV_P_SRV_CHECK);

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached))
8001016e:	cd 20       	breq	80010112 <VmsvHandleNIStateStatus+0x6e>
80010170:	e0 a0 12 58 	rcall	80012620 <ScmGetBoundary>
    {
        #ifdef AMS_MIN
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
80010174:	3e e8       	mov	r8,-18
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
80010176:	18 95       	mov	r5,r12

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached))
    {
        #ifdef AMS_MIN
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
80010178:	f0 0c 18 00 	cp.b	r12,r8
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
8001017c:	cc e0       	breq	80010118 <VmsvHandleNIStateStatus+0x74>
8001017e:	30 8c       	mov	r12,8
80010180:	fe b0 d6 9a 	rcall	8000aeb4 <MostIsSupported>
80010184:	c1 81       	brne	800101b4 <VmsvHandleNIStateStatus+0x110>
80010186:	fe b0 d6 4d 	rcall	8000ae20 <MnsSignalNetOn>
            bool bdvalid  = MNS_TRUE;
            #endif

            if (MNS_FALSE != bdvalid)
            {
                MnsSignalNetOn();
8001018a:	cc 7b       	rjmp	80010118 <VmsvHandleNIStateStatus+0x74>
8001018c:	fe b0 da 14 	rcall	8000b5b4 <MnsPMReady>
        #ifdef AMS_53
            MsgNIStateNetInit();
        #endif
    }

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached) && (MNS_FALSE != MnsPMReady()))
80010190:	c0 e1       	brne	800101ac <VmsvHandleNIStateStatus+0x108>
80010192:	6e 08       	ld.w	r8,r7[0x0]
80010194:	11 88       	ld.ub	r8,r8[0x0]
80010196:	cc 7b       	rjmp	80010124 <VmsvHandleNIStateStatus+0x80>
80010198:	e0 68 03 22 	mov	r8,802

    T_LIB_ENTRY(VMSV_17);

    attached = EHCISTATE_IS_ATTACHED() ? MNS_TRUE : MNS_FALSE;

    ASSERT(msg_ptr);
8001019c:	30 1a       	mov	r10,1
8001019e:	1a d8       	st.w	--sp,r8
800101a0:	31 0b       	mov	r11,16
800101a2:	34 0c       	mov	r12,64
800101a4:	fe b0 bc a4 	rcall	80007aec <mns_trace>
800101a8:	2f fd       	sub	sp,-4
800101aa:	c8 8b       	rjmp	800100ba <VmsvHandleNIStateStatus+0x16>
800101ac:	30 1c       	mov	r12,1
    }

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached) && (MNS_FALSE != MnsPMReady()))
    {
        #ifdef ADS_10
            DataNIStateNetOn(MNS_TRUE);
800101ae:	e0 a0 08 b1 	rcall	80011310 <DataNIStateNetOn>
800101b2:	cc 9b       	rjmp	80010144 <VmsvHandleNIStateStatus+0xa0>
        #ifdef AMS_53
            MsgNIStateNetInit();
        #endif
    }

    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached) && (MNS_FALSE != MnsPMReady()))
800101b4:	58 05       	cp.w	r5,0
    if ((NISTATE_NET_ON == msg_ptr->Data[0]) && (MNS_FALSE != attached))
    {
        #ifdef AMS_MIN
            #ifdef SCM_MIN
            byte boundary = ScmGetBoundary();
            bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
800101b6:	cb 10       	breq	80010118 <VmsvHandleNIStateStatus+0x74>
800101b8:	ce 7b       	rjmp	80010186 <VmsvHandleNIStateStatus+0xe2>
800101ba:	d7 03       	nop
800101bc:	00 00       	add	r0,r0
800101be:	39 9c       	mov	r12,-103

800101c0 <VmsvHandleNIEventStatus>:
800101c0:	eb cd 40 80 	pushm	r7,lr
800101c4:	18 97       	mov	r7,r12
800101c6:	58 0c       	cp.w	r12,0
800101c8:	c1 d0       	breq	80010202 <VmsvHandleNIEventStatus+0x42>
800101ca:	31 1c       	mov	r12,17
800101cc:	fe b0 bc 75 	rcall	80007ab6 <mns_take>
800101d0:	49 28       	lddpc	r8,80010218 <VmsvHandleNIEventStatus+0x58>
800101d2:	f1 39 00 20 	ld.ub	r9,r8[32]
800101d6:	a1 b9       	sbr	r9,0x1
800101d8:	f1 69 00 20 	st.b	r8[32],r9
800101dc:	6e 09       	ld.w	r9,r7[0x0]
800101de:	13 89       	ld.ub	r9,r9[0x0]
800101e0:	31 1c       	mov	r12,17
800101e2:	f1 69 00 26 	st.b	r8[38],r9
800101e6:	fe b0 bc 69 	rcall	80007ab8 <mns_give>
800101ea:	fe b0 d6 83 	rcall	8000aef0 <MnsGetEHCIState>
800101ee:	30 28       	mov	r8,2
800101f0:	f0 0c 18 00 	cp.b	r12,r8
800101f4:	c0 30       	breq	800101fa <VmsvHandleNIEventStatus+0x3a>
800101f6:	e3 cd 80 80 	ldm	sp++,r7,pc
    vmsv.shadow.nievent  = msg_ptr->Data[0];
    GIVE_VMSV();

    if (EHCISTATE_IS_ATTACHED())
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
800101fa:	31 0c       	mov	r12,16
800101fc:	c2 0e       	rcall	8000fe3c <VmsvSetPendingEvent>
800101fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80010202:	e0 68 03 09 	mov	r8,777
#ifdef VMSV_16
void VmsvHandleNIEventStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_16);

    ASSERT(msg_ptr);
80010206:	30 1a       	mov	r10,1
80010208:	1a d8       	st.w	--sp,r8
8001020a:	31 0b       	mov	r11,16
8001020c:	34 0c       	mov	r12,64
8001020e:	fe b0 bc 6f 	rcall	80007aec <mns_trace>
80010212:	2f fd       	sub	sp,-4
80010214:	cd bb       	rjmp	800101ca <VmsvHandleNIEventStatus+0xa>
80010216:	d7 03       	nop
80010218:	00 00       	add	r0,r0
8001021a:	39 9c       	mov	r12,-103

8001021c <VmsvHandleLockStateStatus>:
8001021c:	eb cd 40 c0 	pushm	r6-r7,lr
80010220:	18 97       	mov	r7,r12
80010222:	58 0c       	cp.w	r12,0
80010224:	c3 70       	breq	80010292 <VmsvHandleLockStateStatus+0x76>
80010226:	31 1c       	mov	r12,17
80010228:	fe b0 bc 47 	rcall	80007ab6 <mns_take>
8001022c:	49 f6       	lddpc	r6,800102a8 <VmsvHandleLockStateStatus+0x8c>
8001022e:	ed 38 00 20 	ld.ub	r8,r6[32]
    T_LIB_ENTRY(VMSV_14);

    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed |= VMSV_SHADOW_LOCKSTATE_CHANGED;
80010232:	a3 a8       	sbr	r8,0x2
80010234:	ed 68 00 20 	st.b	r6[32],r8
    vmsv.shadow.lockstate  = msg_ptr->Data[0];
80010238:	6e 08       	ld.w	r8,r7[0x0]
8001023a:	11 88       	ld.ub	r8,r8[0x0]
    GIVE_VMSV();
8001023c:	31 1c       	mov	r12,17

    ASSERT(msg_ptr);

    TAKE_VMSV();
    vmsv.shadow.changed |= VMSV_SHADOW_LOCKSTATE_CHANGED;
    vmsv.shadow.lockstate  = msg_ptr->Data[0];
8001023e:	ed 68 00 32 	st.b	r6[50],r8
    GIVE_VMSV();
80010242:	fe b0 bc 3b 	rcall	80007ab8 <mns_give>

    if (EHCISTATE_IS_ATTACHED())
80010246:	fe b0 d6 55 	rcall	8000aef0 <MnsGetEHCIState>
8001024a:	30 28       	mov	r8,2
8001024c:	f0 0c 18 00 	cp.b	r12,r8
80010250:	c1 d0       	breq	8001028a <VmsvHandleLockStateStatus+0x6e>
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
    }
    else
    {
        MnsNtfCheck(NTF_LOCKSTATE);
80010252:	e0 6c 00 80 	mov	r12,128
80010256:	fe b0 d6 0b 	rcall	8000ae6c <MnsNtfCheck>
    }

    #ifdef NS_MSV_ET
    TAKE_VMSV();
8001025a:	31 1c       	mov	r12,17
8001025c:	fe b0 bc 2d 	rcall	80007ab6 <mns_take>
    if (   (    (VMSV_PLT_TEST1 == vmsv.plt.test_state)
80010260:	ed 39 00 81 	ld.ub	r9,r6[129]
80010264:	49 1a       	lddpc	r10,800102a8 <VmsvHandleLockStateStatus+0x8c>
80010266:	20 49       	sub	r9,4
80010268:	30 18       	mov	r8,1
8001026a:	f0 09 18 00 	cp.b	r9,r8
8001026e:	e0 8b 00 09 	brhi	80010280 <VmsvHandleLockStateStatus+0x64>
80010272:	f5 3b 00 32 	ld.ub	r11,r10[50]
80010276:	30 09       	mov	r9,0
             || (VMSV_PLT_TEST2 == vmsv.plt.test_state) )
        && (MSVAL_E_UNLOCK == vmsv.shadow.lockstate) )
    {
        vmsv.plr.lock_status = MNS_TRUE;
80010278:	f2 0b 18 00 	cp.b	r11,r9
8001027c:	f5 f8 0e 98 	st.beq	r10[0x98],r8
    }
    GIVE_VMSV();
80010280:	31 1c       	mov	r12,17
80010282:	fe b0 bc 1b 	rcall	80007ab8 <mns_give>
    #endif

    T_LIB_EXIT(VMSV_14);
}
80010286:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    vmsv.shadow.lockstate  = msg_ptr->Data[0];
    GIVE_VMSV();

    if (EHCISTATE_IS_ATTACHED())
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
8001028a:	31 0c       	mov	r12,16
8001028c:	fe b0 fd d8 	rcall	8000fe3c <VmsvSetPendingEvent>
80010290:	ce 5b       	rjmp	8001025a <VmsvHandleLockStateStatus+0x3e>
#ifdef VMSV_14
void VmsvHandleLockStateStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(VMSV_14);

    ASSERT(msg_ptr);
80010292:	e0 68 02 db 	mov	r8,731
80010296:	30 1a       	mov	r10,1
80010298:	1a d8       	st.w	--sp,r8
8001029a:	31 0b       	mov	r11,16
8001029c:	34 0c       	mov	r12,64
8001029e:	fe b0 bc 27 	rcall	80007aec <mns_trace>
800102a2:	2f fd       	sub	sp,-4
800102a4:	cc 1b       	rjmp	80010226 <VmsvHandleLockStateStatus+0xa>
800102a6:	d7 03       	nop
800102a8:	00 00       	add	r0,r0
800102aa:	39 9c       	mov	r12,-103

800102ac <VmsvNWStartUpRetry>:
800102ac:	d4 21       	pushm	r4-r7,lr
800102ae:	30 7c       	mov	r12,7
800102b0:	fe b0 c5 f6 	rcall	80008e9c <MsgGetTxPtrExt>
800102b4:	18 97       	mov	r7,r12
800102b6:	c5 50       	breq	80010360 <VmsvNWStartUpRetry+0xb4>
800102b8:	30 15       	mov	r5,1
800102ba:	30 04       	mov	r4,0
800102bc:	b8 35       	st.h	r12[0x6],r5
800102be:	f9 64 00 0a 	st.b	r12[10],r4
800102c2:	31 1c       	mov	r12,17
    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;

        TAKE_VMSV();
800102c4:	fe b0 bb f9 	rcall	80007ab6 <mns_take>
        switch (vmsv.nwstartup.state)
800102c8:	4a 86       	lddpc	r6,80010368 <VmsvNWStartUpRetry+0xbc>
800102ca:	30 2a       	mov	r10,2
800102cc:	0d c9       	ld.ub	r9,r6[0x4]
800102ce:	12 98       	mov	r8,r9
800102d0:	f4 09 18 00 	cp.b	r9,r10
800102d4:	c3 d0       	breq	8001034e <VmsvNWStartUpRetry+0xa2>
800102d6:	30 49       	mov	r9,4
800102d8:	f2 08 18 00 	cp.b	r8,r9
800102dc:	c1 f0       	breq	8001031a <VmsvNWStartUpRetry+0x6e>
800102de:	ea 08 18 00 	cp.b	r8,r5
800102e2:	c2 b0       	breq	80010338 <VmsvNWStartUpRetry+0x8c>
                #endif

                break;

             default:
                FAILED_ASSERT();
800102e4:	e0 68 01 d1 	mov	r8,465
800102e8:	30 1a       	mov	r10,1
800102ea:	1a d8       	st.w	--sp,r8
800102ec:	31 0b       	mov	r11,16
800102ee:	34 0c       	mov	r12,64
800102f0:	30 15       	mov	r5,1
800102f2:	fe b0 bb fd 	rcall	80007aec <mns_trace>
800102f6:	2f fd       	sub	sp,-4
                problem = MNS_TRUE;
                break;
        }
        if (VMSV_NWSTARTUP_DEVMODE != vmsv.nwstartup.state)
800102f8:	0d c9       	ld.ub	r9,r6[0x4]
800102fa:	30 18       	mov	r8,1
800102fc:	f0 09 18 00 	cp.b	r9,r8
80010300:	c0 40       	breq	80010308 <VmsvNWStartUpRetry+0x5c>
        {
            vmsv.nwstartup.state = VMSV_NWSTARTUP_COMPLETE;
80010302:	30 09       	mov	r9,0
80010304:	49 98       	lddpc	r8,80010368 <VmsvNWStartUpRetry+0xbc>
80010306:	b0 c9       	st.b	r8[0x4],r9
        }
        GIVE_VMSV();
80010308:	31 1c       	mov	r12,17
8001030a:	fe b0 bb d7 	rcall	80007ab8 <mns_give>

        if (MNS_FALSE == problem)
8001030e:	58 05       	cp.w	r5,0
80010310:	c1 01       	brne	80010330 <VmsvNWStartUpRetry+0x84>
        {
            MsgSend3(msg_ptr);
80010312:	0e 9c       	mov	r12,r7
80010314:	fe b0 c9 08 	rcall	80009524 <MsgSend3>
80010318:	d8 22       	popm	r4-r7,pc
                break;

            case VMSV_NWSTARTUP_RBD:
                msg_ptr->Func_ID   = FUNCID_INIC_RBDTRIGGER;
                msg_ptr->Operation = OP_START;
                msg_ptr->Length    = (word)1;
8001031a:	ae 25       	st.h	r7[0x4],r5
                msg_ptr->Length    = (word)0;
                break;

            case VMSV_NWSTARTUP_RBD:
                msg_ptr->Func_ID   = FUNCID_INIC_RBDTRIGGER;
                msg_ptr->Operation = OP_START;
8001031c:	ef 64 00 0c 	st.b	r7[12],r4
                msg_ptr->Operation = OP_STARTRESULT;
                msg_ptr->Length    = (word)0;
                break;

            case VMSV_NWSTARTUP_RBD:
                msg_ptr->Func_ID   = FUNCID_INIC_RBDTRIGGER;
80010320:	e0 68 05 07 	mov	r8,1287
80010324:	ae 48       	st.h	r7[0x8],r8
                msg_ptr->Operation = OP_START;
                msg_ptr->Length    = (word)1;
                msg_ptr->Data[0]   = (byte)0x00;
80010326:	6e 08       	ld.w	r8,r7[0x0]
80010328:	b0 84       	st.b	r8[0x0],r4

                #ifdef MSV_DIAG_RESULT_MSG
                    vmsv.nwstartup.comm_state = VMSV_COMM_OFF;
8001032a:	ac f4       	st.b	r6[0x7],r4
8001032c:	30 05       	mov	r5,0
                #endif

                break;
8001032e:	ce 5b       	rjmp	800102f8 <VmsvNWStartUpRetry+0x4c>
        {
            MsgSend3(msg_ptr);
        }
        else
        {
            MsgTxUnused(msg_ptr);
80010330:	0e 9c       	mov	r12,r7
80010332:	fe b0 c6 01 	rcall	80008f34 <MsgTxUnused>
80010336:	d8 22       	popm	r4-r7,pc
        switch (vmsv.nwstartup.state)
        {
            case VMSV_NWSTARTUP_DEVMODE:
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = (word)1;
80010338:	ae 25       	st.h	r7[0x4],r5
        TAKE_VMSV();
        switch (vmsv.nwstartup.state)
        {
            case VMSV_NWSTARTUP_DEVMODE:
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                msg_ptr->Operation = OP_SET;
8001033a:	ef 64 00 0c 	st.b	r7[12],r4

        TAKE_VMSV();
        switch (vmsv.nwstartup.state)
        {
            case VMSV_NWSTARTUP_DEVMODE:
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
8001033e:	e0 68 05 02 	mov	r8,1282
80010342:	ae 48       	st.h	r7[0x8],r8
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = (word)1;
                msg_ptr->Data[0]   = vmsv.nwstartup.dev_mode;
80010344:	30 05       	mov	r5,0
80010346:	6e 08       	ld.w	r8,r7[0x0]
80010348:	0d d9       	ld.ub	r9,r6[0x5]
8001034a:	b0 89       	st.b	r8[0x0],r9
                break;
8001034c:	cd 6b       	rjmp	800102f8 <VmsvNWStartUpRetry+0x4c>

            case VMSV_NWSTARTUP_NWSTARTUP:
                msg_ptr->Func_ID   = FUNCID_INIC_NWSTARTUP;
8001034e:	e0 68 05 00 	mov	r8,1280
                msg_ptr->Operation = OP_STARTRESULT;
80010352:	ef 69 00 0c 	st.b	r7[12],r9
                msg_ptr->Length    = (word)1;
                msg_ptr->Data[0]   = vmsv.nwstartup.dev_mode;
                break;

            case VMSV_NWSTARTUP_NWSTARTUP:
                msg_ptr->Func_ID   = FUNCID_INIC_NWSTARTUP;
80010356:	ae 48       	st.h	r7[0x8],r8
                msg_ptr->Operation = OP_STARTRESULT;
                msg_ptr->Length    = (word)0;
80010358:	30 05       	mov	r5,0
8001035a:	30 08       	mov	r8,0
8001035c:	ae 28       	st.h	r7[0x4],r8
                break;
8001035e:	cc db       	rjmp	800102f8 <VmsvNWStartUpRetry+0x4c>
            MsgTxUnused(msg_ptr);
        }
    }
    else
    {
        VmsvSetPendingEvent(VMSV_P_NWSTARTUP_RETRY);
80010360:	30 1c       	mov	r12,1
80010362:	fe b0 fd 6d 	rcall	8000fe3c <VmsvSetPendingEvent>
80010366:	d8 22       	popm	r4-r7,pc
80010368:	00 00       	add	r0,r0
8001036a:	39 9c       	mov	r12,-103

8001036c <VmsvHandleDeviceModeStatus>:
8001036c:	eb cd 40 80 	pushm	r7,lr
80010370:	18 97       	mov	r7,r12
80010372:	58 0c       	cp.w	r12,0
80010374:	c2 a0       	breq	800103c8 <VmsvHandleDeviceModeStatus+0x5c>
80010376:	31 1c       	mov	r12,17
80010378:	fe b0 bb 9f 	rcall	80007ab6 <mns_take>
8001037c:	6e 08       	ld.w	r8,r7[0x0]
8001037e:	11 89       	ld.ub	r9,r8[0x0]
80010380:	49 78       	lddpc	r8,800103dc <VmsvHandleDeviceModeStatus+0x70>
80010382:	f1 69 00 2c 	st.b	r8[44],r9
80010386:	11 ca       	ld.ub	r10,r8[0x4]

    state_change = MNS_FALSE;

    TAKE_VMSV();
    vmsv.shadow.devmode = msg_ptr->Data[0];
    if(VMSV_NWSTARTUP_DEVMODE == vmsv.nwstartup.state)
80010388:	30 19       	mov	r9,1
8001038a:	f2 0a 18 00 	cp.b	r10,r9
8001038e:	c0 f0       	breq	800103ac <VmsvHandleDeviceModeStatus+0x40>
    {
        vmsv.nwstartup.state = (MNS_FALSE != vmsv.nwstartup.diagnosis) ?
            VMSV_NWSTARTUP_RBD : VMSV_NWSTARTUP_NWSTARTUP;
        state_change = MNS_TRUE;
    }
    GIVE_VMSV();
80010390:	31 1c       	mov	r12,17
80010392:	fe b0 bb 93 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != state_change)
    {
        VmsvNWStartUpRetry();
    }
    if (!EHCISTATE_IS_ATTACHED())
80010396:	fe b0 d5 ad 	rcall	8000aef0 <MnsGetEHCIState>
8001039a:	30 28       	mov	r8,2
8001039c:	f0 0c 18 00 	cp.b	r12,r8
800103a0:	c0 40       	breq	800103a8 <VmsvHandleDeviceModeStatus+0x3c>
    {
        MnsNtfCheck(NTF_DEVMODE);
800103a2:	34 0c       	mov	r12,64
800103a4:	fe b0 d5 64 	rcall	8000ae6c <MnsNtfCheck>
800103a8:	e3 cd 80 80 	ldm	sp++,r7,pc

    TAKE_VMSV();
    vmsv.shadow.devmode = msg_ptr->Data[0];
    if(VMSV_NWSTARTUP_DEVMODE == vmsv.nwstartup.state)
    {
        vmsv.nwstartup.state = (MNS_FALSE != vmsv.nwstartup.diagnosis) ?
800103ac:	11 ea       	ld.ub	r10,r8[0x6]
            VMSV_NWSTARTUP_RBD : VMSV_NWSTARTUP_NWSTARTUP;
        state_change = MNS_TRUE;
    }
    GIVE_VMSV();
800103ae:	31 1c       	mov	r12,17

    TAKE_VMSV();
    vmsv.shadow.devmode = msg_ptr->Data[0];
    if(VMSV_NWSTARTUP_DEVMODE == vmsv.nwstartup.state)
    {
        vmsv.nwstartup.state = (MNS_FALSE != vmsv.nwstartup.diagnosis) ?
800103b0:	30 09       	mov	r9,0
800103b2:	f2 0a 18 00 	cp.b	r10,r9
800103b6:	f9 b9 01 04 	movne	r9,4
800103ba:	f9 b9 00 02 	moveq	r9,2
800103be:	b0 c9       	st.b	r8[0x4],r9
            VMSV_NWSTARTUP_RBD : VMSV_NWSTARTUP_NWSTARTUP;
        state_change = MNS_TRUE;
    }
    GIVE_VMSV();
800103c0:	fe b0 bb 7c 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != state_change)
    {
        VmsvNWStartUpRetry();
800103c4:	c7 4f       	rcall	800102ac <VmsvNWStartUpRetry>
800103c6:	ce 8b       	rjmp	80010396 <VmsvHandleDeviceModeStatus+0x2a>
800103c8:	e0 68 02 b1 	mov	r8,689
{
    bool state_change;

    T_LIB_ENTRY(VMSV_13);

    ASSERT(msg_ptr);
800103cc:	30 1a       	mov	r10,1
800103ce:	1a d8       	st.w	--sp,r8
800103d0:	31 0b       	mov	r11,16
800103d2:	34 0c       	mov	r12,64
800103d4:	fe b0 bb 8c 	rcall	80007aec <mns_trace>
800103d8:	2f fd       	sub	sp,-4
800103da:	cc eb       	rjmp	80010376 <VmsvHandleDeviceModeStatus+0xa>
800103dc:	00 00       	add	r0,r0
800103de:	39 9c       	mov	r12,-103

800103e0 <MostStartUp>:
800103e0:	eb cd 40 e0 	pushm	r5-r7,lr
800103e4:	3f c8       	mov	r8,-4
800103e6:	18 99       	mov	r9,r12
800103e8:	18 97       	mov	r7,r12
800103ea:	16 96       	mov	r6,r11
800103ec:	20 29       	sub	r9,2
800103ee:	f0 09 18 00 	cp.b	r9,r8
800103f2:	e0 8b 00 05 	brhi	800103fc <MostStartUp+0x1c>
800103f6:	31 0c       	mov	r12,16
800103f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
         && (MNS_SLAVE        != dev_mode)
         && (MNS_DEVMODE_AUTO != dev_mode))
    {
        result = ERR_NOT_SUPPORTED;
    }
    else if (DIAGNOSIS & options)
800103fc:	ed bb 00 01 	bld	r11,0x1
80010400:	c2 71       	brne	8001044e <MostStartUp+0x6e>
    {
        if (MNS_FALSE == MostIsSupported(NSF_RBD))
80010402:	e0 6c 02 00 	mov	r12,512
80010406:	fe b0 d5 57 	rcall	8000aeb4 <MostIsSupported>
8001040a:	cf 60       	breq	800103f6 <MostStartUp+0x16>
        {
            result = ERR_NOT_SUPPORTED;
        }
        else if ((MNS_DEVMODE_AUTO != dev_mode) && (dev_mode != MostGetDevMode()))
8001040c:	3f f8       	mov	r8,-1
8001040e:	f0 07 18 00 	cp.b	r7,r8
80010412:	c2 f0       	breq	80010470 <MostStartUp+0x90>
80010414:	fe b0 f6 1c 	rcall	8000f04c <MostGetDevMode>
80010418:	ee 0c 18 00 	cp.b	r12,r7
8001041c:	c2 a0       	breq	80010470 <MostStartUp+0x90>
        {
            if (MNS_NET_ON == MostGetState())
8001041e:	fe b0 fc cf 	rcall	8000fdbc <MostGetState>
80010422:	30 48       	mov	r8,4
80010424:	f0 0c 18 00 	cp.b	r12,r8
80010428:	c2 60       	breq	80010474 <MostStartUp+0x94>
    {
        if (MNS_NET_ON == MostGetState())
        {
            result = VMSV_MSU_ALREADY_ON;
        }
        else if ((MNS_DEVMODE_AUTO != dev_mode) && (dev_mode != MostGetDevMode()))
8001042a:	30 15       	mov	r5,1
        }
    }

    if (VMSV_NWSTARTUP_COMPLETE != new_state)
    {
        TAKE_VMSV();
8001042c:	31 1c       	mov	r12,17
8001042e:	fe b0 bb 44 	rcall	80007ab6 <mns_take>
        vmsv.nwstartup.state     = new_state;
80010432:	49 48       	lddpc	r8,80010480 <MostStartUp+0xa0>
        vmsv.nwstartup.dev_mode  = dev_mode;
        vmsv.nwstartup.diagnosis = (DIAGNOSIS == options) ? MNS_TRUE : MNS_FALSE;
        GIVE_VMSV();
80010434:	31 1c       	mov	r12,17
    if (VMSV_NWSTARTUP_COMPLETE != new_state)
    {
        TAKE_VMSV();
        vmsv.nwstartup.state     = new_state;
        vmsv.nwstartup.dev_mode  = dev_mode;
        vmsv.nwstartup.diagnosis = (DIAGNOSIS == options) ? MNS_TRUE : MNS_FALSE;
80010436:	30 29       	mov	r9,2
80010438:	f2 06 18 00 	cp.b	r6,r9
8001043c:	5f 09       	sreq	r9
    }

    if (VMSV_NWSTARTUP_COMPLETE != new_state)
    {
        TAKE_VMSV();
        vmsv.nwstartup.state     = new_state;
8001043e:	b0 c5       	st.b	r8[0x4],r5
        vmsv.nwstartup.dev_mode  = dev_mode;
80010440:	b0 d7       	st.b	r8[0x5],r7
        vmsv.nwstartup.diagnosis = (DIAGNOSIS == options) ? MNS_TRUE : MNS_FALSE;
80010442:	b0 e9       	st.b	r8[0x6],r9
        GIVE_VMSV();
80010444:	fe b0 bb 3a 	rcall	80007ab8 <mns_give>
        VmsvNWStartUpRetry();
80010448:	c3 2f       	rcall	800102ac <VmsvNWStartUpRetry>
8001044a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8001044e:	fe b0 fc b7 	rcall	8000fdbc <MostGetState>
            new_state = VMSV_NWSTARTUP_RBD;
        }
    }
    else
    {
        if (MNS_NET_ON == MostGetState())
80010452:	30 48       	mov	r8,4
80010454:	f0 0c 18 00 	cp.b	r12,r8
80010458:	c1 10       	breq	8001047a <MostStartUp+0x9a>
8001045a:	3f f8       	mov	r8,-1
        {
            result = VMSV_MSU_ALREADY_ON;
        }
        else if ((MNS_DEVMODE_AUTO != dev_mode) && (dev_mode != MostGetDevMode()))
8001045c:	f0 07 18 00 	cp.b	r7,r8
80010460:	c0 60       	breq	8001046c <MostStartUp+0x8c>
80010462:	fe b0 f5 f5 	rcall	8000f04c <MostGetDevMode>
80010466:	ee 0c 18 00 	cp.b	r12,r7
8001046a:	ce 01       	brne	8001042a <MostStartUp+0x4a>
8001046c:	30 25       	mov	r5,2
8001046e:	cd fb       	rjmp	8001042c <MostStartUp+0x4c>
80010470:	30 45       	mov	r5,4
80010472:	cd db       	rjmp	8001042c <MostStartUp+0x4c>
80010474:	30 2c       	mov	r12,2
        {
            result = ERR_NOT_SUPPORTED;
        }
        else if ((MNS_DEVMODE_AUTO != dev_mode) && (dev_mode != MostGetDevMode()))
        {
            if (MNS_NET_ON == MostGetState())
80010476:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001047a:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
            new_state = VMSV_NWSTARTUP_RBD;
        }
    }
    else
    {
        if (MNS_NET_ON == MostGetState())
8001047e:	d7 03       	nop
80010480:	00 00       	add	r0,r0
80010482:	39 9c       	mov	r12,-103

80010484 <MostShutDown>:
80010484:	d4 01       	pushm	lr
80010486:	30 0c       	mov	r12,0
80010488:	fe b0 c5 0a 	rcall	80008e9c <MsgGetTxPtrExt>
8001048c:	c1 10       	breq	800104ae <MostShutDown+0x2a>
8001048e:	30 19       	mov	r9,1
80010490:	b8 39       	st.h	r12[0x6],r9
80010492:	30 09       	mov	r9,0
80010494:	f9 69 00 0a 	st.b	r12[10],r9
80010498:	e0 69 05 01 	mov	r9,1281

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_NWSHUTDOWN;
8001049c:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_STARTRESULT;
8001049e:	30 29       	mov	r9,2
800104a0:	f9 69 00 0c 	st.b	r12[12],r9
        msg_ptr->Length    = (word)0;
800104a4:	30 09       	mov	r9,0
800104a6:	b8 29       	st.h	r12[0x4],r9

        MsgSend3(msg_ptr);
800104a8:	fe b0 c8 3e 	rcall	80009524 <MsgSend3>
800104ac:	d8 02       	popm	pc
    }
    else
    {
        VmsvSetPendingEvent(VMSV_P_NWSHUTDOWN_RETRY);
800104ae:	30 2c       	mov	r12,2
800104b0:	fe b0 fc c6 	rcall	8000fe3c <VmsvSetPendingEvent>
800104b4:	d8 02       	popm	pc
800104b6:	d7 03       	nop

800104b8 <VmsvCommRBDResultPos0>:
800104b8:	d4 31       	pushm	r0-r7,lr
800104ba:	18 97       	mov	r7,r12
800104bc:	31 1c       	mov	r12,17
800104be:	fe b0 ba fc 	rcall	80007ab6 <mns_take>
800104c2:	4e 46       	lddpc	r6,80010650 <VmsvCommRBDResultPos0+0x198>

    TAKE_VMSV();
    nistate = vmsv.shadow.nistate;

    /* check if the transition is ok */
    if(   (go_to_state == (vmsv.nwstartup.comm_state+1))
800104c4:	30 65       	mov	r5,6
800104c6:	0d f9       	ld.ub	r9,r6[0x7]
800104c8:	ea 07 18 00 	cp.b	r7,r5
800104cc:	5f 08       	sreq	r8
800104ce:	2f f9       	sub	r9,-1
    T_MOD_ENTRY(VMSV_67);

    go_on = MNS_FALSE;

    TAKE_VMSV();
    nistate = vmsv.shadow.nistate;
800104d0:	ed 32 00 21 	ld.ub	r2,r6[33]

    /* check if the transition is ok */
    if(   (go_to_state == (vmsv.nwstartup.comm_state+1))
800104d4:	12 37       	cp.w	r7,r9
800104d6:	5f 09       	sreq	r9
800104d8:	30 04       	mov	r4,0
800104da:	f3 e8 10 08 	or	r8,r9,r8
800104de:	e8 08 18 00 	cp.b	r8,r4
800104e2:	c3 b0       	breq	80010558 <VmsvCommRBDResultPos0+0xa0>
    else
    {
        FAILED_ASSERT();
    }

    GIVE_VMSV();
800104e4:	31 1c       	mov	r12,17

    /* check if the transition is ok */
    if(   (go_to_state == (vmsv.nwstartup.comm_state+1))
       || (VMSV_COMM_WAIT_AFTER_SEND == go_to_state) )
    {
        vmsv.nwstartup.comm_state = go_to_state;
800104e6:	ac f7       	st.b	r6[0x7],r7
    else
    {
        FAILED_ASSERT();
    }

    GIVE_VMSV();
800104e8:	fe b0 ba e8 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != go_on)
    {
        word timer = (word)0;

        T_COMM_CHANGE(go_to_state);
800104ec:	30 83       	mov	r3,8
800104ee:	1a d7       	st.w	--sp,r7
800104f0:	30 2a       	mov	r10,2
800104f2:	1a d3       	st.w	--sp,r3
800104f4:	30 fb       	mov	r11,15
800104f6:	34 0c       	mov	r12,64

    /* check if the transition is ok */
    if(   (go_to_state == (vmsv.nwstartup.comm_state+1))
       || (VMSV_COMM_WAIT_AFTER_SEND == go_to_state) )
    {
        vmsv.nwstartup.comm_state = go_to_state;
800104f8:	0e 90       	mov	r0,r7

    if (MNS_FALSE != go_on)
    {
        word timer = (word)0;

        T_COMM_CHANGE(go_to_state);
800104fa:	fe b0 ba f9 	rcall	80007aec <mns_trace>

        switch (go_to_state)
800104fe:	30 31       	mov	r1,3
80010500:	06 0d       	add	sp,r3
80010502:	e2 07 18 00 	cp.b	r7,r1
80010506:	e0 80 00 8a 	breq	8001061a <VmsvCommRBDResultPos0+0x162>
8001050a:	e0 88 00 14 	brls	80010532 <VmsvCommRBDResultPos0+0x7a>
8001050e:	30 48       	mov	r8,4
80010510:	f0 07 18 00 	cp.b	r7,r8
80010514:	c6 e0       	breq	800105f0 <VmsvCommRBDResultPos0+0x138>
80010516:	ea 07 18 00 	cp.b	r7,r5
8001051a:	e0 80 00 8d 	breq	80010634 <VmsvCommRBDResultPos0+0x17c>
                /* wait for net_off */
                break;


            default:
                FAILED_ASSERT();
8001051e:	e0 68 0a 31 	mov	r8,2609
80010522:	30 1a       	mov	r10,1
80010524:	1a d8       	st.w	--sp,r8
80010526:	31 0b       	mov	r11,16
80010528:	34 0c       	mov	r12,64
8001052a:	fe b0 ba e1 	rcall	80007aec <mns_trace>
8001052e:	2f fd       	sub	sp,-4
80010530:	d8 32       	popm	r0-r7,pc
    {
        word timer = (word)0;

        T_COMM_CHANGE(go_to_state);

        switch (go_to_state)
80010532:	30 18       	mov	r8,1
80010534:	f0 07 18 00 	cp.b	r7,r8
80010538:	c1 d0       	breq	80010572 <VmsvCommRBDResultPos0+0xba>
8001053a:	30 28       	mov	r8,2
8001053c:	f0 07 18 00 	cp.b	r7,r8
80010540:	ce f1       	brne	8001051e <VmsvCommRBDResultPos0+0x66>
                MostSetTimer(&vmsv.nwstartup.comm_timer, timer, MNS_FALSE);
                break;

            case VMSV_COMM_STARTNW:
                /* start the network */
                MostStartUp(MNS_MASTER, MNS_DEFAULT);
80010542:	30 0b       	mov	r11,0
80010544:	30 1c       	mov	r12,1
80010546:	c4 df       	rcall	800103e0 <MostStartUp>
80010548:	ec cc ff f8 	sub	r12,r6,-8
                /* start t_rbd */
                MostSetTimer(&vmsv.nwstartup.comm_timer, VMSV_DC_T_RBD, MNS_FALSE);
8001054c:	30 0a       	mov	r10,0
8001054e:	e0 6b 03 e8 	mov	r11,1000
80010552:	fe b0 d5 ab 	rcall	8000b0a8 <MostSetTimer>
80010556:	d8 32       	popm	r0-r7,pc
                break;
80010558:	e0 68 09 d0 	mov	r8,2512
        vmsv.nwstartup.comm_state = go_to_state;
        go_on = MNS_TRUE;
    }
    else
    {
        FAILED_ASSERT();
8001055c:	30 1a       	mov	r10,1
8001055e:	1a d8       	st.w	--sp,r8
80010560:	31 0b       	mov	r11,16
80010562:	34 0c       	mov	r12,64
80010564:	fe b0 ba c4 	rcall	80007aec <mns_trace>
80010568:	31 1c       	mov	r12,17
    }

    GIVE_VMSV();
8001056a:	fe b0 ba a7 	rcall	80007ab8 <mns_give>
8001056e:	2f fd       	sub	sp,-4
80010570:	d8 32       	popm	r0-r7,pc
80010572:	6c f8       	ld.w	r8,r6[0x3c]

        switch (go_to_state)
        {
            case VMSV_COMM_CALL_CB:
                /* call the callback */
                if(vmsv.cfg_ptr->rbd_store_rbd_result_fptr)
80010574:	70 58       	ld.w	r8,r8[0x14]
80010576:	58 08       	cp.w	r8,0
80010578:	c2 10       	breq	800105ba <VmsvCommRBDResultPos0+0x102>
8001057a:	31 1c       	mov	r12,17
                {
                    byte rbd_status;

                    TAKE_VMSV();
8001057c:	fe b0 ba 9d 	rcall	80007ab6 <mns_take>
80010580:	ed 38 00 29 	ld.ub	r8,r6[41]
                    switch (vmsv.shadow.rbdresult[0])
80010584:	ee 08 18 00 	cp.b	r8,r7
80010588:	c6 10       	breq	8001064a <VmsvCommRBDResultPos0+0x192>
8001058a:	e2 08 18 00 	cp.b	r8,r1
8001058e:	c5 c0       	breq	80010646 <VmsvCommRBDResultPos0+0x18e>
80010590:	e0 68 09 f0 	mov	r8,2544
                            rbd_status = RBD_ACTIVITY_NO_LOCK;
                            break;

                        default:
                            rbd_status = INIC_SHADOW_INVALID_BYTE;
                            FAILED_ASSERT();
80010594:	30 1a       	mov	r10,1
80010596:	1a d8       	st.w	--sp,r8
80010598:	31 0b       	mov	r11,16
8001059a:	34 0c       	mov	r12,64
8001059c:	fe b0 ba a8 	rcall	80007aec <mns_trace>
800105a0:	2f fd       	sub	sp,-4
800105a2:	e0 67 00 ee 	mov	r7,238
800105a6:	31 1c       	mov	r12,17
                            break;
                    }
                    GIVE_VMSV();
800105a8:	fe b0 ba 88 	rcall	80007ab8 <mns_give>
800105ac:	6c f9       	ld.w	r9,r6[0x3c]

                    vmsv.cfg_ptr->rbd_store_rbd_result_fptr(rbd_status, vmsv.cfg_ptr->diag_id.length, vmsv.cfg_ptr->diag_id.stream);
800105ae:	0e 9c       	mov	r12,r7
800105b0:	f3 3b 00 1c 	ld.ub	r11,r9[28]
800105b4:	72 58       	ld.w	r8,r9[0x14]
800105b6:	72 6a       	ld.w	r10,r9[0x18]
800105b8:	5d 18       	icall	r8
800105ba:	31 1c       	mov	r12,17
                }

                /* save and set device mode */
                TAKE_VMSV();
800105bc:	fe b0 ba 7d 	rcall	80007ab6 <mns_take>
800105c0:	ed 38 00 2c 	ld.ub	r8,r6[44]
                vmsv.nwstartup.saved_dev_mode = vmsv.shadow.devmode;
800105c4:	31 1c       	mov	r12,17
                GIVE_VMSV();
800105c6:	ed 68 00 1c 	st.b	r6[28],r8
                    vmsv.cfg_ptr->rbd_store_rbd_result_fptr(rbd_status, vmsv.cfg_ptr->diag_id.length, vmsv.cfg_ptr->diag_id.stream);
                }

                /* save and set device mode */
                TAKE_VMSV();
                vmsv.nwstartup.saved_dev_mode = vmsv.shadow.devmode;
800105ca:	fe b0 ba 77 	rcall	80007ab8 <mns_give>
                GIVE_VMSV();
800105ce:	ed 39 00 1c 	ld.ub	r9,r6[28]
                if(MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
800105d2:	30 18       	mov	r8,1
800105d4:	f0 09 18 00 	cp.b	r9,r8
800105d8:	c3 40       	breq	80010640 <VmsvCommRBDResultPos0+0x188>
800105da:	30 1c       	mov	r12,1
                    /* start t_wait_rbd */
                    timer = VMSV_DC_T_WAIT_RBD;
                }
                else
                {
                    MostSetDevMode(MNS_MASTER);
800105dc:	fe b0 f6 1c 	rcall	8000f214 <MostSetDevMode>
800105e0:	e0 6b 00 c8 	mov	r11,200
800105e4:	ec cc ff f8 	sub	r12,r6,-8
                    /* start t_prepre_rbd */
                    timer = VMSV_DC_T_PREPARE_RBD;
                }
                /* start timer */
                MostSetTimer(&vmsv.nwstartup.comm_timer, timer, MNS_FALSE);
800105e8:	30 0a       	mov	r10,0
800105ea:	fe b0 d5 5f 	rcall	8000b0a8 <MostSetTimer>
800105ee:	d8 32       	popm	r0-r7,pc
                break;
800105f0:	ed 3c 00 1c 	ld.ub	r12,r6[28]
                }
                break;

            case VMSV_COMM_RESTORE_DEVMODE:
                /* restore the previous device mode */
                MostSetDevMode(vmsv.nwstartup.saved_dev_mode);
800105f4:	fe b0 f6 10 	rcall	8000f214 <MostSetDevMode>
800105f8:	31 1c       	mov	r12,17
                /* stop state machine */
                TAKE_VMSV();
800105fa:	fe b0 ba 5e 	rcall	80007ab6 <mns_take>
800105fe:	31 1c       	mov	r12,17
                vmsv.nwstartup.comm_state = VMSV_COMM_OFF;
                GIVE_VMSV();
80010600:	ac f4       	st.b	r6[0x7],r4
            case VMSV_COMM_RESTORE_DEVMODE:
                /* restore the previous device mode */
                MostSetDevMode(vmsv.nwstartup.saved_dev_mode);
                /* stop state machine */
                TAKE_VMSV();
                vmsv.nwstartup.comm_state = VMSV_COMM_OFF;
80010602:	fe b0 ba 5b 	rcall	80007ab8 <mns_give>
                GIVE_VMSV();
80010606:	30 08       	mov	r8,0
                T_COMM_CHANGE(VMSV_COMM_OFF);
80010608:	30 2a       	mov	r10,2
8001060a:	1a d8       	st.w	--sp,r8
8001060c:	30 fb       	mov	r11,15
8001060e:	1a d3       	st.w	--sp,r3
80010610:	34 0c       	mov	r12,64
80010612:	fe b0 ba 6d 	rcall	80007aec <mns_trace>
80010616:	2f ed       	sub	sp,-8
                break;
80010618:	d8 32       	popm	r0-r7,pc
8001061a:	fe b0 f9 25 	rcall	8000f864 <VmsvBroadcastRBDResult>
                MostSetTimer(&vmsv.nwstartup.comm_timer, VMSV_DC_T_RBD, MNS_FALSE);
                break;

            case VMSV_COMM_BROADCAST:
                /* broadcast the message */
                VmsvBroadcastRBDResult();
8001061e:	ee 02 18 00 	cp.b	r2,r7
                /* wait for net_off or start timer to shut the network down */
                if (NISTATE_NET_ON == nistate)
80010622:	c8 71       	brne	80010530 <VmsvCommRBDResultPos0+0x78>
80010624:	ec cc ff f8 	sub	r12,r6,-8
                {
                    MostSetTimer(&vmsv.nwstartup.comm_timer, VMSV_DC_T_RBD, MNS_FALSE);
80010628:	30 0a       	mov	r10,0
8001062a:	e0 6b 03 e8 	mov	r11,1000
8001062e:	fe b0 d5 3d 	rcall	8000b0a8 <MostSetTimer>
80010632:	d8 32       	popm	r0-r7,pc
80010634:	e2 02 18 00 	cp.b	r2,r1
                T_COMM_CHANGE(VMSV_COMM_OFF);
                break;

            case VMSV_COMM_WAIT_AFTER_SEND:
                /* shut down if still in MNS_NET_ON */
                if (NISTATE_NET_ON == nistate)
80010638:	fe 91 ff 7c 	brne	80010530 <VmsvCommRBDResultPos0+0x78>
8001063c:	c2 4f       	rcall	80010484 <MostShutDown>
                {
                    MostShutDown();
8001063e:	d8 32       	popm	r0-r7,pc
80010640:	e0 6b 07 d0 	mov	r11,2000

                /* save and set device mode */
                TAKE_VMSV();
                vmsv.nwstartup.saved_dev_mode = vmsv.shadow.devmode;
                GIVE_VMSV();
                if(MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
80010644:	cd 0b       	rjmp	800105e4 <VmsvCommRBDResultPos0+0x12c>
80010646:	30 17       	mov	r7,1
80010648:	ca fb       	rjmp	800105a6 <VmsvCommRBDResultPos0+0xee>
                if(vmsv.cfg_ptr->rbd_store_rbd_result_fptr)
                {
                    byte rbd_status;

                    TAKE_VMSV();
                    switch (vmsv.shadow.rbdresult[0])
8001064a:	30 27       	mov	r7,2
8001064c:	ca db       	rjmp	800105a6 <VmsvCommRBDResultPos0+0xee>
8001064e:	d7 03       	nop
80010650:	00 00       	add	r0,r0
80010652:	39 9c       	mov	r12,-103

80010654 <VmsvPhysicalLayerTestProcedure>:
80010654:	eb cd 40 f8 	pushm	r3-r7,lr
80010658:	31 1c       	mov	r12,17
8001065a:	fe b0 ba 2e 	rcall	80007ab6 <mns_take>
8001065e:	fe f6 02 4e 	ld.w	r6,pc[590]
80010662:	31 1c       	mov	r12,17
80010664:	ed 37 00 81 	ld.ub	r7,r6[129]
80010668:	fe b0 ba 28 	rcall	80007ab8 <mns_give>
8001066c:	58 67       	cp.w	r7,6
8001066e:	e0 88 00 16 	brls	8001069a <VmsvPhysicalLayerTestProcedure+0x46>
80010672:	e0 68 0e 34 	mov	r8,3636
80010676:	1a d8       	st.w	--sp,r8

            break;
        }

        default:
            FAILED_ASSERT();
80010678:	30 1a       	mov	r10,1
8001067a:	31 0b       	mov	r11,16
8001067c:	34 0c       	mov	r12,64
8001067e:	fe b0 ba 37 	rcall	80007aec <mns_trace>
80010682:	2f fd       	sub	sp,-4
            break;
    }

    TAKE_VMSV();
80010684:	31 1c       	mov	r12,17
80010686:	fe b0 ba 18 	rcall	80007ab6 <mns_take>
    vmsv.plt.test_state = test_state;
    GIVE_VMSV();
8001068a:	31 1c       	mov	r12,17
            FAILED_ASSERT();
            break;
    }

    TAKE_VMSV();
    vmsv.plt.test_state = test_state;
8001068c:	ed 67 00 81 	st.b	r6[129],r7
    GIVE_VMSV();
80010690:	fe b0 ba 14 	rcall	80007ab8 <mns_give>


    T_MOD_EXIT(VMSV_95);

    return(test_state);
}
80010694:	0e 9c       	mov	r12,r7
80010696:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    TAKE_VMSV();
    test_state = vmsv.plt.test_state;
    GIVE_VMSV();

    switch (test_state)
8001069a:	fe f8 02 16 	ld.w	r8,pc[534]
8001069e:	f0 07 03 2f 	ld.w	pc,r8[r7<<0x2]
            break;
        }

        case VMSV_PLT_TEST2:
        {
            msg_ptr = MsgGetTxPtrExt(0);
800106a2:	30 0c       	mov	r12,0
800106a4:	fe b0 c3 fc 	rcall	80008e9c <MsgGetTxPtrExt>
            if (msg_ptr)
800106a8:	e0 80 00 e7 	breq	80010876 <VmsvPhysicalLayerTestProcedure+0x222>
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800106ac:	30 19       	mov	r9,1
                msg_ptr->FBlock_ID = FBLOCK_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_NUMCODINGERRORS;
                msg_ptr->Operation = OP_GET;
800106ae:	f9 69 00 0c 	st.b	r12[12],r9
        case VMSV_PLT_TEST2:
        {
            msg_ptr = MsgGetTxPtrExt(0);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800106b2:	b8 39       	st.h	r12[0x6],r9
                msg_ptr->FBlock_ID = FBLOCK_INIC;
800106b4:	30 09       	mov	r9,0
800106b6:	f9 69 00 0a 	st.b	r12[10],r9
                msg_ptr->Func_ID   = FUNCID_INIC_NUMCODINGERRORS;
800106ba:	e0 69 05 0d 	mov	r9,1293
800106be:	b8 49       	st.h	r12[0x8],r9
                msg_ptr->Operation = OP_GET;
                msg_ptr->Length    = (word)0;
800106c0:	30 09       	mov	r9,0
800106c2:	b8 29       	st.h	r12[0x4],r9
                MsgSend3(msg_ptr);
800106c4:	fe b0 c7 30 	rcall	80009524 <MsgSend3>

                /* start timer t_lead_out */
                TAKE_VMSV();
800106c8:	31 1c       	mov	r12,17
800106ca:	fe b0 b9 f6 	rcall	80007ab6 <mns_take>
                lead_out_time = vmsv.plt.lead_out;
                GIVE_VMSV();
800106ce:	31 1c       	mov	r12,17
                msg_ptr->Length    = (word)0;
                MsgSend3(msg_ptr);

                /* start timer t_lead_out */
                TAKE_VMSV();
                lead_out_time = vmsv.plt.lead_out;
800106d0:	ed 07 00 78 	ld.sh	r7,r6[120]
                GIVE_VMSV();
800106d4:	fe b0 b9 f2 	rcall	80007ab8 <mns_give>

                MostSetTimer(&vmsv.plt.state_timer, lead_out_time, MNS_FALSE);
800106d8:	0e 9b       	mov	r11,r7
800106da:	30 0a       	mov	r10,0
800106dc:	5c 7b       	castu.h	r11
800106de:	ec cc ff 7c 	sub	r12,r6,-132
800106e2:	fe b0 d4 e3 	rcall	8000b0a8 <MostSetTimer>
800106e6:	30 67       	mov	r7,6
800106e8:	cc eb       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
            break;
        }

        case VMSV_PLT_LEAD_OUT:
        {
            TAKE_VMSV();
800106ea:	31 1c       	mov	r12,17
800106ec:	fe b0 b9 e5 	rcall	80007ab6 <mns_take>
            dev_mode = vmsv.plt.saved_dev_mode;
            GIVE_VMSV();
800106f0:	31 1c       	mov	r12,17
        }

        case VMSV_PLT_LEAD_OUT:
        {
            TAKE_VMSV();
            dev_mode = vmsv.plt.saved_dev_mode;
800106f2:	ed 34 00 80 	ld.ub	r4,r6[128]
            GIVE_VMSV();
800106f6:	fe b0 b9 e1 	rcall	80007ab8 <mns_give>

            msg_ptr = MsgGetTxPtrExt(1);
800106fa:	30 1c       	mov	r12,1
        }

        case VMSV_PLT_LEAD_OUT:
        {
            TAKE_VMSV();
            dev_mode = vmsv.plt.saved_dev_mode;
800106fc:	4e c5       	lddpc	r5,800108ac <VmsvPhysicalLayerTestProcedure+0x258>
            GIVE_VMSV();

            msg_ptr = MsgGetTxPtrExt(1);
800106fe:	fe b0 c3 cf 	rcall	80008e9c <MsgGetTxPtrExt>
            if (msg_ptr)
80010702:	e0 80 00 c8 	breq	80010892 <VmsvPhysicalLayerTestProcedure+0x23e>
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                msg_ptr->FBlock_ID = FBLOCK_INIC;
80010706:	30 09       	mov	r9,0
            GIVE_VMSV();

            msg_ptr = MsgGetTxPtrExt(1);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80010708:	30 17       	mov	r7,1
                msg_ptr->FBlock_ID = FBLOCK_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = (word)1;
                msg_ptr->Data[0]   = dev_mode;
8001070a:	78 08       	ld.w	r8,r12[0x0]
            GIVE_VMSV();

            msg_ptr = MsgGetTxPtrExt(1);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
8001070c:	b8 37       	st.h	r12[0x6],r7
                msg_ptr->FBlock_ID = FBLOCK_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = (word)1;
8001070e:	b8 27       	st.h	r12[0x4],r7
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                msg_ptr->FBlock_ID = FBLOCK_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                msg_ptr->Operation = OP_SET;
80010710:	f9 69 00 0c 	st.b	r12[12],r9

            msg_ptr = MsgGetTxPtrExt(1);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                msg_ptr->FBlock_ID = FBLOCK_INIC;
80010714:	f9 69 00 0a 	st.b	r12[10],r9
                msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
80010718:	e0 69 05 02 	mov	r9,1282
8001071c:	b8 49       	st.h	r12[0x8],r9
                msg_ptr->Operation = OP_SET;
                msg_ptr->Length    = (word)1;
                msg_ptr->Data[0]   = dev_mode;
8001071e:	b0 84       	st.b	r8[0x0],r4
                MsgSend3(msg_ptr);
80010720:	fe b0 c7 02 	rcall	80009524 <MsgSend3>

                /* finish state machine */
                TAKE_VMSV();
80010724:	31 1c       	mov	r12,17
80010726:	fe b0 b9 c8 	rcall	80007ab6 <mns_take>
                vmsv.plt.test_done = MNS_TRUE;
                GIVE_VMSV();
8001072a:	31 1c       	mov	r12,17
                msg_ptr->Data[0]   = dev_mode;
                MsgSend3(msg_ptr);

                /* finish state machine */
                TAKE_VMSV();
                vmsv.plt.test_done = MNS_TRUE;
8001072c:	eb 67 00 74 	st.b	r5[116],r7
                GIVE_VMSV();
80010730:	fe b0 b9 c4 	rcall	80007ab8 <mns_give>

                ET_PhysicalLayerTest_Finished();
80010734:	30 07       	mov	r7,0
80010736:	e0 a0 20 8b 	rcall	8001484c <ET_PhysicalLayerTest_Finished>
8001073a:	ca 5b       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
    GIVE_VMSV();

    switch (test_state)
    {
        case VMSV_PLT_OFF:
            FAILED_ASSERT();
8001073c:	e0 68 0d 6c 	mov	r8,3436
80010740:	c9 bb       	rjmp	80010676 <VmsvPhysicalLayerTestProcedure+0x22>
            break;

        case VMSV_PLT_WAIT_TX:
            FAILED_ASSERT();
80010742:	e0 68 0d 70 	mov	r8,3440
80010746:	c9 8b       	rjmp	80010676 <VmsvPhysicalLayerTestProcedure+0x22>
            break;

        case VMSV_PLT_START:
        {

            TAKE_VMSV();
80010748:	31 1c       	mov	r12,17
8001074a:	fe b0 b9 b6 	rcall	80007ab6 <mns_take>
            vmsv.plt.saved_dev_mode = vmsv.shadow.devmode;  /* save current devmode */
8001074e:	ed 38 00 2c 	ld.ub	r8,r6[44]
80010752:	ed 68 00 80 	st.b	r6[128],r8
80010756:	10 9a       	mov	r10,r8
            type = vmsv.plt.type;

            switch (type)
80010758:	30 19       	mov	r9,1
8001075a:	ed 38 00 75 	ld.ub	r8,r6[117]
8001075e:	f2 08 18 00 	cp.b	r8,r9
80010762:	e0 80 00 96 	breq	8001088e <VmsvPhysicalLayerTestProcedure+0x23a>
80010766:	c7 b2       	brcc	8001085c <VmsvPhysicalLayerTestProcedure+0x208>
            {
                case VMSV_PLT_TYPE_AUTO:
                    if (MNS_MASTER == vmsv.shadow.devmode)
80010768:	f2 0a 18 00 	cp.b	r10,r9
8001076c:	e0 80 00 91 	breq	8001088e <VmsvPhysicalLayerTestProcedure+0x23a>
80010770:	30 45       	mov	r5,4
                default:
                    dev_mode   = INIC_SHADOW_INVALID_BYTE;    /* avoid lint warning */
                    test_state = VMSV_PLT_OFF;
                    break;
            }
            GIVE_VMSV();
80010772:	31 1c       	mov	r12,17
80010774:	fe b0 b9 a2 	rcall	80007ab8 <mns_give>

            if (VMSV_PLT_OFF != test_state)
            {
                msg_ptr = MsgGetTxPtrExt(1);
80010778:	30 1c       	mov	r12,1
8001077a:	fe b0 c3 91 	rcall	80008e9c <MsgGetTxPtrExt>
                if (msg_ptr)
8001077e:	c7 c0       	breq	80010876 <VmsvPhysicalLayerTestProcedure+0x222>
                {
                    msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80010780:	30 19       	mov	r9,1
                    msg_ptr->FBlock_ID = FBLOCK_INIC;
                    msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                    msg_ptr->Operation = OP_SET;
                    msg_ptr->Length    = (word)1;
80010782:	b8 29       	st.h	r12[0x4],r9
            if (VMSV_PLT_OFF != test_state)
            {
                msg_ptr = MsgGetTxPtrExt(1);
                if (msg_ptr)
                {
                    msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80010784:	b8 39       	st.h	r12[0x6],r9
                    msg_ptr->FBlock_ID = FBLOCK_INIC;
80010786:	30 09       	mov	r9,0
                    msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                    msg_ptr->Operation = OP_SET;
                    msg_ptr->Length    = (word)1;
                    msg_ptr->Data[0]   = dev_mode;
80010788:	78 08       	ld.w	r8,r12[0x0]
                if (msg_ptr)
                {
                    msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                    msg_ptr->FBlock_ID = FBLOCK_INIC;
                    msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
                    msg_ptr->Operation = OP_SET;
8001078a:	f9 69 00 0c 	st.b	r12[12],r9
            {
                msg_ptr = MsgGetTxPtrExt(1);
                if (msg_ptr)
                {
                    msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                    msg_ptr->FBlock_ID = FBLOCK_INIC;
8001078e:	f9 69 00 0a 	st.b	r12[10],r9
                    msg_ptr->Func_ID   = FUNCID_INIC_DEVICEMODE;
80010792:	e0 69 05 02 	mov	r9,1282
80010796:	b8 49       	st.h	r12[0x8],r9
                    msg_ptr->Operation = OP_SET;
                    msg_ptr->Length    = (word)1;
                    msg_ptr->Data[0]   = dev_mode;
80010798:	b0 85       	st.b	r8[0x0],r5

                    MsgSend3(msg_ptr);
8001079a:	fe b0 c6 c5 	rcall	80009524 <MsgSend3>

                    /* start timer t_lead_in */
                    TAKE_VMSV();
8001079e:	31 1c       	mov	r12,17
800107a0:	fe b0 b9 8b 	rcall	80007ab6 <mns_take>
                    lead_in_time = vmsv.plt.lead_in;
                    GIVE_VMSV();
800107a4:	31 1c       	mov	r12,17

                    MsgSend3(msg_ptr);

                    /* start timer t_lead_in */
                    TAKE_VMSV();
                    lead_in_time = vmsv.plt.lead_in;
800107a6:	ed 07 00 76 	ld.sh	r7,r6[118]
                    GIVE_VMSV();
800107aa:	fe b0 b9 87 	rcall	80007ab8 <mns_give>

                    MostSetTimer(&vmsv.plt.state_timer, lead_in_time, MNS_FALSE);
800107ae:	0e 9b       	mov	r11,r7
800107b0:	30 0a       	mov	r10,0
800107b2:	5c 7b       	castu.h	r11
800107b4:	ec cc ff 7c 	sub	r12,r6,-132
800107b8:	fe b0 d4 78 	rcall	8000b0a8 <MostSetTimer>
800107bc:	30 37       	mov	r7,3
800107be:	c6 3b       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
            break;
        }

        case VMSV_PLT_LEAD_IN:
        {
            msg_ptr = MsgGetTxPtrExt(0);
800107c0:	30 0c       	mov	r12,0
800107c2:	fe b0 c3 6d 	rcall	80008e9c <MsgGetTxPtrExt>
            if (msg_ptr)
800107c6:	c5 80       	breq	80010876 <VmsvPhysicalLayerTestProcedure+0x222>
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800107c8:	30 19       	mov	r9,1
                msg_ptr->FBlock_ID = FBLOCK_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_NUMCODINGERRORS;
                msg_ptr->Operation = OP_GET;
800107ca:	f9 69 00 0c 	st.b	r12[12],r9
        case VMSV_PLT_LEAD_IN:
        {
            msg_ptr = MsgGetTxPtrExt(0);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
800107ce:	b8 39       	st.h	r12[0x6],r9
                msg_ptr->FBlock_ID = FBLOCK_INIC;
800107d0:	30 09       	mov	r9,0
800107d2:	f9 69 00 0a 	st.b	r12[10],r9
                msg_ptr->Func_ID   = FUNCID_INIC_NUMCODINGERRORS;
800107d6:	e0 69 05 0d 	mov	r9,1293
                msg_ptr->Operation = OP_GET;
                msg_ptr->Length    = (word)0;
800107da:	30 07       	mov	r7,0
            msg_ptr = MsgGetTxPtrExt(0);
            if (msg_ptr)
            {
                msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
                msg_ptr->FBlock_ID = FBLOCK_INIC;
                msg_ptr->Func_ID   = FUNCID_INIC_NUMCODINGERRORS;
800107dc:	b8 49       	st.h	r12[0x8],r9
                msg_ptr->Operation = OP_GET;
                msg_ptr->Length    = (word)0;
800107de:	b8 27       	st.h	r12[0x4],r7
                MsgSend3(msg_ptr);
800107e0:	fe b0 c6 a2 	rcall	80009524 <MsgSend3>

                TAKE_VMSV();
800107e4:	31 1c       	mov	r12,17
800107e6:	fe b0 b9 68 	rcall	80007ab6 <mns_take>
                vmsv.plr.lock_status = MNS_FALSE;           /* reset result variables */
                vmsv.plr.err_count   = (word)0;
                GIVE_VMSV();
800107ea:	31 1c       	mov	r12,17
                msg_ptr->Length    = (word)0;
                MsgSend3(msg_ptr);

                TAKE_VMSV();
                vmsv.plr.lock_status = MNS_FALSE;           /* reset result variables */
                vmsv.plr.err_count   = (word)0;
800107ec:	ed 57 00 9a 	st.h	r6[154],r7
                msg_ptr->Operation = OP_GET;
                msg_ptr->Length    = (word)0;
                MsgSend3(msg_ptr);

                TAKE_VMSV();
                vmsv.plr.lock_status = MNS_FALSE;           /* reset result variables */
800107f0:	ed 67 00 98 	st.b	r6[152],r7
                vmsv.plr.err_count   = (word)0;
                GIVE_VMSV();
800107f4:	fe b0 b9 62 	rcall	80007ab8 <mns_give>

                test_state = VMSV_PLT_TEST1;                     /* goto next state, start timers */
                VmsvSetPendingEvent(VMSV_P_PHYSICAL_LAYER_TEST);
800107f8:	e0 6c 10 00 	mov	r12,4096
800107fc:	fe b0 fb 20 	rcall	8000fe3c <VmsvSetPendingEvent>
80010800:	30 47       	mov	r7,4
80010802:	c4 1b       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
        }

        case VMSV_PLT_TEST1:
        {
            /* start timer t_duration */
            TAKE_VMSV();
80010804:	31 1c       	mov	r12,17
80010806:	fe b0 b9 58 	rcall	80007ab6 <mns_take>
            duration_time = vmsv.plt.duration;
            GIVE_VMSV();
8001080a:	31 1c       	mov	r12,17

        case VMSV_PLT_TEST1:
        {
            /* start timer t_duration */
            TAKE_VMSV();
            duration_time = vmsv.plt.duration;
8001080c:	6d f5       	ld.w	r5,r6[0x7c]
            GIVE_VMSV();
8001080e:	fe b0 b9 55 	rcall	80007ab8 <mns_give>

            if (duration_time > (dword)0xFFFF)
80010812:	e0 45 ff ff 	cp.w	r5,65535
80010816:	e0 88 00 19 	brls	80010848 <VmsvPhysicalLayerTestProcedure+0x1f4>
            {
                if (duration_time < (dword)0x1FFFF)     /* largest timer value is 0xFFFF*/
8001081a:	e0 55 ff fe 	cp.w	r5,131070
8001081e:	e0 8b 00 28 	brhi	8001086e <VmsvPhysicalLayerTestProcedure+0x21a>
                {
                    diff_time = (word)(duration_time/2);  /* avoid very small values at the end */
80010822:	e9 d5 c0 30 	bfextu	r4,r5,0x1,0x10
80010826:	08 93       	mov	r3,r4
                {
                    diff_time = (word)0xFFFF;
                }

                duration_time -= (dword)diff_time;
                TAKE_VMSV();
80010828:	31 1c       	mov	r12,17
8001082a:	fe b0 b9 46 	rcall	80007ab6 <mns_take>
                vmsv.plt.duration = duration_time;
8001082e:	08 15       	sub	r5,r4
                GIVE_VMSV();
80010830:	31 1c       	mov	r12,17
                    diff_time = (word)0xFFFF;
                }

                duration_time -= (dword)diff_time;
                TAKE_VMSV();
                vmsv.plt.duration = duration_time;
80010832:	ed 45 00 7c 	st.w	r6[124],r5
                GIVE_VMSV();
80010836:	fe b0 b9 41 	rcall	80007ab8 <mns_give>

                MostSetTimer(&vmsv.plt.state_timer, diff_time, MNS_FALSE);
8001083a:	06 9b       	mov	r11,r3
8001083c:	30 0a       	mov	r10,0
8001083e:	ec cc ff 7c 	sub	r12,r6,-132
80010842:	fe b0 d4 33 	rcall	8000b0a8 <MostSetTimer>
80010846:	c1 fb       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
                /*remain in this state until duration ends*/
            }
            else
            {
                MostSetTimer(&vmsv.plt.state_timer, (word)duration_time, MNS_FALSE);
80010848:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8001084c:	49 8c       	lddpc	r12,800108ac <VmsvPhysicalLayerTestProcedure+0x258>
8001084e:	30 0a       	mov	r10,0
80010850:	f8 cc ff 7c 	sub	r12,r12,-132
80010854:	fe b0 d4 2a 	rcall	8000b0a8 <MostSetTimer>
80010858:	30 57       	mov	r7,5
8001085a:	c1 5b       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>

            TAKE_VMSV();
            vmsv.plt.saved_dev_mode = vmsv.shadow.devmode;  /* save current devmode */
            type = vmsv.plt.type;

            switch (type)
8001085c:	30 29       	mov	r9,2
8001085e:	f2 08 18 00 	cp.b	r8,r9
80010862:	c8 70       	breq	80010770 <VmsvPhysicalLayerTestProcedure+0x11c>
                default:
                    dev_mode   = INIC_SHADOW_INVALID_BYTE;    /* avoid lint warning */
                    test_state = VMSV_PLT_OFF;
                    break;
            }
            GIVE_VMSV();
80010864:	31 1c       	mov	r12,17
80010866:	fe b0 b9 29 	rcall	80007ab8 <mns_give>
8001086a:	30 07       	mov	r7,0
8001086c:	c0 cb       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
            duration_time = vmsv.plt.duration;
            GIVE_VMSV();

            if (duration_time > (dword)0xFFFF)
            {
                if (duration_time < (dword)0x1FFFF)     /* largest timer value is 0xFFFF*/
8001086e:	e0 63 ff ff 	mov	r3,65535
80010872:	06 94       	mov	r4,r3
80010874:	cd ab       	rjmp	80010828 <VmsvPhysicalLayerTestProcedure+0x1d4>

                test_state = VMSV_PLT_LEAD_OUT;
            }
            else
            {
                SCHEDULE_RETRY(VMSV_RETRY_PLT);
80010876:	31 0c       	mov	r12,16
80010878:	fe b0 b9 1f 	rcall	80007ab6 <mns_take>
8001087c:	ed 08 00 64 	ld.sh	r8,r6[100]
80010880:	a9 a8       	sbr	r8,0x8
80010882:	31 0c       	mov	r12,16
80010884:	ed 58 00 64 	st.h	r6[100],r8
80010888:	fe b0 b9 18 	rcall	80007ab8 <mns_give>
8001088c:	cf ca       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
            type = vmsv.plt.type;

            switch (type)
            {
                case VMSV_PLT_TYPE_AUTO:
                    if (MNS_MASTER == vmsv.shadow.devmode)
8001088e:	30 55       	mov	r5,5
80010890:	c7 1b       	rjmp	80010772 <VmsvPhysicalLayerTestProcedure+0x11e>
                ET_PhysicalLayerTest_Finished();
                test_state = VMSV_PLT_OFF;
            }
            else
            {
                SCHEDULE_RETRY(VMSV_RETRY_PLT);
80010892:	31 0c       	mov	r12,16
80010894:	fe b0 b9 11 	rcall	80007ab6 <mns_take>
80010898:	eb 08 00 64 	ld.sh	r8,r5[100]
8001089c:	a9 a8       	sbr	r8,0x8
8001089e:	31 0c       	mov	r12,16
800108a0:	eb 58 00 64 	st.h	r5[100],r8
800108a4:	fe b0 b9 0a 	rcall	80007ab8 <mns_give>
800108a8:	ce ea       	rjmp	80010684 <VmsvPhysicalLayerTestProcedure+0x30>
800108aa:	d7 03       	nop
800108ac:	00 00       	add	r0,r0
800108ae:	39 9c       	mov	r12,-103
800108b0:	80 06       	ld.sh	r6,r0[0x0]
800108b2:	ff 10 eb cd 	ld.uh	r0,pc[-5171]

800108b4 <VmsvService>:
800108b4:	eb cd 40 fc 	pushm	r2-r7,lr
800108b8:	20 1d       	sub	sp,4
800108ba:	fe f7 09 6e 	ld.w	r7,pc[2414]
800108be:	e0 68 40 00 	mov	r8,16384
800108c2:	30 19       	mov	r9,1
800108c4:	ee ca ff fe 	sub	r10,r7,-2
800108c8:	0e 9b       	mov	r11,r7
800108ca:	31 0c       	mov	r12,16
800108cc:	fe b0 d4 b8 	rcall	8000b23c <MnsGetNextEventFlagToCall>
800108d0:	34 08       	mov	r8,64
800108d2:	5c 8c       	casts.h	r12
    event_to_handle = VmsvGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
800108d4:	f0 0c 19 00 	cp.h	r12,r8
800108d8:	e0 80 01 b6 	breq	80010c44 <VmsvService+0x390>
800108dc:	e0 88 00 2d 	brls	80010936 <VmsvService+0x82>
800108e0:	e0 68 04 00 	mov	r8,1024
800108e4:	f0 0c 19 00 	cp.h	r12,r8
800108e8:	e0 80 01 4b 	breq	80010b7e <VmsvService+0x2ca>
800108ec:	e0 8b 00 77 	brhi	800109da <VmsvService+0x126>
800108f0:	e0 68 00 80 	mov	r8,128
800108f4:	f0 0c 19 00 	cp.h	r12,r8
800108f8:	c1 00       	breq	80010918 <VmsvService+0x64>
800108fa:	e0 68 02 00 	mov	r8,512
800108fe:	f0 0c 19 00 	cp.h	r12,r8
80010902:	e0 80 01 01 	breq	80010b04 <VmsvService+0x250>
        }
        #endif

        default:
            event_to_handle = VMSV_P_NONE;
            FAILED_ASSERT();
80010906:	e0 68 01 34 	mov	r8,308
8001090a:	1a d8       	st.w	--sp,r8
8001090c:	30 1a       	mov	r10,1
8001090e:	31 0b       	mov	r11,16
80010910:	34 0c       	mov	r12,64
80010912:	fe b0 b8 ed 	rcall	80007aec <mns_trace>
80010916:	2f fd       	sub	sp,-4
            break;
    }

    TAKE_EVENTS();
80010918:	31 0c       	mov	r12,16
8001091a:	fe b0 b8 ce 	rcall	80007ab6 <mns_take>
    request_flag = (VMSV_P_NONE != vmsv.events.pending) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
8001091e:	31 0c       	mov	r12,16
            FAILED_ASSERT();
            break;
    }

    TAKE_EVENTS();
    request_flag = (VMSV_P_NONE != vmsv.events.pending) ? MNS_TRUE : MNS_FALSE;
80010920:	8e 07       	ld.sh	r7,r7[0x0]
    GIVE_EVENTS();
80010922:	fe b0 b8 cb 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != request_flag)
80010926:	58 07       	cp.w	r7,0
80010928:	c0 40       	breq	80010930 <VmsvService+0x7c>
    {
        MnsSetPendingService(MNS_P_SRV_VMSV);
8001092a:	34 0c       	mov	r12,64
8001092c:	fe b0 d4 ee 	rcall	8000b308 <MnsSetPendingService>
    }

    T_LIB_EXIT(VMSV_1);
}
80010930:	2f fd       	sub	sp,-4
80010932:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    event_to_handle = VmsvGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80010936:	30 48       	mov	r8,4
80010938:	f0 0c 19 00 	cp.h	r12,r8
8001093c:	e0 80 01 2b 	breq	80010b92 <VmsvService+0x2de>
80010940:	e0 88 00 5e 	brls	800109fc <VmsvService+0x148>
80010944:	31 08       	mov	r8,16
80010946:	f0 0c 19 00 	cp.h	r12,r8
8001094a:	e0 80 00 99 	breq	80010a7c <VmsvService+0x1c8>
8001094e:	32 08       	mov	r8,32
80010950:	f0 0c 19 00 	cp.h	r12,r8
80010954:	e0 80 00 8f 	breq	80010a72 <VmsvService+0x1be>
80010958:	30 88       	mov	r8,8
8001095a:	f0 0c 19 00 	cp.h	r12,r8
8001095e:	cd 41       	brne	80010906 <VmsvService+0x52>
#ifdef VMSV_12
static void VmsvEHCIGoAttached(void)
{
    T_LIB_ENTRY(VMSV_12);

    VmsvCheckForNpr(MNS_TRUE);
80010960:	30 1c       	mov	r12,1
80010962:	fe b0 f9 d9 	rcall	8000fd14 <VmsvCheckForNpr>
    VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
80010966:	31 0c       	mov	r12,16
80010968:	fe b0 fa 6a 	rcall	8000fe3c <VmsvSetPendingEvent>
    MostSetTimer(&(vmsv.check_phase.timer), VMSV_CHECK_PHASE_TIMER, MNS_FALSE);
8001096c:	30 0a       	mov	r10,0
8001096e:	e0 6b 01 00 	mov	r11,256
80010972:	ee cc ff b8 	sub	r12,r7,-72
80010976:	fe b0 d3 99 	rcall	8000b0a8 <MostSetTimer>

    TAKE_VMSV();
8001097a:	31 1c       	mov	r12,17
8001097c:	fe b0 b8 9d 	rcall	80007ab6 <mns_take>
    if ((NCS_INVALID_NWM != vmsv.shadow.nwm_addr) &&
80010980:	ef 09 00 30 	ld.sh	r9,r7[48]
80010984:	3f f8       	mov	r8,-1
80010986:	f0 09 19 00 	cp.h	r9,r8
8001098a:	c1 80       	breq	800109ba <VmsvService+0x106>
8001098c:	ef 39 00 61 	ld.ub	r9,r7[97]
80010990:	30 08       	mov	r8,0
80010992:	f0 09 18 00 	cp.b	r9,r8
80010996:	c1 21       	brne	800109ba <VmsvService+0x106>
80010998:	ef 39 00 21 	ld.ub	r9,r7[33]
8001099c:	30 38       	mov	r8,3
8001099e:	f0 09 18 00 	cp.b	r9,r8
800109a2:	c0 c1       	brne	800109ba <VmsvService+0x106>
        (MNS_FALSE == vmsv.fblock_ids_get_received) &&
        (MSVAL_S_ON == vmsv.shadow.nistate))
    {
        vmsv.check_phase.state = (NCS_OK == vmsv.shadow.ncstate) ?
800109a4:	ef 39 00 2d 	ld.ub	r9,r7[45]
800109a8:	30 18       	mov	r8,1
800109aa:	f0 09 18 00 	cp.b	r9,r8
800109ae:	f9 b8 00 01 	moveq	r8,1
800109b2:	f9 b8 01 02 	movne	r8,2
800109b6:	ef 68 00 5c 	st.b	r7[92],r8
                                 VMSV_CP_INJECTED : VMSV_CP_WAITING;
    }
    vmsv.attached = MNS_TRUE;
800109ba:	30 16       	mov	r6,1
    GIVE_VMSV();
800109bc:	31 1c       	mov	r12,17
        (MSVAL_S_ON == vmsv.shadow.nistate))
    {
        vmsv.check_phase.state = (NCS_OK == vmsv.shadow.ncstate) ?
                                 VMSV_CP_INJECTED : VMSV_CP_WAITING;
    }
    vmsv.attached = MNS_TRUE;
800109be:	ef 66 00 60 	st.b	r7[96],r6
    GIVE_VMSV();
800109c2:	fe b0 b8 7b 	rcall	80007ab8 <mns_give>

    if (VMSV_CP_INJECTED == vmsv.check_phase.state)
800109c6:	ef 38 00 5c 	ld.ub	r8,r7[92]
800109ca:	ec 08 18 00 	cp.b	r8,r6
800109ce:	ca 51       	brne	80010918 <VmsvService+0x64>
    {
        (void)VmsvInjectFBlockIDsGet();
800109d0:	fe b0 f8 90 	rcall	8000faf0 <VmsvInjectFBlockIDsGet>
        (void)VmsvInjectCfgState();
800109d4:	fe b0 f7 ce 	rcall	8000f970 <VmsvInjectCfgState>
800109d8:	ca 0b       	rjmp	80010918 <VmsvService+0x64>
    event_to_handle = VmsvGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
800109da:	e0 68 20 00 	mov	r8,8192
800109de:	f0 0c 19 00 	cp.h	r12,r8
800109e2:	c3 c0       	breq	80010a5a <VmsvService+0x1a6>
800109e4:	e0 68 40 00 	mov	r8,16384
800109e8:	f0 0c 19 00 	cp.h	r12,r8
800109ec:	c1 70       	breq	80010a1a <VmsvService+0x166>
800109ee:	e0 68 10 00 	mov	r8,4096
800109f2:	f0 0c 19 00 	cp.h	r12,r8
800109f6:	c8 81       	brne	80010906 <VmsvService+0x52>
            break;
        #endif

        #ifdef VMSV_95
        case VMSV_P_PHYSICAL_LAYER_TEST:
            (void)VmsvPhysicalLayerTestProcedure();
800109f8:	c2 ee       	rcall	80010654 <VmsvPhysicalLayerTestProcedure>
800109fa:	c8 fb       	rjmp	80010918 <VmsvService+0x64>
            break;
800109fc:	30 18       	mov	r8,1
    event_to_handle = VmsvGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
800109fe:	f0 0c 19 00 	cp.h	r12,r8
80010a02:	c0 90       	breq	80010a14 <VmsvService+0x160>
80010a04:	30 28       	mov	r8,2
80010a06:	f0 0c 19 00 	cp.h	r12,r8
80010a0a:	fe 91 ff 7e 	brne	80010906 <VmsvService+0x52>
80010a0e:	fe b0 fd 3b 	rcall	80010484 <MostShutDown>
        case VMSV_P_NWSTARTUP_RETRY:
            VmsvNWStartUpRetry();
            break;

        case VMSV_P_NWSHUTDOWN_RETRY:
            MostShutDown();
80010a12:	c8 3b       	rjmp	80010918 <VmsvService+0x64>
            break;
80010a14:	fe b0 fc 4c 	rcall	800102ac <VmsvNWStartUpRetry>
        case VMSV_P_GO_ATTACHED:
            VmsvEHCIGoAttached();
            break;

        case VMSV_P_NWSTARTUP_RETRY:
            VmsvNWStartUpRetry();
80010a18:	c8 0b       	rjmp	80010918 <VmsvService+0x64>
            break;
80010a1a:	31 1c       	mov	r12,17
        #ifdef MSV_DIAG_RESULT_MSG
        case VMSV_P_COMM_TIMER:
            {
                byte next_state = VMSV_COMM_OFF;

                TAKE_VMSV();
80010a1c:	fe b0 b8 4d 	rcall	80007ab6 <mns_take>
80010a20:	0f f8       	ld.ub	r8,r7[0x7]
                switch (vmsv.nwstartup.comm_state)
80010a22:	30 29       	mov	r9,2
80010a24:	f2 08 18 00 	cp.b	r8,r9
80010a28:	e0 80 01 9f 	breq	80010d66 <VmsvService+0x4b2>
80010a2c:	30 39       	mov	r9,3
80010a2e:	f2 08 18 00 	cp.b	r8,r9
80010a32:	e0 80 01 51 	breq	80010cd4 <VmsvService+0x420>
80010a36:	30 19       	mov	r9,1
80010a38:	f2 08 18 00 	cp.b	r8,r9
80010a3c:	e0 80 01 97 	breq	80010d6a <VmsvService+0x4b6>
80010a40:	e0 68 01 11 	mov	r8,273
                    case VMSV_COMM_BROADCAST:
                        next_state = VMSV_COMM_WAIT_AFTER_SEND;
                        break;

                    default:
                        FAILED_ASSERT();
80010a44:	30 1a       	mov	r10,1
80010a46:	1a d8       	st.w	--sp,r8
80010a48:	31 0b       	mov	r11,16
80010a4a:	34 0c       	mov	r12,64
80010a4c:	fe b0 b8 50 	rcall	80007aec <mns_trace>
80010a50:	31 1c       	mov	r12,17
                        break;
                }
                GIVE_VMSV();
80010a52:	fe b0 b8 33 	rcall	80007ab8 <mns_give>
80010a56:	2f fd       	sub	sp,-4
80010a58:	c6 0b       	rjmp	80010918 <VmsvService+0x64>
80010a5a:	31 1c       	mov	r12,17
        #ifdef VMSV_100
        case VMSV_P_EMERGENCYCONDITION_RETRY:
        {
            bool state;

            TAKE_VMSV();
80010a5c:	fe b0 b8 2d 	rcall	80007ab6 <mns_take>
80010a60:	31 1c       	mov	r12,17
            state = vmsv.emergency_state;
            GIVE_VMSV();
80010a62:	ef 36 00 9c 	ld.ub	r6,r7[156]
        case VMSV_P_EMERGENCYCONDITION_RETRY:
        {
            bool state;

            TAKE_VMSV();
            state = vmsv.emergency_state;
80010a66:	fe b0 b8 29 	rcall	80007ab8 <mns_give>
            GIVE_VMSV();
80010a6a:	0c 9c       	mov	r12,r6

            MostEmergencyCondition(state);
80010a6c:	fe b0 f9 f2 	rcall	8000fe50 <MostEmergencyCondition>
80010a70:	c5 4b       	rjmp	80010918 <VmsvService+0x64>
            break;
80010a72:	34 0b       	mov	r11,64
        case VMSV_P_SHADOW_CHANGE:
            VmsvFireCallbacks();
            break;

        case VMSV_P_NTF_COMPLETE:
            MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_VMSV);
80010a74:	30 2c       	mov	r12,2
80010a76:	fe b0 d7 23 	rcall	8000b8bc <MnsServiceInitComplete>
80010a7a:	c4 fb       	rjmp	80010918 <VmsvService+0x64>
            break;
80010a7c:	31 1c       	mov	r12,17

    change  = (byte)0;
    bit_pos = (byte)0;
    test    = (byte)0;

    TAKE_VMSV();
80010a7e:	fe b0 b8 1c 	rcall	80007ab6 <mns_take>
80010a82:	30 08       	mov	r8,0
80010a84:	ef 3a 00 20 	ld.ub	r10,r7[32]
80010a88:	30 14       	mov	r4,1
    while (((byte)0 == change) && (bit_pos < 8))
    {
        test = 1 << bit_pos;
80010a8a:	10 9c       	mov	r12,r8

        if (test & vmsv.shadow.changed)
80010a8c:	30 75       	mov	r5,7
    change  = (byte)0;
    bit_pos = (byte)0;
    test    = (byte)0;

    TAKE_VMSV();
    while (((byte)0 == change) && (bit_pos < 8))
80010a8e:	f0 c9 ff ff 	sub	r9,r8,-1
            vmsv.shadow.changed &= ~test;
            change = test;
        }
        else
        {
            bit_pos++;
80010a92:	e8 08 09 46 	lsl	r6,r4,r8
    test    = (byte)0;

    TAKE_VMSV();
    while (((byte)0 == change) && (bit_pos < 8))
    {
        test = 1 << bit_pos;
80010a96:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
            vmsv.shadow.changed &= ~test;
            change = test;
        }
        else
        {
            bit_pos++;
80010a9a:	5c 56       	castu.b	r6
    test    = (byte)0;

    TAKE_VMSV();
    while (((byte)0 == change) && (bit_pos < 8))
    {
        test = 1 << bit_pos;
80010a9c:	ed ea 00 09 	and	r9,r6,r10

        if (test & vmsv.shadow.changed)
80010aa0:	f0 05 18 00 	cp.b	r5,r8
    change  = (byte)0;
    bit_pos = (byte)0;
    test    = (byte)0;

    TAKE_VMSV();
    while (((byte)0 == change) && (bit_pos < 8))
80010aa4:	f9 bb 02 01 	movhs	r11,1
80010aa8:	f2 0b 17 30 	movlo	r11,r9
80010aac:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
80010ab0:	f8 09 18 00 	cp.b	r9,r12
    {
        test = 1 << bit_pos;

        if (test & vmsv.shadow.changed)
80010ab4:	c2 30       	breq	80010afa <VmsvService+0x246>
80010ab6:	0c 8a       	andn	r10,r6
        {
            vmsv.shadow.changed &= ~test;
80010ab8:	ef 6a 00 20 	st.b	r7[32],r10
    change  = (byte)0;
    bit_pos = (byte)0;
    test    = (byte)0;

    TAKE_VMSV();
    while (((byte)0 == change) && (bit_pos < 8))
80010abc:	58 0a       	cp.w	r10,0
        else
        {
            bit_pos++;
        }
    }
    if (vmsv.shadow.changed)
80010abe:	e0 81 01 45 	brne	80010d48 <VmsvService+0x494>
80010ac2:	31 1c       	mov	r12,17
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
    }
    GIVE_VMSV();
80010ac4:	fe b0 b7 fa 	rcall	80007ab8 <mns_give>
80010ac8:	30 48       	mov	r8,4

    switch (change)
80010aca:	f0 06 18 00 	cp.b	r6,r8
80010ace:	e0 80 02 5d 	breq	80010f88 <VmsvService+0x6d4>
80010ad2:	e0 88 00 f3 	brls	80010cb8 <VmsvService+0x404>
80010ad6:	31 08       	mov	r8,16
80010ad8:	f0 06 18 00 	cp.b	r6,r8
80010adc:	e0 80 02 92 	breq	80011000 <VmsvService+0x74c>
80010ae0:	32 08       	mov	r8,32
80010ae2:	f0 06 18 00 	cp.b	r6,r8
80010ae6:	e0 80 02 75 	breq	80010fd0 <VmsvService+0x71c>
80010aea:	30 88       	mov	r8,8
80010aec:	f0 06 18 00 	cp.b	r6,r8
80010af0:	e0 81 00 ee 	brne	80010ccc <VmsvService+0x418>
80010af4:	fe b0 f5 7a 	rcall	8000f5e8 <VmsvHandleNCEDelayedChange>
        case VMSV_SHADOW_NIEVENT_CHANGED:
            VmsvHandleNIEventChange();
            break;

        case VMSV_SHADOW_NCEDELAYED_CHANGED:
            VmsvHandleNCEDelayedChange();
80010af8:	c1 0b       	rjmp	80010918 <VmsvService+0x64>
80010afa:	f8 0b 18 00 	cp.b	r11,r12
    change  = (byte)0;
    bit_pos = (byte)0;
    test    = (byte)0;

    TAKE_VMSV();
    while (((byte)0 == change) && (bit_pos < 8))
80010afe:	cc 81       	brne	80010a8e <VmsvService+0x1da>
80010b00:	30 06       	mov	r6,0
80010b02:	cd bb       	rjmp	80010ab8 <VmsvService+0x204>
80010b04:	31 1c       	mov	r12,17
    byte        bit_mask;
    TMnsStdCB  *cb_ptr;

    T_MOD_ENTRY(VMSV_57);

    TAKE_VMSV();
80010b06:	fe b0 b7 d8 	rcall	80007ab6 <mns_take>
80010b0a:	31 1c       	mov	r12,17
    bit_mask = vmsv.sys_err_monitor.bit_mask;
    cb_ptr   = vmsv.sys_err_monitor.cb_ptr;
    GIVE_VMSV();
80010b0c:	ef 36 00 6c 	ld.ub	r6,r7[108]
    TMnsStdCB  *cb_ptr;

    T_MOD_ENTRY(VMSV_57);

    TAKE_VMSV();
    bit_mask = vmsv.sys_err_monitor.bit_mask;
80010b10:	6f a5       	ld.w	r5,r7[0x68]
    cb_ptr   = vmsv.sys_err_monitor.cb_ptr;
80010b12:	fe b0 b7 d3 	rcall	80007ab8 <mns_give>
    GIVE_VMSV();
80010b16:	58 05       	cp.w	r5,0

    if (bit_mask && cb_ptr)
80010b18:	5f 1a       	srne	r10
80010b1a:	30 08       	mov	r8,0
80010b1c:	f0 06 18 00 	cp.b	r6,r8
80010b20:	5f 19       	srne	r9
80010b22:	f5 e9 00 09 	and	r9,r10,r9
80010b26:	f0 09 18 00 	cp.b	r9,r8
80010b2a:	e0 80 01 13 	breq	80010d50 <VmsvService+0x49c>
80010b2e:	0c 99       	mov	r9,r6
    {
        byte pos = (byte)0;

        while (!(bit_mask & (1 << pos)) && pos < (byte)8)
80010b30:	ec 19 00 01 	eorl	r9,0x1
80010b34:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80010b38:	f0 09 18 00 	cp.b	r9,r8
80010b3c:	e0 80 00 e5 	breq	80010d06 <VmsvService+0x452>
80010b40:	30 08       	mov	r8,0
80010b42:	30 7c       	mov	r12,7
80010b44:	10 9b       	mov	r11,r8
80010b46:	2f f8       	sub	r8,-1
        {
            pos++;
80010b48:	5c 58       	castu.b	r8
80010b4a:	ec 08 08 49 	asr	r9,r6,r8

    if (bit_mask && cb_ptr)
    {
        byte pos = (byte)0;

        while (!(bit_mask & (1 << pos)) && pos < (byte)8)
80010b4e:	f0 0c 18 00 	cp.b	r12,r8
80010b52:	f9 ba 02 01 	movhs	r10,1
80010b56:	f9 ba 03 00 	movlo	r10,0
80010b5a:	ec 19 00 01 	eorl	r9,0x1
80010b5e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80010b62:	14 69       	and	r9,r10
80010b64:	f6 09 18 00 	cp.b	r9,r11
80010b68:	ce f1       	brne	80010b46 <VmsvService+0x292>
80010b6a:	30 79       	mov	r9,7
        {
            pos++;
        }

        if (pos < 8)
80010b6c:	f2 08 18 00 	cp.b	r8,r9
80010b70:	e0 88 00 ff 	brls	80010d6e <VmsvService+0x4ba>
80010b74:	e0 6c 02 00 	mov	r12,512
            TAKE_VMSV();
            vmsv.sys_err_monitor.bit_mask &= ~event;
            GIVE_VMSV();
        }

        VmsvSetPendingEvent(VMSV_P_REPORT_EM);
80010b78:	fe b0 f9 62 	rcall	8000fe3c <VmsvSetPendingEvent>
80010b7c:	cc ea       	rjmp	80010918 <VmsvService+0x64>
80010b7e:	ef 39 00 2c 	ld.ub	r9,r7[44]
static void VmsvEHCIGoSemiProtected(void)
{
    T_MOD_ENTRY(VMSV_60);

    #ifdef MSV_DIAG_RESULT_MSG
    if(MNS_MASTER == vmsv.shadow.devmode)
80010b82:	30 18       	mov	r8,1
80010b84:	f0 09 18 00 	cp.b	r9,r8
80010b88:	fe 91 fe c8 	brne	80010918 <VmsvService+0x64>
80010b8c:	fe b0 f2 70 	rcall	8000f06c <VmsvRequestNIWakeUpMode>
    {
        (void)VmsvRequestNIWakeUpMode();
80010b90:	cc 4a       	rjmp	80010918 <VmsvService+0x64>
80010b92:	31 1c       	mov	r12,17
#ifdef VMSV_11
static void VmsvEHCIGoProtected(void)
{
    T_MOD_ENTRY(VMSV_11);

    TAKE_VMSV();
80010b94:	fe b0 b7 91 	rcall	80007ab6 <mns_take>
80010b98:	3e e6       	mov	r6,-18
    vmsv.nwstartup.state          = VMSV_NWSTARTUP_COMPLETE;
    vmsv.nwstartup.dev_mode       = INIC_SHADOW_INVALID_BYTE;
80010b9a:	30 05       	mov	r5,0
static void VmsvEHCIGoProtected(void)
{
    T_MOD_ENTRY(VMSV_11);

    TAKE_VMSV();
    vmsv.nwstartup.state          = VMSV_NWSTARTUP_COMPLETE;
80010b9c:	ae d6       	st.b	r7[0x5],r6
    vmsv.nwstartup.dev_mode       = INIC_SHADOW_INVALID_BYTE;
80010b9e:	ae c5       	st.b	r7[0x4],r5
static void VmsvEHCIGoProtected(void)
{
    T_MOD_ENTRY(VMSV_11);

    TAKE_VMSV();
    vmsv.nwstartup.state          = VMSV_NWSTARTUP_COMPLETE;
80010ba0:	ae e5       	st.b	r7[0x6],r5
    vmsv.nwstartup.dev_mode       = INIC_SHADOW_INVALID_BYTE;
    vmsv.nwstartup.diagnosis      = MNS_FALSE;
80010ba2:	ae f5       	st.b	r7[0x7],r5

    #ifdef MSV_DIAG_RESULT_MSG
    vmsv.nwstartup.comm_state     = VMSV_COMM_OFF;
80010ba4:	30 88       	mov	r8,8
    T_COMM_CHANGE(VMSV_COMM_OFF);
80010ba6:	30 04       	mov	r4,0
80010ba8:	30 2a       	mov	r10,2
80010baa:	1a d4       	st.w	--sp,r4
80010bac:	30 fb       	mov	r11,15
80010bae:	1a d8       	st.w	--sp,r8
80010bb0:	34 0c       	mov	r12,64
80010bb2:	fe b0 b7 9d 	rcall	80007aec <mns_trace>
80010bb6:	3f f8       	mov	r8,-1
    vmsv.shadow.nistate            = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.late_nistate       = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.nievent            = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.devmode            = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.ncstate            = NCS_NOT_OK;
    vmsv.shadow.nwm_addr           = NCS_INVALID_NWM;
80010bb8:	ef 58 00 30 	st.h	r7[48],r8
80010bbc:	fe 78 ee ee 	mov	r8,-4370
    vmsv.shadow.ncedelayed[0]      = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.ncedelayed[1]      = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.rbdresult[0]       = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.rbdresult[1]       = INIC_SHADOW_INVALID_BYTE;
    vmsv.check_phase.state         = VMSV_CP_DO_NOTHING;
    vmsv.shadow.node_pos_check     = INIC_SHADOW_INVALID_WORD;
80010bc0:	31 1c       	mov	r12,17
    vmsv.sys_err_monitor.bit_mask = (byte)0;
    vmsv.net_on_cb_ptr            = NULL;
    vmsv.attached                 = MNS_FALSE;
    vmsv.fblock_ids_get_received  = MNS_FALSE;
    vmsv.fblock_ids_status_sent   = MNS_FALSE;
    GIVE_VMSV();
80010bc2:	ef 58 00 34 	st.h	r7[52],r8
    vmsv.shadow.ncedelayed[0]      = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.ncedelayed[1]      = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.rbdresult[0]       = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.rbdresult[1]       = INIC_SHADOW_INVALID_BYTE;
    vmsv.check_phase.state         = VMSV_CP_DO_NOTHING;
    vmsv.shadow.node_pos_check     = INIC_SHADOW_INVALID_WORD;
80010bc6:	ef 66 00 37 	st.b	r7[55],r6
    vmsv.shadow.neton_reported     = MNS_FALSE;
    vmsv.shadow.delayed_nce        = MNS_FALSE;
    vmsv.shadow.delayed_mpr        = MNS_FALSE;
    vmsv.shadow.pmi.state          = INIC_SHADOW_INVALID_BYTE;
    vmsv.shadow.pmi.events         = INIC_SHADOW_INVALID_BYTE;
80010bca:	ef 65 00 62 	st.b	r7[98],r5
    vmsv.sys_err_monitor.cb_ptr   = NULL;
    vmsv.sys_err_monitor.bit_mask = (byte)0;
    vmsv.net_on_cb_ptr            = NULL;
    vmsv.attached                 = MNS_FALSE;
    vmsv.fblock_ids_get_received  = MNS_FALSE;
    vmsv.fblock_ids_status_sent   = MNS_FALSE;
80010bce:	ef 66 00 21 	st.b	r7[33],r6
    #ifdef MSV_DIAG_RESULT_MSG
    vmsv.nwstartup.comm_state     = VMSV_COMM_OFF;
    T_COMM_CHANGE(VMSV_COMM_OFF);
    #endif

    vmsv.shadow.nistate            = INIC_SHADOW_INVALID_BYTE;
80010bd2:	ef 66 00 25 	st.b	r7[37],r6
    vmsv.shadow.late_nistate       = INIC_SHADOW_INVALID_BYTE;
80010bd6:	ef 66 00 26 	st.b	r7[38],r6
    vmsv.shadow.nievent            = INIC_SHADOW_INVALID_BYTE;
80010bda:	ef 66 00 2c 	st.b	r7[44],r6
    vmsv.shadow.devmode            = INIC_SHADOW_INVALID_BYTE;
80010bde:	ef 64 00 2d 	st.b	r7[45],r4
    vmsv.shadow.ncstate            = NCS_NOT_OK;
80010be2:	ef 66 00 2e 	st.b	r7[46],r6
    vmsv.shadow.nwm_addr           = NCS_INVALID_NWM;
    vmsv.shadow.ncstate_flags      = INIC_SHADOW_INVALID_BYTE;
80010be6:	ef 66 00 32 	st.b	r7[50],r6
    vmsv.shadow.lockstate          = INIC_SHADOW_INVALID_BYTE;
80010bea:	ef 66 00 27 	st.b	r7[39],r6
    vmsv.shadow.ncedelayed[0]      = INIC_SHADOW_INVALID_BYTE;
80010bee:	ef 66 00 28 	st.b	r7[40],r6
    vmsv.shadow.ncedelayed[1]      = INIC_SHADOW_INVALID_BYTE;
80010bf2:	ef 66 00 29 	st.b	r7[41],r6
    vmsv.shadow.rbdresult[0]       = INIC_SHADOW_INVALID_BYTE;
80010bf6:	ef 66 00 2a 	st.b	r7[42],r6
    vmsv.shadow.rbdresult[1]       = INIC_SHADOW_INVALID_BYTE;
80010bfa:	ef 65 00 5c 	st.b	r7[92],r5
    vmsv.check_phase.state         = VMSV_CP_DO_NOTHING;
80010bfe:	ef 65 00 22 	st.b	r7[34],r5
    vmsv.shadow.node_pos_check     = INIC_SHADOW_INVALID_WORD;
    vmsv.shadow.neton_reported     = MNS_FALSE;
80010c02:	ef 65 00 24 	st.b	r7[36],r5
    vmsv.shadow.delayed_nce        = MNS_FALSE;
80010c06:	ef 65 00 23 	st.b	r7[35],r5
    vmsv.shadow.delayed_mpr        = MNS_FALSE;
80010c0a:	ef 66 00 36 	st.b	r7[54],r6
    vmsv.shadow.pmi.state          = INIC_SHADOW_INVALID_BYTE;
80010c0e:	ef 44 00 68 	st.w	r7[104],r4
    vmsv.shadow.pmi.events         = INIC_SHADOW_INVALID_BYTE;
    vmsv.sys_err_monitor.cb_ptr   = NULL;
80010c12:	ef 65 00 6c 	st.b	r7[108],r5
    vmsv.sys_err_monitor.bit_mask = (byte)0;
80010c16:	ef 44 00 70 	st.w	r7[112],r4
    vmsv.net_on_cb_ptr            = NULL;
80010c1a:	ef 65 00 60 	st.b	r7[96],r5
    vmsv.attached                 = MNS_FALSE;
80010c1e:	ef 65 00 61 	st.b	r7[97],r5
    vmsv.fblock_ids_get_received  = MNS_FALSE;
80010c22:	fe b0 b7 4b 	rcall	80007ab8 <mns_give>
    vmsv.fblock_ids_status_sent   = MNS_FALSE;
    GIVE_VMSV();
80010c26:	31 0c       	mov	r12,16

    TAKE_EVENTS();
80010c28:	fe b0 b7 47 	rcall	80007ab6 <mns_take>
80010c2c:	31 0c       	mov	r12,16
    vmsv.retry = (word)0;
    GIVE_EVENTS();
80010c2e:	ef 54 00 64 	st.h	r7[100],r4
    vmsv.fblock_ids_get_received  = MNS_FALSE;
    vmsv.fblock_ids_status_sent   = MNS_FALSE;
    GIVE_VMSV();

    TAKE_EVENTS();
    vmsv.retry = (word)0;
80010c32:	fe b0 b7 43 	rcall	80007ab8 <mns_give>
    GIVE_EVENTS();
80010c36:	34 0b       	mov	r11,64

    MnsServiceInitComplete(MNS_PHASE_RESET, MNS_P_SRV_VMSV);
80010c38:	30 1c       	mov	r12,1
80010c3a:	fe b0 d6 41 	rcall	8000b8bc <MnsServiceInitComplete>
80010c3e:	2f ed       	sub	sp,-8

    switch (event_to_handle)
    {
        case VMSV_P_GO_PROTECTED:
            VmsvEHCIGoProtected();
            break;
80010c40:	fe 9f fe 6c 	bral	80010918 <VmsvService+0x64>
80010c44:	31 0c       	mov	r12,16
    T_MOD_ENTRY(VMSV_38);

    retry  = (word)0;
    result = ERR_NO;

    TAKE_EVENTS();
80010c46:	fe b0 b7 38 	rcall	80007ab6 <mns_take>
80010c4a:	31 0c       	mov	r12,16
    retry = vmsv.retry;
    GIVE_EVENTS();
80010c4c:	ef 06 00 64 	ld.sh	r6,r7[100]

    retry  = (word)0;
    result = ERR_NO;

    TAKE_EVENTS();
    retry = vmsv.retry;
80010c50:	fe b0 b7 34 	rcall	80007ab8 <mns_give>
    GIVE_EVENTS();
80010c54:	5c 76       	castu.h	r6

    PROCESS_RETRY    (VMSV_RETRY_FBLOCKIDS_GET,         VmsvInjectFBlockIDsGet        );
80010c56:	ed b6 00 00 	bld	r6,0x0
80010c5a:	c6 70       	breq	80010d28 <VmsvService+0x474>
80010c5c:	ed b6 00 03 	bld	r6,0x3
    PROCESS_RETRY    (VMSV_RETRY_CFG_STATE,             VmsvInjectCfgState            );
80010c60:	c4 30       	breq	80010ce6 <VmsvService+0x432>
80010c62:	ed b6 00 02 	bld	r6,0x2
    PROCESS_RETRY    (VMSV_RETRY_SYSERRMONITOR,         VmsvRequestSysErrMonitor      );
80010c66:	e0 80 00 c2 	breq	80010dea <VmsvService+0x536>
80010c6a:	ed b6 00 04 	bld	r6,0x4
#ifdef VMSV_69
    PROCESS_RETRY    (VMSV_RETRY_RBDRESULT,             VmsvBroadcastRBDResult        );
80010c6e:	e0 80 00 ad 	breq	80010dc8 <VmsvService+0x514>
80010c72:	ed b6 00 05 	bld	r6,0x5
#endif

    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NETONTIMER,    VmsvRequestNetOnTime          );
80010c76:	e0 80 00 98 	breq	80010da6 <VmsvService+0x4f2>
80010c7a:	ed b6 00 06 	bld	r6,0x6
#ifdef MSV_DIAG_RESULT_MSG
    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NIWAKEUPMODE,  VmsvRequestNIWakeUpMode       );
80010c7e:	e0 80 00 83 	breq	80010d84 <VmsvService+0x4d0>
80010c82:	ed b6 00 07 	bld	r6,0x7
    PROCESS_RETRY    (VMSV_RETRY_SET_NIWAKEUPMODE,      VmsvSetNIWakeUpMode           );
80010c86:	e0 80 00 d4 	breq	80010e2e <VmsvService+0x57a>
80010c8a:	ed b6 00 08 	bld	r6,0x8
#endif

#ifdef VMSV_95
    PROCESS_RETRY    (VMSV_RETRY_PLT,                   VmsvPhysicalLayerTestProcedure);
80010c8e:	e0 80 00 bf 	breq	80010e0c <VmsvService+0x558>
80010c92:	e2 16 02 00 	andl	r6,0x200,COH
#endif
#ifdef VMSV_99
    PROCESS_RETRY    (VMSV_RETRY_SSORESULT,             VmsvResetINICSSOResult        );
80010c96:	fe 90 fe 41 	breq	80010918 <VmsvService+0x64>
80010c9a:	31 0c       	mov	r12,16
80010c9c:	fe b0 b7 0d 	rcall	80007ab6 <mns_take>
80010ca0:	ef 08 00 64 	ld.sh	r8,r7[100]
80010ca4:	a9 d8       	cbr	r8,0x9
80010ca6:	31 0c       	mov	r12,16
80010ca8:	ef 58 00 64 	st.h	r7[100],r8
80010cac:	fe b0 b7 06 	rcall	80007ab8 <mns_give>
80010cb0:	fe b0 f2 00 	rcall	8000f0b0 <VmsvResetINICSSOResult>
80010cb4:	fe 9f fe 32 	bral	80010918 <VmsvService+0x64>
80010cb8:	30 18       	mov	r8,1
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
    }
    GIVE_VMSV();

    switch (change)
80010cba:	f0 06 18 00 	cp.b	r6,r8
80010cbe:	e0 80 01 0f 	breq	80010edc <VmsvService+0x628>
80010cc2:	30 28       	mov	r8,2
80010cc4:	f0 06 18 00 	cp.b	r6,r8
80010cc8:	e0 80 00 c4 	breq	80010e50 <VmsvService+0x59c>
80010ccc:	e0 68 04 6e 	mov	r8,1134
        case VMSV_SHADOW_PMISTATE_CHANGED:
            VmsvHandlePMIStateChange();
            break;

        default:
            FAILED_ASSERT();
80010cd0:	fe 9f fe 1d 	bral	8001090a <VmsvService+0x56>
80010cd4:	30 66       	mov	r6,6
        case VMSV_P_COMM_TIMER:
            {
                byte next_state = VMSV_COMM_OFF;

                TAKE_VMSV();
                switch (vmsv.nwstartup.comm_state)
80010cd6:	31 1c       	mov	r12,17

                    default:
                        FAILED_ASSERT();
                        break;
                }
                GIVE_VMSV();
80010cd8:	fe b0 b6 f0 	rcall	80007ab8 <mns_give>
80010cdc:	0c 9c       	mov	r12,r6

                if (VMSV_COMM_OFF != next_state)
                {
                    VmsvCommRBDResultPos0(next_state);
80010cde:	fe b0 fb ed 	rcall	800104b8 <VmsvCommRBDResultPos0>
80010ce2:	fe 9f fe 1b 	bral	80010918 <VmsvService+0x64>
80010ce6:	31 0c       	mov	r12,16
    TAKE_EVENTS();
    retry = vmsv.retry;
    GIVE_EVENTS();

    PROCESS_RETRY    (VMSV_RETRY_FBLOCKIDS_GET,         VmsvInjectFBlockIDsGet        );
    PROCESS_RETRY    (VMSV_RETRY_CFG_STATE,             VmsvInjectCfgState            );
80010ce8:	fe b0 b6 e7 	rcall	80007ab6 <mns_take>
80010cec:	ef 08 00 64 	ld.sh	r8,r7[100]
80010cf0:	a3 d8       	cbr	r8,0x3
80010cf2:	31 0c       	mov	r12,16
80010cf4:	ef 58 00 64 	st.h	r7[100],r8
80010cf8:	fe b0 b6 e0 	rcall	80007ab8 <mns_give>
80010cfc:	fe b0 f6 3a 	rcall	8000f970 <VmsvInjectCfgState>
80010d00:	cb 10       	breq	80010c62 <VmsvService+0x3ae>
    PROCESS_RETRY    (VMSV_RETRY_SYSERRMONITOR,         VmsvRequestSysErrMonitor      );
80010d02:	fe 9f fe 0b 	bral	80010918 <VmsvService+0x64>
80010d06:	e0 66 00 fe 	mov	r6,254

    if (bit_mask && cb_ptr)
    {
        byte pos = (byte)0;

        while (!(bit_mask & (1 << pos)) && pos < (byte)8)
80010d0a:	e0 6c c5 01 	mov	r12,50433
80010d0e:	5d 15       	icall	r5

        if (pos < 8)
        {
            byte event = (byte)(1 << pos);

            cb_ptr(NSR_BUILD(MNS_FALSE, NSR_CODE_SYS_ERR_MONITOR, event));
80010d10:	31 1c       	mov	r12,17

            TAKE_VMSV();
80010d12:	fe b0 b6 d2 	rcall	80007ab6 <mns_take>
80010d16:	ef 38 00 6c 	ld.ub	r8,r7[108]
            vmsv.sys_err_monitor.bit_mask &= ~event;
80010d1a:	31 1c       	mov	r12,17
            GIVE_VMSV();
80010d1c:	10 66       	and	r6,r8
            byte event = (byte)(1 << pos);

            cb_ptr(NSR_BUILD(MNS_FALSE, NSR_CODE_SYS_ERR_MONITOR, event));

            TAKE_VMSV();
            vmsv.sys_err_monitor.bit_mask &= ~event;
80010d1e:	ef 66 00 6c 	st.b	r7[108],r6
80010d22:	fe b0 b6 cb 	rcall	80007ab8 <mns_give>
            GIVE_VMSV();
80010d26:	c2 7b       	rjmp	80010b74 <VmsvService+0x2c0>
80010d28:	31 0c       	mov	r12,16

    TAKE_EVENTS();
    retry = vmsv.retry;
    GIVE_EVENTS();

    PROCESS_RETRY    (VMSV_RETRY_FBLOCKIDS_GET,         VmsvInjectFBlockIDsGet        );
80010d2a:	fe b0 b6 c6 	rcall	80007ab6 <mns_take>
80010d2e:	ef 08 00 64 	ld.sh	r8,r7[100]
80010d32:	a1 c8       	cbr	r8,0x0
80010d34:	31 0c       	mov	r12,16
80010d36:	ef 58 00 64 	st.h	r7[100],r8
80010d3a:	fe b0 b6 bf 	rcall	80007ab8 <mns_give>
80010d3e:	fe b0 f6 d9 	rcall	8000faf0 <VmsvInjectFBlockIDsGet>
80010d42:	fe 91 fd eb 	brne	80010918 <VmsvService+0x64>
    PROCESS_RETRY    (VMSV_RETRY_CFG_STATE,             VmsvInjectCfgState            );
80010d46:	c8 bb       	rjmp	80010c5c <VmsvService+0x3a8>
80010d48:	31 0c       	mov	r12,16
            bit_pos++;
        }
    }
    if (vmsv.shadow.changed)
    {
        VmsvSetPendingEvent(VMSV_P_SHADOW_CHANGE);
80010d4a:	fe b0 f8 79 	rcall	8000fe3c <VmsvSetPendingEvent>
80010d4e:	cb aa       	rjmp	80010ac2 <VmsvService+0x20e>
80010d50:	31 1c       	mov	r12,17

        VmsvSetPendingEvent(VMSV_P_REPORT_EM);
    }
    else
    {
        TAKE_VMSV();
80010d52:	fe b0 b6 b2 	rcall	80007ab6 <mns_take>
80010d56:	30 08       	mov	r8,0
        vmsv.sys_err_monitor.cb_ptr   = NULL;
80010d58:	31 1c       	mov	r12,17
        GIVE_VMSV();
80010d5a:	ef 48 00 68 	st.w	r7[104],r8
        VmsvSetPendingEvent(VMSV_P_REPORT_EM);
    }
    else
    {
        TAKE_VMSV();
        vmsv.sys_err_monitor.cb_ptr   = NULL;
80010d5e:	fe b0 b6 ad 	rcall	80007ab8 <mns_give>
        GIVE_VMSV();
80010d62:	fe 9f fd db 	bral	80010918 <VmsvService+0x64>
80010d66:	30 36       	mov	r6,3
        case VMSV_P_COMM_TIMER:
            {
                byte next_state = VMSV_COMM_OFF;

                TAKE_VMSV();
                switch (vmsv.nwstartup.comm_state)
80010d68:	cb 7b       	rjmp	80010cd6 <VmsvService+0x422>
80010d6a:	30 26       	mov	r6,2

                    default:
                        FAILED_ASSERT();
                        break;
                }
                GIVE_VMSV();
80010d6c:	cb 5b       	rjmp	80010cd6 <VmsvService+0x422>
80010d6e:	30 19       	mov	r9,1
        while (!(bit_mask & (1 << pos)) && pos < (byte)8)
        {
            pos++;
        }

        if (pos < 8)
80010d70:	f2 08 09 48 	lsl	r8,r9,r8
80010d74:	5c 58       	castu.b	r8
80010d76:	f0 06 11 ff 	rsub	r6,r8,-1
80010d7a:	10 9c       	mov	r12,r8
80010d7c:	5c 56       	castu.b	r6
80010d7e:	e8 1c c5 00 	orl	r12,0xc500
80010d82:	cc 6b       	rjmp	80010d0e <VmsvService+0x45a>
80010d84:	31 0c       	mov	r12,16
    PROCESS_RETRY    (VMSV_RETRY_RBDRESULT,             VmsvBroadcastRBDResult        );
#endif

    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NETONTIMER,    VmsvRequestNetOnTime          );
#ifdef MSV_DIAG_RESULT_MSG
    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NIWAKEUPMODE,  VmsvRequestNIWakeUpMode       );
80010d86:	fe b0 b6 98 	rcall	80007ab6 <mns_take>
80010d8a:	ef 08 00 64 	ld.sh	r8,r7[100]
80010d8e:	a7 c8       	cbr	r8,0x6
80010d90:	31 0c       	mov	r12,16
80010d92:	ef 58 00 64 	st.h	r7[100],r8
80010d96:	fe b0 b6 91 	rcall	80007ab8 <mns_give>
80010d9a:	fe b0 f1 69 	rcall	8000f06c <VmsvRequestNIWakeUpMode>
80010d9e:	fe 90 ff 72 	breq	80010c82 <VmsvService+0x3ce>
    PROCESS_RETRY    (VMSV_RETRY_SET_NIWAKEUPMODE,      VmsvSetNIWakeUpMode           );
80010da2:	fe 9f fd bb 	bral	80010918 <VmsvService+0x64>
80010da6:	31 0c       	mov	r12,16
    PROCESS_RETRY    (VMSV_RETRY_SYSERRMONITOR,         VmsvRequestSysErrMonitor      );
#ifdef VMSV_69
    PROCESS_RETRY    (VMSV_RETRY_RBDRESULT,             VmsvBroadcastRBDResult        );
#endif

    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NETONTIMER,    VmsvRequestNetOnTime          );
80010da8:	fe b0 b6 87 	rcall	80007ab6 <mns_take>
80010dac:	ef 08 00 64 	ld.sh	r8,r7[100]
80010db0:	a5 d8       	cbr	r8,0x5
80010db2:	31 0c       	mov	r12,16
80010db4:	ef 58 00 64 	st.h	r7[100],r8
80010db8:	fe b0 b6 80 	rcall	80007ab8 <mns_give>
80010dbc:	fe b0 f1 b6 	rcall	8000f128 <VmsvRequestNetOnTime>
80010dc0:	fe 90 ff 5d 	breq	80010c7a <VmsvService+0x3c6>
#ifdef MSV_DIAG_RESULT_MSG
    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NIWAKEUPMODE,  VmsvRequestNIWakeUpMode       );
80010dc4:	fe 9f fd aa 	bral	80010918 <VmsvService+0x64>
80010dc8:	31 0c       	mov	r12,16

    PROCESS_RETRY    (VMSV_RETRY_FBLOCKIDS_GET,         VmsvInjectFBlockIDsGet        );
    PROCESS_RETRY    (VMSV_RETRY_CFG_STATE,             VmsvInjectCfgState            );
    PROCESS_RETRY    (VMSV_RETRY_SYSERRMONITOR,         VmsvRequestSysErrMonitor      );
#ifdef VMSV_69
    PROCESS_RETRY    (VMSV_RETRY_RBDRESULT,             VmsvBroadcastRBDResult        );
80010dca:	fe b0 b6 76 	rcall	80007ab6 <mns_take>
80010dce:	ef 08 00 64 	ld.sh	r8,r7[100]
80010dd2:	a5 c8       	cbr	r8,0x4
80010dd4:	31 0c       	mov	r12,16
80010dd6:	ef 58 00 64 	st.h	r7[100],r8
80010dda:	fe b0 b6 6f 	rcall	80007ab8 <mns_give>
80010dde:	fe b0 f5 43 	rcall	8000f864 <VmsvBroadcastRBDResult>
80010de2:	fe 90 ff 48 	breq	80010c72 <VmsvService+0x3be>
#endif

    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NETONTIMER,    VmsvRequestNetOnTime          );
80010de6:	fe 9f fd 99 	bral	80010918 <VmsvService+0x64>
80010dea:	31 0c       	mov	r12,16
    retry = vmsv.retry;
    GIVE_EVENTS();

    PROCESS_RETRY    (VMSV_RETRY_FBLOCKIDS_GET,         VmsvInjectFBlockIDsGet        );
    PROCESS_RETRY    (VMSV_RETRY_CFG_STATE,             VmsvInjectCfgState            );
    PROCESS_RETRY    (VMSV_RETRY_SYSERRMONITOR,         VmsvRequestSysErrMonitor      );
80010dec:	fe b0 b6 65 	rcall	80007ab6 <mns_take>
80010df0:	ef 08 00 64 	ld.sh	r8,r7[100]
80010df4:	a3 c8       	cbr	r8,0x2
80010df6:	31 0c       	mov	r12,16
80010df8:	ef 58 00 64 	st.h	r7[100],r8
80010dfc:	fe b0 b6 5e 	rcall	80007ab8 <mns_give>
80010e00:	fe b0 f1 e8 	rcall	8000f1d0 <VmsvRequestSysErrMonitor>
80010e04:	fe 90 ff 33 	breq	80010c6a <VmsvService+0x3b6>
#ifdef VMSV_69
    PROCESS_RETRY    (VMSV_RETRY_RBDRESULT,             VmsvBroadcastRBDResult        );
80010e08:	fe 9f fd 88 	bral	80010918 <VmsvService+0x64>
80010e0c:	31 0c       	mov	r12,16
    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NIWAKEUPMODE,  VmsvRequestNIWakeUpMode       );
    PROCESS_RETRY    (VMSV_RETRY_SET_NIWAKEUPMODE,      VmsvSetNIWakeUpMode           );
#endif

#ifdef VMSV_95
    PROCESS_RETRY    (VMSV_RETRY_PLT,                   VmsvPhysicalLayerTestProcedure);
80010e0e:	fe b0 b6 54 	rcall	80007ab6 <mns_take>
80010e12:	ef 08 00 64 	ld.sh	r8,r7[100]
80010e16:	a9 c8       	cbr	r8,0x8
80010e18:	31 0c       	mov	r12,16
80010e1a:	ef 58 00 64 	st.h	r7[100],r8
80010e1e:	fe b0 b6 4d 	rcall	80007ab8 <mns_give>
80010e22:	fe b0 fc 19 	rcall	80010654 <VmsvPhysicalLayerTestProcedure>
80010e26:	fe 90 ff 36 	breq	80010c92 <VmsvService+0x3de>
#endif
#ifdef VMSV_99
    PROCESS_RETRY    (VMSV_RETRY_SSORESULT,             VmsvResetINICSSOResult        );
80010e2a:	fe 9f fd 77 	bral	80010918 <VmsvService+0x64>
80010e2e:	31 0c       	mov	r12,16
#endif

    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NETONTIMER,    VmsvRequestNetOnTime          );
#ifdef MSV_DIAG_RESULT_MSG
    PROCESS_RETRY    (VMSV_RETRY_REQUEST_NIWAKEUPMODE,  VmsvRequestNIWakeUpMode       );
    PROCESS_RETRY    (VMSV_RETRY_SET_NIWAKEUPMODE,      VmsvSetNIWakeUpMode           );
80010e30:	fe b0 b6 43 	rcall	80007ab6 <mns_take>
80010e34:	ef 08 00 64 	ld.sh	r8,r7[100]
80010e38:	a7 d8       	cbr	r8,0x7
80010e3a:	31 0c       	mov	r12,16
80010e3c:	ef 58 00 64 	st.h	r7[100],r8
80010e40:	fe b0 b6 3c 	rcall	80007ab8 <mns_give>
80010e44:	fe b0 f1 94 	rcall	8000f16c <VmsvSetNIWakeUpMode>
80010e48:	fe 90 ff 21 	breq	80010c8a <VmsvService+0x3d6>
#endif

#ifdef VMSV_95
    PROCESS_RETRY    (VMSV_RETRY_PLT,                   VmsvPhysicalLayerTestProcedure);
80010e4c:	fe 9f fd 66 	bral	80010918 <VmsvService+0x64>
80010e50:	31 1c       	mov	r12,17
    byte state;
    bool reported;

    T_LIB_ENTRY(VMSV_27);

    TAKE_VMSV();
80010e52:	fe b0 b6 32 	rcall	80007ab6 <mns_take>
80010e56:	31 1c       	mov	r12,17
    nievent = vmsv.shadow.nievent;
    state = vmsv.shadow.nistate;
    reported = vmsv.shadow.neton_reported;
    GIVE_VMSV();
80010e58:	ef 36 00 26 	ld.ub	r6,r7[38]
    bool reported;

    T_LIB_ENTRY(VMSV_27);

    TAKE_VMSV();
    nievent = vmsv.shadow.nievent;
80010e5c:	ef 34 00 21 	ld.ub	r4,r7[33]
    state = vmsv.shadow.nistate;
80010e60:	ef 33 00 22 	ld.ub	r3,r7[34]
    reported = vmsv.shadow.neton_reported;
80010e64:	fe b0 b6 2a 	rcall	80007ab8 <mns_give>
    GIVE_VMSV();
80010e68:	fe f5 03 c0 	ld.w	r5,pc[960]
    bool reported;

    T_LIB_ENTRY(VMSV_27);

    TAKE_VMSV();
    nievent = vmsv.shadow.nievent;
80010e6c:	3e e8       	mov	r8,-18
    state = vmsv.shadow.nistate;
    reported = vmsv.shadow.neton_reported;
    GIVE_VMSV();

    ASSERT(INIC_SHADOW_INVALID_BYTE != nievent);
80010e6e:	f0 06 18 00 	cp.b	r6,r8
80010e72:	e0 80 01 82 	breq	80011176 <VmsvService+0x8c2>
80010e76:	31 08       	mov	r8,16


    /* NIState needs to be "net on" and reported to be able to fire
     * MSVAL_E_MPR
     */
    if ((INIC_NIEVENT_MPR_CHANGED == nievent) &&
80010e78:	f0 06 18 00 	cp.b	r6,r8
80010e7c:	e0 80 01 48 	breq	8001110c <VmsvService+0x858>
80010e80:	3e 18       	mov	r8,-31
            TAKE_VMSV();
            vmsv.shadow.delayed_mpr = MNS_TRUE;
            GIVE_VMSV();
        }
    }
    else if ((INIC_NIEVENT_CRITICAL_UNLOCK == nievent) &&
80010e82:	f0 06 18 00 	cp.b	r6,r8
80010e86:	e0 80 01 59 	breq	80011138 <VmsvService+0x884>
80010e8a:	3e 08       	mov	r8,-32
             vmsv.cfg_ptr->msval_error_fptr)
    {
        vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_UNLOCK_CRITICAL, NULL);
    }
    else if ((INIC_NIEVENT_SHORT_UNLOCK == nievent) && vmsv.cfg_ptr->msval_error_fptr)
80010e8c:	f0 06 18 00 	cp.b	r6,r8
80010e90:	e0 80 01 5e 	breq	8001114c <VmsvService+0x898>
80010e94:	38 08       	mov	r8,-128
    {
        vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_UNLOCK_SHORT, NULL);
    }
    else if ((INIC_NIEVENT_NET_ACTIVITY == nievent) && vmsv.cfg_ptr->msval_event_fptr)
80010e96:	f0 06 18 00 	cp.b	r6,r8
80010e9a:	e0 80 01 63 	breq	80011160 <VmsvService+0x8ac>
80010e9e:	3f 18       	mov	r8,-15
    {
        vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NET_ACTIVITY, NULL);
    }
    else if (INIC_NIEVENT_TIMEOUT_CFG_STATUS == nievent)
80010ea0:	f0 06 18 00 	cp.b	r6,r8
80010ea4:	fe 91 fd 3a 	brne	80010918 <VmsvService+0x64>
80010ea8:	ef 0c 00 30 	ld.sh	r12,r7[48]
    {
        if ((NCS_INVALID_NWM != vmsv.shadow.nwm_addr) && vmsv.update_nwm_address_fptr)
80010eac:	3f f8       	mov	r8,-1
80010eae:	f0 0c 19 00 	cp.h	r12,r8
80010eb2:	c0 c0       	breq	80010eca <VmsvService+0x616>
80010eb4:	fe f8 03 74 	ld.w	r8,pc[884]
80010eb8:	71 08       	ld.w	r8,r8[0x40]
80010eba:	58 08       	cp.w	r8,0
80010ebc:	c0 70       	breq	80010eca <VmsvService+0x616>
80010ebe:	5c 7c       	castu.h	r12
        {
            vmsv.update_nwm_address_fptr(vmsv.shadow.nwm_addr);
80010ec0:	5d 18       	icall	r8
80010ec2:	fe b0 f0 b5 	rcall	8000f02c <MostGetNCState>
            if(NCS_NOT_OK == MostGetNCState())
80010ec6:	e0 80 01 98 	breq	800111f6 <VmsvService+0x942>
80010eca:	6f 18       	ld.w	r8,r7[0x44]
            {
                (void)VmsvInjectFBlockIDsGet();
            }
        }
        if (vmsv.store_error_info2_fptr)
80010ecc:	58 08       	cp.w	r8,0
80010ece:	fe 90 fd 25 	breq	80010918 <VmsvService+0x64>
80010ed2:	e0 6c 00 f1 	mov	r12,241
        {
            vmsv.store_error_info2_fptr(INIC_NIEVENT_TIMEOUT_CFG_STATUS);
80010ed6:	5d 18       	icall	r8
80010ed8:	fe 9f fd 20 	bral	80010918 <VmsvService+0x64>
80010edc:	30 04       	mov	r4,0
    bool reported;

    T_MOD_ENTRY(VMSV_26);

    event   = (byte)0xFF;
    info[0] = (byte)0;
80010ede:	31 1c       	mov	r12,17
    info[1] = (byte)0;
    info[2] = (byte)0;

    TAKE_VMSV();
80010ee0:	ba 84       	st.b	sp[0x0],r4
    bool reported;

    T_MOD_ENTRY(VMSV_26);

    event   = (byte)0xFF;
    info[0] = (byte)0;
80010ee2:	ba 94       	st.b	sp[0x1],r4
    info[1] = (byte)0;
80010ee4:	ba a4       	st.b	sp[0x2],r4
    info[2] = (byte)0;
80010ee6:	fe b0 b5 e8 	rcall	80007ab6 <mns_take>

    TAKE_VMSV();
80010eea:	31 1c       	mov	r12,17
    late_nistate = vmsv.shadow.late_nistate;
    nistate      = vmsv.shadow.nistate;
    reported     = vmsv.shadow.neton_reported;
    GIVE_VMSV();
80010eec:	ef 35 00 25 	ld.ub	r5,r7[37]
    info[0] = (byte)0;
    info[1] = (byte)0;
    info[2] = (byte)0;

    TAKE_VMSV();
    late_nistate = vmsv.shadow.late_nistate;
80010ef0:	ef 36 00 21 	ld.ub	r6,r7[33]
    nistate      = vmsv.shadow.nistate;
80010ef4:	ef 32 00 22 	ld.ub	r2,r7[34]
    reported     = vmsv.shadow.neton_reported;
80010ef8:	3e e3       	mov	r3,-18
    GIVE_VMSV();

    ASSERT(INIC_SHADOW_INVALID_BYTE != nistate);
80010efa:	fe b0 b5 df 	rcall	80007ab8 <mns_give>

    TAKE_VMSV();
    late_nistate = vmsv.shadow.late_nistate;
    nistate      = vmsv.shadow.nistate;
    reported     = vmsv.shadow.neton_reported;
    GIVE_VMSV();
80010efe:	e6 06 18 00 	cp.b	r6,r3

    ASSERT(INIC_SHADOW_INVALID_BYTE != nistate);
80010f02:	e0 80 01 44 	breq	8001118a <VmsvService+0x8d6>
80010f06:	e8 06 18 00 	cp.b	r6,r4

    switch (nistate)
80010f0a:	e0 80 00 d7 	breq	800110b8 <VmsvService+0x804>
80010f0e:	30 38       	mov	r8,3
80010f10:	f0 06 18 00 	cp.b	r6,r8
80010f14:	e0 80 00 bb 	breq	8001108a <VmsvService+0x7d6>
80010f18:	e0 64 00 ff 	mov	r4,255
80010f1c:	31 1c       	mov	r12,17
            }
            #endif

        /*lint -e(616) control flows into case default */
        default:
            TAKE_VMSV();
80010f1e:	fe b0 b5 cc 	rcall	80007ab6 <mns_take>
80010f22:	30 08       	mov	r8,0
            vmsv.shadow.neton_reported = MNS_FALSE;
80010f24:	31 1c       	mov	r12,17
            vmsv.shadow.delayed_nce    = MNS_FALSE;
            vmsv.shadow.delayed_mpr    = MNS_FALSE;
            GIVE_VMSV();
80010f26:	ef 68 00 23 	st.b	r7[35],r8
        /*lint -e(616) control flows into case default */
        default:
            TAKE_VMSV();
            vmsv.shadow.neton_reported = MNS_FALSE;
            vmsv.shadow.delayed_nce    = MNS_FALSE;
            vmsv.shadow.delayed_mpr    = MNS_FALSE;
80010f2a:	ef 68 00 22 	st.b	r7[34],r8
            #endif

        /*lint -e(616) control flows into case default */
        default:
            TAKE_VMSV();
            vmsv.shadow.neton_reported = MNS_FALSE;
80010f2e:	ef 68 00 24 	st.b	r7[36],r8
            vmsv.shadow.delayed_nce    = MNS_FALSE;
80010f32:	fe b0 b5 c3 	rcall	80007ab8 <mns_give>
            vmsv.shadow.delayed_mpr    = MNS_FALSE;
            GIVE_VMSV();
80010f36:	6e f8       	ld.w	r8,r7[0x3c]
            break;
    }

    if (vmsv.cfg_ptr->msval_state_changed_fptr)
80010f38:	70 08       	ld.w	r8,r8[0x0]
80010f3a:	58 08       	cp.w	r8,0
80010f3c:	c0 30       	breq	80010f42 <VmsvService+0x68e>
80010f3e:	0c 9c       	mov	r12,r6
    {
        vmsv.cfg_ptr->msval_state_changed_fptr(nistate);
80010f40:	5d 18       	icall	r8
80010f42:	3f f8       	mov	r8,-1
    }
    if (0xFF != event && vmsv.cfg_ptr->msval_event_fptr)
80010f44:	f0 04 18 00 	cp.b	r4,r8
80010f48:	c0 80       	breq	80010f58 <VmsvService+0x6a4>
80010f4a:	6e f8       	ld.w	r8,r7[0x3c]
80010f4c:	70 28       	ld.w	r8,r8[0x8]
80010f4e:	58 08       	cp.w	r8,0
80010f50:	c0 40       	breq	80010f58 <VmsvService+0x6a4>
80010f52:	08 9c       	mov	r12,r4
    {
        vmsv.cfg_ptr->msval_event_fptr(event, info);
80010f54:	1a 9b       	mov	r11,sp
80010f56:	5d 18       	icall	r8
80010f58:	30 08       	mov	r8,0
    }

    if ((MSVAL_S_INIT == late_nistate) && (MSVAL_S_OFF == nistate) &&
80010f5a:	30 19       	mov	r9,1
80010f5c:	f0 06 18 00 	cp.b	r6,r8
80010f60:	5f 0a       	sreq	r10
80010f62:	f2 05 18 00 	cp.b	r5,r9
80010f66:	5f 09       	sreq	r9
80010f68:	f5 e9 00 09 	and	r9,r10,r9
80010f6c:	f0 09 18 00 	cp.b	r9,r8
80010f70:	fe 90 fc d4 	breq	80010918 <VmsvService+0x64>
80010f74:	6e f8       	ld.w	r8,r7[0x3c]
         vmsv.cfg_ptr->msval_error_fptr)
80010f76:	70 18       	ld.w	r8,r8[0x4]
80010f78:	58 08       	cp.w	r8,0
    if (0xFF != event && vmsv.cfg_ptr->msval_event_fptr)
    {
        vmsv.cfg_ptr->msval_event_fptr(event, info);
    }

    if ((MSVAL_S_INIT == late_nistate) && (MSVAL_S_OFF == nistate) &&
80010f7a:	fe 90 fc cf 	breq	80010918 <VmsvService+0x64>
80010f7e:	30 0b       	mov	r11,0
         vmsv.cfg_ptr->msval_error_fptr)
    {
        vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_INIT_ERROR, NULL);
80010f80:	30 4c       	mov	r12,4
80010f82:	5d 18       	icall	r8
80010f84:	fe 9f fc ca 	bral	80010918 <VmsvService+0x64>
80010f88:	31 1c       	mov	r12,17
{
    byte event;

    T_MOD_ENTRY(VMSV_29);

    TAKE_VMSV();
80010f8a:	fe b0 b5 96 	rcall	80007ab6 <mns_take>
80010f8e:	30 18       	mov	r8,1
    switch (vmsv.shadow.lockstate)          /* map lockstate to msval events */
80010f90:	ef 36 00 32 	ld.ub	r6,r7[50]
80010f94:	f0 06 18 00 	cp.b	r6,r8
80010f98:	e0 88 00 6b 	brls	8001106e <VmsvService+0x7ba>
80010f9c:	31 1c       	mov	r12,17

        default:
            event = vmsv.shadow.lockstate;
            break;
    }
    GIVE_VMSV();
80010f9e:	fe b0 b5 8d 	rcall	80007ab8 <mns_give>
80010fa2:	3e e8       	mov	r8,-18

    ASSERT(INIC_SHADOW_INVALID_BYTE != event);
80010fa4:	f0 06 18 00 	cp.b	r6,r8
80010fa8:	c0 a1       	brne	80010fbc <VmsvService+0x708>
80010faa:	e0 68 05 9e 	mov	r8,1438
80010fae:	30 1a       	mov	r10,1
80010fb0:	1a d8       	st.w	--sp,r8
80010fb2:	31 0b       	mov	r11,16
80010fb4:	34 0c       	mov	r12,64
80010fb6:	fe b0 b5 9b 	rcall	80007aec <mns_trace>
80010fba:	2f fd       	sub	sp,-4
80010fbc:	6e f8       	ld.w	r8,r7[0x3c]

    if (vmsv.cfg_ptr->msval_event_fptr)
80010fbe:	70 28       	ld.w	r8,r8[0x8]
80010fc0:	58 08       	cp.w	r8,0
80010fc2:	fe 90 fc ab 	breq	80010918 <VmsvService+0x64>
80010fc6:	0c 9c       	mov	r12,r6
    {
        vmsv.cfg_ptr->msval_event_fptr(event, NULL);
80010fc8:	30 0b       	mov	r11,0
80010fca:	5d 18       	icall	r8
80010fcc:	fe 9f fc a6 	bral	80010918 <VmsvService+0x64>
80010fd0:	6e f8       	ld.w	r8,r7[0x3c]
  */
static void VmsvHandlePMIStateChange(void)
{
    T_MOD_ENTRY(VMSV_48);

    if (vmsv.cfg_ptr->pmistate_changed_fptr)
80010fd2:	fe f6 02 56 	ld.w	r6,pc[598]
80010fd6:	70 48       	ld.w	r8,r8[0x10]
80010fd8:	58 08       	cp.w	r8,0
80010fda:	fe 90 fc 9f 	breq	80010918 <VmsvService+0x64>
80010fde:	31 1c       	mov	r12,17
    {
        byte state;
        byte events;

        TAKE_VMSV();
80010fe0:	fe b0 b5 6b 	rcall	80007ab6 <mns_take>
80010fe4:	31 1c       	mov	r12,17
        state = vmsv.shadow.pmi.state;
        events = vmsv.shadow.pmi.events;
        GIVE_VMSV();
80010fe6:	ed 35 00 36 	ld.ub	r5,r6[54]
    {
        byte state;
        byte events;

        TAKE_VMSV();
        state = vmsv.shadow.pmi.state;
80010fea:	ed 34 00 37 	ld.ub	r4,r6[55]
        events = vmsv.shadow.pmi.events;
80010fee:	fe b0 b5 65 	rcall	80007ab8 <mns_give>
        GIVE_VMSV();
80010ff2:	6c f8       	ld.w	r8,r6[0x3c]

        vmsv.cfg_ptr->pmistate_changed_fptr(state, events);
80010ff4:	08 9b       	mov	r11,r4
80010ff6:	0a 9c       	mov	r12,r5
80010ff8:	70 48       	ld.w	r8,r8[0x10]
80010ffa:	5d 18       	icall	r8
80010ffc:	fe 9f fc 8e 	bral	80010918 <VmsvService+0x64>
80011000:	31 1c       	mov	r12,17
{
    byte rbdresult[2];

    T_MOD_ENTRY(VMSV_30);

    TAKE_VMSV();
80011002:	fe b0 b5 5a 	rcall	80007ab6 <mns_take>
80011006:	31 1c       	mov	r12,17
    rbdresult[0] = vmsv.shadow.rbdresult[0];
    rbdresult[1] = vmsv.shadow.rbdresult[1];
    GIVE_VMSV();
80011008:	ef 36 00 29 	ld.ub	r6,r7[41]
    byte rbdresult[2];

    T_MOD_ENTRY(VMSV_30);

    TAKE_VMSV();
    rbdresult[0] = vmsv.shadow.rbdresult[0];
8001100c:	ef 35 00 2a 	ld.ub	r5,r7[42]
    rbdresult[1] = vmsv.shadow.rbdresult[1];
80011010:	fe b0 b5 54 	rcall	80007ab8 <mns_give>
    GIVE_VMSV();
80011014:	3e e8       	mov	r8,-18

    ASSERT((INIC_SHADOW_INVALID_BYTE != rbdresult[0]) &&
80011016:	f0 06 18 00 	cp.b	r6,r8
8001101a:	c2 e0       	breq	80011076 <VmsvService+0x7c2>
8001101c:	f0 05 18 00 	cp.b	r5,r8
80011020:	c2 b0       	breq	80011076 <VmsvService+0x7c2>
80011022:	3f f8       	mov	r8,-1
           (INIC_SHADOW_INVALID_BYTE != rbdresult[1]));

    if ((byte)0xFF != rbdresult[0])
80011024:	f0 06 18 00 	cp.b	r6,r8
80011028:	fe 90 fc 78 	breq	80010918 <VmsvService+0x64>
8001102c:	6e f8       	ld.w	r8,r7[0x3c]
    {
        if (vmsv.cfg_ptr->msval_diag_result_fptr)
8001102e:	70 39       	ld.w	r9,r8[0xc]
80011030:	58 09       	cp.w	r9,0
80011032:	c1 00       	breq	80011052 <VmsvService+0x79e>
80011034:	30 19       	mov	r9,1
        {
            byte info[2];

            if (MSVAL_DIAG_POS == rbdresult[0])
80011036:	f2 06 18 00 	cp.b	r6,r9
            {
                info[0] = (byte)0x01;
8001103a:	fb f6 0e 00 	st.beq	sp[0x0],r6
8001103e:	fb f5 0e 01 	st.beq	sp[0x1],r5
                info[1] = rbdresult[1];
80011042:	f9 b9 01 00 	movne	r9,0
            }
            else
            {
                info[0] = (byte)0x00;
80011046:	fb f9 1e 00 	st.bne	sp[0x0],r9
8001104a:	1a 9b       	mov	r11,sp
            }
            vmsv.cfg_ptr->msval_diag_result_fptr(rbdresult[0], info);
8001104c:	70 38       	ld.w	r8,r8[0xc]
8001104e:	0c 9c       	mov	r12,r6
80011050:	5d 18       	icall	r8
80011052:	30 14       	mov	r4,1
static void VmsvCommRBDResult(byte result[2])
{
    T_MOD_ENTRY(VMSV_66);

    /* pos detected ? */
    if (MSVAL_DIAG_POS == result[0])
80011054:	e8 06 18 00 	cp.b	r6,r4
80011058:	c4 30       	breq	800110de <VmsvService+0x82a>
8001105a:	30 38       	mov	r8,3
        else
        {
            VmsvCommRBDResultPosX();
        }
    }
    else if (MSVAL_DIAG_SIGNAL_NO_LOCK == result[0])
8001105c:	f0 06 18 00 	cp.b	r6,r8
80011060:	fe 91 fc 5c 	brne	80010918 <VmsvService+0x64>
80011064:	30 1c       	mov	r12,1
    {
        VmsvCommRBDResultPos0(VMSV_COMM_CALL_CB);
80011066:	fe b0 fa 29 	rcall	800104b8 <VmsvCommRBDResultPos0>
8001106a:	fe 9f fc 57 	bral	80010918 <VmsvService+0x64>
8001106e:	31 1c       	mov	r12,17

        default:
            event = vmsv.shadow.lockstate;
            break;
    }
    GIVE_VMSV();
80011070:	fe b0 b5 24 	rcall	80007ab8 <mns_give>
80011074:	ca 4b       	rjmp	80010fbc <VmsvService+0x708>
80011076:	e0 68 05 be 	mov	r8,1470
    TAKE_VMSV();
    rbdresult[0] = vmsv.shadow.rbdresult[0];
    rbdresult[1] = vmsv.shadow.rbdresult[1];
    GIVE_VMSV();

    ASSERT((INIC_SHADOW_INVALID_BYTE != rbdresult[0]) &&
8001107a:	30 1a       	mov	r10,1
8001107c:	1a d8       	st.w	--sp,r8
8001107e:	31 0b       	mov	r11,16
80011080:	34 0c       	mov	r12,64
80011082:	fe b0 b5 35 	rcall	80007aec <mns_trace>
80011086:	2f fd       	sub	sp,-4
80011088:	cc db       	rjmp	80011022 <VmsvService+0x76e>
8001108a:	e0 a0 0a cb 	rcall	80012620 <ScmGetBoundary>
    switch (nistate)
    {
        case NISTATE_NET_ON:
            {
                #ifdef SCM_MIN
                byte boundary = ScmGetBoundary();
8001108e:	18 94       	mov	r4,r12
80011090:	e6 0c 18 00 	cp.b	r12,r3
                bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
80011094:	c0 70       	breq	800110a2 <VmsvService+0x7ee>
80011096:	30 8c       	mov	r12,8
80011098:	fe b0 cf 0e 	rcall	8000aeb4 <MostIsSupported>
8001109c:	c0 c0       	breq	800110b4 <VmsvService+0x800>
8001109e:	58 04       	cp.w	r4,0
800110a0:	c0 a1       	brne	800110b4 <VmsvService+0x800>
800110a2:	30 08       	mov	r8,0
800110a4:	58 02       	cp.w	r2,0

                /* MSVAL_E_NETON shall only be communicated when the
                 * boundary is valid
                 * see also MostGetState() and ScmHandleBandwidthStatus()
                 */
                if ((MNS_FALSE == reported) && (MNS_FALSE != bdvalid))
800110a6:	c0 41       	brne	800110ae <VmsvService+0x7fa>
800110a8:	58 08       	cp.w	r8,0
800110aa:	e0 81 00 8a 	brne	800111be <VmsvService+0x90a>
800110ae:	e0 64 00 ff 	mov	r4,255
        default:
            TAKE_VMSV();
            vmsv.shadow.neton_reported = MNS_FALSE;
            vmsv.shadow.delayed_nce    = MNS_FALSE;
            vmsv.shadow.delayed_mpr    = MNS_FALSE;
            GIVE_VMSV();
800110b2:	c4 2b       	rjmp	80010f36 <VmsvService+0x682>
800110b4:	30 18       	mov	r8,1
    {
        case NISTATE_NET_ON:
            {
                #ifdef SCM_MIN
                byte boundary = ScmGetBoundary();
                bool bdvalid  = (INIC_SHADOW_INVALID_BYTE != boundary) &&
800110b6:	cf 7b       	rjmp	800110a4 <VmsvService+0x7f0>
800110b8:	31 1c       	mov	r12,17

            #ifdef MSV_DIAG_RESULT_MSG
            {
                bool react = MNS_FALSE;

                TAKE_VMSV();
800110ba:	fe b0 b4 fe 	rcall	80007ab6 <mns_take>
800110be:	4d b8       	lddpc	r8,80011228 <VmsvService+0x974>
                react = (VMSV_COMM_BROADCAST == vmsv.nwstartup.comm_state) ?
800110c0:	31 1c       	mov	r12,17
                        MNS_TRUE : MNS_FALSE;
                GIVE_VMSV();
800110c2:	11 f4       	ld.ub	r4,r8[0x7]
            #ifdef MSV_DIAG_RESULT_MSG
            {
                bool react = MNS_FALSE;

                TAKE_VMSV();
                react = (VMSV_COMM_BROADCAST == vmsv.nwstartup.comm_state) ?
800110c4:	fe b0 b4 fa 	rcall	80007ab8 <mns_give>
                        MNS_TRUE : MNS_FALSE;
                GIVE_VMSV();
800110c8:	30 38       	mov	r8,3

                if (MNS_FALSE != react)
800110ca:	f0 04 18 00 	cp.b	r4,r8
800110ce:	c0 30       	breq	800110d4 <VmsvService+0x820>
800110d0:	32 14       	mov	r4,33
                {
                    VmsvCommRBDResultPos0(VMSV_COMM_RESTORE_DEVMODE);
800110d2:	c2 5b       	rjmp	80010f1c <VmsvService+0x668>
800110d4:	30 4c       	mov	r12,4
800110d6:	32 14       	mov	r4,33
800110d8:	fe b0 f9 f0 	rcall	800104b8 <VmsvCommRBDResultPos0>
800110dc:	c2 0b       	rjmp	80010f1c <VmsvService+0x668>
800110de:	58 05       	cp.w	r5,0

    /* pos detected ? */
    if (MSVAL_DIAG_POS == result[0])
    {
        /* pos 0 or X ? */
        if(0 == result[1])
800110e0:	cc 20       	breq	80011064 <VmsvService+0x7b0>
800110e2:	31 1c       	mov	r12,17
    T_MOD_ENTRY(VMSV_68);

    react            = MNS_FALSE;
    send_wakeup_mode = MNS_FALSE;

    TAKE_VMSV();
800110e4:	fe b0 b4 e9 	rcall	80007ab6 <mns_take>
800110e8:	4d 08       	lddpc	r8,80011228 <VmsvService+0x974>
    react = (VMSV_COMM_OFF == vmsv.nwstartup.comm_state) ? MNS_TRUE : MNS_FALSE;
    if(MNS_FALSE != react)
800110ea:	0f fa       	ld.ub	r10,r7[0x7]
800110ec:	30 09       	mov	r9,0
800110ee:	f2 0a 18 00 	cp.b	r10,r9
800110f2:	c5 81       	brne	800111a2 <VmsvService+0x8ee>
800110f4:	30 59       	mov	r9,5
    {
        vmsv.nwstartup.comm_state = VMSV_COMM_WAIT_FOR_MSG;
800110f6:	b0 f9       	st.b	r8[0x7],r9
800110f8:	f1 39 00 1c 	ld.ub	r9,r8[28]
        if (MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
800110fc:	e8 09 18 00 	cp.b	r9,r4
80011100:	c7 f0       	breq	800111fe <VmsvService+0x94a>
80011102:	31 1c       	mov	r12,17
                vmsv.shadow.ni_wakeup_mode.request = vmsv.shadow.ni_wakeup_mode.mode & ~VMSV_NIWAKEUPMODE_WAKEUPBAN;
                send_wakeup_mode = MNS_TRUE;
            }
        }
    }
    GIVE_VMSV();
80011104:	fe b0 b4 da 	rcall	80007ab8 <mns_give>
80011108:	fe 9f fc 08 	bral	80010918 <VmsvService+0x64>
8001110c:	6a f8       	ld.w	r8,r5[0x3c]


    /* NIState needs to be "net on" and reported to be able to fire
     * MSVAL_E_MPR
     */
    if ((INIC_NIEVENT_MPR_CHANGED == nievent) &&
8001110e:	70 28       	ld.w	r8,r8[0x8]
80011110:	58 08       	cp.w	r8,0
80011112:	fe 90 fe bc 	breq	80010e8a <VmsvService+0x5d6>
80011116:	30 38       	mov	r8,3
        vmsv.cfg_ptr->msval_event_fptr)
    {
        if((MSVAL_S_ON == state) && (MNS_FALSE != reported))
80011118:	f0 04 18 00 	cp.b	r4,r8
8001111c:	c0 31       	brne	80011122 <VmsvService+0x86e>
8001111e:	58 03       	cp.w	r3,0
80011120:	c5 b1       	brne	800111d6 <VmsvService+0x922>
80011122:	31 1c       	mov	r12,17

            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_MPR, NULL);
        }
        else
        {
            TAKE_VMSV();
80011124:	fe b0 b4 c9 	rcall	80007ab6 <mns_take>
80011128:	30 18       	mov	r8,1
            vmsv.shadow.delayed_mpr = MNS_TRUE;
8001112a:	31 1c       	mov	r12,17
            GIVE_VMSV();
8001112c:	ef 68 00 23 	st.b	r7[35],r8
            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_MPR, NULL);
        }
        else
        {
            TAKE_VMSV();
            vmsv.shadow.delayed_mpr = MNS_TRUE;
80011130:	fe b0 b4 c4 	rcall	80007ab8 <mns_give>
            GIVE_VMSV();
80011134:	fe 9f fb f2 	bral	80010918 <VmsvService+0x64>
80011138:	6a f8       	ld.w	r8,r5[0x3c]
        }
    }
    else if ((INIC_NIEVENT_CRITICAL_UNLOCK == nievent) &&
             vmsv.cfg_ptr->msval_error_fptr)
8001113a:	70 18       	ld.w	r8,r8[0x4]
8001113c:	58 08       	cp.w	r8,0
            TAKE_VMSV();
            vmsv.shadow.delayed_mpr = MNS_TRUE;
            GIVE_VMSV();
        }
    }
    else if ((INIC_NIEVENT_CRITICAL_UNLOCK == nievent) &&
8001113e:	fe 90 fe ab 	breq	80010e94 <VmsvService+0x5e0>
80011142:	30 0b       	mov	r11,0
             vmsv.cfg_ptr->msval_error_fptr)
    {
        vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_UNLOCK_CRITICAL, NULL);
80011144:	30 1c       	mov	r12,1
80011146:	5d 18       	icall	r8
80011148:	fe 9f fb e8 	bral	80010918 <VmsvService+0x64>
8001114c:	6e f8       	ld.w	r8,r7[0x3c]
    }
    else if ((INIC_NIEVENT_SHORT_UNLOCK == nievent) && vmsv.cfg_ptr->msval_error_fptr)
8001114e:	70 18       	ld.w	r8,r8[0x4]
80011150:	58 08       	cp.w	r8,0
80011152:	fe 90 fb e3 	breq	80010918 <VmsvService+0x64>
80011156:	30 0b       	mov	r11,0
    {
        vmsv.cfg_ptr->msval_error_fptr(MSVAL_ERR_UNLOCK_SHORT, NULL);
80011158:	16 9c       	mov	r12,r11
8001115a:	5d 18       	icall	r8
8001115c:	fe 9f fb de 	bral	80010918 <VmsvService+0x64>
80011160:	6e f8       	ld.w	r8,r7[0x3c]
    }
    else if ((INIC_NIEVENT_NET_ACTIVITY == nievent) && vmsv.cfg_ptr->msval_event_fptr)
80011162:	70 28       	ld.w	r8,r8[0x8]
80011164:	58 08       	cp.w	r8,0
80011166:	fe 90 fb d9 	breq	80010918 <VmsvService+0x64>
8001116a:	30 0b       	mov	r11,0
    {
        vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_NET_ACTIVITY, NULL);
8001116c:	e0 6c 00 80 	mov	r12,128
80011170:	5d 18       	icall	r8
80011172:	fe 9f fb d3 	bral	80010918 <VmsvService+0x64>
80011176:	e0 68 04 f8 	mov	r8,1272
    nievent = vmsv.shadow.nievent;
    state = vmsv.shadow.nistate;
    reported = vmsv.shadow.neton_reported;
    GIVE_VMSV();

    ASSERT(INIC_SHADOW_INVALID_BYTE != nievent);
8001117a:	30 1a       	mov	r10,1
8001117c:	1a d8       	st.w	--sp,r8
8001117e:	31 0b       	mov	r11,16
80011180:	34 0c       	mov	r12,64
80011182:	fe b0 b4 b5 	rcall	80007aec <mns_trace>
80011186:	2f fd       	sub	sp,-4
80011188:	c8 ba       	rjmp	80010e9e <VmsvService+0x5ea>
8001118a:	e0 68 04 95 	mov	r8,1173
    late_nistate = vmsv.shadow.late_nistate;
    nistate      = vmsv.shadow.nistate;
    reported     = vmsv.shadow.neton_reported;
    GIVE_VMSV();

    ASSERT(INIC_SHADOW_INVALID_BYTE != nistate);
8001118e:	30 1a       	mov	r10,1
80011190:	1a d8       	st.w	--sp,r8
80011192:	31 0b       	mov	r11,16
80011194:	34 0c       	mov	r12,64
80011196:	e0 64 00 ff 	mov	r4,255
8001119a:	fe b0 b4 a9 	rcall	80007aec <mns_trace>
8001119e:	2f fd       	sub	sp,-4
800111a0:	cb ea       	rjmp	80010f1c <VmsvService+0x668>
800111a2:	31 1c       	mov	r12,17
                vmsv.shadow.ni_wakeup_mode.request = vmsv.shadow.ni_wakeup_mode.mode & ~VMSV_NIWAKEUPMODE_WAKEUPBAN;
                send_wakeup_mode = MNS_TRUE;
            }
        }
    }
    GIVE_VMSV();
800111a4:	fe b0 b4 8a 	rcall	80007ab8 <mns_give>
800111a8:	e0 68 0a 5d 	mov	r8,2653
    ASSERT(react);
800111ac:	30 1a       	mov	r10,1
800111ae:	1a d8       	st.w	--sp,r8
800111b0:	31 0b       	mov	r11,16
800111b2:	34 0c       	mov	r12,64
800111b4:	fe b0 b4 9c 	rcall	80007aec <mns_trace>
800111b8:	2f fd       	sub	sp,-4
800111ba:	fe 9f fb af 	bral	80010918 <VmsvService+0x64>
800111be:	fe b0 ce 31 	rcall	8000ae20 <MnsSignalNetOn>
                 * boundary is valid
                 * see also MostGetState() and ScmHandleBandwidthStatus()
                 */
                if ((MNS_FALSE == reported) && (MNS_FALSE != bdvalid))
                {
                    MnsSignalNetOn();
800111c2:	fe b0 f2 73 	rcall	8000f6a8 <VmsvReportNetOn>
                    VmsvReportNetOn();
800111c6:	e0 6b 08 00 	mov	r11,2048
                    MnsDistribEvent(MNS_P_SRV_VMSV, VMSV_P_SRV_CHECK);
800111ca:	34 0c       	mov	r12,64
800111cc:	e0 64 00 ff 	mov	r4,255
800111d0:	fe b0 cd 96 	rcall	8000acfc <MnsDistribEvent>
800111d4:	cb 1a       	rjmp	80010f36 <VmsvService+0x682>
800111d6:	31 1c       	mov	r12,17
    if ((INIC_NIEVENT_MPR_CHANGED == nievent) &&
        vmsv.cfg_ptr->msval_event_fptr)
    {
        if((MSVAL_S_ON == state) && (MNS_FALSE != reported))
        {
            TAKE_VMSV();
800111d8:	fe b0 b4 6f 	rcall	80007ab6 <mns_take>
800111dc:	30 08       	mov	r8,0
            vmsv.shadow.delayed_mpr = MNS_FALSE;
800111de:	31 1c       	mov	r12,17
            GIVE_VMSV();
800111e0:	eb 68 00 23 	st.b	r5[35],r8
        vmsv.cfg_ptr->msval_event_fptr)
    {
        if((MSVAL_S_ON == state) && (MNS_FALSE != reported))
        {
            TAKE_VMSV();
            vmsv.shadow.delayed_mpr = MNS_FALSE;
800111e4:	fe b0 b4 6a 	rcall	80007ab8 <mns_give>
            GIVE_VMSV();
800111e8:	6a f8       	ld.w	r8,r5[0x3c]

            vmsv.cfg_ptr->msval_event_fptr(MSVAL_E_MPR, NULL);
800111ea:	30 0b       	mov	r11,0
800111ec:	70 28       	ld.w	r8,r8[0x8]
800111ee:	31 0c       	mov	r12,16
800111f0:	5d 18       	icall	r8
800111f2:	fe 9f fb 93 	bral	80010918 <VmsvService+0x64>
800111f6:	fe b0 f4 7d 	rcall	8000faf0 <VmsvInjectFBlockIDsGet>
        if ((NCS_INVALID_NWM != vmsv.shadow.nwm_addr) && vmsv.update_nwm_address_fptr)
        {
            vmsv.update_nwm_address_fptr(vmsv.shadow.nwm_addr);
            if(NCS_NOT_OK == MostGetNCState())
            {
                (void)VmsvInjectFBlockIDsGet();
800111fa:	fe 9f fe 68 	bral	80010eca <VmsvService+0x616>
800111fe:	f1 39 00 38 	ld.ub	r9,r8[56]
    if(MNS_FALSE != react)
    {
        vmsv.nwstartup.comm_state = VMSV_COMM_WAIT_FOR_MSG;
        if (MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
        {
            if (    (INIC_SHADOW_INVALID_BYTE != vmsv.shadow.ni_wakeup_mode.mode)
80011202:	3e ea       	mov	r10,-18
80011204:	f4 09 18 00 	cp.b	r9,r10
80011208:	fe 90 ff 7d 	breq	80011102 <VmsvService+0x84e>
8001120c:	ed b9 00 01 	bld	r9,0x1
80011210:	fe 91 ff 79 	brne	80011102 <VmsvService+0x84e>
80011214:	a1 d9       	cbr	r9,0x1
                 && (VMSV_NIWAKEUPMODE_WAKEUPBAN == (vmsv.shadow.ni_wakeup_mode.mode & VMSV_NIWAKEUPMODE_WAKEUPBAN)) )
            {
                vmsv.shadow.ni_wakeup_mode.request = vmsv.shadow.ni_wakeup_mode.mode & ~VMSV_NIWAKEUPMODE_WAKEUPBAN;
80011216:	31 1c       	mov	r12,17
                send_wakeup_mode = MNS_TRUE;
            }
        }
    }
    GIVE_VMSV();
80011218:	f1 69 00 39 	st.b	r8[57],r9
        if (MNS_MASTER == vmsv.nwstartup.saved_dev_mode)
        {
            if (    (INIC_SHADOW_INVALID_BYTE != vmsv.shadow.ni_wakeup_mode.mode)
                 && (VMSV_NIWAKEUPMODE_WAKEUPBAN == (vmsv.shadow.ni_wakeup_mode.mode & VMSV_NIWAKEUPMODE_WAKEUPBAN)) )
            {
                vmsv.shadow.ni_wakeup_mode.request = vmsv.shadow.ni_wakeup_mode.mode & ~VMSV_NIWAKEUPMODE_WAKEUPBAN;
8001121c:	fe b0 b4 4e 	rcall	80007ab8 <mns_give>
                send_wakeup_mode = MNS_TRUE;
            }
        }
    }
    GIVE_VMSV();
80011220:	fe b0 ef a6 	rcall	8000f16c <VmsvSetNIWakeUpMode>
    ASSERT(react);

    if (MNS_FALSE != send_wakeup_mode)
    {
        VmsvSetNIWakeUpMode();
80011224:	fe 9f fb 7a 	bral	80010918 <VmsvService+0x64>
80011228:	00 00       	add	r0,r0
8001122a:	39 9c       	mov	r12,-103

8001122c <VmsvInit>:
8001122c:	eb cd 40 e0 	pushm	r5-r7,lr
80011230:	18 96       	mov	r6,r12
80011232:	58 0c       	cp.w	r12,0
80011234:	c6 20       	breq	800112f8 <VmsvInit+0xcc>
80011236:	30 0a       	mov	r10,0
80011238:	30 7b       	mov	r11,7
8001123a:	34 0c       	mov	r12,64
8001123c:	fe b0 b4 58 	rcall	80007aec <mns_trace>
80011240:	31 0c       	mov	r12,16
80011242:	4b 37       	lddpc	r7,8001130c <VmsvInit+0xe0>
80011244:	8f f6       	st.w	r7[0x3c],r6
80011246:	fe b0 b4 38 	rcall	80007ab6 <mns_take>
8001124a:	30 06       	mov	r6,0
8001124c:	31 0c       	mov	r12,16
8001124e:	ae 06       	st.h	r7[0x0],r6
80011250:	ae 16       	st.h	r7[0x2],r6
80011252:	fe b0 b4 33 	rcall	80007ab8 <mns_give>
80011256:	30 05       	mov	r5,0
80011258:	e0 6a 00 80 	mov	r10,128
8001125c:	fe cb 14 20 	sub	r11,pc,5152
80011260:	ee cc ff b8 	sub	r12,r7,-72
80011264:	ef 45 00 40 	st.w	r7[64],r5
80011268:	ef 45 00 44 	st.w	r7[68],r5
8001126c:	fe b0 cf 94 	rcall	8000b194 <MostRegisterTimer>
80011270:	e0 6a 40 00 	mov	r10,16384
80011274:	fe cb 14 38 	sub	r11,pc,5176
80011278:	ee cc ff f8 	sub	r12,r7,-8
8001127c:	fe b0 cf 8c 	rcall	8000b194 <MostRegisterTimer>
80011280:	31 1c       	mov	r12,17
80011282:	fe b0 b4 1a 	rcall	80007ab6 <mns_take>
80011286:	3e e8       	mov	r8,-18
80011288:	31 1c       	mov	r12,17
8001128a:	ef 68 00 39 	st.b	r7[57],r8
8001128e:	ef 68 00 38 	st.b	r7[56],r8
80011292:	ef 66 00 20 	st.b	r7[32],r6
80011296:	fe b0 b4 11 	rcall	80007ab8 <mns_give>
8001129a:	e0 6a 10 00 	mov	r10,4096
8001129e:	fe cb 14 62 	sub	r11,pc,5218
800112a2:	ee cc ff 7c 	sub	r12,r7,-132
    #endif

    #ifdef NS_MSV_ET
    MostRegisterTimer(&(vmsv.plt.state_timer), VmsvSetPendingEvent, VMSV_P_PHYSICAL_LAYER_TEST);

    TAKE_VMSV();
800112a6:	fe b0 cf 77 	rcall	8000b194 <MostRegisterTimer>
    vmsv.plt.test_state     = VMSV_PLT_OFF;
    vmsv.plt.test_done      = MNS_FALSE;
    vmsv.plr.lock_status    = MNS_FALSE;
    vmsv.plr.err_count      = (word)0;
    GIVE_VMSV();
800112aa:	31 1c       	mov	r12,17

    TAKE_VMSV();
    vmsv.plt.test_state     = VMSV_PLT_OFF;
    vmsv.plt.test_done      = MNS_FALSE;
    vmsv.plr.lock_status    = MNS_FALSE;
    vmsv.plr.err_count      = (word)0;
800112ac:	fe b0 b4 05 	rcall	80007ab6 <mns_take>

    #ifdef NS_MSV_ET
    MostRegisterTimer(&(vmsv.plt.state_timer), VmsvSetPendingEvent, VMSV_P_PHYSICAL_LAYER_TEST);

    TAKE_VMSV();
    vmsv.plt.test_state     = VMSV_PLT_OFF;
800112b0:	31 1c       	mov	r12,17
800112b2:	ef 55 00 9a 	st.h	r7[154],r5
    vmsv.plt.test_done      = MNS_FALSE;
800112b6:	ef 66 00 81 	st.b	r7[129],r6
    vmsv.plr.lock_status    = MNS_FALSE;
800112ba:	ef 66 00 74 	st.b	r7[116],r6
    vmsv.plr.err_count      = (word)0;
    GIVE_VMSV();
800112be:	ef 66 00 98 	st.b	r7[152],r6
    #endif

    #ifdef _OS81110_SSO
    /* restore ssoresult from nonvolatile memory */
    if (vmsv.cfg_ptr->sso_restore_ssoresult_fptr)
800112c2:	fe b0 b3 fb 	rcall	80007ab8 <mns_give>
800112c6:	6e f8       	ld.w	r8,r7[0x3c]
    {
        byte ssoresult;
        ssoresult = vmsv.cfg_ptr->sso_restore_ssoresult_fptr();
800112c8:	70 9c       	ld.w	r12,r8[0x24]
800112ca:	58 0c       	cp.w	r12,0
        vmsv.shadow.ssoresult = ssoresult;
        GIVE_VMSV();
    }
    else
    {
        TAKE_VMSV();
800112cc:	c0 30       	breq	800112d2 <VmsvInit+0xa6>
800112ce:	5d 1c       	icall	r12
800112d0:	18 96       	mov	r6,r12
        vmsv.shadow.ssoresult = SDR_NO_RESULT;
        GIVE_VMSV();
800112d2:	31 1c       	mov	r12,17
        GIVE_VMSV();
    }
    else
    {
        TAKE_VMSV();
        vmsv.shadow.ssoresult = SDR_NO_RESULT;
800112d4:	fe b0 b3 f1 	rcall	80007ab6 <mns_take>
        GIVE_VMSV();
800112d8:	31 1c       	mov	r12,17
800112da:	ef 66 00 2b 	st.b	r7[43],r6
    }
    #endif

    TAKE_VMSV();
800112de:	fe b0 b3 ed 	rcall	80007ab8 <mns_give>
    vmsv.emergency_state = MNS_FALSE;
800112e2:	31 1c       	mov	r12,17
    GIVE_VMSV();
800112e4:	fe b0 b3 e9 	rcall	80007ab6 <mns_take>
        GIVE_VMSV();
    }
    #endif

    TAKE_VMSV();
    vmsv.emergency_state = MNS_FALSE;
800112e8:	30 08       	mov	r8,0
    GIVE_VMSV();
800112ea:	31 1c       	mov	r12,17
800112ec:	ef 68 00 9c 	st.b	r7[156],r8

    T_LIB_EXIT(VMSV_0);
}
800112f0:	fe b0 b3 e4 	rcall	80007ab8 <mns_give>
#ifdef VMSV_0
void VmsvInit(struct TVmsvConfig *cfg_ptr)
{
    T_LIB_ENTRY(VMSV_0);

    ASSERT(cfg_ptr);
800112f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800112f8:	e0 68 00 88 	mov	r8,136
800112fc:	30 1a       	mov	r10,1
800112fe:	1a d8       	st.w	--sp,r8
80011300:	31 0b       	mov	r11,16
80011302:	34 0c       	mov	r12,64
80011304:	fe b0 b3 f4 	rcall	80007aec <mns_trace>
80011308:	2f fd       	sub	sp,-4
8001130a:	c9 6b       	rjmp	80011236 <VmsvInit+0xa>
8001130c:	00 00       	add	r0,r0
8001130e:	39 9c       	mov	r12,-103

80011310 <DataNIStateNetOn>:
}
#endif

#ifdef ADS_10
void DataNIStateNetOn(bool on)
{
80011310:	eb cd 40 e0 	pushm	r5-r7,lr
    T_LIB_ENTRY(ADS_10);

    wads_data.net_on = on;
80011314:	49 47       	lddpc	r7,80011364 <DataNIStateNetOn+0x54>
80011316:	ae cc       	st.b	r7[0x4],r12

    if(MNS_FALSE != on)
80011318:	58 0c       	cp.w	r12,0
8001131a:	c1 51       	brne	80011344 <DataNIStateNetOn+0x34>
            DataSetPendingEvent(ADS_P_RX);
        }
    }
    else
    {
        while (MbmQueueLength(&(wads_data.rx_queue)))
8001131c:	ef 09 00 12 	ld.sh	r9,r7[18]
80011320:	f8 09 19 00 	cp.h	r9,r12
80011324:	c1 e0       	breq	80011360 <DataNIStateNetOn+0x50>
80011326:	18 95       	mov	r5,r12
        {
            HMBMBUF handle = MbmDequeue(&(wads_data.rx_queue));
80011328:	ee c6 ff f8 	sub	r6,r7,-8
8001132c:	0c 9c       	mov	r12,r6
8001132e:	fe b0 c6 e5 	rcall	8000a0f8 <MbmDequeue>
            MbmFree(handle);
80011332:	fe b0 de 13 	rcall	8000cf58 <MbmFree>
            DataSetPendingEvent(ADS_P_RX);
        }
    }
    else
    {
        while (MbmQueueLength(&(wads_data.rx_queue)))
80011336:	ef 08 00 12 	ld.sh	r8,r7[18]
8001133a:	ea 08 19 00 	cp.h	r8,r5
8001133e:	cf 71       	brne	8001132c <DataNIStateNetOn+0x1c>
80011340:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    wads_data.net_on = on;

    if(MNS_FALSE != on)
    {
        if (MbmQueueLength(&(wads_data.rx_queue)))
80011344:	ef 09 00 12 	ld.sh	r9,r7[18]
80011348:	30 08       	mov	r8,0
8001134a:	f0 09 19 00 	cp.h	r9,r8
8001134e:	cf 90       	breq	80011340 <DataNIStateNetOn+0x30>
static void DataSetPendingEvent(word event_flag)
{
    T_MOD_ENTRY(ADS_2);

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_ADS_PE,
80011350:	0e 9a       	mov	r10,r7
80011352:	32 09       	mov	r9,32
80011354:	30 eb       	mov	r11,14
80011356:	30 1c       	mov	r12,1
80011358:	fe b0 d0 12 	rcall	8000b37c <MnsSetPendingEventFlag>
8001135c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80011360:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80011364:	00 00       	add	r0,r0
80011366:	3a 3c       	mov	r12,-93

80011368 <DataRxOutTrigger>:
80011368:	d4 31       	pushm	r0-r7,lr
8001136a:	4d 05       	lddpc	r5,800114a8 <DataRxOutTrigger+0x140>
8001136c:	18 97       	mov	r7,r12
8001136e:	6a 58       	ld.w	r8,r5[0x14]
80011370:	30 09       	mov	r9,0
80011372:	f1 3a 00 0d 	ld.ub	r10,r8[13]

    T_MOD_ENTRY(ADS_9);

    /* if wads_data.cfg_ptr->rx_direct is MNS_TRUE, there shouldn't be any packet in the
       queue, except for BUSY operation and packets received before NET_ON */
    rx_burst = (MNS_FALSE != wads_data.cfg_ptr->rx_direct) ? 0xFF : wads_data.cfg_ptr->rx_burst;
80011376:	f2 0a 18 00 	cp.b	r10,r9
8001137a:	c6 80       	breq	8001144a <DataRxOutTrigger+0xe2>
8001137c:	e0 66 00 ff 	mov	r6,255

    #ifndef PACKET_COMMUNICATION_ONLY
    if(MNS_FALSE == wads_data.net_on)
80011380:	0b c9       	ld.ub	r9,r5[0x4]
80011382:	30 08       	mov	r8,0
80011384:	f0 09 18 00 	cp.b	r9,r8
80011388:	c4 a0       	breq	8001141c <DataRxOutTrigger+0xb4>
    {
        return;
    }
    #endif

    if(NULL == handle)
8001138a:	58 07       	cp.w	r7,0
8001138c:	c7 d0       	breq	80011486 <DataRxOutTrigger+0x11e>
            }
            else
            #endif
            {
                #ifndef PACKET_COMMUNICATION_ONLY
                if (wads_data.cfg_ptr->rx_filter_fptr && EHCISTATE_IS_ATTACHED())
8001138e:	4c 71       	lddpc	r1,800114a8 <DataRxOutTrigger+0x140>
        handle = MbmDequeue(&(wads_data.rx_queue));
    }

    ASSERT(handle);

    while (handle && rx_burst)
80011390:	30 04       	mov	r4,0
            default:
                FAILED_ASSERT();

            case DATA_RX_FILTER_DEFAULT: /*lint !e616 control flows intentionally into case default */
            #ifndef PACKET_COMMUNICATION_ONLY
                if (wads_data.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
80011392:	30 23       	mov	r3,2
                    result = DATA_RX_COMPLETE_FREE;
                }
                switch (result)
                {
                    case DATA_RX_COMPLETE_BUSY:
                        MbmEnqueueFirst(&(wads_data.rx_queue), handle);
80011394:	e2 c0 ff f8 	sub	r0,r1,-8
        handle = MbmDequeue(&(wads_data.rx_queue));
    }

    ASSERT(handle);

    while (handle && rx_burst)
80011398:	e8 06 18 00 	cp.b	r6,r4
8001139c:	5f 19       	srne	r9
8001139e:	58 07       	cp.w	r7,0
800113a0:	5f 18       	srne	r8
800113a2:	f3 e8 00 08 	and	r8,r9,r8
800113a6:	e8 08 18 00 	cp.b	r8,r4
800113aa:	c3 90       	breq	8001141c <DataRxOutTrigger+0xb4>
            }
            else
            #endif
            {
                #ifndef PACKET_COMMUNICATION_ONLY
                if (wads_data.cfg_ptr->rx_filter_fptr && EHCISTATE_IS_ATTACHED())
800113ac:	6a 58       	ld.w	r8,r5[0x14]

    ASSERT(handle);

    while (handle && rx_burst)
    {
        TDataRx *msg_ptr = MBM_GET_DATA_RX_PTR(handle);
800113ae:	ee c2 ff ec 	sub	r2,r7,-20
            }
            else
            #endif
            {
                #ifndef PACKET_COMMUNICATION_ONLY
                if (wads_data.cfg_ptr->rx_filter_fptr && EHCISTATE_IS_ATTACHED())
800113b2:	70 29       	ld.w	r9,r8[0x8]
800113b4:	58 09       	cp.w	r9,0
800113b6:	c0 70       	breq	800113c4 <DataRxOutTrigger+0x5c>
800113b8:	fe b0 cd 9c 	rcall	8000aef0 <MnsGetEHCIState>
800113bc:	e6 0c 18 00 	cp.b	r12,r3
800113c0:	c2 f0       	breq	8001141e <DataRxOutTrigger+0xb6>
                MbmEnqueueFirst(&(wads_data.rx_queue), handle);
                rx_burst = 1;
                break;

            default:
                FAILED_ASSERT();
800113c2:	62 58       	ld.w	r8,r1[0x14]

            case DATA_RX_FILTER_DEFAULT: /*lint !e616 control flows intentionally into case default */
            #ifndef PACKET_COMMUNICATION_ONLY
                if (wads_data.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
800113c4:	70 18       	ld.w	r8,r8[0x4]
800113c6:	58 08       	cp.w	r8,0
800113c8:	c0 60       	breq	800113d4 <DataRxOutTrigger+0x6c>
800113ca:	fe b0 cd 93 	rcall	8000aef0 <MnsGetEHCIState>
800113ce:	e6 0c 18 00 	cp.b	r12,r3
800113d2:	c3 f0       	breq	80011450 <DataRxOutTrigger+0xe8>

                    default:
                        FAILED_ASSERT();

                    case DATA_RX_COMPLETE_FREE: /*lint !e616 control flows intentionally into case default */
                        MbmFree(handle);
800113d4:	0e 9c       	mov	r12,r7
800113d6:	20 16       	sub	r6,1
800113d8:	fe b0 dd c0 	rcall	8000cf58 <MbmFree>
800113dc:	5c 56       	castu.b	r6
800113de:	30 07       	mov	r7,0
                break;
        }

        rx_burst--;

        if (MbmQueueLength(&(wads_data.rx_queue)))
800113e0:	eb 09 00 12 	ld.sh	r9,r5[18]
800113e4:	30 08       	mov	r8,0
800113e6:	f0 09 19 00 	cp.h	r9,r8
800113ea:	cd 70       	breq	80011398 <DataRxOutTrigger+0x30>
        {
            if((byte)0 == rx_burst)
800113ec:	58 06       	cp.w	r6,0
800113ee:	c0 81       	brne	800113fe <DataRxOutTrigger+0x96>
static void DataSetPendingEvent(word event_flag)
{
    T_MOD_ENTRY(ADS_2);

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_ADS_PE,
800113f0:	32 09       	mov	r9,32
800113f2:	4a ea       	lddpc	r10,800114a8 <DataRxOutTrigger+0x140>
800113f4:	30 eb       	mov	r11,14
800113f6:	30 1c       	mov	r12,1
800113f8:	fe b0 cf c2 	rcall	8000b37c <MnsSetPendingEventFlag>
800113fc:	cc eb       	rjmp	80011398 <DataRxOutTrigger+0x30>
            {
                DataSetPendingEvent(ADS_P_RX);
            }
            else
            {
                handle = MbmDequeue(&(wads_data.rx_queue));
800113fe:	00 9c       	mov	r12,r0
80011400:	fe b0 c6 7c 	rcall	8000a0f8 <MbmDequeue>
80011404:	18 97       	mov	r7,r12
                ASSERT(handle);
80011406:	cc 91       	brne	80011398 <DataRxOutTrigger+0x30>
80011408:	e0 68 02 25 	mov	r8,549
8001140c:	30 1a       	mov	r10,1
8001140e:	1a d8       	st.w	--sp,r8
80011410:	31 0b       	mov	r11,16
80011412:	32 0c       	mov	r12,32
80011414:	fe b0 b3 6c 	rcall	80007aec <mns_trace>
80011418:	2f fd       	sub	sp,-4
8001141a:	cb fb       	rjmp	80011398 <DataRxOutTrigger+0x30>
8001141c:	d8 32       	popm	r0-r7,pc
                if (wads_data.cfg_ptr->rx_filter_fptr && EHCISTATE_IS_ATTACHED())
                #else
                if (wads_data.cfg_ptr->rx_filter_fptr)
                #endif
                {
                    result = wads_data.cfg_ptr->rx_filter_fptr(msg_ptr);
8001141e:	62 58       	ld.w	r8,r1[0x14]
80011420:	04 9c       	mov	r12,r2
80011422:	70 28       	ld.w	r8,r8[0x8]
80011424:	5d 18       	icall	r8
                }
            }
        }

        switch (result)
80011426:	30 18       	mov	r8,1
80011428:	f0 0c 18 00 	cp.b	r12,r8
8001142c:	cd 40       	breq	800113d4 <DataRxOutTrigger+0x6c>
8001142e:	cc a3       	brcs	800113c2 <DataRxOutTrigger+0x5a>
80011430:	e6 0c 18 00 	cp.b	r12,r3
80011434:	c1 90       	breq	80011466 <DataRxOutTrigger+0xfe>
                MbmEnqueueFirst(&(wads_data.rx_queue), handle);
                rx_burst = 1;
                break;

            default:
                FAILED_ASSERT();
80011436:	e0 68 01 f9 	mov	r8,505
8001143a:	30 1a       	mov	r10,1
8001143c:	1a d8       	st.w	--sp,r8
8001143e:	31 0b       	mov	r11,16
80011440:	32 0c       	mov	r12,32
80011442:	fe b0 b3 55 	rcall	80007aec <mns_trace>
80011446:	2f fd       	sub	sp,-4
80011448:	cb db       	rjmp	800113c2 <DataRxOutTrigger+0x5a>

    T_MOD_ENTRY(ADS_9);

    /* if wads_data.cfg_ptr->rx_direct is MNS_TRUE, there shouldn't be any packet in the
       queue, except for BUSY operation and packets received before NET_ON */
    rx_burst = (MNS_FALSE != wads_data.cfg_ptr->rx_direct) ? 0xFF : wads_data.cfg_ptr->rx_burst;
8001144a:	f1 36 00 0c 	ld.ub	r6,r8[12]
8001144e:	c9 9b       	rjmp	80011380 <DataRxOutTrigger+0x18>
                if (wads_data.cfg_ptr->rx_complete_fptr && EHCISTATE_IS_ATTACHED())
            #else
                if (wads_data.cfg_ptr->rx_complete_fptr)
            #endif
                {
                    result = wads_data.cfg_ptr->rx_complete_fptr(msg_ptr);
80011450:	6a 58       	ld.w	r8,r5[0x14]
80011452:	04 9c       	mov	r12,r2
80011454:	70 18       	ld.w	r8,r8[0x4]
80011456:	5d 18       	icall	r8
                }
                else
                {
                    result = DATA_RX_COMPLETE_FREE;
                }
                switch (result)
80011458:	30 18       	mov	r8,1
8001145a:	f0 0c 18 00 	cp.b	r12,r8
8001145e:	cb b0       	breq	800113d4 <DataRxOutTrigger+0x6c>
80011460:	e6 0c 18 00 	cp.b	r12,r3
80011464:	c0 71       	brne	80011472 <DataRxOutTrigger+0x10a>
                {
                    case DATA_RX_COMPLETE_BUSY:
                        MbmEnqueueFirst(&(wads_data.rx_queue), handle);
80011466:	0e 9b       	mov	r11,r7
80011468:	00 9c       	mov	r12,r0
8001146a:	30 06       	mov	r6,0
8001146c:	fe b0 c6 7e 	rcall	8000a168 <MbmEnqueueFirst>
                        rx_burst = 1;
                        break;
80011470:	cb 8b       	rjmp	800113e0 <DataRxOutTrigger+0x78>

                    default:
                        FAILED_ASSERT();
80011472:	e0 68 02 10 	mov	r8,528
80011476:	30 1a       	mov	r10,1
80011478:	1a d8       	st.w	--sp,r8
8001147a:	31 0b       	mov	r11,16
8001147c:	32 0c       	mov	r12,32
8001147e:	fe b0 b3 37 	rcall	80007aec <mns_trace>
80011482:	2f fd       	sub	sp,-4
80011484:	ca 8b       	rjmp	800113d4 <DataRxOutTrigger+0x6c>
    }
    #endif

    if(NULL == handle)
    {
        handle = MbmDequeue(&(wads_data.rx_queue));
80011486:	48 9c       	lddpc	r12,800114a8 <DataRxOutTrigger+0x140>
80011488:	2f 8c       	sub	r12,-8
8001148a:	fe b0 c6 37 	rcall	8000a0f8 <MbmDequeue>
8001148e:	18 97       	mov	r7,r12
    }

    ASSERT(handle);
80011490:	fe 91 ff 7f 	brne	8001138e <DataRxOutTrigger+0x26>
80011494:	e0 68 01 bf 	mov	r8,447
80011498:	30 1a       	mov	r10,1
8001149a:	1a d8       	st.w	--sp,r8
8001149c:	31 0b       	mov	r11,16
8001149e:	32 0c       	mov	r12,32
800114a0:	fe b0 b3 26 	rcall	80007aec <mns_trace>
800114a4:	2f fd       	sub	sp,-4
800114a6:	c7 4b       	rjmp	8001138e <DataRxOutTrigger+0x26>
800114a8:	00 00       	add	r0,r0
800114aa:	3a 3c       	mov	r12,-93

800114ac <DataRxTrigger>:
800114ac:	eb cd 40 c0 	pushm	r6-r7,lr
800114b0:	18 97       	mov	r7,r12
800114b2:	58 0c       	cp.w	r12,0
800114b4:	c2 b0       	breq	8001150a <DataRxTrigger+0x5e>
800114b6:	49 b6       	lddpc	r6,80011520 <DataRxTrigger+0x74>
800114b8:	30 08       	mov	r8,0
800114ba:	6c 59       	ld.w	r9,r6[0x14]
800114bc:	f3 39 00 0d 	ld.ub	r9,r9[13]
800114c0:	f0 09 18 00 	cp.b	r9,r8
        }
    }
    #endif

    #ifndef PACKET_COMMUNICATION_ONLY
    if ((MNS_FALSE != wads_data.cfg_ptr->rx_direct) && (MNS_FALSE != wads_data.net_on) && ((word)0 == MbmQueueLength(&(wads_data.rx_queue))))
800114c4:	c0 50       	breq	800114ce <DataRxTrigger+0x22>
800114c6:	0d c9       	ld.ub	r9,r6[0x4]
800114c8:	f0 09 18 00 	cp.b	r9,r8
800114cc:	c1 51       	brne	800114f6 <DataRxTrigger+0x4a>
    {
        DataRxOutTrigger(handle);
    }
    else
    {
        MbmEnqueue(&(wads_data.rx_queue), handle);
800114ce:	0e 9b       	mov	r11,r7
800114d0:	ec c7 ff f8 	sub	r7,r6,-8
800114d4:	0e 9c       	mov	r12,r7
800114d6:	fe b0 c6 f3 	rcall	8000a2bc <MbmEnqueue>
        #ifndef PACKET_COMMUNICATION_ONLY
        if(MNS_FALSE != wads_data.net_on)
800114da:	0d c9       	ld.ub	r9,r6[0x4]
800114dc:	30 08       	mov	r8,0
800114de:	f0 09 18 00 	cp.b	r9,r8
800114e2:	c0 80       	breq	800114f2 <DataRxTrigger+0x46>
static void DataSetPendingEvent(word event_flag)
{
    T_MOD_ENTRY(ADS_2);

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_ADS_PE,
800114e4:	ee ca 00 08 	sub	r10,r7,8
800114e8:	32 09       	mov	r9,32
800114ea:	30 eb       	mov	r11,14
800114ec:	30 1c       	mov	r12,1
800114ee:	fe b0 cf 47 	rcall	8000b37c <MnsSetPendingEventFlag>
800114f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        }
    }
    #endif

    #ifndef PACKET_COMMUNICATION_ONLY
    if ((MNS_FALSE != wads_data.cfg_ptr->rx_direct) && (MNS_FALSE != wads_data.net_on) && ((word)0 == MbmQueueLength(&(wads_data.rx_queue))))
800114f6:	ed 09 00 12 	ld.sh	r9,r6[18]
800114fa:	30 08       	mov	r8,0
800114fc:	f0 09 19 00 	cp.h	r9,r8
80011500:	ce 71       	brne	800114ce <DataRxTrigger+0x22>
    #else
    if ((MNS_FALSE != wads_data.cfg_ptr->rx_direct) && ((word)0 == MbmQueueLength(&(wads_data.rx_queue))))
    #endif
    {
        DataRxOutTrigger(handle);
80011502:	0e 9c       	mov	r12,r7
80011504:	c3 2f       	rcall	80011368 <DataRxOutTrigger>
80011506:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        }
    }
    #endif

    #ifndef PACKET_COMMUNICATION_ONLY
    if ((MNS_FALSE != wads_data.cfg_ptr->rx_direct) && (MNS_FALSE != wads_data.net_on) && ((word)0 == MbmQueueLength(&(wads_data.rx_queue))))
8001150a:	e0 68 01 82 	mov	r8,386

#ifdef ADS_8
void DataRxTrigger(HMBMBUF handle)
{
    T_MOD_ENTRY(ADS_8);
    ASSERT(handle);
8001150e:	30 1a       	mov	r10,1
80011510:	1a d8       	st.w	--sp,r8
80011512:	31 0b       	mov	r11,16
80011514:	32 0c       	mov	r12,32
80011516:	fe b0 b2 eb 	rcall	80007aec <mns_trace>
8001151a:	2f fd       	sub	sp,-4
8001151c:	cc db       	rjmp	800114b6 <DataRxTrigger+0xa>
8001151e:	d7 03       	nop
80011520:	00 00       	add	r0,r0
80011522:	3a 3c       	mov	r12,-93

80011524 <DataService>:
80011524:	eb cd 40 80 	pushm	r7,lr
80011528:	49 47       	lddpc	r7,80011578 <DataService+0x54>
8001152a:	30 18       	mov	r8,1
8001152c:	ee ca ff fe 	sub	r10,r7,-2
80011530:	10 99       	mov	r9,r8
80011532:	0e 9b       	mov	r11,r7
static word DataGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(ADS_3);
    result = MnsGetNextEventFlagToCall(MX_ADS_PE,
80011534:	30 ec       	mov	r12,14
80011536:	fe b0 ce 83 	rcall	8000b23c <MnsGetNextEventFlagToCall>
    event_to_handle = DataGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
8001153a:	30 18       	mov	r8,1
8001153c:	f0 0c 19 00 	cp.h	r12,r8
80011540:	c1 80       	breq	80011570 <DataService+0x4c>
                DataRxOutTrigger(NULL);
            #endif
            break;

        default:
            FAILED_ASSERT();
80011542:	e0 68 00 c4 	mov	r8,196
80011546:	30 1a       	mov	r10,1
80011548:	1a d8       	st.w	--sp,r8
8001154a:	31 0b       	mov	r11,16
8001154c:	32 0c       	mov	r12,32
8001154e:	fe b0 b2 cf 	rcall	80007aec <mns_trace>
80011552:	2f fd       	sub	sp,-4
            event_to_handle = ADS_P_NONE;
            break;
    }

    TAKE_EVENTS();
80011554:	30 ec       	mov	r12,14
80011556:	fe b0 b2 b0 	rcall	80007ab6 <mns_take>
    request_flag = (ADS_P_NONE != wads_data.pending_events) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
8001155a:	30 ec       	mov	r12,14
            event_to_handle = ADS_P_NONE;
            break;
    }

    TAKE_EVENTS();
    request_flag = (ADS_P_NONE != wads_data.pending_events) ? MNS_TRUE : MNS_FALSE;
8001155c:	8e 07       	ld.sh	r7,r7[0x0]
    GIVE_EVENTS();
8001155e:	fe b0 b2 ad 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != request_flag)
80011562:	58 07       	cp.w	r7,0
80011564:	c0 40       	breq	8001156c <DataService+0x48>
    {
        MnsSetPendingService(MNS_P_SRV_WADS);
80011566:	32 0c       	mov	r12,32
80011568:	fe b0 ce d0 	rcall	8000b308 <MnsSetPendingService>
8001156c:	e3 cd 80 80 	ldm	sp++,r7,pc

    switch (event_to_handle)
    {
        case ADS_P_RX:
            #ifdef ADS_9
                DataRxOutTrigger(NULL);
80011570:	30 0c       	mov	r12,0
80011572:	cf be       	rcall	80011368 <DataRxOutTrigger>
80011574:	cf 0b       	rjmp	80011554 <DataService+0x30>
            #endif
            break;
80011576:	d7 03       	nop
80011578:	00 00       	add	r0,r0
8001157a:	3a 3c       	mov	r12,-93

8001157c <DataInit>:
8001157c:	eb cd 40 c0 	pushm	r6-r7,lr
80011580:	18 96       	mov	r6,r12
80011582:	58 0c       	cp.w	r12,0
80011584:	c2 60       	breq	800115d0 <DataInit+0x54>
80011586:	49 87       	lddpc	r7,800115e4 <DataInit+0x68>
80011588:	8f 56       	st.w	r7[0x14],r6
8001158a:	30 08       	mov	r8,0
8001158c:	ed 39 00 0c 	ld.ub	r9,r6[12]
80011590:	f0 09 18 00 	cp.b	r9,r8

    wads_data.cfg_ptr = cfg_ptr;

    if ((byte)0 == wads_data.cfg_ptr->rx_burst)
    {
        wads_data.cfg_ptr->rx_burst = DATA_STD_RX_BURST;
80011594:	f9 b8 00 01 	moveq	r8,1
80011598:	ed f8 0e 0c 	st.beq	r6[0xc],r8
    }

    T_INIT();
8001159c:	30 0a       	mov	r10,0
8001159e:	30 7b       	mov	r11,7
800115a0:	32 0c       	mov	r12,32
800115a2:	fe b0 b2 a5 	rcall	80007aec <mns_trace>
    TAKE_EVENTS();
800115a6:	30 ec       	mov	r12,14
800115a8:	fe b0 b2 87 	rcall	80007ab6 <mns_take>
    wads_data.pending_events       = ADS_P_NONE;
800115ac:	30 08       	mov	r8,0
    wads_data.latest_handled_event = ADS_P_NONE;
    #ifndef PACKET_COMMUNICATION_ONLY
        wads_data.net_on           = MNS_FALSE;
    #endif
    GIVE_EVENTS();
800115ae:	30 ec       	mov	r12,14
    T_INIT();
    TAKE_EVENTS();
    wads_data.pending_events       = ADS_P_NONE;
    wads_data.latest_handled_event = ADS_P_NONE;
    #ifndef PACKET_COMMUNICATION_ONLY
        wads_data.net_on           = MNS_FALSE;
800115b0:	ae c8       	st.b	r7[0x4],r8
        wads_data.cfg_ptr->rx_burst = DATA_STD_RX_BURST;
    }

    T_INIT();
    TAKE_EVENTS();
    wads_data.pending_events       = ADS_P_NONE;
800115b2:	ae 08       	st.h	r7[0x0],r8
    wads_data.latest_handled_event = ADS_P_NONE;
800115b4:	ae 18       	st.h	r7[0x2],r8
    #ifndef PACKET_COMMUNICATION_ONLY
        wads_data.net_on           = MNS_FALSE;
    #endif
    GIVE_EVENTS();
800115b6:	fe b0 b2 81 	rcall	80007ab8 <mns_give>

    MbmQueueInit(&(wads_data.rx_queue), MX_ADS_RX_Q);
800115ba:	ee cc ff f8 	sub	r12,r7,-8
800115be:	30 fb       	mov	r11,15
800115c0:	fe b0 c6 aa 	rcall	8000a314 <MbmQueueInit>

    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_WADS);
800115c4:	32 0b       	mov	r11,32
800115c6:	30 2c       	mov	r12,2
800115c8:	fe b0 d1 7a 	rcall	8000b8bc <MnsServiceInitComplete>
    T_LIB_EXIT(ADS_0);
}
800115cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef ADS_0
void DataInit(struct TDataConfig *cfg_ptr)
{
    T_LIB_ENTRY(ADS_0);

    ASSERT(cfg_ptr);
800115d0:	e0 68 00 95 	mov	r8,149
800115d4:	30 1a       	mov	r10,1
800115d6:	1a d8       	st.w	--sp,r8
800115d8:	31 0b       	mov	r11,16
800115da:	32 0c       	mov	r12,32
800115dc:	fe b0 b2 88 	rcall	80007aec <mns_trace>
800115e0:	2f fd       	sub	sp,-4
800115e2:	cd 2b       	rjmp	80011586 <DataInit+0xa>
800115e4:	00 00       	add	r0,r0
800115e6:	3a 3c       	mov	r12,-93

800115e8 <WmcsHandleConfStringError>:
/*!
  * \brief      Internal helper function to parse INIC.ConfStringRead.Error
  * \param[in]  msg_ptr Pointer to the received message
  */
void WmcsHandleConfStringError(TMsgRx *msg_ptr)
{
800115e8:	eb cd 40 e0 	pushm	r5-r7,lr
800115ec:	18 97       	mov	r7,r12
    TMnsResult            result;
    TWmcsReadConfStringCB *cs_cb_ptr;

    T_MOD_ENTRY(WMCS_62);

    ASSERT(msg_ptr);
800115ee:	58 0c       	cp.w	r12,0
800115f0:	c3 00       	breq	80011650 <WmcsHandleConfStringError+0x68>

    result    = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);
800115f2:	6e 08       	ld.w	r8,r7[0x0]

    TAKE_WMCS();
800115f4:	31 3c       	mov	r12,19

    T_MOD_ENTRY(WMCS_62);

    ASSERT(msg_ptr);

    result    = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);
800115f6:	11 85       	ld.ub	r5,r8[0x0]

    TAKE_WMCS();
800115f8:	fe b0 b2 5f 	rcall	80007ab6 <mns_take>
    cs_cb_ptr = wmcs.memory.cs_cb_ptr;
    GIVE_WMCS();
800115fc:	31 3c       	mov	r12,19
    ASSERT(msg_ptr);

    result    = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);

    TAKE_WMCS();
    cs_cb_ptr = wmcs.memory.cs_cb_ptr;
800115fe:	49 a7       	lddpc	r7,80011664 <WmcsHandleConfStringError+0x7c>
80011600:	6e d6       	ld.w	r6,r7[0x34]
    GIVE_WMCS();
80011602:	fe b0 b2 5b 	rcall	80007ab8 <mns_give>

    if (cs_cb_ptr)
80011606:	58 06       	cp.w	r6,0
80011608:	c1 a0       	breq	8001163c <WmcsHandleConfStringError+0x54>
    {
        cs_cb_ptr(result, NULL, 0);
8001160a:	30 0a       	mov	r10,0
8001160c:	0a 9c       	mov	r12,r5
8001160e:	14 9b       	mov	r11,r10
80011610:	e8 1c a0 00 	orl	r12,0xa000
80011614:	5d 16       	icall	r6

        TAKE_WMCS();
80011616:	31 3c       	mov	r12,19
80011618:	fe b0 b2 4f 	rcall	80007ab6 <mns_take>
        wmcs.memory.cs_cb_ptr = NULL;
8001161c:	30 08       	mov	r8,0
        GIVE_WMCS();
8001161e:	31 3c       	mov	r12,19
    if (cs_cb_ptr)
    {
        cs_cb_ptr(result, NULL, 0);

        TAKE_WMCS();
        wmcs.memory.cs_cb_ptr = NULL;
80011620:	8f d8       	st.w	r7[0x34],r8
        GIVE_WMCS();
80011622:	fe b0 b2 4b 	rcall	80007ab8 <mns_give>
    else
    {
        FAILED_ASSERT();
    }

    TAKE_WMCS();
80011626:	31 3c       	mov	r12,19
80011628:	fe b0 b2 47 	rcall	80007ab6 <mns_take>
    wmcs.memory.pending   = MNS_FALSE;
8001162c:	30 08       	mov	r8,0
    GIVE_WMCS();
8001162e:	31 3c       	mov	r12,19
    {
        FAILED_ASSERT();
    }

    TAKE_WMCS();
    wmcs.memory.pending   = MNS_FALSE;
80011630:	ef 68 00 3d 	st.b	r7[61],r8
    GIVE_WMCS();
80011634:	fe b0 b2 42 	rcall	80007ab8 <mns_give>


    T_MOD_EXIT(WMCS_62);
}
80011638:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        wmcs.memory.cs_cb_ptr = NULL;
        GIVE_WMCS();
    }
    else
    {
        FAILED_ASSERT();
8001163c:	e0 68 0a 42 	mov	r8,2626
80011640:	31 0b       	mov	r11,16
80011642:	1a d8       	st.w	--sp,r8
80011644:	30 1a       	mov	r10,1
80011646:	16 9c       	mov	r12,r11
80011648:	fe b0 b2 52 	rcall	80007aec <mns_trace>
8001164c:	2f fd       	sub	sp,-4
8001164e:	ce cb       	rjmp	80011626 <WmcsHandleConfStringError+0x3e>
    TMnsResult            result;
    TWmcsReadConfStringCB *cs_cb_ptr;

    T_MOD_ENTRY(WMCS_62);

    ASSERT(msg_ptr);
80011650:	e0 68 0a 30 	mov	r8,2608
80011654:	31 0b       	mov	r11,16
80011656:	1a d8       	st.w	--sp,r8
80011658:	30 1a       	mov	r10,1
8001165a:	16 9c       	mov	r12,r11
8001165c:	fe b0 b2 48 	rcall	80007aec <mns_trace>
80011660:	2f fd       	sub	sp,-4
80011662:	cc 8b       	rjmp	800115f2 <WmcsHandleConfStringError+0xa>
80011664:	00 00       	add	r0,r0
80011666:	3a 54       	mov	r4,-91

80011668 <WmcsHandleConfStringResult>:
80011668:	eb cd 40 e0 	pushm	r5-r7,lr
8001166c:	18 97       	mov	r7,r12
8001166e:	58 0c       	cp.w	r12,0
80011670:	c2 b0       	breq	800116c6 <WmcsHandleConfStringResult+0x5e>
80011672:	6e 05       	ld.w	r5,r7[0x0]

    ASSERT(msg_ptr);

    src = &msg_ptr->Data[WMCS_MEMORY_OFFSET_ROM];

    TAKE_WMCS();
80011674:	31 3c       	mov	r12,19
80011676:	fe b0 b2 20 	rcall	80007ab6 <mns_take>
    tgt = wmcs.memory.conf_string;
    GIVE_WMCS();
8001167a:	31 3c       	mov	r12,19
    ASSERT(msg_ptr);

    src = &msg_ptr->Data[WMCS_MEMORY_OFFSET_ROM];

    TAKE_WMCS();
    tgt = wmcs.memory.conf_string;
8001167c:	49 d7       	lddpc	r7,800116f0 <WmcsHandleConfStringResult+0x88>
8001167e:	6e e6       	ld.w	r6,r7[0x38]
    GIVE_WMCS();
80011680:	fe b0 b2 1c 	rcall	80007ab8 <mns_give>
#ifdef WMCS_61
/*!
  * \brief      Internal helper function to parse INIC.ConfStringRead.Status
  * \param[in]  msg_ptr Pointer to the received message
  */
void WmcsHandleConfStringResult(TMsgRx *msg_ptr)
80011684:	ea c9 ff df 	sub	r9,r5,-33

    T_MOD_ENTRY(WMCS_61);

    ASSERT(msg_ptr);

    src = &msg_ptr->Data[WMCS_MEMORY_OFFSET_ROM];
80011688:	2f f5       	sub	r5,-1
    GIVE_WMCS();

    /* assemble ConfigurationString */
    for (i=0; i<INIC_MEM_CS_LEN; ++i)
    {
        *tgt++ = *src++;
8001168a:	0b 38       	ld.ub	r8,r5++
8001168c:	0c c8       	st.b	r6++,r8
    TAKE_WMCS();
    tgt = wmcs.memory.conf_string;
    GIVE_WMCS();

    /* assemble ConfigurationString */
    for (i=0; i<INIC_MEM_CS_LEN; ++i)
8001168e:	12 35       	cp.w	r5,r9
80011690:	cf d1       	brne	8001168a <WmcsHandleConfStringResult+0x22>
    {
        *tgt++ = *src++;
    }


    TAKE_WMCS();
80011692:	31 3c       	mov	r12,19
80011694:	fe b0 b2 11 	rcall	80007ab6 <mns_take>
    cb_ptr      = wmcs.memory.cs_cb_ptr;
    conf_string = (byte*)wmcs.memory.conf_string;
    GIVE_WMCS();
80011698:	31 3c       	mov	r12,19
        *tgt++ = *src++;
    }


    TAKE_WMCS();
    cb_ptr      = wmcs.memory.cs_cb_ptr;
8001169a:	6e d6       	ld.w	r6,r7[0x34]
    conf_string = (byte*)wmcs.memory.conf_string;
8001169c:	6e e5       	ld.w	r5,r7[0x38]
    GIVE_WMCS();
8001169e:	fe b0 b2 0d 	rcall	80007ab8 <mns_give>

    ASSERT(cb_ptr);
800116a2:	58 06       	cp.w	r6,0
800116a4:	c1 b0       	breq	800116da <WmcsHandleConfStringResult+0x72>

    if (cb_ptr)
    {
        cb_ptr(NSR_S_OK, conf_string,(byte)INIC_MEM_CS_LEN);
800116a6:	0a 9b       	mov	r11,r5
800116a8:	32 0a       	mov	r10,32
800116aa:	30 0c       	mov	r12,0
800116ac:	5d 16       	icall	r6
    }

    TAKE_WMCS();
800116ae:	31 3c       	mov	r12,19
800116b0:	fe b0 b2 03 	rcall	80007ab6 <mns_take>
    wmcs.memory.cs_cb_ptr = NULL;
800116b4:	30 08       	mov	r8,0
    wmcs.memory.pending   = MNS_FALSE;
    GIVE_WMCS();
800116b6:	31 3c       	mov	r12,19
        cb_ptr(NSR_S_OK, conf_string,(byte)INIC_MEM_CS_LEN);
    }

    TAKE_WMCS();
    wmcs.memory.cs_cb_ptr = NULL;
    wmcs.memory.pending   = MNS_FALSE;
800116b8:	ef 68 00 3d 	st.b	r7[61],r8
    {
        cb_ptr(NSR_S_OK, conf_string,(byte)INIC_MEM_CS_LEN);
    }

    TAKE_WMCS();
    wmcs.memory.cs_cb_ptr = NULL;
800116bc:	8f d8       	st.w	r7[0x34],r8
    wmcs.memory.pending   = MNS_FALSE;
    GIVE_WMCS();
800116be:	fe b0 b1 fd 	rcall	80007ab8 <mns_give>

    T_MOD_EXIT(WMCS_61);

}
800116c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    byte i;
    byte *conf_string;

    T_MOD_ENTRY(WMCS_61);

    ASSERT(msg_ptr);
800116c6:	e0 68 09 ff 	mov	r8,2559
800116ca:	31 0b       	mov	r11,16
800116cc:	1a d8       	st.w	--sp,r8
800116ce:	30 1a       	mov	r10,1
800116d0:	16 9c       	mov	r12,r11
800116d2:	fe b0 b2 0d 	rcall	80007aec <mns_trace>
800116d6:	2f fd       	sub	sp,-4
800116d8:	cc db       	rjmp	80011672 <WmcsHandleConfStringResult+0xa>
    TAKE_WMCS();
    cb_ptr      = wmcs.memory.cs_cb_ptr;
    conf_string = (byte*)wmcs.memory.conf_string;
    GIVE_WMCS();

    ASSERT(cb_ptr);
800116da:	e0 68 0a 13 	mov	r8,2579
800116de:	31 0b       	mov	r11,16
800116e0:	1a d8       	st.w	--sp,r8
800116e2:	30 1a       	mov	r10,1
800116e4:	16 9c       	mov	r12,r11
800116e6:	fe b0 b2 03 	rcall	80007aec <mns_trace>
800116ea:	2f fd       	sub	sp,-4
800116ec:	ce 1b       	rjmp	800116ae <WmcsHandleConfStringResult+0x46>
800116ee:	d7 03       	nop
800116f0:	00 00       	add	r0,r0
800116f2:	3a 54       	mov	r4,-91

800116f4 <WmcsHandlePacketRetryTimeError>:
800116f4:	eb cd 40 e0 	pushm	r5-r7,lr
800116f8:	18 97       	mov	r7,r12
800116fa:	58 0c       	cp.w	r12,0
800116fc:	c3 00       	breq	8001175c <WmcsHandlePacketRetryTimeError+0x68>
800116fe:	6e 08       	ld.w	r8,r7[0x0]
    T_MOD_ENTRY(WMCS_56);

    ASSERT(msg_ptr);
    result  = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);

    TAKE_WMCS();
80011700:	31 3c       	mov	r12,19
    TWmcsPacketRetryTimeCB *cb_ptr;

    T_MOD_ENTRY(WMCS_56);

    ASSERT(msg_ptr);
    result  = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);
80011702:	11 85       	ld.ub	r5,r8[0x0]

    TAKE_WMCS();
80011704:	fe b0 b1 d9 	rcall	80007ab6 <mns_take>
    cb_ptr = wmcs.packetretrytime.cb_ptr;
    GIVE_WMCS();
80011708:	31 3c       	mov	r12,19

    ASSERT(msg_ptr);
    result  = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);

    TAKE_WMCS();
    cb_ptr = wmcs.packetretrytime.cb_ptr;
8001170a:	49 a7       	lddpc	r7,80011770 <WmcsHandlePacketRetryTimeError+0x7c>
8001170c:	6f 06       	ld.w	r6,r7[0x40]
    GIVE_WMCS();
8001170e:	fe b0 b1 d5 	rcall	80007ab8 <mns_give>

    if (cb_ptr)                          /* call respective callback function */
80011712:	58 06       	cp.w	r6,0
80011714:	c1 a0       	breq	80011748 <WmcsHandlePacketRetryTimeError+0x54>
    {
        cb_ptr(result, 0);
80011716:	30 0b       	mov	r11,0
80011718:	0a 9c       	mov	r12,r5
8001171a:	e8 1c a0 00 	orl	r12,0xa000
8001171e:	5d 16       	icall	r6

        TAKE_WMCS();
80011720:	31 3c       	mov	r12,19
80011722:	fe b0 b1 ca 	rcall	80007ab6 <mns_take>
        wmcs.packetretrytime.cb_ptr = NULL;  /* for distinction in error case */
80011726:	30 08       	mov	r8,0
        GIVE_WMCS();
80011728:	31 3c       	mov	r12,19
    if (cb_ptr)                          /* call respective callback function */
    {
        cb_ptr(result, 0);

        TAKE_WMCS();
        wmcs.packetretrytime.cb_ptr = NULL;  /* for distinction in error case */
8001172a:	ef 48 00 40 	st.w	r7[64],r8
        GIVE_WMCS();
8001172e:	fe b0 b1 c5 	rcall	80007ab8 <mns_give>
    else                             /* error message without pending request */
    {
        FAILED_ASSERT();
    }

    TAKE_WMCS();
80011732:	31 3c       	mov	r12,19
80011734:	fe b0 b1 c1 	rcall	80007ab6 <mns_take>
    wmcs.packetretrytime.pending = MNS_FALSE;
80011738:	30 08       	mov	r8,0
    GIVE_WMCS();
8001173a:	31 3c       	mov	r12,19
    {
        FAILED_ASSERT();
    }

    TAKE_WMCS();
    wmcs.packetretrytime.pending = MNS_FALSE;
8001173c:	ef 68 00 44 	st.b	r7[68],r8
    GIVE_WMCS();
80011740:	fe b0 b1 bc 	rcall	80007ab8 <mns_give>

    T_MOD_EXIT(WMCS_56);
}
80011744:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        wmcs.packetretrytime.cb_ptr = NULL;  /* for distinction in error case */
        GIVE_WMCS();
    }
    else                             /* error message without pending request */
    {
        FAILED_ASSERT();
80011748:	e0 68 09 4f 	mov	r8,2383
8001174c:	31 0b       	mov	r11,16
8001174e:	1a d8       	st.w	--sp,r8
80011750:	30 1a       	mov	r10,1
80011752:	16 9c       	mov	r12,r11
80011754:	fe b0 b1 cc 	rcall	80007aec <mns_trace>
80011758:	2f fd       	sub	sp,-4
8001175a:	ce cb       	rjmp	80011732 <WmcsHandlePacketRetryTimeError+0x3e>
    TMnsResult             result;
    TWmcsPacketRetryTimeCB *cb_ptr;

    T_MOD_ENTRY(WMCS_56);

    ASSERT(msg_ptr);
8001175c:	e0 68 09 3e 	mov	r8,2366
80011760:	31 0b       	mov	r11,16
80011762:	1a d8       	st.w	--sp,r8
80011764:	30 1a       	mov	r10,1
80011766:	16 9c       	mov	r12,r11
80011768:	fe b0 b1 c2 	rcall	80007aec <mns_trace>
8001176c:	2f fd       	sub	sp,-4
8001176e:	cc 8b       	rjmp	800116fe <WmcsHandlePacketRetryTimeError+0xa>
80011770:	00 00       	add	r0,r0
80011772:	3a 54       	mov	r4,-91

80011774 <WmcsHandlePacketRetryTimeStatus>:
80011774:	eb cd 40 e0 	pushm	r5-r7,lr
80011778:	18 97       	mov	r7,r12
8001177a:	58 0c       	cp.w	r12,0
8001177c:	c1 60       	breq	800117a8 <WmcsHandlePacketRetryTimeStatus+0x34>
8001177e:	31 3c       	mov	r12,19

    T_MOD_ENTRY(WMCS_55);

    ASSERT(msg_ptr);

    TAKE_WMCS();
80011780:	fe b0 b1 9b 	rcall	80007ab6 <mns_take>
    cb_ptr = wmcs.packetretrytime.cb_ptr;
80011784:	48 e8       	lddpc	r8,800117bc <WmcsHandlePacketRetryTimeStatus+0x48>
    wmcs.packetretrytime.cb_ptr     = NULL;
80011786:	30 05       	mov	r5,0
    T_MOD_ENTRY(WMCS_55);

    ASSERT(msg_ptr);

    TAKE_WMCS();
    cb_ptr = wmcs.packetretrytime.cb_ptr;
80011788:	71 06       	ld.w	r6,r8[0x40]
    wmcs.packetretrytime.cb_ptr     = NULL;
    wmcs.packetretrytime.pending    = MNS_FALSE;
8001178a:	f1 65 00 44 	st.b	r8[68],r5

    ASSERT(msg_ptr);

    TAKE_WMCS();
    cb_ptr = wmcs.packetretrytime.cb_ptr;
    wmcs.packetretrytime.cb_ptr     = NULL;
8001178e:	f1 45 00 40 	st.w	r8[64],r5
    wmcs.packetretrytime.pending    = MNS_FALSE;
    GIVE_WMCS();
80011792:	31 3c       	mov	r12,19
80011794:	fe b0 b1 92 	rcall	80007ab8 <mns_give>

    if(cb_ptr)
80011798:	58 06       	cp.w	r6,0
8001179a:	c0 50       	breq	800117a4 <WmcsHandlePacketRetryTimeStatus+0x30>
    {
        cb_ptr(NSR_S_OK, msg_ptr->Data[0]);
8001179c:	6e 08       	ld.w	r8,r7[0x0]
8001179e:	0a 9c       	mov	r12,r5
800117a0:	11 8b       	ld.ub	r11,r8[0x0]
800117a2:	5d 16       	icall	r6
800117a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TWmcsPacketRetryTimeCB *cb_ptr;

    T_MOD_ENTRY(WMCS_55);

    ASSERT(msg_ptr);
800117a8:	e0 68 09 1a 	mov	r8,2330
800117ac:	31 0b       	mov	r11,16
800117ae:	1a d8       	st.w	--sp,r8
800117b0:	30 1a       	mov	r10,1
800117b2:	16 9c       	mov	r12,r11
800117b4:	fe b0 b1 9c 	rcall	80007aec <mns_trace>
800117b8:	2f fd       	sub	sp,-4
800117ba:	ce 2b       	rjmp	8001177e <WmcsHandlePacketRetryTimeStatus+0xa>
800117bc:	00 00       	add	r0,r0
800117be:	3a 54       	mov	r4,-91

800117c0 <WmcsHandleMemoryError>:
800117c0:	eb cd 40 e0 	pushm	r5-r7,lr
800117c4:	18 97       	mov	r7,r12
800117c6:	58 0c       	cp.w	r12,0
800117c8:	c3 00       	breq	80011828 <WmcsHandleMemoryError+0x68>
800117ca:	6e 08       	ld.w	r8,r7[0x0]
    T_MOD_ENTRY(WMCS_35);
    ASSERT(msg_ptr);

    result    = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);

    TAKE_WMCS();
800117cc:	31 3c       	mov	r12,19
    TWmcsReadConfStringCB  *cs_cb_ptr;

    T_MOD_ENTRY(WMCS_35);
    ASSERT(msg_ptr);

    result    = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);
800117ce:	11 85       	ld.ub	r5,r8[0x0]

    TAKE_WMCS();
800117d0:	fe b0 b1 73 	rcall	80007ab6 <mns_take>
    cs_cb_ptr = wmcs.memory.cs_cb_ptr;
    GIVE_WMCS();
800117d4:	31 3c       	mov	r12,19
    ASSERT(msg_ptr);

    result    = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);

    TAKE_WMCS();
    cs_cb_ptr = wmcs.memory.cs_cb_ptr;
800117d6:	49 a7       	lddpc	r7,8001183c <WmcsHandleMemoryError+0x7c>
800117d8:	6e d6       	ld.w	r6,r7[0x34]
    GIVE_WMCS();
800117da:	fe b0 b1 6f 	rcall	80007ab8 <mns_give>

    if (cs_cb_ptr)
800117de:	58 06       	cp.w	r6,0
800117e0:	c1 a0       	breq	80011814 <WmcsHandleMemoryError+0x54>
    {
        cs_cb_ptr(result, NULL, 0);
800117e2:	30 0a       	mov	r10,0
800117e4:	0a 9c       	mov	r12,r5
800117e6:	14 9b       	mov	r11,r10
800117e8:	e8 1c a0 00 	orl	r12,0xa000
800117ec:	5d 16       	icall	r6

        TAKE_WMCS();
800117ee:	31 3c       	mov	r12,19
800117f0:	fe b0 b1 63 	rcall	80007ab6 <mns_take>
        wmcs.memory.cs_cb_ptr = NULL;        /* for distinction in error case */
800117f4:	30 08       	mov	r8,0
        GIVE_WMCS();
800117f6:	31 3c       	mov	r12,19
    if (cs_cb_ptr)
    {
        cs_cb_ptr(result, NULL, 0);

        TAKE_WMCS();
        wmcs.memory.cs_cb_ptr = NULL;        /* for distinction in error case */
800117f8:	8f d8       	st.w	r7[0x34],r8
        GIVE_WMCS();
800117fa:	fe b0 b1 5f 	rcall	80007ab8 <mns_give>
    else  /* invalid UseCaseID, error message without pending request */
    {
        FAILED_ASSERT();
    }

    TAKE_WMCS();
800117fe:	31 3c       	mov	r12,19
80011800:	fe b0 b1 5b 	rcall	80007ab6 <mns_take>
    wmcs.memory.pending   = MNS_FALSE;
80011804:	30 08       	mov	r8,0
    GIVE_WMCS();
80011806:	31 3c       	mov	r12,19
    {
        FAILED_ASSERT();
    }

    TAKE_WMCS();
    wmcs.memory.pending   = MNS_FALSE;
80011808:	ef 68 00 3d 	st.b	r7[61],r8
    GIVE_WMCS();
8001180c:	fe b0 b1 56 	rcall	80007ab8 <mns_give>

    T_MOD_EXIT(WMCS_35);
}
80011810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        wmcs.memory.cs_cb_ptr = NULL;        /* for distinction in error case */
        GIVE_WMCS();
    }
    else  /* invalid UseCaseID, error message without pending request */
    {
        FAILED_ASSERT();
80011814:	e0 68 05 63 	mov	r8,1379
80011818:	31 0b       	mov	r11,16
8001181a:	1a d8       	st.w	--sp,r8
8001181c:	30 1a       	mov	r10,1
8001181e:	16 9c       	mov	r12,r11
80011820:	fe b0 b1 66 	rcall	80007aec <mns_trace>
80011824:	2f fd       	sub	sp,-4
80011826:	ce cb       	rjmp	800117fe <WmcsHandleMemoryError+0x3e>
{
    TMnsResult             result;
    TWmcsReadConfStringCB  *cs_cb_ptr;

    T_MOD_ENTRY(WMCS_35);
    ASSERT(msg_ptr);
80011828:	e0 68 05 51 	mov	r8,1361
8001182c:	31 0b       	mov	r11,16
8001182e:	1a d8       	st.w	--sp,r8
80011830:	30 1a       	mov	r10,1
80011832:	16 9c       	mov	r12,r11
80011834:	fe b0 b1 5c 	rcall	80007aec <mns_trace>
80011838:	2f fd       	sub	sp,-4
8001183a:	cc 8b       	rjmp	800117ca <WmcsHandleMemoryError+0xa>
8001183c:	00 00       	add	r0,r0
8001183e:	3a 54       	mov	r4,-91

80011840 <WmcsHandleCodingErrorsStatus>:
80011840:	eb cd 40 c0 	pushm	r6-r7,lr
80011844:	18 97       	mov	r7,r12
80011846:	58 0c       	cp.w	r12,0
80011848:	c1 90       	breq	8001187a <WmcsHandleCodingErrorsStatus+0x3a>
8001184a:	31 3c       	mov	r12,19

    T_LIB_ENTRY(WMCS_27);

    ASSERT(msg_ptr);

    TAKE_WMCS();
8001184c:	fe b0 b1 35 	rcall	80007ab6 <mns_take>
    cb_ptr = wmcs.coding_errors.cb_ptr;
80011850:	49 08       	lddpc	r8,80011890 <WmcsHandleCodingErrorsStatus+0x50>
    wmcs.coding_errors.cb_ptr     = NULL;
80011852:	30 09       	mov	r9,0
    T_LIB_ENTRY(WMCS_27);

    ASSERT(msg_ptr);

    TAKE_WMCS();
    cb_ptr = wmcs.coding_errors.cb_ptr;
80011854:	70 b6       	ld.w	r6,r8[0x2c]
    wmcs.coding_errors.cb_ptr     = NULL;
    wmcs.coding_errors.busy_reset = MNS_FALSE;
    GIVE_WMCS();
80011856:	31 3c       	mov	r12,19
    ASSERT(msg_ptr);

    TAKE_WMCS();
    cb_ptr = wmcs.coding_errors.cb_ptr;
    wmcs.coding_errors.cb_ptr     = NULL;
    wmcs.coding_errors.busy_reset = MNS_FALSE;
80011858:	f1 69 00 30 	st.b	r8[48],r9

    ASSERT(msg_ptr);

    TAKE_WMCS();
    cb_ptr = wmcs.coding_errors.cb_ptr;
    wmcs.coding_errors.cb_ptr     = NULL;
8001185c:	91 b9       	st.w	r8[0x2c],r9
    wmcs.coding_errors.busy_reset = MNS_FALSE;
    GIVE_WMCS();
8001185e:	fe b0 b1 2d 	rcall	80007ab8 <mns_give>

    if(cb_ptr)
80011862:	58 06       	cp.w	r6,0
80011864:	c0 90       	breq	80011876 <WmcsHandleCodingErrorsStatus+0x36>
    {
        cb_ptr(NSR_S_CE_INIC, (word)((msg_ptr->Data[0] << 8) | msg_ptr->Data[1]));
80011866:	6e 08       	ld.w	r8,r7[0x0]
80011868:	11 99       	ld.ub	r9,r8[0x1]
8001186a:	11 8b       	ld.ub	r11,r8[0x0]
8001186c:	e0 6c 01 01 	mov	r12,257
80011870:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
80011874:	5d 16       	icall	r6
80011876:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
{
    TWmcsCodingErrorCB *cb_ptr ;

    T_LIB_ENTRY(WMCS_27);

    ASSERT(msg_ptr);
8001187a:	e0 68 02 dd 	mov	r8,733
8001187e:	31 0b       	mov	r11,16
80011880:	1a d8       	st.w	--sp,r8
80011882:	30 1a       	mov	r10,1
80011884:	16 9c       	mov	r12,r11
80011886:	fe b0 b1 33 	rcall	80007aec <mns_trace>
8001188a:	2f fd       	sub	sp,-4
8001188c:	cd fb       	rjmp	8001184a <WmcsHandleCodingErrorsStatus+0xa>
8001188e:	d7 03       	nop
80011890:	00 00       	add	r0,r0
80011892:	3a 54       	mov	r4,-91

80011894 <MostCheckOwnAddress>:
80011894:	d4 21       	pushm	r4-r7,lr
80011896:	18 97       	mov	r7,r12
80011898:	31 3c       	mov	r12,19
8001189a:	fe b0 b1 0e 	rcall	80007ab6 <mns_take>
8001189e:	49 78       	lddpc	r8,800118f8 <MostCheckOwnAddress+0x64>

    TAKE_WMCS();
    node_addr  = wmcs.node_addr.value;
    node_pos   = wmcs.node_pos;
    group_addr = wmcs.group_addr.value;
    GIVE_WMCS();
800118a0:	31 3c       	mov	r12,19
    result = MOST_CHECK_ADDR_NONE;

    TAKE_WMCS();
    node_addr  = wmcs.node_addr.value;
    node_pos   = wmcs.node_pos;
    group_addr = wmcs.group_addr.value;
800118a2:	f1 34 00 0c 	ld.ub	r4,r8[12]
    T_LIB_ENTRY(WMCS_11);

    result = MOST_CHECK_ADDR_NONE;

    TAKE_WMCS();
    node_addr  = wmcs.node_addr.value;
800118a6:	90 46       	ld.sh	r6,r8[0x8]
    node_pos   = wmcs.node_pos;
800118a8:	11 c5       	ld.ub	r5,r8[0x4]
    group_addr = wmcs.group_addr.value;
    GIVE_WMCS();
800118aa:	fe b0 b1 07 	rcall	80007ab8 <mns_give>

    if (MSG_TGT_EHC == address)
800118ae:	58 07       	cp.w	r7,0
800118b0:	c1 a0       	breq	800118e4 <MostCheckOwnAddress+0x50>
    {
        result = MOST_CHECK_ADDR_INTERN;
    }
    else if (node_addr == address)
800118b2:	ee 06 19 00 	cp.h	r6,r7
800118b6:	c1 90       	breq	800118e8 <MostCheckOwnAddress+0x54>
    {
        result = MOST_CHECK_ADDR_NODE;
    }
    else if ((0x400 + node_pos) == address)
800118b8:	0e 98       	mov	r8,r7
800118ba:	ea c5 fc 00 	sub	r5,r5,-1024
800118be:	5c 78       	castu.h	r8
800118c0:	10 35       	cp.w	r5,r8
800118c2:	c1 70       	breq	800118f0 <MostCheckOwnAddress+0x5c>
    {
        result = MOST_CHECK_ADDR_POS;
    }
    else if ((0x300 + group_addr) == address)
800118c4:	e8 c4 fd 00 	sub	r4,r4,-768
800118c8:	08 38       	cp.w	r8,r4
800118ca:	c1 50       	breq	800118f4 <MostCheckOwnAddress+0x60>
    {
        result = MOST_CHECK_ADDR_GROUP;
    }
    else if (MSG_TGT_BROADCAST_BLOCKING == address)
800118cc:	e0 68 03 c8 	mov	r8,968
800118d0:	f0 07 19 00 	cp.h	r7,r8
800118d4:	c0 c0       	breq	800118ec <MostCheckOwnAddress+0x58>
    {
        result = MOST_CHECK_ADDR_BROADCAST;
    }
    else if (MSG_TGT_BROADCAST_UNBLOCKING == address)
800118d6:	e0 68 03 ff 	mov	r8,1023
800118da:	f0 07 19 00 	cp.h	r7,r8
800118de:	c0 70       	breq	800118ec <MostCheckOwnAddress+0x58>
800118e0:	31 0c       	mov	r12,16
800118e2:	d8 22       	popm	r4-r7,pc
    node_addr  = wmcs.node_addr.value;
    node_pos   = wmcs.node_pos;
    group_addr = wmcs.group_addr.value;
    GIVE_WMCS();

    if (MSG_TGT_EHC == address)
800118e4:	32 8c       	mov	r12,40
800118e6:	d8 22       	popm	r4-r7,pc
    {
        result = MOST_CHECK_ADDR_INTERN;
    }
    else if (node_addr == address)
800118e8:	32 0c       	mov	r12,32
800118ea:	d8 22       	popm	r4-r7,pc
    }
    else if (MSG_TGT_BROADCAST_BLOCKING == address)
    {
        result = MOST_CHECK_ADDR_BROADCAST;
    }
    else if (MSG_TGT_BROADCAST_UNBLOCKING == address)
800118ec:	33 2c       	mov	r12,50
        result = MOST_CHECK_ADDR_BROADCAST;
    }

    T_LIB_EXIT(WMCS_11);
    return (result);
}
800118ee:	d8 22       	popm	r4-r7,pc
    }
    else if (node_addr == address)
    {
        result = MOST_CHECK_ADDR_NODE;
    }
    else if ((0x400 + node_pos) == address)
800118f0:	32 1c       	mov	r12,33
800118f2:	d8 22       	popm	r4-r7,pc
    {
        result = MOST_CHECK_ADDR_POS;
    }
    else if ((0x300 + group_addr) == address)
800118f4:	33 3c       	mov	r12,51
800118f6:	d8 22       	popm	r4-r7,pc
800118f8:	00 00       	add	r0,r0
800118fa:	3a 54       	mov	r4,-91

800118fc <MostGetNodePos>:
800118fc:	eb cd 40 80 	pushm	r7,lr
80011900:	31 3c       	mov	r12,19
80011902:	fe b0 b0 da 	rcall	80007ab6 <mns_take>
{
    byte result;

    T_API_ENTRY(WMCS_5);
    TAKE_WMCS();
    result = wmcs.node_pos;
80011906:	48 58       	lddpc	r8,80011918 <MostGetNodePos+0x1c>
    GIVE_WMCS();
80011908:	31 3c       	mov	r12,19
{
    byte result;

    T_API_ENTRY(WMCS_5);
    TAKE_WMCS();
    result = wmcs.node_pos;
8001190a:	11 c7       	ld.ub	r7,r8[0x4]
    GIVE_WMCS();
8001190c:	fe b0 b0 d6 	rcall	80007ab8 <mns_give>
    T_API_EXIT(WMCS_5);

    return(result);
}
80011910:	0e 9c       	mov	r12,r7
80011912:	e3 cd 80 80 	ldm	sp++,r7,pc
80011916:	d7 03       	nop
80011918:	00 00       	add	r0,r0
8001191a:	3a 54       	mov	r4,-91

8001191c <MostGetNodeAdr>:
8001191c:	eb cd 40 80 	pushm	r7,lr
80011920:	31 3c       	mov	r12,19
80011922:	fe b0 b0 ca 	rcall	80007ab6 <mns_take>
{
    word result;

    T_API_ENTRY(WMCS_4);
    TAKE_WMCS();
    result = wmcs.node_addr.value;
80011926:	48 58       	lddpc	r8,80011938 <MostGetNodeAdr+0x1c>
    GIVE_WMCS();
80011928:	31 3c       	mov	r12,19
{
    word result;

    T_API_ENTRY(WMCS_4);
    TAKE_WMCS();
    result = wmcs.node_addr.value;
8001192a:	90 47       	ld.sh	r7,r8[0x8]
    GIVE_WMCS();
8001192c:	fe b0 b0 c6 	rcall	80007ab8 <mns_give>
    T_API_EXIT(WMCS_4);

    return(result);
}
80011930:	0e 9c       	mov	r12,r7
80011932:	e3 cd 80 80 	ldm	sp++,r7,pc
80011936:	d7 03       	nop
80011938:	00 00       	add	r0,r0
8001193a:	3a 54       	mov	r4,-91

8001193c <WmcsHandleMemoryStatus>:
8001193c:	eb cd 40 f8 	pushm	r3-r7,lr
80011940:	18 97       	mov	r7,r12
80011942:	58 0c       	cp.w	r12,0
{
    dword use_case_id;

    T_MOD_ENTRY(WMCS_34);

    ASSERT(msg_ptr);
80011944:	e0 80 00 98 	breq	80011a74 <WmcsHandleMemoryStatus+0x138>

    use_case_id =     (dword)((dword)msg_ptr->Data[0] << 24L)
80011948:	6e 05       	ld.w	r5,r7[0x0]
8001194a:	0b b8       	ld.ub	r8,r5[0x3]
8001194c:	0b 84       	ld.ub	r4,r5[0x0]
8001194e:	b9 64       	lsl	r4,0x18
80011950:	f0 04 00 04 	add	r4,r8,r4
80011954:	0b 98       	ld.ub	r8,r5[0x1]
80011956:	b1 68       	lsl	r8,0x10
80011958:	10 04       	add	r4,r8
8001195a:	0b a8       	ld.ub	r8,r5[0x2]
8001195c:	a9 68       	lsl	r8,0x8
                    + (dword)((dword)msg_ptr->Data[1] << 16L)
                    + (dword)((dword)msg_ptr->Data[2] <<  8L)
                    + (dword)((dword)msg_ptr->Data[3]);

    if (INIC_MEM_CONF_STRING == (use_case_id & 0xFFFFFF00))  /* Conf. String request */
8001195e:	fc 19 01 02 	movh	r9,0x102

    T_MOD_ENTRY(WMCS_34);

    ASSERT(msg_ptr);

    use_case_id =     (dword)((dword)msg_ptr->Data[0] << 24L)
80011962:	10 04       	add	r4,r8
                    + (dword)((dword)msg_ptr->Data[1] << 16L)
                    + (dword)((dword)msg_ptr->Data[2] <<  8L)
                    + (dword)((dword)msg_ptr->Data[3]);

    if (INIC_MEM_CONF_STRING == (use_case_id & 0xFFFFFF00))  /* Conf. String request */
80011964:	08 98       	mov	r8,r4
80011966:	e0 18 ff 00 	andl	r8,0xff00
8001196a:	12 38       	cp.w	r8,r9
8001196c:	c1 70       	breq	8001199a <WmcsHandleMemoryStatus+0x5e>
        }

    }
    else                                                 /* invalid UseCaseID */
    {
        FAILED_ASSERT();
8001196e:	e0 68 05 37 	mov	r8,1335
80011972:	31 0b       	mov	r11,16
80011974:	1a d8       	st.w	--sp,r8
80011976:	16 9c       	mov	r12,r11
80011978:	30 1a       	mov	r10,1
8001197a:	fe b0 b0 b9 	rcall	80007aec <mns_trace>
        TAKE_WMCS();
8001197e:	31 3c       	mov	r12,19
80011980:	fe b0 b0 9b 	rcall	80007ab6 <mns_take>
        wmcs.memory.cs_cb_ptr = NULL;
80011984:	4d 08       	lddpc	r8,80011ac4 <WmcsHandleMemoryStatus+0x188>
80011986:	30 09       	mov	r9,0
        wmcs.memory.pending   = MNS_FALSE;
        GIVE_WMCS();
80011988:	31 3c       	mov	r12,19
    else                                                 /* invalid UseCaseID */
    {
        FAILED_ASSERT();
        TAKE_WMCS();
        wmcs.memory.cs_cb_ptr = NULL;
        wmcs.memory.pending   = MNS_FALSE;
8001198a:	f1 69 00 3d 	st.b	r8[61],r9
    }
    else                                                 /* invalid UseCaseID */
    {
        FAILED_ASSERT();
        TAKE_WMCS();
        wmcs.memory.cs_cb_ptr = NULL;
8001198e:	91 d9       	st.w	r8[0x34],r9
        wmcs.memory.pending   = MNS_FALSE;
        GIVE_WMCS();
80011990:	fe b0 b0 94 	rcall	80007ab8 <mns_give>
80011994:	2f fd       	sub	sp,-4
80011996:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
        byte *tgt;
        byte cs_msg_num;
        byte i;

        src = &msg_ptr->Data[WMCS_MEMORY_OFFSET];
        TAKE_WMCS();
8001199a:	31 3c       	mov	r12,19
8001199c:	fe b0 b0 8d 	rcall	80007ab6 <mns_take>
        tgt = wmcs.memory.conf_string + (byte)(use_case_id & 0xFF);
800119a0:	08 98       	mov	r8,r4
800119a2:	5c 58       	castu.b	r8
800119a4:	4c 87       	lddpc	r7,80011ac4 <WmcsHandleMemoryStatus+0x188>
        GIVE_WMCS();
800119a6:	31 3c       	mov	r12,19
        byte cs_msg_num;
        byte i;

        src = &msg_ptr->Data[WMCS_MEMORY_OFFSET];
        TAKE_WMCS();
        tgt = wmcs.memory.conf_string + (byte)(use_case_id & 0xFF);
800119a8:	6e e6       	ld.w	r6,r7[0x38]
800119aa:	10 06       	add	r6,r8
        GIVE_WMCS();
800119ac:	fe b0 b0 86 	rcall	80007ab8 <mns_give>
  * @updated    11/20/2006
  * @version    2.1.1
  *
  * @return     nothing
  */
void WmcsHandleMemoryStatus(TMsgRx *msg_ptr)
800119b0:	ea c9 ff db 	sub	r9,r5,-37
        byte *src;
        byte *tgt;
        byte cs_msg_num;
        byte i;

        src = &msg_ptr->Data[WMCS_MEMORY_OFFSET];
800119b4:	2f b5       	sub	r5,-5
        GIVE_WMCS();

        /* assemble ConfigurationString */
        for (i=0; i<INIC_MEM_CS_LEN; ++i)
        {
            *tgt++ = *src++;
800119b6:	0b 38       	ld.ub	r8,r5++
800119b8:	0c c8       	st.b	r6++,r8
        TAKE_WMCS();
        tgt = wmcs.memory.conf_string + (byte)(use_case_id & 0xFF);
        GIVE_WMCS();

        /* assemble ConfigurationString */
        for (i=0; i<INIC_MEM_CS_LEN; ++i)
800119ba:	12 35       	cp.w	r5,r9
800119bc:	cf d1       	brne	800119b6 <WmcsHandleMemoryStatus+0x7a>
        {
            *tgt++ = *src++;
        }
        TAKE_WMCS();
800119be:	31 3c       	mov	r12,19
800119c0:	fe b0 b0 7b 	rcall	80007ab6 <mns_take>
        cs_msg_num = wmcs.memory.cs_msg_num;
        GIVE_WMCS();
800119c4:	31 3c       	mov	r12,19
        for (i=0; i<INIC_MEM_CS_LEN; ++i)
        {
            *tgt++ = *src++;
        }
        TAKE_WMCS();
        cs_msg_num = wmcs.memory.cs_msg_num;
800119c6:	ef 33 00 3c 	ld.ub	r3,r7[60]
        GIVE_WMCS();
800119ca:	fe b0 b0 77 	rcall	80007ab8 <mns_give>

        ++cs_msg_num;
800119ce:	2f f3       	sub	r3,-1
        for (i=0; i<INIC_MEM_CS_LEN; ++i)
        {
            *tgt++ = *src++;
        }
        TAKE_WMCS();
        cs_msg_num = wmcs.memory.cs_msg_num;
800119d0:	4b d6       	lddpc	r6,80011ac4 <WmcsHandleMemoryStatus+0x188>
        GIVE_WMCS();

        ++cs_msg_num;
800119d2:	5c 53       	castu.b	r3
        if (NUM_CS_SEGMENTS > cs_msg_num) /* more segments to be requested? */
800119d4:	30 18       	mov	r8,1
800119d6:	f0 03 18 00 	cp.b	r3,r8
800119da:	e0 88 00 1e 	brls	80011a16 <WmcsHandleMemoryStatus+0xda>
        {
            TWmcsReadConfStringCB   *cb_ptr = NULL;
            byte *conf_string;
            dword len;

            TAKE_WMCS();
800119de:	31 3c       	mov	r12,19
800119e0:	fe b0 b0 6b 	rcall	80007ab6 <mns_take>
            cb_ptr      = wmcs.memory.cs_cb_ptr;
            conf_string = (byte*)wmcs.memory.conf_string;
            len         = use_case_id;
            len        += INIC_MEM_CS_LEN;
            len        -= INIC_MEM_CONF_STRING;
            GIVE_WMCS();
800119e4:	31 3c       	mov	r12,19
            byte *conf_string;
            dword len;

            TAKE_WMCS();
            cb_ptr      = wmcs.memory.cs_cb_ptr;
            conf_string = (byte*)wmcs.memory.conf_string;
800119e6:	6c e5       	ld.w	r5,r6[0x38]
            TWmcsReadConfStringCB   *cb_ptr = NULL;
            byte *conf_string;
            dword len;

            TAKE_WMCS();
            cb_ptr      = wmcs.memory.cs_cb_ptr;
800119e8:	6c d6       	ld.w	r6,r6[0x34]
            conf_string = (byte*)wmcs.memory.conf_string;
            len         = use_case_id;
            len        += INIC_MEM_CS_LEN;
            len        -= INIC_MEM_CONF_STRING;
            GIVE_WMCS();
800119ea:	fe b0 b0 67 	rcall	80007ab8 <mns_give>

            ASSERT(cb_ptr);
800119ee:	58 06       	cp.w	r6,0
800119f0:	c4 c0       	breq	80011a88 <WmcsHandleMemoryStatus+0x14c>

            if (cb_ptr)
            {
                cb_ptr(NSR_S_OK, conf_string,(byte)len);
800119f2:	08 9a       	mov	r10,r4
800119f4:	0a 9b       	mov	r11,r5
800119f6:	2e 0a       	sub	r10,-32
800119f8:	30 0c       	mov	r12,0
800119fa:	5c 5a       	castu.b	r10
800119fc:	5d 16       	icall	r6
            }

            TAKE_WMCS();
800119fe:	31 3c       	mov	r12,19
80011a00:	fe b0 b0 5b 	rcall	80007ab6 <mns_take>
            wmcs.memory.cs_cb_ptr = NULL;    /* for distinction in error case */
80011a04:	30 08       	mov	r8,0
            wmcs.memory.pending   = MNS_FALSE;
            GIVE_WMCS();
80011a06:	31 3c       	mov	r12,19
                cb_ptr(NSR_S_OK, conf_string,(byte)len);
            }

            TAKE_WMCS();
            wmcs.memory.cs_cb_ptr = NULL;    /* for distinction in error case */
            wmcs.memory.pending   = MNS_FALSE;
80011a08:	ef 68 00 3d 	st.b	r7[61],r8
            {
                cb_ptr(NSR_S_OK, conf_string,(byte)len);
            }

            TAKE_WMCS();
            wmcs.memory.cs_cb_ptr = NULL;    /* for distinction in error case */
80011a0c:	8f d8       	st.w	r7[0x34],r8
            wmcs.memory.pending   = MNS_FALSE;
            GIVE_WMCS();
80011a0e:	fe b0 b0 55 	rcall	80007ab8 <mns_give>
80011a12:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
        if (NUM_CS_SEGMENTS > cs_msg_num) /* more segments to be requested? */
        {
            TMsgTx *tx_ptr;
            dword  mem_addr = use_case_id + INIC_MEM_CS_LEN;

            tx_ptr = MsgGetTxPtrExt(5);
80011a16:	30 5c       	mov	r12,5
80011a18:	fe b0 ba 42 	rcall	80008e9c <MsgGetTxPtrExt>
80011a1c:	18 95       	mov	r5,r12
            if (tx_ptr)
80011a1e:	c3 f0       	breq	80011a9c <WmcsHandleMemoryStatus+0x160>
            {
                tx_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011a20:	30 18       	mov	r8,1
                tx_ptr->FBlock_ID = FBLOCK_INIC;
                tx_ptr->Inst_ID   = 0;
                tx_ptr->Func_ID   = FUNCID_INIC_MEMORY;
                tx_ptr->Operation = OP_GET;
80011a22:	f9 68 00 0c 	st.b	r12[12],r8
            dword  mem_addr = use_case_id + INIC_MEM_CS_LEN;

            tx_ptr = MsgGetTxPtrExt(5);
            if (tx_ptr)
            {
                tx_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011a26:	b8 38       	st.h	r12[0x6],r8
                tx_ptr->FBlock_ID = FBLOCK_INIC;
80011a28:	30 08       	mov	r8,0
                tx_ptr->Inst_ID   = 0;
80011a2a:	f9 68 00 0b 	st.b	r12[11],r8

            tx_ptr = MsgGetTxPtrExt(5);
            if (tx_ptr)
            {
                tx_ptr->Tgt_Adr   = MSG_TGT_INIC;
                tx_ptr->FBlock_ID = FBLOCK_INIC;
80011a2e:	f9 68 00 0a 	st.b	r12[10],r8
                tx_ptr->Inst_ID   = 0;
                tx_ptr->Func_ID   = FUNCID_INIC_MEMORY;
80011a32:	e0 68 0e 00 	mov	r8,3584
80011a36:	b8 48       	st.h	r12[0x8],r8
                tx_ptr->Operation = OP_GET;
                tx_ptr->Data[0]   = (byte)((mem_addr >> 24) & 0x000000FF);
80011a38:	78 08       	ld.w	r8,r12[0x0]

        ++cs_msg_num;
        if (NUM_CS_SEGMENTS > cs_msg_num) /* more segments to be requested? */
        {
            TMsgTx *tx_ptr;
            dword  mem_addr = use_case_id + INIC_MEM_CS_LEN;
80011a3a:	2e 04       	sub	r4,-32
                tx_ptr->Tgt_Adr   = MSG_TGT_INIC;
                tx_ptr->FBlock_ID = FBLOCK_INIC;
                tx_ptr->Inst_ID   = 0;
                tx_ptr->Func_ID   = FUNCID_INIC_MEMORY;
                tx_ptr->Operation = OP_GET;
                tx_ptr->Data[0]   = (byte)((mem_addr >> 24) & 0x000000FF);
80011a3c:	e8 09 16 18 	lsr	r9,r4,0x18
80011a40:	b0 89       	st.b	r8[0x0],r9
                tx_ptr->Data[1]   = (byte)((mem_addr >> 16) & 0x000000FF);
80011a42:	78 08       	ld.w	r8,r12[0x0]
80011a44:	e8 09 16 10 	lsr	r9,r4,0x10
80011a48:	b0 99       	st.b	r8[0x1],r9
                tx_ptr->Data[2]   = (byte)((mem_addr >>  8) & 0x000000FF);
80011a4a:	78 08       	ld.w	r8,r12[0x0]
80011a4c:	e8 09 16 08 	lsr	r9,r4,0x8
80011a50:	b0 a9       	st.b	r8[0x2],r9
                tx_ptr->Data[3]   = (byte) (mem_addr        & 0x000000FF);
80011a52:	78 08       	ld.w	r8,r12[0x0]
                tx_ptr->Data[4]   = INIC_MEM_CS_LEN;
80011a54:	32 09       	mov	r9,32
                tx_ptr->Func_ID   = FUNCID_INIC_MEMORY;
                tx_ptr->Operation = OP_GET;
                tx_ptr->Data[0]   = (byte)((mem_addr >> 24) & 0x000000FF);
                tx_ptr->Data[1]   = (byte)((mem_addr >> 16) & 0x000000FF);
                tx_ptr->Data[2]   = (byte)((mem_addr >>  8) & 0x000000FF);
                tx_ptr->Data[3]   = (byte) (mem_addr        & 0x000000FF);
80011a56:	b0 b4       	st.b	r8[0x3],r4
                tx_ptr->Data[4]   = INIC_MEM_CS_LEN;
80011a58:	78 08       	ld.w	r8,r12[0x0]
80011a5a:	b0 c9       	st.b	r8[0x4],r9

                MsgSend3(tx_ptr);  /* request next ConfigString segment */
80011a5c:	fe b0 bd 64 	rcall	80009524 <MsgSend3>

                TAKE_WMCS();
80011a60:	31 3c       	mov	r12,19
80011a62:	fe b0 b0 2a 	rcall	80007ab6 <mns_take>
                wmcs.memory.cs_msg_num = cs_msg_num;
                GIVE_WMCS();
80011a66:	31 3c       	mov	r12,19
                tx_ptr->Data[4]   = INIC_MEM_CS_LEN;

                MsgSend3(tx_ptr);  /* request next ConfigString segment */

                TAKE_WMCS();
                wmcs.memory.cs_msg_num = cs_msg_num;
80011a68:	ed 63 00 3c 	st.b	r6[60],r3
                GIVE_WMCS();
80011a6c:	fe b0 b0 26 	rcall	80007ab8 <mns_give>
80011a70:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
{
    dword use_case_id;

    T_MOD_ENTRY(WMCS_34);

    ASSERT(msg_ptr);
80011a74:	e0 68 04 cd 	mov	r8,1229
80011a78:	31 0b       	mov	r11,16
80011a7a:	1a d8       	st.w	--sp,r8
80011a7c:	30 1a       	mov	r10,1
80011a7e:	16 9c       	mov	r12,r11
80011a80:	fe b0 b0 36 	rcall	80007aec <mns_trace>
80011a84:	2f fd       	sub	sp,-4
80011a86:	c6 1b       	rjmp	80011948 <WmcsHandleMemoryStatus+0xc>
            len         = use_case_id;
            len        += INIC_MEM_CS_LEN;
            len        -= INIC_MEM_CONF_STRING;
            GIVE_WMCS();

            ASSERT(cb_ptr);
80011a88:	31 0b       	mov	r11,16
80011a8a:	e0 68 05 27 	mov	r8,1319
80011a8e:	1a d8       	st.w	--sp,r8
80011a90:	30 1a       	mov	r10,1
80011a92:	16 9c       	mov	r12,r11
80011a94:	fe b0 b0 2c 	rcall	80007aec <mns_trace>
80011a98:	2f fd       	sub	sp,-4
80011a9a:	cb 2b       	rjmp	800119fe <WmcsHandleMemoryStatus+0xc2>
            }
            else
            {
                TWmcsReadConfStringCB   *cb_ptr = NULL;

                TAKE_WMCS();
80011a9c:	31 3c       	mov	r12,19
80011a9e:	fe b0 b0 0c 	rcall	80007ab6 <mns_take>
                cb_ptr      = wmcs.memory.cs_cb_ptr;
                GIVE_WMCS();
80011aa2:	31 3c       	mov	r12,19
            else
            {
                TWmcsReadConfStringCB   *cb_ptr = NULL;

                TAKE_WMCS();
                cb_ptr      = wmcs.memory.cs_cb_ptr;
80011aa4:	6c d6       	ld.w	r6,r6[0x34]
                GIVE_WMCS();
80011aa6:	fe b0 b0 09 	rcall	80007ab8 <mns_give>

                ASSERT(cb_ptr);
80011aaa:	58 06       	cp.w	r6,0
80011aac:	c0 70       	breq	80011aba <WmcsHandleMemoryStatus+0x17e>

                if (cb_ptr)
                {
                    cb_ptr(NSR_E_MEMORY_BUF_OV, NULL, 0);
80011aae:	0a 9a       	mov	r10,r5
80011ab0:	e0 6c c8 01 	mov	r12,51201
80011ab4:	0a 9b       	mov	r11,r5
80011ab6:	5d 16       	icall	r6
80011ab8:	ca 3b       	rjmp	800119fe <WmcsHandleMemoryStatus+0xc2>

                TAKE_WMCS();
                cb_ptr      = wmcs.memory.cs_cb_ptr;
                GIVE_WMCS();

                ASSERT(cb_ptr);
80011aba:	31 0b       	mov	r11,16
80011abc:	e0 68 05 0b 	mov	r8,1291
80011ac0:	ce 7b       	rjmp	80011a8e <WmcsHandleMemoryStatus+0x152>
80011ac2:	d7 03       	nop
80011ac4:	00 00       	add	r0,r0
80011ac6:	3a 54       	mov	r4,-91

80011ac8 <WmcsRequestCodingErrors>:
80011ac8:	d4 01       	pushm	lr
80011aca:	30 0c       	mov	r12,0
80011acc:	fe b0 b9 e8 	rcall	80008e9c <MsgGetTxPtrExt>
80011ad0:	c0 d0       	breq	80011aea <WmcsRequestCodingErrors+0x22>
80011ad2:	30 09       	mov	r9,0
80011ad4:	f9 69 00 0a 	st.b	r12[10],r9
80011ad8:	e0 69 05 0d 	mov	r9,1293
    msg_ptr = MsgGetTxPtrExt(0);

    if (msg_ptr)
    {
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Func_ID   = FUNCID_INIC_NUMCODINGERRORS;
80011adc:	b8 49       	st.h	r12[0x8],r9
        msg_ptr->Operation = OP_GET;
80011ade:	30 19       	mov	r9,1
80011ae0:	f9 69 00 0c 	st.b	r12[12],r9

        MsgSend3(msg_ptr);
80011ae4:	fe b0 bd 20 	rcall	80009524 <MsgSend3>
80011ae8:	d8 0a       	popm	pc,r12=0
    }
    else
    {
        SCHEDULE_RETRY(WMCS_RETRY_REQUEST_CODINGERR);
80011aea:	31 2c       	mov	r12,18
80011aec:	fe b0 af e5 	rcall	80007ab6 <mns_take>
80011af0:	48 59       	lddpc	r9,80011b04 <WmcsRequestCodingErrors+0x3c>
80011af2:	92 38       	ld.sh	r8,r9[0x6]
80011af4:	a1 b8       	sbr	r8,0x1
80011af6:	31 2c       	mov	r12,18
80011af8:	b2 38       	st.h	r9[0x6],r8
80011afa:	fe b0 af df 	rcall	80007ab8 <mns_give>
80011afe:	30 4c       	mov	r12,4
        result = ERR_BUFOV;
    }

    T_MOD_EXIT(WMCS_26);
    return(result);
}
80011b00:	d8 02       	popm	pc
80011b02:	d7 03       	nop
80011b04:	00 00       	add	r0,r0
80011b06:	3a 54       	mov	r4,-91

80011b08 <MostGetCodingErrors>:
80011b08:	d4 21       	pushm	r4-r7,lr
80011b0a:	4b 46       	lddpc	r6,80011bd8 <MostGetCodingErrors+0xd0>
80011b0c:	18 97       	mov	r7,r12
80011b0e:	31 3c       	mov	r12,19
80011b10:	fe b0 af d3 	rcall	80007ab6 <mns_take>
80011b14:	6c b5       	ld.w	r5,r6[0x2c]
80011b16:	58 05       	cp.w	r5,0
    T_API_ENTRY(WMCS_28);

    result = ERR_NO;

    TAKE_WMCS();
    busy = (wmcs.coding_errors.cb_ptr || (MNS_FALSE != wmcs.coding_errors.busy_reset)) ? MNS_TRUE : MNS_FALSE;
80011b18:	c0 c0       	breq	80011b30 <MostGetCodingErrors+0x28>
    GIVE_WMCS();
80011b1a:	31 3c       	mov	r12,19
80011b1c:	fe b0 af ce 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != busy)
    {
        if (cb_ptr)
80011b20:	58 07       	cp.w	r7,0
80011b22:	c4 f0       	breq	80011bc0 <MostGetCodingErrors+0xb8>
        {
            /* busy: application has to retry later */
            result = ERR_BUFOV;
            cb_ptr(NSR_E_BUSY, 0);
80011b24:	e0 6c 81 00 	mov	r12,33024
80011b28:	30 0b       	mov	r11,0
80011b2a:	5d 17       	icall	r7
80011b2c:	30 4c       	mov	r12,4
80011b2e:	d8 22       	popm	r4-r7,pc
    T_API_ENTRY(WMCS_28);

    result = ERR_NO;

    TAKE_WMCS();
    busy = (wmcs.coding_errors.cb_ptr || (MNS_FALSE != wmcs.coding_errors.busy_reset)) ? MNS_TRUE : MNS_FALSE;
80011b30:	ed 39 00 30 	ld.ub	r9,r6[48]
80011b34:	ea 09 18 00 	cp.b	r9,r5
80011b38:	cf 11       	brne	80011b1a <MostGetCodingErrors+0x12>
    GIVE_WMCS();
80011b3a:	31 3c       	mov	r12,19
80011b3c:	fe b0 af be 	rcall	80007ab8 <mns_give>
        }

        /* if this was a call using NULL, we do not have to retry since the
           already pending job will reset the counter anyway */
    }
    else if((TWmcsCodingErrorCB*)WmcsCodingErrorsCallback == cb_ptr)
80011b40:	fe c8 fe cc 	sub	r8,pc,-308
80011b44:	10 37       	cp.w	r7,r8
    {
        TMnsResult code          = NSR_S_CE_INIC;  /* normal procedure */
        word       coding_errors = 0;

        /* if this is not a reset action */
        if (cb_ptr)
80011b46:	c3 f0       	breq	80011bc4 <MostGetCodingErrors+0xbc>
80011b48:	58 07       	cp.w	r7,0
        {
            /* external call: check if we have an extended job running */
            TAKE_WMCS();
80011b4a:	c1 b0       	breq	80011b80 <MostGetCodingErrors+0x78>
80011b4c:	31 3c       	mov	r12,19
80011b4e:	fe b0 af b4 	rcall	80007ab6 <mns_take>
            if(WMCS_CE_INACTIVE != wmcs.coding_errors.counter)
80011b52:	3f f8       	mov	r8,-1
80011b54:	ed 04 00 10 	ld.sh	r4,r6[16]
80011b58:	f0 04 19 00 	cp.h	r4,r8
            {
                /* there is a running or finished job */
                coding_errors = (word) wmcs.coding_errors.counter;

                /* is the job finished? */
                if((word)0 != wmcs.coding_errors.deadtime)
80011b5c:	c2 10       	breq	80011b9e <MostGetCodingErrors+0x96>
80011b5e:	ed 0a 00 28 	ld.sh	r10,r6[40]
80011b62:	ea 0a 19 00 	cp.h	r10,r5
                {
                    /* no, it is not: just reset counter to zero */
                    wmcs.coding_errors.counter = 0;
80011b66:	c2 80       	breq	80011bb6 <MostGetCodingErrors+0xae>
80011b68:	ed 55 00 10 	st.h	r6[16],r5
80011b6c:	e0 66 01 02 	mov	r6,258
                    /* yes it is: flag inactive */
                    wmcs.coding_errors.counter = WMCS_CE_INACTIVE;
                    code                       = NSR_S_CE_EXT_RESULT;
                }
            }
            GIVE_WMCS();
80011b70:	31 3c       	mov	r12,19
80011b72:	fe b0 af a3 	rcall	80007ab8 <mns_give>
        if(NSR_S_CE_INIC != code)
        {
            /* call the callback immediately with the extended result */
            if (cb_ptr)
            {
                cb_ptr(code, coding_errors);
80011b76:	0c 9c       	mov	r12,r6
80011b78:	08 9b       	mov	r11,r4
80011b7a:	5c 7b       	castu.h	r11
80011b7c:	5d 17       	icall	r7
            GIVE_WMCS();
        }
        else
        {
            /* this is a reset operation */
            TAKE_WMCS();
80011b7e:	d8 2a       	popm	r4-r7,pc,r12=0
80011b80:	31 3c       	mov	r12,19
80011b82:	fe b0 af 9a 	rcall	80007ab6 <mns_take>
            wmcs.coding_errors.busy_reset = MNS_TRUE;

            if(WMCS_CE_INACTIVE != wmcs.coding_errors.counter)
80011b86:	30 18       	mov	r8,1
80011b88:	ed 09 00 10 	ld.sh	r9,r6[16]
        }
        else
        {
            /* this is a reset operation */
            TAKE_WMCS();
            wmcs.coding_errors.busy_reset = MNS_TRUE;
80011b8c:	ed 68 00 30 	st.b	r6[48],r8

            if(WMCS_CE_INACTIVE != wmcs.coding_errors.counter)
            {
                wmcs.coding_errors.counter = 0;
80011b90:	3f f8       	mov	r8,-1
80011b92:	f0 09 19 00 	cp.h	r9,r8
80011b96:	ee 08 17 10 	movne	r8,r7
80011b9a:	ed f8 1c 08 	st.hne	r6[0x10],r8
            }
            GIVE_WMCS();
80011b9e:	31 3c       	mov	r12,19
80011ba0:	fe b0 af 8c 	rcall	80007ab8 <mns_give>
            }
        }
        else
        {
            /* normal procedure */
            TAKE_WMCS();
80011ba4:	31 3c       	mov	r12,19
80011ba6:	fe b0 af 88 	rcall	80007ab6 <mns_take>
            /* can be NULL in case of a reset, the field busy_rest is also
               MNS_TRUE in that case */
            wmcs.coding_errors.cb_ptr = cb_ptr;
80011baa:	31 3c       	mov	r12,19
            GIVE_WMCS();
80011bac:	8d b7       	st.w	r6[0x2c],r7
80011bae:	fe b0 af 85 	rcall	80007ab8 <mns_give>
            (void)WmcsRequestCodingErrors();
80011bb2:	c8 bf       	rcall	80011ac8 <WmcsRequestCodingErrors>
80011bb4:	d8 2a       	popm	r4-r7,pc,r12=0
                    code                       = NSR_S_CE_EXT_ONGOING;
                }
                else
                {
                    /* yes it is: flag inactive */
                    wmcs.coding_errors.counter = WMCS_CE_INACTIVE;
80011bb6:	ed 58 00 10 	st.h	r6[16],r8
80011bba:	e0 66 01 03 	mov	r6,259
80011bbe:	cd 9b       	rjmp	80011b70 <MostGetCodingErrors+0x68>
    busy = (wmcs.coding_errors.cb_ptr || (MNS_FALSE != wmcs.coding_errors.busy_reset)) ? MNS_TRUE : MNS_FALSE;
    GIVE_WMCS();

    if (MNS_FALSE != busy)
    {
        if (cb_ptr)
80011bc0:	0e 9c       	mov	r12,r7
80011bc2:	d8 22       	popm	r4-r7,pc
           already pending job will reset the counter anyway */
    }
    else if((TWmcsCodingErrorCB*)WmcsCodingErrorsCallback == cb_ptr)
    {
        /* internal call */
        TAKE_WMCS();
80011bc4:	31 3c       	mov	r12,19
80011bc6:	fe b0 af 78 	rcall	80007ab6 <mns_take>
        wmcs.coding_errors.cb_ptr = cb_ptr;
        GIVE_WMCS();
80011bca:	31 3c       	mov	r12,19
    }
    else if((TWmcsCodingErrorCB*)WmcsCodingErrorsCallback == cb_ptr)
    {
        /* internal call */
        TAKE_WMCS();
        wmcs.coding_errors.cb_ptr = cb_ptr;
80011bcc:	8d b7       	st.w	r6[0x2c],r7
        GIVE_WMCS();
80011bce:	fe b0 af 75 	rcall	80007ab8 <mns_give>
        (void)WmcsRequestCodingErrors();
80011bd2:	c7 bf       	rcall	80011ac8 <WmcsRequestCodingErrors>
80011bd4:	0a 9c       	mov	r12,r5
80011bd6:	d8 22       	popm	r4-r7,pc
80011bd8:	00 00       	add	r0,r0
80011bda:	3a 54       	mov	r4,-91

80011bdc <MostCountCodingErrors>:
80011bdc:	eb cd 40 e0 	pushm	r5-r7,lr
80011be0:	4a 47       	lddpc	r7,80011c70 <MostCountCodingErrors+0x94>
80011be2:	18 96       	mov	r6,r12
80011be4:	31 3c       	mov	r12,19
80011be6:	fe b0 af 68 	rcall	80007ab6 <mns_take>
80011bea:	ef 09 00 10 	ld.sh	r9,r7[16]
80011bee:	3f f8       	mov	r8,-1
    result      = ERR_NO;
    clear_timer = MNS_FALSE;

    /* check if we are already running */
    TAKE_WMCS();
    if(WMCS_CE_INACTIVE != wmcs.coding_errors.counter)
80011bf0:	f0 09 19 00 	cp.h	r9,r8
80011bf4:	c2 50       	breq	80011c3e <MostCountCodingErrors+0x62>
    {
        /* reset running job completely */
        wmcs.coding_errors.counter  = WMCS_CE_INACTIVE;
80011bf6:	ef 58 00 10 	st.h	r7[16],r8
        wmcs.coding_errors.timeout  = 0;
80011bfa:	30 08       	mov	r8,0
        wmcs.coding_errors.deadtime = 0;
        clear_timer                 = MNS_TRUE;
    }
    GIVE_WMCS();
80011bfc:	31 3c       	mov	r12,19
    if(WMCS_CE_INACTIVE != wmcs.coding_errors.counter)
    {
        /* reset running job completely */
        wmcs.coding_errors.counter  = WMCS_CE_INACTIVE;
        wmcs.coding_errors.timeout  = 0;
        wmcs.coding_errors.deadtime = 0;
80011bfe:	ef 58 00 28 	st.h	r7[40],r8
    TAKE_WMCS();
    if(WMCS_CE_INACTIVE != wmcs.coding_errors.counter)
    {
        /* reset running job completely */
        wmcs.coding_errors.counter  = WMCS_CE_INACTIVE;
        wmcs.coding_errors.timeout  = 0;
80011c02:	ef 58 00 2a 	st.h	r7[42],r8
        wmcs.coding_errors.deadtime = 0;
        clear_timer                 = MNS_TRUE;
    }
    GIVE_WMCS();
80011c06:	fe b0 af 59 	rcall	80007ab8 <mns_give>
    if(MNS_FALSE != clear_timer)
    {
        MostClearTimer(&(wmcs.coding_errors.timer));
80011c0a:	30 0a       	mov	r10,0
80011c0c:	ee cc ff ec 	sub	r12,r7,-20
80011c10:	14 9b       	mov	r11,r10
80011c12:	fe b0 ca 4b 	rcall	8000b0a8 <MostSetTimer>
    }

    /* do we want to start another job? */
    if((word)0 != timeout)
80011c16:	58 06       	cp.w	r6,0
80011c18:	c0 51       	brne	80011c22 <MostCountCodingErrors+0x46>
80011c1a:	0c 95       	mov	r5,r6
        }
    }

    T_API_EXIT(WMCS_29);
    return(result);
}
80011c1c:	0a 9c       	mov	r12,r5
80011c1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    /* do we want to start another job? */
    if((word)0 != timeout)
    {
        /*reset counter in INIC if possible, WmcsCodingErrorCallback will be
          called*/
        result = MostGetCodingErrors(WmcsCodingErrorsCallback);
80011c22:	fe cc ff ae 	sub	r12,pc,-82
80011c26:	c7 1f       	rcall	80011b08 <MostGetCodingErrors>
80011c28:	18 95       	mov	r5,r12
        if(ERR_NO == result)
80011c2a:	cf 91       	brne	80011c1c <MostCountCodingErrors+0x40>
        {
            /* new params are valid? */
            if (timeout  < WMCS_CE_TIMEOUT_MIN)
80011c2c:	31 88       	mov	r8,24
80011c2e:	f0 06 19 00 	cp.h	r6,r8
80011c32:	e0 8b 00 0a 	brhi	80011c46 <MostCountCodingErrors+0x6a>
80011c36:	30 15       	mov	r5,1
        }
    }

    T_API_EXIT(WMCS_29);
    return(result);
}
80011c38:	0a 9c       	mov	r12,r5
80011c3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        wmcs.coding_errors.counter  = WMCS_CE_INACTIVE;
        wmcs.coding_errors.timeout  = 0;
        wmcs.coding_errors.deadtime = 0;
        clear_timer                 = MNS_TRUE;
    }
    GIVE_WMCS();
80011c3e:	31 3c       	mov	r12,19
80011c40:	fe b0 af 3c 	rcall	80007ab8 <mns_give>
80011c44:	ce 9b       	rjmp	80011c16 <MostCountCodingErrors+0x3a>
            }
            else
            {
                /* set the parameters, so WmcsCodingErrorsCallback can start
                   the new job */
                TAKE_WMCS();
80011c46:	31 3c       	mov	r12,19
80011c48:	fe b0 af 37 	rcall	80007ab6 <mns_take>
                wmcs.coding_errors.timeout  = timeout;
80011c4c:	ef 56 00 2a 	st.h	r7[42],r6
80011c50:	48 88       	lddpc	r8,80011c70 <MostCountCodingErrors+0x94>
                if ((word)0xFFFF != timeout)
80011c52:	3f f9       	mov	r9,-1
80011c54:	f2 06 19 00 	cp.h	r6,r9
80011c58:	c0 70       	breq	80011c66 <MostCountCodingErrors+0x8a>
                {
                    wmcs.coding_errors.deadtime = timeout;
80011c5a:	f1 56 00 28 	st.h	r8[40],r6
                }
                else
                {
                    wmcs.coding_errors.deadtime = (word)1000;
                }
                GIVE_WMCS();
80011c5e:	31 3c       	mov	r12,19
80011c60:	fe b0 af 2c 	rcall	80007ab8 <mns_give>
80011c64:	cd cb       	rjmp	80011c1c <MostCountCodingErrors+0x40>
                {
                    wmcs.coding_errors.deadtime = timeout;
                }
                else
                {
                    wmcs.coding_errors.deadtime = (word)1000;
80011c66:	e0 69 03 e8 	mov	r9,1000
80011c6a:	f1 59 00 28 	st.h	r8[40],r9
80011c6e:	cf 8b       	rjmp	80011c5e <MostCountCodingErrors+0x82>
80011c70:	00 00       	add	r0,r0
80011c72:	3a 54       	mov	r4,-91

80011c74 <WmcsCodingErrorsCallback>:
80011c74:	eb cd 40 80 	pushm	r7,lr
80011c78:	31 3c       	mov	r12,19
80011c7a:	16 97       	mov	r7,r11
80011c7c:	fe b0 af 1d 	rcall	80007ab6 <mns_take>
80011c80:	4a 18       	lddpc	r8,80011d04 <WmcsCodingErrorsCallback+0x90>
80011c82:	3f fa       	mov	r10,-1
80011c84:	f1 09 00 10 	ld.sh	r9,r8[16]
    (void) result;
    set_timer = 0;
    TAKE_WMCS();

    /* is this the callback from the "reset" stage of a new job? */
    if((WMCS_CE_INACTIVE == wmcs.coding_errors.counter) && ((word)0 != wmcs.coding_errors.deadtime))
80011c88:	f4 09 19 00 	cp.h	r9,r10
80011c8c:	c1 90       	breq	80011cbe <WmcsCodingErrorsCallback+0x4a>
        {
            wmcs.coding_errors.timeout -= wmcs.coding_errors.deadtime;
        }
        set_timer = wmcs.coding_errors.deadtime;
    }
    else if((WMCS_CE_INACTIVE != wmcs.coding_errors.counter) && ((word)0 != coding_errors))
80011c8e:	30 0a       	mov	r10,0
80011c90:	f4 07 19 00 	cp.h	r7,r10
80011c94:	5f 1b       	srne	r11
80011c96:	f4 0b 18 00 	cp.b	r11,r10
80011c9a:	c0 d0       	breq	80011cb4 <WmcsCodingErrorsCallback+0x40>
    {
        /* this is a call during a job, just increase the counter if there were coding errors */
        dword temp;

        temp = (dword)wmcs.coding_errors.counter + (dword)coding_errors;
80011c9c:	5c 77       	castu.h	r7
80011c9e:	5c 79       	castu.h	r9
80011ca0:	ee 09 00 09 	add	r9,r7,r9

        if ((dword)WMCS_CE_INACTIVE <= temp)                /* check for overflow */
        {
            wmcs.coding_errors.counter = WMCS_CE_INACTIVE - (word)1;
80011ca4:	e0 49 ff fe 	cp.w	r9,65534
80011ca8:	f9 b9 0b fe 	movhi	r9,-2
80011cac:	f1 f9 bc 08 	st.hhi	r8[0x10],r9
        }
        else
        {
            wmcs.coding_errors.counter = (word)temp;
80011cb0:	f1 f9 8c 08 	st.hls	r8[0x10],r9
        }
    }

    GIVE_WMCS();
80011cb4:	31 3c       	mov	r12,19
80011cb6:	fe b0 af 01 	rcall	80007ab8 <mns_give>
80011cba:	e3 cd 80 80 	ldm	sp++,r7,pc
    (void) result;
    set_timer = 0;
    TAKE_WMCS();

    /* is this the callback from the "reset" stage of a new job? */
    if((WMCS_CE_INACTIVE == wmcs.coding_errors.counter) && ((word)0 != wmcs.coding_errors.deadtime))
80011cbe:	f1 0b 00 28 	ld.sh	r11,r8[40]
80011cc2:	30 09       	mov	r9,0
80011cc4:	f2 0b 19 00 	cp.h	r11,r9
80011cc8:	cf 60       	breq	80011cb4 <WmcsCodingErrorsCallback+0x40>
    {
        /* start new job by setting counter to zero and start deadtime timer,
           when it times out WmcsCodingErrorsTimeout is going to be called */
        wmcs.coding_errors.counter = (word)0;
80011cca:	f1 59 00 10 	st.h	r8[16],r9
        if((word)0xFFFF != wmcs.coding_errors.timeout)
80011cce:	f1 09 00 2a 	ld.sh	r9,r8[42]
        {
            wmcs.coding_errors.timeout -= wmcs.coding_errors.deadtime;
80011cd2:	f4 09 19 00 	cp.h	r9,r10
80011cd6:	f3 db e1 1b 	subne	r11,r9,r11
80011cda:	f1 fb 1c 15 	st.hne	r8[0x2a],r11
        }
        set_timer = wmcs.coding_errors.deadtime;
80011cde:	f1 07 00 28 	ld.sh	r7,r8[40]
        {
            wmcs.coding_errors.counter = (word)temp;
        }
    }

    GIVE_WMCS();
80011ce2:	31 3c       	mov	r12,19
80011ce4:	fe b0 ae ea 	rcall	80007ab8 <mns_give>

    if(set_timer)
80011ce8:	58 07       	cp.w	r7,0
80011cea:	c0 a0       	breq	80011cfe <WmcsCodingErrorsCallback+0x8a>
    {
        MostSetTimer(&(wmcs.coding_errors.timer), set_timer, MNS_FALSE);
80011cec:	0e 9b       	mov	r11,r7
80011cee:	48 6c       	lddpc	r12,80011d04 <WmcsCodingErrorsCallback+0x90>
80011cf0:	5c 7b       	castu.h	r11
80011cf2:	2e cc       	sub	r12,-20
80011cf4:	30 0a       	mov	r10,0
80011cf6:	fe b0 c9 d9 	rcall	8000b0a8 <MostSetTimer>
80011cfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80011cfe:	e3 cd 80 80 	ldm	sp++,r7,pc
80011d02:	d7 03       	nop
80011d04:	00 00       	add	r0,r0
80011d06:	3a 54       	mov	r4,-91

80011d08 <WmcsHandleGroupAddrStatus>:
80011d08:	eb cd 40 80 	pushm	r7,lr
80011d0c:	18 97       	mov	r7,r12
80011d0e:	58 0c       	cp.w	r12,0
80011d10:	c1 10       	breq	80011d32 <WmcsHandleGroupAddrStatus+0x2a>
80011d12:	31 3c       	mov	r12,19
{
    T_LIB_ENTRY(WMCS_20);

    ASSERT(msg_ptr);

    TAKE_WMCS();
80011d14:	fe b0 ae d1 	rcall	80007ab6 <mns_take>
    wmcs.group_addr.value = msg_ptr->Data[1];
80011d18:	6e 08       	ld.w	r8,r7[0x0]
80011d1a:	11 99       	ld.ub	r9,r8[0x1]
80011d1c:	48 b8       	lddpc	r8,80011d48 <WmcsHandleGroupAddrStatus+0x40>
    GIVE_WMCS();
80011d1e:	31 3c       	mov	r12,19
    T_LIB_ENTRY(WMCS_20);

    ASSERT(msg_ptr);

    TAKE_WMCS();
    wmcs.group_addr.value = msg_ptr->Data[1];
80011d20:	f1 69 00 0c 	st.b	r8[12],r9
    GIVE_WMCS();
80011d24:	fe b0 ae ca 	rcall	80007ab8 <mns_give>

    MnsNtfCheck(NTF_GROUP_ADDR);
80011d28:	31 0c       	mov	r12,16
80011d2a:	fe b0 c8 a1 	rcall	8000ae6c <MnsNtfCheck>

    T_LIB_EXIT(WMCS_20);
}
80011d2e:	e3 cd 80 80 	ldm	sp++,r7,pc
#ifdef WMCS_20
void WmcsHandleGroupAddrStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(WMCS_20);

    ASSERT(msg_ptr);
80011d32:	e0 68 02 5e 	mov	r8,606
80011d36:	31 0b       	mov	r11,16
80011d38:	1a d8       	st.w	--sp,r8
80011d3a:	30 1a       	mov	r10,1
80011d3c:	16 9c       	mov	r12,r11
80011d3e:	fe b0 ae d7 	rcall	80007aec <mns_trace>
80011d42:	2f fd       	sub	sp,-4
80011d44:	ce 7b       	rjmp	80011d12 <WmcsHandleGroupAddrStatus+0xa>
80011d46:	d7 03       	nop
80011d48:	00 00       	add	r0,r0
80011d4a:	3a 54       	mov	r4,-91

80011d4c <WmcsHandleNodeAddrStatus>:
80011d4c:	eb cd 40 80 	pushm	r7,lr
80011d50:	18 97       	mov	r7,r12
80011d52:	58 0c       	cp.w	r12,0
80011d54:	c1 30       	breq	80011d7a <WmcsHandleNodeAddrStatus+0x2e>
80011d56:	31 3c       	mov	r12,19
80011d58:	fe b0 ae af 	rcall	80007ab6 <mns_take>
    T_LIB_ENTRY(WMCS_17);

    ASSERT(msg_ptr);

    TAKE_WMCS();
    wmcs.node_addr.value = (word)(((word)msg_ptr->Data[0] << 8) |
80011d5c:	6e 08       	ld.w	r8,r7[0x0]
80011d5e:	11 99       	ld.ub	r9,r8[0x1]
80011d60:	11 88       	ld.ub	r8,r8[0x0]
80011d62:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80011d66:	48 b8       	lddpc	r8,80011d90 <WmcsHandleNodeAddrStatus+0x44>
                      (word)msg_ptr->Data[1]);
    GIVE_WMCS();
80011d68:	31 3c       	mov	r12,19
    T_LIB_ENTRY(WMCS_17);

    ASSERT(msg_ptr);

    TAKE_WMCS();
    wmcs.node_addr.value = (word)(((word)msg_ptr->Data[0] << 8) |
80011d6a:	b0 49       	st.h	r8[0x8],r9
                      (word)msg_ptr->Data[1]);
    GIVE_WMCS();
80011d6c:	fe b0 ae a6 	rcall	80007ab8 <mns_give>

    MnsNtfCheck(NTF_NODE_ADDR);
80011d70:	30 8c       	mov	r12,8
80011d72:	fe b0 c8 7d 	rcall	8000ae6c <MnsNtfCheck>

    T_LIB_EXIT(WMCS_17);
}
80011d76:	e3 cd 80 80 	ldm	sp++,r7,pc
#ifdef WMCS_17
void WmcsHandleNodeAddrStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(WMCS_17);

    ASSERT(msg_ptr);
80011d7a:	e0 68 02 4c 	mov	r8,588
80011d7e:	31 0b       	mov	r11,16
80011d80:	1a d8       	st.w	--sp,r8
80011d82:	30 1a       	mov	r10,1
80011d84:	16 9c       	mov	r12,r11
80011d86:	fe b0 ae b3 	rcall	80007aec <mns_trace>
80011d8a:	2f fd       	sub	sp,-4
80011d8c:	ce 5b       	rjmp	80011d56 <WmcsHandleNodeAddrStatus+0xa>
80011d8e:	d7 03       	nop
80011d90:	00 00       	add	r0,r0
80011d92:	3a 54       	mov	r4,-91

80011d94 <WmcsRefreshNodePos>:
80011d94:	eb cd 40 80 	pushm	r7,lr
80011d98:	18 97       	mov	r7,r12
80011d9a:	31 3c       	mov	r12,19
80011d9c:	fe b0 ae 8d 	rcall	80007ab6 <mns_take>
80011da0:	48 58       	lddpc	r8,80011db4 <WmcsRefreshNodePos+0x20>
80011da2:	31 3c       	mov	r12,19
void WmcsRefreshNodePos(byte pos)
{
    T_LIB_ENTRY(WMCS_25);

    TAKE_WMCS();
    wmcs.node_pos = pos;
80011da4:	b0 c7       	st.b	r8[0x4],r7
    GIVE_WMCS();
80011da6:	fe b0 ae 89 	rcall	80007ab8 <mns_give>

    #ifdef VMSV_58
    VmsvRefreshNodePos(pos);
80011daa:	0e 9c       	mov	r12,r7
80011dac:	fe b0 ef e8 	rcall	8000fd7c <VmsvRefreshNodePos>
    #endif

    T_LIB_EXIT(WMCS_25);
}
80011db0:	e3 cd 80 80 	ldm	sp++,r7,pc
80011db4:	00 00       	add	r0,r0
80011db6:	3a 54       	mov	r4,-91

80011db8 <WmcsSetPendingEvent>:
80011db8:	d4 01       	pushm	lr
80011dba:	31 09       	mov	r9,16
80011dbc:	5c 7c       	castu.h	r12
80011dbe:	48 3a       	lddpc	r10,80011dc8 <WmcsSetPendingEvent+0x10>
80011dc0:	31 2b       	mov	r11,18
80011dc2:	fe b0 ca dd 	rcall	8000b37c <MnsSetPendingEventFlag>

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_WMCS_PE,
                           &wmcs.pending_events, MNS_P_SRV_WMCS);
    T_MOD_EXIT(WMCS_2);
}
80011dc6:	d8 02       	popm	pc
80011dc8:	00 00       	add	r0,r0
80011dca:	3a 54       	mov	r4,-91

80011dcc <MostSelectClockOutput>:
80011dcc:	eb cd 40 c0 	pushm	r6-r7,lr
}
#endif

#ifdef WMCS_21
void MostSelectClockOutput(byte rmck_divider)
{
80011dd0:	18 96       	mov	r6,r12
    TMsgTx *msg_ptr;

    T_API_ENTRY(WMCS_21);

    msg_ptr = MsgGetTxPtrExt(1);
80011dd2:	30 1c       	mov	r12,1
80011dd4:	fe b0 b8 64 	rcall	80008e9c <MsgGetTxPtrExt>
80011dd8:	18 97       	mov	r7,r12

    TAKE_WMCS();
80011dda:	31 3c       	mov	r12,19
80011ddc:	fe b0 ae 6d 	rcall	80007ab6 <mns_take>
    wmcs.rmck_divider = rmck_divider;
80011de0:	48 f8       	lddpc	r8,80011e1c <MostSelectClockOutput+0x50>
    GIVE_WMCS();
80011de2:	31 3c       	mov	r12,19
    T_API_ENTRY(WMCS_21);

    msg_ptr = MsgGetTxPtrExt(1);

    TAKE_WMCS();
    wmcs.rmck_divider = rmck_divider;
80011de4:	b0 d6       	st.b	r8[0x5],r6
    GIVE_WMCS();
80011de6:	fe b0 ae 69 	rcall	80007ab8 <mns_give>

    if (msg_ptr)
80011dea:	58 07       	cp.w	r7,0
80011dec:	c1 40       	breq	80011e14 <MostSelectClockOutput+0x48>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
80011dee:	30 08       	mov	r8,0
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNCID_INIC_RMCK;
        msg_ptr->Operation = OP_SET;
80011df0:	ef 68 00 0c 	st.b	r7[12],r8
    GIVE_WMCS();

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
80011df4:	ef 68 00 0a 	st.b	r7[10],r8
        msg_ptr->Inst_ID   = 0;
80011df8:	ef 68 00 0b 	st.b	r7[11],r8
    wmcs.rmck_divider = rmck_divider;
    GIVE_WMCS();

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011dfc:	30 18       	mov	r8,1
80011dfe:	ae 38       	st.h	r7[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNCID_INIC_RMCK;
80011e00:	e0 68 02 01 	mov	r8,513
80011e04:	ae 48       	st.h	r7[0x8],r8
        msg_ptr->Operation = OP_SET;
        msg_ptr->Data[0]   = rmck_divider;
80011e06:	6e 08       	ld.w	r8,r7[0x0]

        MsgSend3(msg_ptr);
80011e08:	0e 9c       	mov	r12,r7
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_INIC;
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNCID_INIC_RMCK;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Data[0]   = rmck_divider;
80011e0a:	b0 86       	st.b	r8[0x0],r6

        MsgSend3(msg_ptr);
80011e0c:	fe b0 bb 8c 	rcall	80009524 <MsgSend3>
80011e10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    }
    else
    {
        WmcsSetPendingEvent(WMCS_P_RMCK_RETRY);
80011e14:	32 0c       	mov	r12,32
80011e16:	cd 1f       	rcall	80011db8 <WmcsSetPendingEvent>
80011e18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80011e1c:	00 00       	add	r0,r0
80011e1e:	3a 54       	mov	r4,-91

80011e20 <MostSetGroupAdr>:
80011e20:	eb cd 40 c0 	pushm	r6-r7,lr
80011e24:	18 96       	mov	r6,r12
80011e26:	30 2c       	mov	r12,2
80011e28:	fe b0 b8 3a 	rcall	80008e9c <MsgGetTxPtrExt>
80011e2c:	18 97       	mov	r7,r12
80011e2e:	31 3c       	mov	r12,19
80011e30:	fe b0 ae 43 	rcall	80007ab6 <mns_take>
80011e34:	49 28       	lddpc	r8,80011e7c <MostSetGroupAdr+0x5c>
80011e36:	31 3c       	mov	r12,19

    T_API_ENTRY(WMCS_10);

    msg_ptr = MsgGetTxPtrExt(2);
    TAKE_WMCS();
    wmcs.group_addr.scheduled = address;
80011e38:	f1 66 00 0d 	st.b	r8[13],r6
    GIVE_WMCS();
80011e3c:	fe b0 ae 3e 	rcall	80007ab8 <mns_give>

    if (msg_ptr)
80011e40:	58 07       	cp.w	r7,0
80011e42:	c1 80       	breq	80011e72 <MostSetGroupAdr+0x52>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011e44:	30 18       	mov	r8,1
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
80011e46:	ef 68 00 0a 	st.b	r7[10],r8
    wmcs.group_addr.scheduled = address;
    GIVE_WMCS();

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011e4a:	ae 38       	st.h	r7[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = 0;
80011e4c:	30 08       	mov	r8,0
        msg_ptr->Func_ID   = FUNC_GROUPADDRESS;
        msg_ptr->Operation = OP_SET;
80011e4e:	ef 68 00 0c 	st.b	r7[12],r8

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = 0;
80011e52:	ef 68 00 0b 	st.b	r7[11],r8
        msg_ptr->Func_ID   = FUNC_GROUPADDRESS;
80011e56:	30 48       	mov	r8,4
80011e58:	ae 48       	st.h	r7[0x8],r8
        msg_ptr->Operation = OP_SET;
        msg_ptr->Length    = 2;
80011e5a:	30 28       	mov	r8,2
80011e5c:	ae 28       	st.h	r7[0x4],r8
        msg_ptr->Data[0]   = 3;
80011e5e:	6e 08       	ld.w	r8,r7[0x0]
80011e60:	30 39       	mov	r9,3
80011e62:	b0 89       	st.b	r8[0x0],r9
        msg_ptr->Data[1]   = address;
80011e64:	6e 08       	ld.w	r8,r7[0x0]

        MsgSend3(msg_ptr);
80011e66:	0e 9c       	mov	r12,r7
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNC_GROUPADDRESS;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Length    = 2;
        msg_ptr->Data[0]   = 3;
        msg_ptr->Data[1]   = address;
80011e68:	b0 96       	st.b	r8[0x1],r6

        MsgSend3(msg_ptr);
80011e6a:	fe b0 bb 5d 	rcall	80009524 <MsgSend3>
80011e6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    }
    else
    {
        WmcsSetPendingEvent(WMCS_P_GROUP_ADDR_RETRY);
80011e72:	30 4c       	mov	r12,4
80011e74:	ca 2f       	rcall	80011db8 <WmcsSetPendingEvent>
80011e76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80011e7a:	d7 03       	nop
80011e7c:	00 00       	add	r0,r0
80011e7e:	3a 54       	mov	r4,-91

80011e80 <MostSetNodeAdr>:
80011e80:	eb cd 40 c0 	pushm	r6-r7,lr
80011e84:	18 96       	mov	r6,r12
80011e86:	30 2c       	mov	r12,2
80011e88:	fe b0 b8 0a 	rcall	80008e9c <MsgGetTxPtrExt>
80011e8c:	18 97       	mov	r7,r12
80011e8e:	31 3c       	mov	r12,19
80011e90:	fe b0 ae 13 	rcall	80007ab6 <mns_take>
    T_API_ENTRY(WMCS_9);

    msg_ptr = MsgGetTxPtrExt(2);

    TAKE_WMCS();
    wmcs.node_addr.scheduled = address;
80011e94:	49 28       	lddpc	r8,80011edc <MostSetNodeAdr+0x5c>
    GIVE_WMCS();
80011e96:	31 3c       	mov	r12,19
    T_API_ENTRY(WMCS_9);

    msg_ptr = MsgGetTxPtrExt(2);

    TAKE_WMCS();
    wmcs.node_addr.scheduled = address;
80011e98:	b0 56       	st.h	r8[0xa],r6
    GIVE_WMCS();
80011e9a:	fe b0 ae 0f 	rcall	80007ab8 <mns_give>

    if (msg_ptr)
80011e9e:	58 07       	cp.w	r7,0
80011ea0:	c1 90       	breq	80011ed2 <MostSetNodeAdr+0x52>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011ea2:	30 18       	mov	r8,1
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
80011ea4:	ef 68 00 0a 	st.b	r7[10],r8
    wmcs.node_addr.scheduled = address;
    GIVE_WMCS();

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011ea8:	ae 38       	st.h	r7[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = 0;
80011eaa:	30 08       	mov	r8,0
        msg_ptr->Func_ID   = FUNC_NODEADDRESS;
        msg_ptr->Operation = OP_SET;
80011eac:	ef 68 00 0c 	st.b	r7[12],r8

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = 0;
80011eb0:	ef 68 00 0b 	st.b	r7[11],r8
        msg_ptr->Func_ID   = FUNC_NODEADDRESS;
80011eb4:	30 38       	mov	r8,3
80011eb6:	ae 48       	st.h	r7[0x8],r8
        msg_ptr->Operation = OP_SET;
        msg_ptr->Length    = 2;
80011eb8:	30 28       	mov	r8,2
80011eba:	ae 28       	st.h	r7[0x4],r8
        msg_ptr->Data[0]   = HB(address);
80011ebc:	6e 08       	ld.w	r8,r7[0x0]
80011ebe:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80011ec2:	b0 89       	st.b	r8[0x0],r9
        msg_ptr->Data[1]   = LB(address);
80011ec4:	6e 08       	ld.w	r8,r7[0x0]

        MsgSend3(msg_ptr);
80011ec6:	0e 9c       	mov	r12,r7
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNC_NODEADDRESS;
        msg_ptr->Operation = OP_SET;
        msg_ptr->Length    = 2;
        msg_ptr->Data[0]   = HB(address);
        msg_ptr->Data[1]   = LB(address);
80011ec8:	b0 96       	st.b	r8[0x1],r6

        MsgSend3(msg_ptr);
80011eca:	fe b0 bb 2d 	rcall	80009524 <MsgSend3>
80011ece:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    }
    else
    {
        WmcsSetPendingEvent(WMCS_P_NODE_ADDR_RETRY);
80011ed2:	30 8c       	mov	r12,8
80011ed4:	c7 2f       	rcall	80011db8 <WmcsSetPendingEvent>
80011ed6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80011eda:	d7 03       	nop
80011edc:	00 00       	add	r0,r0
80011ede:	3a 54       	mov	r4,-91

80011ee0 <MostSetGetNodeAdr>:
80011ee0:	eb cd 40 c0 	pushm	r6-r7,lr
80011ee4:	18 96       	mov	r6,r12
80011ee6:	30 2c       	mov	r12,2
80011ee8:	fe b0 b7 da 	rcall	80008e9c <MsgGetTxPtrExt>
80011eec:	18 97       	mov	r7,r12
80011eee:	31 3c       	mov	r12,19
80011ef0:	fe b0 ad e3 	rcall	80007ab6 <mns_take>
    T_API_ENTRY(WMCS_8);

    msg_ptr = MsgGetTxPtrExt(2);

    TAKE_WMCS();
    wmcs.node_addr.scheduled = address;
80011ef4:	49 38       	lddpc	r8,80011f40 <MostSetGetNodeAdr+0x60>
    GIVE_WMCS();
80011ef6:	31 3c       	mov	r12,19
    T_API_ENTRY(WMCS_8);

    msg_ptr = MsgGetTxPtrExt(2);

    TAKE_WMCS();
    wmcs.node_addr.scheduled = address;
80011ef8:	b0 56       	st.h	r8[0xa],r6
    GIVE_WMCS();
80011efa:	fe b0 ad df 	rcall	80007ab8 <mns_give>

    if (msg_ptr)
80011efe:	58 07       	cp.w	r7,0
80011f00:	c1 a0       	breq	80011f34 <MostSetGetNodeAdr+0x54>
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011f02:	30 18       	mov	r8,1
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
80011f04:	ef 68 00 0a 	st.b	r7[10],r8
    wmcs.node_addr.scheduled = address;
    GIVE_WMCS();

    if (msg_ptr)
    {
        msg_ptr->Tgt_Adr   = MSG_TGT_INIC;
80011f08:	ae 38       	st.h	r7[0x6],r8
        msg_ptr->FBlock_ID = FBLOCK_NETBLOCK;
        msg_ptr->Inst_ID   = 0;
80011f0a:	30 08       	mov	r8,0
80011f0c:	ef 68 00 0b 	st.b	r7[11],r8
        msg_ptr->Func_ID   = FUNC_NODEADDRESS;
80011f10:	30 38       	mov	r8,3
80011f12:	ae 48       	st.h	r7[0x8],r8
        msg_ptr->Operation = OP_SETGET;
80011f14:	30 28       	mov	r8,2
80011f16:	ef 68 00 0c 	st.b	r7[12],r8
        msg_ptr->Length    = 2;
80011f1a:	30 28       	mov	r8,2
80011f1c:	ae 28       	st.h	r7[0x4],r8
        msg_ptr->Data[0]   = HB(address);
80011f1e:	6e 08       	ld.w	r8,r7[0x0]
80011f20:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80011f24:	b0 89       	st.b	r8[0x0],r9
        msg_ptr->Data[1]   = LB(address);
80011f26:	6e 08       	ld.w	r8,r7[0x0]

        MsgSend3(msg_ptr);
80011f28:	0e 9c       	mov	r12,r7
        msg_ptr->Inst_ID   = 0;
        msg_ptr->Func_ID   = FUNC_NODEADDRESS;
        msg_ptr->Operation = OP_SETGET;
        msg_ptr->Length    = 2;
        msg_ptr->Data[0]   = HB(address);
        msg_ptr->Data[1]   = LB(address);
80011f2a:	b0 96       	st.b	r8[0x1],r6

        MsgSend3(msg_ptr);
80011f2c:	fe b0 ba fc 	rcall	80009524 <MsgSend3>
80011f30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    }
    else
    {
        WmcsSetPendingEvent(WMCS_P_NODE_ADDR_SETGET_RETRY);
80011f34:	e0 6c 02 00 	mov	r12,512
80011f38:	c4 0f       	rcall	80011db8 <WmcsSetPendingEvent>
80011f3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80011f3e:	d7 03       	nop
80011f40:	00 00       	add	r0,r0
80011f42:	3a 54       	mov	r4,-91

80011f44 <WmcsService>:
80011f44:	d4 21       	pushm	r4-r7,lr
80011f46:	fe f7 02 12 	ld.w	r7,pc[530]
80011f4a:	e0 68 02 00 	mov	r8,512
80011f4e:	30 19       	mov	r9,1
80011f50:	ee ca ff fe 	sub	r10,r7,-2
80011f54:	0e 9b       	mov	r11,r7
80011f56:	31 2c       	mov	r12,18
static word WmcsGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(WMCS_3);
    result = MnsGetNextEventFlagToCall(MX_WMCS_PE,
80011f58:	fe b0 c9 72 	rcall	8000b23c <MnsGetNextEventFlagToCall>
    event_to_handle = WmcsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80011f5c:	32 08       	mov	r8,32
static word WmcsGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(WMCS_3);
    result = MnsGetNextEventFlagToCall(MX_WMCS_PE,
80011f5e:	5c 8c       	casts.h	r12
    event_to_handle = WmcsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80011f60:	f0 0c 19 00 	cp.h	r12,r8
80011f64:	e0 80 00 cb 	breq	800120fa <WmcsService+0x1b6>
80011f68:	e0 88 00 1f 	brls	80011fa6 <WmcsService+0x62>
80011f6c:	e0 68 00 80 	mov	r8,128
80011f70:	f0 0c 19 00 	cp.h	r12,r8
80011f74:	c7 b0       	breq	8001206a <WmcsService+0x126>
80011f76:	e0 88 00 66 	brls	80012042 <WmcsService+0xfe>
80011f7a:	e0 68 01 00 	mov	r8,256
80011f7e:	f0 0c 19 00 	cp.h	r12,r8
80011f82:	e0 80 00 8a 	breq	80012096 <WmcsService+0x152>
80011f86:	e0 68 02 00 	mov	r8,512
80011f8a:	f0 0c 19 00 	cp.h	r12,r8
80011f8e:	c4 d1       	brne	80012028 <WmcsService+0xe4>

        case WMCS_P_NODE_ADDR_SETGET_RETRY:
            {
                word temp;

                TAKE_WMCS();
80011f90:	31 3c       	mov	r12,19
80011f92:	fe b0 ad 92 	rcall	80007ab6 <mns_take>
                temp = wmcs.node_addr.scheduled;
                GIVE_WMCS();
80011f96:	31 3c       	mov	r12,19
        case WMCS_P_NODE_ADDR_SETGET_RETRY:
            {
                word temp;

                TAKE_WMCS();
                temp = wmcs.node_addr.scheduled;
80011f98:	8e 56       	ld.sh	r6,r7[0xa]
                GIVE_WMCS();
80011f9a:	fe b0 ad 8f 	rcall	80007ab8 <mns_give>

                MostSetGetNodeAdr(temp);
80011f9e:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
80011fa2:	c9 ff       	rcall	80011ee0 <MostSetGetNodeAdr>
80011fa4:	c4 28       	rjmp	80012028 <WmcsService+0xe4>
            }
            break;
80011fa6:	30 48       	mov	r8,4
    event_to_handle = WmcsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80011fa8:	f0 0c 19 00 	cp.h	r12,r8
80011fac:	e0 80 00 b1 	breq	8001210e <WmcsService+0x1ca>
80011fb0:	30 88       	mov	r8,8
80011fb2:	f0 0c 19 00 	cp.h	r12,r8
80011fb6:	c4 f0       	breq	80012054 <WmcsService+0x110>
80011fb8:	30 18       	mov	r8,1
80011fba:	f0 0c 19 00 	cp.h	r12,r8
80011fbe:	c3 51       	brne	80012028 <WmcsService+0xe4>
80011fc0:	31 3c       	mov	r12,19
static void Wmcs_Go_Protected(void)
{

    T_MOD_ENTRY(WMCS_14);

    TAKE_WMCS();
80011fc2:	fe b0 ad 7a 	rcall	80007ab6 <mns_take>
80011fc6:	3e e8       	mov	r8,-18
    wmcs.node_pos                   = INIC_SHADOW_INVALID_BYTE;
80011fc8:	ae d8       	st.b	r7[0x5],r8
    wmcs.node_addr.value            = INIC_SHADOW_INVALID_WORD;
    wmcs.node_addr.scheduled        = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.value           = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.scheduled       = INIC_SHADOW_INVALID_BYTE;
    wmcs.rmck_divider               = INIC_SHADOW_INVALID_BYTE;
80011fca:	ae c8       	st.b	r7[0x4],r8
{

    T_MOD_ENTRY(WMCS_14);

    TAKE_WMCS();
    wmcs.node_pos                   = INIC_SHADOW_INVALID_BYTE;
80011fcc:	ef 68 00 0c 	st.b	r7[12],r8
    wmcs.node_addr.value            = INIC_SHADOW_INVALID_WORD;
    wmcs.node_addr.scheduled        = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.value           = INIC_SHADOW_INVALID_BYTE;
80011fd0:	ef 68 00 0d 	st.b	r7[13],r8
    wmcs.group_addr.scheduled       = INIC_SHADOW_INVALID_BYTE;
80011fd4:	fe 78 ee ee 	mov	r8,-4370

    T_MOD_ENTRY(WMCS_14);

    TAKE_WMCS();
    wmcs.node_pos                   = INIC_SHADOW_INVALID_BYTE;
    wmcs.node_addr.value            = INIC_SHADOW_INVALID_WORD;
80011fd8:	ae 78       	st.h	r7[0xe],r8
    wmcs.node_addr.scheduled        = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.value           = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.scheduled       = INIC_SHADOW_INVALID_BYTE;
    wmcs.rmck_divider               = INIC_SHADOW_INVALID_BYTE;
    wmcs.shadow.alt_packet_addr     = INIC_SHADOW_INVALID_WORD;
80011fda:	ae 48       	st.h	r7[0x8],r8

    T_MOD_ENTRY(WMCS_14);

    TAKE_WMCS();
    wmcs.node_pos                   = INIC_SHADOW_INVALID_BYTE;
    wmcs.node_addr.value            = INIC_SHADOW_INVALID_WORD;
80011fdc:	e0 68 00 ee 	mov	r8,238
    wmcs.node_addr.scheduled        = INIC_SHADOW_INVALID_BYTE;
80011fe0:	ae 58       	st.h	r7[0xa],r8
80011fe2:	3f f8       	mov	r8,-1
    wmcs.group_addr.value           = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.scheduled       = INIC_SHADOW_INVALID_BYTE;
    wmcs.rmck_divider               = INIC_SHADOW_INVALID_BYTE;
    wmcs.shadow.alt_packet_addr     = INIC_SHADOW_INVALID_WORD;
    wmcs.coding_errors.cb_ptr       = NULL;
    wmcs.coding_errors.counter      = WMCS_CE_INACTIVE;
80011fe4:	30 06       	mov	r6,0
    wmcs.node_addr.scheduled        = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.value           = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.scheduled       = INIC_SHADOW_INVALID_BYTE;
    wmcs.rmck_divider               = INIC_SHADOW_INVALID_BYTE;
    wmcs.shadow.alt_packet_addr     = INIC_SHADOW_INVALID_WORD;
    wmcs.coding_errors.cb_ptr       = NULL;
80011fe6:	ef 58 00 10 	st.h	r7[16],r8
    wmcs.coding_errors.counter      = WMCS_CE_INACTIVE;
80011fea:	31 3c       	mov	r12,19
  #ifdef _OS81110_PCK_LLR
    wmcs.packetretrytime.pending    = MNS_FALSE;
  #endif


    GIVE_WMCS();
80011fec:	8f b6       	st.w	r7[0x2c],r6
    wmcs.node_addr.scheduled        = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.value           = INIC_SHADOW_INVALID_BYTE;
    wmcs.group_addr.scheduled       = INIC_SHADOW_INVALID_BYTE;
    wmcs.rmck_divider               = INIC_SHADOW_INVALID_BYTE;
    wmcs.shadow.alt_packet_addr     = INIC_SHADOW_INVALID_WORD;
    wmcs.coding_errors.cb_ptr       = NULL;
80011fee:	ef 56 00 28 	st.h	r7[40],r6
    wmcs.coding_errors.counter      = WMCS_CE_INACTIVE;
    wmcs.coding_errors.deadtime     = 0;
80011ff2:	ef 56 00 2a 	st.h	r7[42],r6
    wmcs.coding_errors.timeout      = 0;
80011ff6:	ef 66 00 44 	st.b	r7[68],r6
    wmcs.mephashtable.pending       = MNS_FALSE;
    wmcs.eui48.pending              = MNS_FALSE;
  #endif

  #ifdef _OS81110_PCK_LLR
    wmcs.packetretrytime.pending    = MNS_FALSE;
80011ffa:	ef 66 00 30 	st.b	r7[48],r6
    wmcs.shadow.alt_packet_addr     = INIC_SHADOW_INVALID_WORD;
    wmcs.coding_errors.cb_ptr       = NULL;
    wmcs.coding_errors.counter      = WMCS_CE_INACTIVE;
    wmcs.coding_errors.deadtime     = 0;
    wmcs.coding_errors.timeout      = 0;
    wmcs.coding_errors.busy_reset   = MNS_FALSE;
80011ffe:	ef 66 00 3d 	st.b	r7[61],r6

    wmcs.memory.pending             = MNS_FALSE;
80012002:	fe b0 ad 5b 	rcall	80007ab8 <mns_give>
  #ifdef _OS81110_PCK_LLR
    wmcs.packetretrytime.pending    = MNS_FALSE;
  #endif


    GIVE_WMCS();
80012006:	0c 9b       	mov	r11,r6

    MostClearTimer(&(wmcs.coding_errors.timer));
80012008:	0c 9a       	mov	r10,r6
8001200a:	ee cc ff ec 	sub	r12,r7,-20
8001200e:	fe b0 c8 4d 	rcall	8000b0a8 <MostSetTimer>
80012012:	31 2c       	mov	r12,18

    TAKE_EVENTS();
80012014:	fe b0 ad 51 	rcall	80007ab6 <mns_take>
80012018:	31 2c       	mov	r12,18
    wmcs.retry = 0;
    GIVE_EVENTS();
8001201a:	ae 36       	st.h	r7[0x6],r6
    GIVE_WMCS();

    MostClearTimer(&(wmcs.coding_errors.timer));

    TAKE_EVENTS();
    wmcs.retry = 0;
8001201c:	fe b0 ad 4e 	rcall	80007ab8 <mns_give>
    GIVE_EVENTS();
80012020:	31 0b       	mov	r11,16

  #ifdef MNS_AVOID_ATTACH
    MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_WMCS);
  #endif

    MnsServiceInitComplete(MNS_PHASE_RESET, MNS_P_SRV_WMCS);
80012022:	30 1c       	mov	r12,1
80012024:	fe b0 cc 4c 	rcall	8000b8bc <MnsServiceInitComplete>
80012028:	31 2c       	mov	r12,18
        default:
            event_to_handle = WMCS_P_NONE;
            break;
    }

    TAKE_EVENTS();
8001202a:	fe b0 ad 46 	rcall	80007ab6 <mns_take>
8001202e:	31 2c       	mov	r12,18
    request_flag = (WMCS_P_NONE != wmcs.pending_events) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
80012030:	8e 07       	ld.sh	r7,r7[0x0]
            event_to_handle = WMCS_P_NONE;
            break;
    }

    TAKE_EVENTS();
    request_flag = (WMCS_P_NONE != wmcs.pending_events) ? MNS_TRUE : MNS_FALSE;
80012032:	fe b0 ad 43 	rcall	80007ab8 <mns_give>
    GIVE_EVENTS();
80012036:	58 07       	cp.w	r7,0

    if (MNS_FALSE != request_flag)
80012038:	c0 40       	breq	80012040 <WmcsService+0xfc>
8001203a:	31 0c       	mov	r12,16
    {
        MnsSetPendingService(MNS_P_SRV_WMCS);
8001203c:	fe b0 c9 66 	rcall	8000b308 <MnsSetPendingService>
80012040:	d8 22       	popm	r4-r7,pc
80012042:	34 08       	mov	r8,64
    event_to_handle = WmcsGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
80012044:	f0 0c 19 00 	cp.h	r12,r8
80012048:	cf 01       	brne	80012028 <WmcsService+0xe4>
8001204a:	31 0b       	mov	r11,16
                MostSelectClockOutput(rmck_divider);
            }
            break;

        case WMCS_P_NTF_COMPLETE:
            MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_WMCS);
8001204c:	30 2c       	mov	r12,2
8001204e:	fe b0 cc 37 	rcall	8000b8bc <MnsServiceInitComplete>
80012052:	ce bb       	rjmp	80012028 <WmcsService+0xe4>
            break;
80012054:	31 3c       	mov	r12,19

        case WMCS_P_NODE_ADDR_RETRY:
            {
                word temp;

                TAKE_WMCS();
80012056:	fe b0 ad 30 	rcall	80007ab6 <mns_take>
8001205a:	31 3c       	mov	r12,19
                temp = wmcs.node_addr.scheduled;
                GIVE_WMCS();
8001205c:	8e 56       	ld.sh	r6,r7[0xa]
        case WMCS_P_NODE_ADDR_RETRY:
            {
                word temp;

                TAKE_WMCS();
                temp = wmcs.node_addr.scheduled;
8001205e:	fe b0 ad 2d 	rcall	80007ab8 <mns_give>
                GIVE_WMCS();
80012062:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10

                MostSetNodeAdr(temp);
80012066:	c0 df       	rcall	80011e80 <MostSetNodeAdr>
80012068:	ce 0b       	rjmp	80012028 <WmcsService+0xe4>
8001206a:	31 3c       	mov	r12,19
            }
            break;
8001206c:	fe b0 ad 25 	rcall	80007ab6 <mns_take>
    byte result;

    T_MOD_ENTRY(WMCS_23);

    result = ERR_NO;
    TAKE_WMCS();
80012070:	31 3c       	mov	r12,19
80012072:	8e 36       	ld.sh	r6,r7[0x6]
    retry = wmcs.retry;
    GIVE_WMCS();
80012074:	fe b0 ad 22 	rcall	80007ab8 <mns_give>
80012078:	e2 16 00 02 	andl	r6,0x2,COH

    PROCESS_RETRY    (WMCS_RETRY_REQUEST_CODINGERR,   WmcsRequestCodingErrors);
8001207c:	cd 60       	breq	80012028 <WmcsService+0xe4>
8001207e:	31 2c       	mov	r12,18
80012080:	fe b0 ad 1b 	rcall	80007ab6 <mns_take>
80012084:	8e 38       	ld.sh	r8,r7[0x6]
80012086:	a1 d8       	cbr	r8,0x1
80012088:	31 2c       	mov	r12,18
8001208a:	ae 38       	st.h	r7[0x6],r8
8001208c:	fe b0 ad 16 	rcall	80007ab8 <mns_give>
80012090:	fe b0 fd 1c 	rcall	80011ac8 <WmcsRequestCodingErrors>
80012094:	cc ab       	rjmp	80012028 <WmcsService+0xe4>
80012096:	31 3c       	mov	r12,19
80012098:	fe b0 ad 0f 	rcall	80007ab6 <mns_take>

    /* this is a deadtime timeout */

    T_MOD_ENTRY(WMCS_31);
    new_deadtime = 0;
    TAKE_WMCS();
8001209c:	31 3c       	mov	r12,19
8001209e:	ef 05 00 10 	ld.sh	r5,r7[16]
    counter = wmcs.coding_errors.counter;
800120a2:	ef 04 00 2a 	ld.sh	r4,r7[42]
    timeout = wmcs.coding_errors.timeout;
800120a6:	3f f6       	mov	r6,-1
800120a8:	fe b0 ad 08 	rcall	80007ab8 <mns_give>
    GIVE_WMCS();
800120ac:	ec 05 19 00 	cp.h	r5,r6

    /* if we are not active, we should not be here */
    ASSERT(WMCS_CE_INACTIVE != counter);
800120b0:	c4 30       	breq	80012136 <WmcsService+0x1f2>
800120b2:	fe cc 04 3e 	sub	r12,pc,1086
    if(WMCS_CE_INACTIVE != counter)
    {
        /* ask the INIC for coding errors during deadtime (resets the counter) */
        if(ERR_NO != MostGetCodingErrors(WmcsCodingErrorsCallback))
800120b6:	fe b0 fd 29 	rcall	80011b08 <MostGetCodingErrors>
800120ba:	c4 81       	brne	8001214a <WmcsService+0x206>
800120bc:	58 04       	cp.w	r4,0
        {
            /* we got a problem, lets try again next service run */
            WmcsSetPendingEvent(WMCS_P_CE_TIMER);
        }
        else if((word)0 != timeout)
800120be:	c3 30       	breq	80012124 <WmcsService+0x1e0>
800120c0:	31 3c       	mov	r12,19
        {
            /* time is not yet over, so we schedule a new deadtime */

            TAKE_WMCS();
800120c2:	fe b0 ac fa 	rcall	80007ab6 <mns_take>
800120c6:	ef 08 00 2a 	ld.sh	r8,r7[42]
            if((word)0xFFFF != wmcs.coding_errors.timeout)
800120ca:	ec 08 19 00 	cp.h	r8,r6
800120ce:	c4 20       	breq	80012152 <WmcsService+0x20e>
800120d0:	ef 06 00 28 	ld.sh	r6,r7[40]
800120d4:	f0 06 19 00 	cp.h	r6,r8
800120d8:	f0 06 17 b0 	movhi	r6,r8
800120dc:	5c 86       	casts.h	r6
800120de:	0c 18       	sub	r8,r6
                }
                else
                {
                    new_deadtime =  wmcs.coding_errors.timeout;
                }
                wmcs.coding_errors.timeout -= new_deadtime;
800120e0:	ef 58 00 2a 	st.h	r7[42],r8
800120e4:	31 3c       	mov	r12,19
            }
            else
            {
                new_deadtime =  wmcs.coding_errors.deadtime;
            }
            GIVE_WMCS();
800120e6:	fe b0 ac e9 	rcall	80007ab8 <mns_give>
800120ea:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10

            MostSetTimer(&(wmcs.coding_errors.timer), new_deadtime, MNS_FALSE);
800120ee:	30 0a       	mov	r10,0
800120f0:	ee cc ff ec 	sub	r12,r7,-20
800120f4:	fe b0 c7 da 	rcall	8000b0a8 <MostSetTimer>
800120f8:	c9 8b       	rjmp	80012028 <WmcsService+0xe4>
800120fa:	31 3c       	mov	r12,19

        case WMCS_P_RMCK_RETRY:
            {
                byte rmck_divider;

                TAKE_WMCS();
800120fc:	fe b0 ac dd 	rcall	80007ab6 <mns_take>
80012100:	31 3c       	mov	r12,19
                rmck_divider = wmcs.rmck_divider;
                GIVE_WMCS();
80012102:	0f d6       	ld.ub	r6,r7[0x5]
        case WMCS_P_RMCK_RETRY:
            {
                byte rmck_divider;

                TAKE_WMCS();
                rmck_divider = wmcs.rmck_divider;
80012104:	fe b0 ac da 	rcall	80007ab8 <mns_give>
                GIVE_WMCS();
80012108:	0c 9c       	mov	r12,r6

                MostSelectClockOutput(rmck_divider);
8001210a:	c6 1e       	rcall	80011dcc <MostSelectClockOutput>
8001210c:	c8 eb       	rjmp	80012028 <WmcsService+0xe4>
8001210e:	31 3c       	mov	r12,19
            }
            break;
80012110:	fe b0 ac d3 	rcall	80007ab6 <mns_take>

        case WMCS_P_GROUP_ADDR_RETRY:
            {
                byte temp;

                TAKE_WMCS();
80012114:	31 3c       	mov	r12,19
80012116:	ef 36 00 0d 	ld.ub	r6,r7[13]
                temp = wmcs.group_addr.scheduled;
8001211a:	fe b0 ac cf 	rcall	80007ab8 <mns_give>
                GIVE_WMCS();
8001211e:	0c 9c       	mov	r12,r6
80012120:	c8 0e       	rcall	80011e20 <MostSetGroupAdr>

                MostSetGroupAdr(temp);
80012122:	c8 3b       	rjmp	80012028 <WmcsService+0xe4>
80012124:	31 3c       	mov	r12,19
80012126:	fe b0 ac c8 	rcall	80007ab6 <mns_take>
        }
        else
        {
            /* this was the last deadtime period, we reset deadtime also to
               signal the job was finished */
            TAKE_WMCS();
8001212a:	31 3c       	mov	r12,19
8001212c:	ef 54 00 28 	st.h	r7[40],r4
            wmcs.coding_errors.deadtime = 0;
            GIVE_WMCS();
80012130:	fe b0 ac c4 	rcall	80007ab8 <mns_give>
        else
        {
            /* this was the last deadtime period, we reset deadtime also to
               signal the job was finished */
            TAKE_WMCS();
            wmcs.coding_errors.deadtime = 0;
80012134:	c7 ab       	rjmp	80012028 <WmcsService+0xe4>
            GIVE_WMCS();
80012136:	e0 68 03 ff 	mov	r8,1023
8001213a:	31 0b       	mov	r11,16
    counter = wmcs.coding_errors.counter;
    timeout = wmcs.coding_errors.timeout;
    GIVE_WMCS();

    /* if we are not active, we should not be here */
    ASSERT(WMCS_CE_INACTIVE != counter);
8001213c:	1a d8       	st.w	--sp,r8
8001213e:	30 1a       	mov	r10,1
80012140:	16 9c       	mov	r12,r11
80012142:	fe b0 ac d5 	rcall	80007aec <mns_trace>
80012146:	2f fd       	sub	sp,-4
80012148:	c7 0b       	rjmp	80012028 <WmcsService+0xe4>
8001214a:	e0 6c 01 00 	mov	r12,256
8001214e:	c3 5e       	rcall	80011db8 <WmcsSetPendingEvent>
    {
        /* ask the INIC for coding errors during deadtime (resets the counter) */
        if(ERR_NO != MostGetCodingErrors(WmcsCodingErrorsCallback))
        {
            /* we got a problem, lets try again next service run */
            WmcsSetPendingEvent(WMCS_P_CE_TIMER);
80012150:	c6 cb       	rjmp	80012028 <WmcsService+0xe4>
80012152:	ef 06 00 28 	ld.sh	r6,r7[40]
80012156:	cc 7b       	rjmp	800120e4 <WmcsService+0x1a0>
80012158:	00 00       	add	r0,r0
                }
                wmcs.coding_errors.timeout -= new_deadtime;
            }
            else
            {
                new_deadtime =  wmcs.coding_errors.deadtime;
8001215a:	3a 54       	mov	r4,-91

8001215c <WmcsInit>:
8001215c:	eb cd 40 c0 	pushm	r6-r7,lr
80012160:	30 0a       	mov	r10,0
80012162:	30 7b       	mov	r11,7
80012164:	31 0c       	mov	r12,16
80012166:	fe b0 ac c3 	rcall	80007aec <mns_trace>
8001216a:	31 2c       	mov	r12,18
8001216c:	fe b0 ac a5 	rcall	80007ab6 <mns_take>
80012170:	30 06       	mov	r6,0
80012172:	48 e7       	lddpc	r7,800121a8 <WmcsInit+0x4c>
80012174:	31 2c       	mov	r12,18
80012176:	ae 06       	st.h	r7[0x0],r6
80012178:	ae 16       	st.h	r7[0x2],r6
8001217a:	ae 36       	st.h	r7[0x6],r6
8001217c:	fe b0 ac 9e 	rcall	80007ab8 <mns_give>
80012180:	31 3c       	mov	r12,19
80012182:	fe b0 ac 9a 	rcall	80007ab6 <mns_take>
80012186:	31 3c       	mov	r12,19
80012188:	ef 66 00 44 	st.b	r7[68],r6
8001218c:	ef 66 00 3d 	st.b	r7[61],r6
80012190:	fe b0 ac 94 	rcall	80007ab8 <mns_give>
80012194:	ee cc ff ec 	sub	r12,r7,-20
80012198:	e0 6a 01 00 	mov	r10,256
8001219c:	fe cb 03 e4 	sub	r11,pc,996
  #ifdef _OS81110_PCK_LLR
    wmcs.packetretrytime.pending = MNS_FALSE;
  #endif
    GIVE_WMCS();

    MostRegisterTimer(&(wmcs.coding_errors.timer), WmcsSetPendingEvent, WMCS_P_CE_TIMER);
800121a0:	fe b0 c7 fa 	rcall	8000b194 <MostRegisterTimer>

    T_LIB_EXIT(WMCS_0);
}
800121a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800121a8:	00 00       	add	r0,r0
800121aa:	3a 54       	mov	r4,-91

800121ac <ScmHandleSCDemuteStatus>:
}
#endif

#ifdef SCM_44
void ScmHandleSCDemuteStatus(TMsgRx  *msg_ptr)
{
800121ac:	eb cd 40 80 	pushm	r7,lr
800121b0:	18 97       	mov	r7,r12
    T_LIB_ENTRY(SCM_44);

    ASSERT(msg_ptr);
800121b2:	58 0c       	cp.w	r12,0
800121b4:	c1 10       	breq	800121d6 <ScmHandleSCDemuteStatus+0x2a>

    WAIT4CS();
800121b6:	31 5c       	mov	r12,21
800121b8:	fe b0 ac 7f 	rcall	80007ab6 <mns_take>
    if ( wscm.cfg_ptr->sc_demute_fptr)
800121bc:	48 c8       	lddpc	r8,800121ec <ScmHandleSCDemuteStatus+0x40>
800121be:	70 58       	ld.w	r8,r8[0x14]
800121c0:	70 28       	ld.w	r8,r8[0x8]
800121c2:	58 08       	cp.w	r8,0
800121c4:	c0 40       	breq	800121cc <ScmHandleSCDemuteStatus+0x20>
    {
        wscm.cfg_ptr->sc_demute_fptr(msg_ptr->Data, msg_ptr->Length);
800121c6:	6e 0c       	ld.w	r12,r7[0x0]
800121c8:	8e ab       	ld.uh	r11,r7[0x4]
800121ca:	5d 18       	icall	r8
    }
    REL_CS();
800121cc:	31 5c       	mov	r12,21
800121ce:	fe b0 ac 75 	rcall	80007ab8 <mns_give>
    T_LIB_EXIT(SCM_44);
}
800121d2:	e3 cd 80 80 	ldm	sp++,r7,pc
#ifdef SCM_44
void ScmHandleSCDemuteStatus(TMsgRx  *msg_ptr)
{
    T_LIB_ENTRY(SCM_44);

    ASSERT(msg_ptr);
800121d6:	e0 68 09 ee 	mov	r8,2542
800121da:	30 1a       	mov	r10,1
800121dc:	1a d8       	st.w	--sp,r8
800121de:	31 0b       	mov	r11,16
800121e0:	e0 6c 00 80 	mov	r12,128
800121e4:	fe b0 ac 84 	rcall	80007aec <mns_trace>
800121e8:	2f fd       	sub	sp,-4
800121ea:	ce 6b       	rjmp	800121b6 <ScmHandleSCDemuteStatus+0xa>
800121ec:	00 00       	add	r0,r0
800121ee:	3a 9c       	mov	r12,-87

800121f0 <ScmPMComplete>:
800121f0:	eb cd 40 80 	pushm	r7,lr
800121f4:	49 17       	lddpc	r7,80012238 <ScmPMComplete+0x48>
800121f6:	6e 58       	ld.w	r8,r7[0x14]
800121f8:	f1 39 00 0c 	ld.ub	r9,r8[12]

    T_LIB_ENTRY(SCM_42);

    result = MNS_TRUE;

    if (SCM_PM_NONE != wscm.cfg_ptr->packet.mode)
800121fc:	30 08       	mov	r8,0
800121fe:	f0 09 18 00 	cp.b	r9,r8
80012202:	c0 51       	brne	8001220c <ScmPMComplete+0x1c>
80012204:	30 17       	mov	r7,1
    }

    T_LIB_EXIT(SCM_42);

    return(result);
}
80012206:	0e 9c       	mov	r12,r7
80012208:	e3 cd 80 80 	ldm	sp++,r7,pc

    result = MNS_TRUE;

    if (SCM_PM_NONE != wscm.cfg_ptr->packet.mode)
    {
        WAIT4CS();
8001220c:	31 5c       	mov	r12,21
8001220e:	fe b0 ac 54 	rcall	80007ab6 <mns_take>
        if ((SCM_HANDLE_INVALID == wscm.pm.handle.in)     ||
80012212:	ef 39 00 20 	ld.ub	r9,r7[32]
80012216:	3f f8       	mov	r8,-1
80012218:	f0 09 18 00 	cp.b	r9,r8
8001221c:	c0 c0       	breq	80012234 <ScmPMComplete+0x44>
    T_MOD_EXIT(SCM_41);
}
#endif

#ifdef SCM_42
bool ScmPMComplete(void)
8001221e:	ef 39 00 21 	ld.ub	r9,r7[33]
80012222:	f0 09 18 00 	cp.b	r9,r8
80012226:	5f 17       	srne	r7
        if ((SCM_HANDLE_INVALID == wscm.pm.handle.in)     ||
            (SCM_HANDLE_INVALID == wscm.pm.handle.out))
        {
            result = MNS_FALSE;
        }
        REL_CS();
80012228:	31 5c       	mov	r12,21
8001222a:	fe b0 ac 47 	rcall	80007ab8 <mns_give>
    }

    T_LIB_EXIT(SCM_42);

    return(result);
}
8001222e:	0e 9c       	mov	r12,r7
80012230:	e3 cd 80 80 	ldm	sp++,r7,pc
    result = MNS_TRUE;

    if (SCM_PM_NONE != wscm.cfg_ptr->packet.mode)
    {
        WAIT4CS();
        if ((SCM_HANDLE_INVALID == wscm.pm.handle.in)     ||
80012234:	30 07       	mov	r7,0
80012236:	cf 9b       	rjmp	80012228 <ScmPMComplete+0x38>
80012238:	00 00       	add	r0,r0
8001223a:	3a 9c       	mov	r12,-87

8001223c <ScmHandleRemoteGetSourceStatus>:
8001223c:	eb cd 40 e0 	pushm	r5-r7,lr
80012240:	18 96       	mov	r6,r12
80012242:	58 0c       	cp.w	r12,0
{
    TScmGetSourceCB *tmp_cb_ptr;

    T_LIB_ENTRY(SCM_37);

    ASSERT(msg_ptr);
80012244:	c3 20       	breq	800122a8 <ScmHandleRemoteGetSourceStatus+0x6c>

    tmp_cb_ptr = NULL;

    WAIT4CS();
80012246:	31 5c       	mov	r12,21
80012248:	fe b0 ac 37 	rcall	80007ab6 <mns_take>
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
8001224c:	49 d8       	lddpc	r8,800122c0 <ScmHandleRemoteGetSourceStatus+0x84>
8001224e:	8c 4a       	ld.sh	r10,r6[0x8]
80012250:	90 69       	ld.sh	r9,r8[0xc]
80012252:	f2 0a 19 00 	cp.h	r10,r9
80012256:	c0 60       	breq	80012262 <ScmHandleRemoteGetSourceStatus+0x26>
    {
        tmp_cb_ptr = (TScmGetSourceCB *) wscm.cb_ptr;
        wscm.cb_ptr     = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
80012258:	31 5c       	mov	r12,21
8001225a:	fe b0 ac 2f 	rcall	80007ab8 <mns_give>
8001225e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr = (TScmGetSourceCB *) wscm.cb_ptr;
80012262:	70 27       	ld.w	r7,r8[0x8]
        wscm.cb_ptr     = NULL;
80012264:	30 05       	mov	r5,0
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
80012266:	31 5c       	mov	r12,21
    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr = (TScmGetSourceCB *) wscm.cb_ptr;
        wscm.cb_ptr     = NULL;
        wscm.api_locked = MNS_FALSE;
80012268:	f1 65 00 0f 	st.b	r8[15],r5

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr = (TScmGetSourceCB *) wscm.cb_ptr;
        wscm.cb_ptr     = NULL;
8001226c:	91 25       	st.w	r8[0x8],r5
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
8001226e:	fe b0 ac 25 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
80012272:	58 07       	cp.w	r7,0
80012274:	cf 50       	breq	8001225e <ScmHandleRemoteGetSourceStatus+0x22>
    {
        word nod_addr   = 0;
        byte group_addr = 0;
        byte node_pos   = 0;

        if (6 == msg_ptr->Length)
80012276:	8c 29       	ld.sh	r9,r6[0x4]
80012278:	30 68       	mov	r8,6
8001227a:	f0 09 19 00 	cp.h	r9,r8
8001227e:	c0 80       	breq	8001228e <ScmHandleRemoteGetSourceStatus+0x52>
80012280:	0a 9b       	mov	r11,r5
80012282:	0a 9a       	mov	r10,r5
80012284:	0a 99       	mov	r9,r5
            nod_addr  |= (word)(msg_ptr->Data[3]);
            group_addr = msg_ptr->Data[4];
            node_pos   = msg_ptr->Data[5];
        }

        tmp_cb_ptr(NSR_S_OK, nod_addr, group_addr, node_pos);
80012286:	30 0c       	mov	r12,0
80012288:	5d 17       	icall	r7
8001228a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        byte group_addr = 0;
        byte node_pos   = 0;

        if (6 == msg_ptr->Length)
        {
            nod_addr   = (word)(msg_ptr->Data[2] << 8);
8001228e:	6c 08       	ld.w	r8,r6[0x0]
80012290:	11 b9       	ld.ub	r9,r8[0x3]
80012292:	f1 2b 00 02 	ld.sb	r11,r8[2]
80012296:	11 ca       	ld.ub	r10,r8[0x4]
80012298:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
            nod_addr  |= (word)(msg_ptr->Data[3]);
            group_addr = msg_ptr->Data[4];
            node_pos   = msg_ptr->Data[5];
        }

        tmp_cb_ptr(NSR_S_OK, nod_addr, group_addr, node_pos);
8001229c:	30 0c       	mov	r12,0
        byte group_addr = 0;
        byte node_pos   = 0;

        if (6 == msg_ptr->Length)
        {
            nod_addr   = (word)(msg_ptr->Data[2] << 8);
8001229e:	5c 7b       	castu.h	r11
800122a0:	11 d9       	ld.ub	r9,r8[0x5]
            nod_addr  |= (word)(msg_ptr->Data[3]);
            group_addr = msg_ptr->Data[4];
            node_pos   = msg_ptr->Data[5];
        }

        tmp_cb_ptr(NSR_S_OK, nod_addr, group_addr, node_pos);
800122a2:	5d 17       	icall	r7
800122a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TScmGetSourceCB *tmp_cb_ptr;

    T_LIB_ENTRY(SCM_37);

    ASSERT(msg_ptr);
800122a8:	e0 68 07 45 	mov	r8,1861
800122ac:	30 1a       	mov	r10,1
800122ae:	1a d8       	st.w	--sp,r8
800122b0:	31 0b       	mov	r11,16
800122b2:	e0 6c 00 80 	mov	r12,128
800122b6:	fe b0 ac 1b 	rcall	80007aec <mns_trace>
800122ba:	2f fd       	sub	sp,-4
800122bc:	cc 5b       	rjmp	80012246 <ScmHandleRemoteGetSourceStatus+0xa>
800122be:	d7 03       	nop
800122c0:	00 00       	add	r0,r0
800122c2:	3a 9c       	mov	r12,-87

800122c4 <ScmAssembleErrResList>:
800122c4:	d4 21       	pushm	r4-r7,lr
800122c6:	18 97       	mov	r7,r12
800122c8:	16 95       	mov	r5,r11
800122ca:	14 96       	mov	r6,r10
800122cc:	58 0c       	cp.w	r12,0
800122ce:	c3 a0       	breq	80012342 <ScmAssembleErrResList+0x7e>
{
    T_MOD_ENTRY(SCM_36);

    ASSERT(msg_ptr);

    *len_ptr      = 0;
800122d0:	30 08       	mov	r8,0
800122d2:	aa 88       	st.b	r5[0x0],r8
    *list_ptr_ptr = NULL;
800122d4:	30 04       	mov	r4,0
800122d6:	8d 04       	st.w	r6[0x0],r4

    if (msg_ptr->Length > 2)
800122d8:	30 28       	mov	r8,2
800122da:	8e 29       	ld.sh	r9,r7[0x4]
800122dc:	f0 09 19 00 	cp.h	r9,r8
800122e0:	e0 8b 00 03 	brhi	800122e6 <ScmAssembleErrResList+0x22>
800122e4:	d8 22       	popm	r4-r7,pc
    {
        WAIT4CS();
800122e6:	31 5c       	mov	r12,21
800122e8:	fe b0 ab e7 	rcall	80007ab6 <mns_take>
        *list_ptr_ptr= wscm.result_list_ptr;
800122ec:	49 b8       	lddpc	r8,80012358 <ScmAssembleErrResList+0x94>
800122ee:	70 19       	ld.w	r9,r8[0x4]
800122f0:	8d 09       	st.w	r6[0x0],r9
        wscm.result_list_ptr = NULL;
800122f2:	91 14       	st.w	r8[0x4],r4
        REL_CS();
800122f4:	31 5c       	mov	r12,21
800122f6:	fe b0 ab e1 	rcall	80007ab8 <mns_give>

        if (*list_ptr_ptr)
800122fa:	6c 08       	ld.w	r8,r6[0x0]
800122fc:	58 08       	cp.w	r8,0
800122fe:	cf 30       	breq	800122e4 <ScmAssembleErrResList+0x20>
        {
            byte count = 0;

            *len_ptr = (byte)((word)(msg_ptr->Length -2) >> 1);
80012300:	8e 28       	ld.sh	r8,r7[0x4]
80012302:	20 28       	sub	r8,2
80012304:	f1 d8 c0 28 	bfextu	r8,r8,0x1,0x8
80012308:	aa 88       	st.b	r5[0x0],r8
            while(count < *len_ptr)
8001230a:	ce d0       	breq	800122e4 <ScmAssembleErrResList+0x20>
            {
                *list_ptr_ptr[count]  = (word)(msg_ptr->Data[(count << 1)+2] << 8);
8001230c:	e8 09 15 01 	lsl	r9,r4,0x1
80012310:	6e 0a       	ld.w	r10,r7[0x0]
80012312:	12 0a       	add	r10,r9
80012314:	15 ab       	ld.ub	r11,r10[0x2]
80012316:	ec 04 03 2a 	ld.w	r10,r6[r4<<0x2]
8001231a:	a9 6b       	lsl	r11,0x8
8001231c:	b4 0b       	st.h	r10[0x0],r11
                *list_ptr_ptr[count] |= (word)(msg_ptr->Data[(count << 1)+3]);
8001231e:	6e 0a       	ld.w	r10,r7[0x0]
80012320:	f4 09 00 09 	add	r9,r10,r9
80012324:	ec 04 03 28 	ld.w	r8,r6[r4<<0x2]
80012328:	13 ba       	ld.ub	r10,r9[0x3]
8001232a:	90 09       	ld.sh	r9,r8[0x0]
8001232c:	f5 e9 10 09 	or	r9,r10,r9
80012330:	b0 09       	st.h	r8[0x0],r9
                count++;
80012332:	2f f4       	sub	r4,-1
        if (*list_ptr_ptr)
        {
            byte count = 0;

            *len_ptr = (byte)((word)(msg_ptr->Length -2) >> 1);
            while(count < *len_ptr)
80012334:	0b 88       	ld.ub	r8,r5[0x0]
            {
                *list_ptr_ptr[count]  = (word)(msg_ptr->Data[(count << 1)+2] << 8);
                *list_ptr_ptr[count] |= (word)(msg_ptr->Data[(count << 1)+3]);
                count++;
80012336:	5c 54       	castu.b	r4
        if (*list_ptr_ptr)
        {
            byte count = 0;

            *len_ptr = (byte)((word)(msg_ptr->Length -2) >> 1);
            while(count < *len_ptr)
80012338:	e8 08 18 00 	cp.b	r8,r4
8001233c:	fe 9b ff e8 	brhi	8001230c <ScmAssembleErrResList+0x48>
80012340:	d8 22       	popm	r4-r7,pc
static void ScmAssembleErrResList(TMsgRx *msg_ptr, byte *len_ptr,
                                  word** list_ptr_ptr)
{
    T_MOD_ENTRY(SCM_36);

    ASSERT(msg_ptr);
80012342:	e0 68 07 20 	mov	r8,1824
80012346:	30 1a       	mov	r10,1
80012348:	1a d8       	st.w	--sp,r8
8001234a:	31 0b       	mov	r11,16
8001234c:	e0 6c 00 80 	mov	r12,128
80012350:	fe b0 ab ce 	rcall	80007aec <mns_trace>
80012354:	2f fd       	sub	sp,-4
80012356:	cb db       	rjmp	800122d0 <ScmAssembleErrResList+0xc>
80012358:	00 00       	add	r0,r0
8001235a:	3a 9c       	mov	r12,-87

8001235c <ScmHandleError>:
8001235c:	eb cd 40 fc 	pushm	r2-r7,lr
80012360:	20 2d       	sub	sp,8
80012362:	18 95       	mov	r5,r12
80012364:	58 0c       	cp.w	r12,0
80012366:	e0 80 00 9c 	breq	8001249e <ScmHandleError+0x142>
    TMnsStdCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_26);

    ASSERT(msg_ptr);
    result     = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);
8001236a:	6a 0b       	ld.w	r11,r5[0x0]
    tmp_cb_ptr = NULL;

    if (NSR_E_ERR_FUNC_SPECIFIC == result)
8001236c:	fe 78 a0 20 	mov	r8,-24544
    TMnsStdCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_26);

    ASSERT(msg_ptr);
    result     = NSR_BUILD(MNS_FALSE, 0xA0, msg_ptr->Data[0]);
80012370:	17 87       	ld.ub	r7,r11[0x0]
80012372:	ea 17 ff ff 	orh	r7,0xffff
80012376:	e8 17 a0 00 	orl	r7,0xa000
    tmp_cb_ptr = NULL;

    if (NSR_E_ERR_FUNC_SPECIFIC == result)
8001237a:	f0 07 19 00 	cp.h	r7,r8
8001237e:	c1 00       	breq	8001239e <ScmHandleError+0x42>
        {
            result = NSR_BUILD(MNS_FALSE, err_ptr->func_code, msg_ptr->Data[1]);
        }
    }

    WAIT4CS();
80012380:	31 5c       	mov	r12,21
80012382:	fe b0 ab 9a 	rcall	80007ab6 <mns_take>
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
80012386:	4c d3       	lddpc	r3,800124b8 <ScmHandleError+0x15c>
80012388:	8a 49       	ld.sh	r9,r5[0x8]
8001238a:	86 68       	ld.sh	r8,r3[0xc]
8001238c:	f0 09 19 00 	cp.h	r9,r8
80012390:	c2 20       	breq	800123d4 <ScmHandleError+0x78>
    {
        tmp_cb_ptr       = wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
80012392:	31 5c       	mov	r12,21
80012394:	fe b0 ab 92 	rcall	80007ab8 <mns_give>
                break;
        }
    }

    T_MOD_EXIT(SCM_26);
}
80012398:	2f ed       	sub	sp,-8
8001239a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    if (NSR_E_ERR_FUNC_SPECIFIC == result)
    {
        WscmErrCodes _CONST *err_ptr = &wscm_err_codes[0];

        while ((err_ptr->func_id) && (err_ptr->func_id != msg_ptr->Func_ID))
8001239e:	8a 4a       	ld.sh	r10,r5[0x8]
800123a0:	e0 68 04 03 	mov	r8,1027
800123a4:	f0 0a 19 00 	cp.h	r10,r8
800123a8:	e0 80 00 86 	breq	800124b4 <ScmHandleError+0x158>
800123ac:	4c 48       	lddpc	r8,800124bc <ScmHandleError+0x160>
        {
            err_ptr++;
800123ae:	2f c8       	sub	r8,-4

    if (NSR_E_ERR_FUNC_SPECIFIC == result)
    {
        WscmErrCodes _CONST *err_ptr = &wscm_err_codes[0];

        while ((err_ptr->func_id) && (err_ptr->func_id != msg_ptr->Func_ID))
800123b0:	90 09       	ld.sh	r9,r8[0x0]
800123b2:	58 09       	cp.w	r9,0
800123b4:	ce 60       	breq	80012380 <ScmHandleError+0x24>
800123b6:	f4 09 19 00 	cp.h	r9,r10
800123ba:	cf a1       	brne	800123ae <ScmHandleError+0x52>
        {
            err_ptr++;
        }

        if ((err_ptr->func_id) && (err_ptr->func_id == msg_ptr->Func_ID))
800123bc:	58 0a       	cp.w	r10,0
800123be:	ce 10       	breq	80012380 <ScmHandleError+0x24>
        {
            result = NSR_BUILD(MNS_FALSE, err_ptr->func_code, msg_ptr->Data[1]);
800123c0:	11 a7       	ld.ub	r7,r8[0x2]
800123c2:	17 98       	ld.ub	r8,r11[0x1]
800123c4:	a7 d7       	cbr	r7,0x7
800123c6:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800123ca:	ea 17 ff ff 	orh	r7,0xffff
800123ce:	e8 17 80 00 	orl	r7,0x8000
800123d2:	cd 7b       	rjmp	80012380 <ScmHandleError+0x24>
    }

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = wscm.cb_ptr;
800123d4:	66 26       	ld.w	r6,r3[0x8]
        wscm.cb_ptr = NULL;
800123d6:	30 04       	mov	r4,0
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800123d8:	31 5c       	mov	r12,21

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = wscm.cb_ptr;
        wscm.cb_ptr = NULL;
800123da:	87 24       	st.w	r3[0x8],r4
        wscm.api_locked = MNS_FALSE;
800123dc:	e7 64 00 0f 	st.b	r3[15],r4
    }
    REL_CS();
800123e0:	fe b0 ab 6c 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
800123e4:	58 06       	cp.w	r6,0
800123e6:	cd 90       	breq	80012398 <ScmHandleError+0x3c>
    {
        switch (msg_ptr->Func_ID)
800123e8:	8a 48       	ld.sh	r8,r5[0x8]
800123ea:	e0 69 04 04 	mov	r9,1028
800123ee:	f2 08 19 00 	cp.h	r8,r9
800123f2:	c3 d0       	breq	8001246c <ScmHandleError+0x110>
800123f4:	e0 8b 00 12 	brhi	80012418 <ScmHandleError+0xbc>
800123f8:	e0 69 04 02 	mov	r9,1026
800123fc:	f2 08 19 00 	cp.h	r8,r9
80012400:	c2 d0       	breq	8001245a <ScmHandleError+0xfe>
80012402:	e0 69 04 03 	mov	r9,1027
80012406:	f2 08 19 00 	cp.h	r8,r9
8001240a:	c1 80       	breq	8001243a <ScmHandleError+0xde>
                }
            }
                break;

            default:
                tmp_cb_ptr(result);
8001240c:	0e 9c       	mov	r12,r7
8001240e:	5c 7c       	castu.h	r12
80012410:	5d 16       	icall	r6
                break;
        }
    }

    T_MOD_EXIT(SCM_26);
}
80012412:	2f ed       	sub	sp,-8
80012414:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    }
    REL_CS();

    if (tmp_cb_ptr)
    {
        switch (msg_ptr->Func_ID)
80012418:	e0 69 04 05 	mov	r9,1029
8001241c:	f2 08 19 00 	cp.h	r8,r9
80012420:	c0 60       	breq	8001242c <ScmHandleError+0xd0>
80012422:	e0 69 04 08 	mov	r9,1032
80012426:	f2 08 19 00 	cp.h	r8,r9
8001242a:	cf 11       	brne	8001240c <ScmHandleError+0xb0>

            case FUNCID_INIC_MEDIALBALLOCATEONLY:
                {
                    TScmAllocOnlyMlbCB *tmp2_cb_ptr =
                        (TScmAllocOnlyMlbCB *) tmp_cb_ptr;
                    tmp2_cb_ptr(result, 0);
8001242c:	0e 9c       	mov	r12,r7
8001242e:	08 9b       	mov	r11,r4
80012430:	5c 7c       	castu.h	r12
80012432:	5d 16       	icall	r6
                break;
        }
    }

    T_MOD_EXIT(SCM_26);
}
80012434:	2f ed       	sub	sp,-8
80012436:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
                    byte                len         = 0;
                    word               *list_ptr    = NULL;
                    TScmCreateSocketCB *tmp2_cb_ptr =
                        (TScmCreateSocketCB *) tmp_cb_ptr;

                    ScmAssembleErrResList(msg_ptr, &len, &list_ptr);
8001243a:	0a 9c       	mov	r12,r5
8001243c:	1a 9a       	mov	r10,sp
8001243e:	fa cb ff f9 	sub	r11,sp,-7
    {
        switch (msg_ptr->Func_ID)
        {
            case FUNCID_INIC_CREATESOCKET:
                {
                    byte                len         = 0;
80012442:	ba f4       	st.b	sp[0x7],r4
                    word               *list_ptr    = NULL;
80012444:	50 04       	stdsp	sp[0x0],r4
                    TScmCreateSocketCB *tmp2_cb_ptr =
                        (TScmCreateSocketCB *) tmp_cb_ptr;

                    ScmAssembleErrResList(msg_ptr, &len, &list_ptr);
80012446:	c3 ff       	rcall	800122c4 <ScmAssembleErrResList>
80012448:	0e 9c       	mov	r12,r7
                    tmp2_cb_ptr(result, 0, len, list_ptr);
8001244a:	08 9b       	mov	r11,r4
8001244c:	5c 7c       	castu.h	r12
8001244e:	40 09       	lddsp	r9,sp[0x0]
80012450:	1b fa       	ld.ub	r10,sp[0x7]
80012452:	5d 16       	icall	r6
80012454:	2f ed       	sub	sp,-8
                break;
        }
    }

    T_MOD_EXIT(SCM_26);
}
80012456:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001245a:	0e 9c       	mov	r12,r7
            case FUNCID_INIC_REMOTEGETSOURCE:
            {
                TScmGetSourceCB *tmp2_cb_ptr =
                    (TScmGetSourceCB *) tmp_cb_ptr;

                tmp2_cb_ptr(result, 0, 0, 0);
8001245c:	08 99       	mov	r9,r4
8001245e:	5c 7c       	castu.h	r12
80012460:	08 9a       	mov	r10,r4
80012462:	08 9b       	mov	r11,r4
80012464:	5d 16       	icall	r6
80012466:	2f ed       	sub	sp,-8
                break;
        }
    }

    T_MOD_EXIT(SCM_26);
}
80012468:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001246c:	31 5c       	mov	r12,21

            case FUNCID_INIC_DESTROYSOCKET:
            {
                bool api_ext = MNS_FALSE;

                WAIT4CS();
8001246e:	fe b0 ab 24 	rcall	80007ab6 <mns_take>
80012472:	31 5c       	mov	r12,21
                api_ext = wscm.api_ext;
                wscm.api_ext = MNS_FALSE;
                REL_CS();
80012474:	e7 32 00 10 	ld.ub	r2,r3[16]
            case FUNCID_INIC_DESTROYSOCKET:
            {
                bool api_ext = MNS_FALSE;

                WAIT4CS();
                api_ext = wscm.api_ext;
80012478:	e7 64 00 10 	st.b	r3[16],r4
                wscm.api_ext = MNS_FALSE;
8001247c:	fe b0 ab 1e 	rcall	80007ab8 <mns_give>
                REL_CS();
80012480:	58 02       	cp.w	r2,0

                if (MNS_FALSE != api_ext)
80012482:	cc 50       	breq	8001240c <ScmHandleError+0xb0>
80012484:	0a 9c       	mov	r12,r5
                    byte                 len         = 0;
                    word                *list_ptr    = NULL;
                    TScmListCB *tmp2_cb_ptr =
                        (TScmListCB *) tmp_cb_ptr;

                    ScmAssembleErrResList(msg_ptr, &len, &list_ptr);
80012486:	1a 9a       	mov	r10,sp
80012488:	fa cb ff f9 	sub	r11,sp,-7
8001248c:	50 04       	stdsp	sp[0x0],r4
                REL_CS();

                if (MNS_FALSE != api_ext)
                {
                    byte                 len         = 0;
                    word                *list_ptr    = NULL;
8001248e:	ba f4       	st.b	sp[0x7],r4
                wscm.api_ext = MNS_FALSE;
                REL_CS();

                if (MNS_FALSE != api_ext)
                {
                    byte                 len         = 0;
80012490:	c1 af       	rcall	800122c4 <ScmAssembleErrResList>
                    word                *list_ptr    = NULL;
                    TScmListCB *tmp2_cb_ptr =
                        (TScmListCB *) tmp_cb_ptr;

                    ScmAssembleErrResList(msg_ptr, &len, &list_ptr);
80012492:	0e 9c       	mov	r12,r7
80012494:	40 0a       	lddsp	r10,sp[0x0]
                    tmp2_cb_ptr(result, len, list_ptr);
80012496:	5c 7c       	castu.h	r12
80012498:	1b fb       	ld.ub	r11,sp[0x7]
8001249a:	5d 16       	icall	r6
8001249c:	c7 eb       	rjmp	80012398 <ScmHandleError+0x3c>
8001249e:	e0 68 05 74 	mov	r8,1396
    TMnsResult result;
    TMnsStdCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_26);

    ASSERT(msg_ptr);
800124a2:	30 1a       	mov	r10,1
800124a4:	1a d8       	st.w	--sp,r8
800124a6:	31 0b       	mov	r11,16
800124a8:	e0 6c 00 80 	mov	r12,128
800124ac:	fe b0 ab 20 	rcall	80007aec <mns_trace>
800124b0:	2f fd       	sub	sp,-4
800124b2:	c5 cb       	rjmp	8001236a <ScmHandleError+0xe>
800124b4:	48 28       	lddpc	r8,800124bc <ScmHandleError+0x160>
800124b6:	c8 5b       	rjmp	800123c0 <ScmHandleError+0x64>

    if (NSR_E_ERR_FUNC_SPECIFIC == result)
    {
        WscmErrCodes _CONST *err_ptr = &wscm_err_codes[0];

        while ((err_ptr->func_id) && (err_ptr->func_id != msg_ptr->Func_ID))
800124b8:	00 00       	add	r0,r0
800124ba:	3a 9c       	mov	r12,-87
800124bc:	80 06       	ld.sh	r6,r0[0x0]
800124be:	ff 4c eb cd 	st.w	pc[-5171],r12

800124c0 <ScmHandleMlbAllocOnlyResult>:
800124c0:	eb cd 40 e0 	pushm	r5-r7,lr
800124c4:	18 97       	mov	r7,r12
800124c6:	58 0c       	cp.w	r12,0
800124c8:	c1 f0       	breq	80012506 <ScmHandleMlbAllocOnlyResult+0x46>
800124ca:	31 5c       	mov	r12,21
800124cc:	fe b0 aa f5 	rcall	80007ab6 <mns_take>
800124d0:	49 38       	lddpc	r8,8001251c <ScmHandleMlbAllocOnlyResult+0x5c>
800124d2:	8e 4a       	ld.sh	r10,r7[0x8]
    ASSERT(msg_ptr);

    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
800124d4:	90 69       	ld.sh	r9,r8[0xc]
800124d6:	f2 0a 19 00 	cp.h	r10,r9
800124da:	c0 60       	breq	800124e6 <ScmHandleMlbAllocOnlyResult+0x26>
    {
        tmp_cb_ptr       = (TScmAllocOnlyMlbCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800124dc:	31 5c       	mov	r12,21
800124de:	fe b0 aa ed 	rcall	80007ab8 <mns_give>
800124e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmAllocOnlyMlbCB *) wscm.cb_ptr;
800124e6:	70 26       	ld.w	r6,r8[0x8]
        wscm.cb_ptr = NULL;
800124e8:	30 05       	mov	r5,0
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800124ea:	31 5c       	mov	r12,21
    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmAllocOnlyMlbCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
800124ec:	f1 65 00 0f 	st.b	r8[15],r5

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmAllocOnlyMlbCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
800124f0:	91 25       	st.w	r8[0x8],r5
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800124f2:	fe b0 aa e3 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
800124f6:	58 06       	cp.w	r6,0
800124f8:	cf 50       	breq	800124e2 <ScmHandleMlbAllocOnlyResult+0x22>
    {
        tmp_cb_ptr(NSR_S_OK, msg_ptr->Data[0]);
800124fa:	6e 08       	ld.w	r8,r7[0x0]
800124fc:	0a 9c       	mov	r12,r5
800124fe:	11 8b       	ld.ub	r11,r8[0x0]
80012500:	5d 16       	icall	r6
80012502:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TScmAllocOnlyMlbCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_22);

    ASSERT(msg_ptr);
80012506:	e0 68 04 fa 	mov	r8,1274
8001250a:	30 1a       	mov	r10,1
8001250c:	1a d8       	st.w	--sp,r8
8001250e:	31 0b       	mov	r11,16
80012510:	e0 6c 00 80 	mov	r12,128
80012514:	fe b0 aa ec 	rcall	80007aec <mns_trace>
80012518:	2f fd       	sub	sp,-4
8001251a:	cd 8b       	rjmp	800124ca <ScmHandleMlbAllocOnlyResult+0xa>
8001251c:	00 00       	add	r0,r0
8001251e:	3a 9c       	mov	r12,-87

80012520 <ScmHandleConnectSocketsResult>:
80012520:	eb cd 40 e0 	pushm	r5-r7,lr
80012524:	18 97       	mov	r7,r12
80012526:	58 0c       	cp.w	r12,0
80012528:	c1 f0       	breq	80012566 <ScmHandleConnectSocketsResult+0x46>
8001252a:	31 5c       	mov	r12,21

    ASSERT(msg_ptr);

    tmp_cb_ptr = NULL;

    WAIT4CS();
8001252c:	fe b0 aa c5 	rcall	80007ab6 <mns_take>
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
80012530:	49 38       	lddpc	r8,8001257c <ScmHandleConnectSocketsResult+0x5c>
80012532:	8e 4a       	ld.sh	r10,r7[0x8]
80012534:	90 69       	ld.sh	r9,r8[0xc]
80012536:	f2 0a 19 00 	cp.h	r10,r9
8001253a:	c0 60       	breq	80012546 <ScmHandleConnectSocketsResult+0x26>
    {
        tmp_cb_ptr       = (TScmConnectSocketsCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
8001253c:	31 5c       	mov	r12,21
8001253e:	fe b0 aa bd 	rcall	80007ab8 <mns_give>
80012542:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmConnectSocketsCB *) wscm.cb_ptr;
80012546:	70 26       	ld.w	r6,r8[0x8]
        wscm.cb_ptr = NULL;
80012548:	30 05       	mov	r5,0
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
8001254a:	31 5c       	mov	r12,21
    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmConnectSocketsCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
8001254c:	f1 65 00 0f 	st.b	r8[15],r5

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmConnectSocketsCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
80012550:	91 25       	st.w	r8[0x8],r5
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
80012552:	fe b0 aa b3 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
80012556:	58 06       	cp.w	r6,0
80012558:	cf 50       	breq	80012542 <ScmHandleConnectSocketsResult+0x22>
    {
        tmp_cb_ptr(NSR_S_OK, msg_ptr->Data[0]);
8001255a:	6e 08       	ld.w	r8,r7[0x0]
8001255c:	0a 9c       	mov	r12,r5
8001255e:	11 8b       	ld.ub	r11,r8[0x0]
80012560:	5d 16       	icall	r6
80012562:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TScmConnectSocketsCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_20);

    ASSERT(msg_ptr);
80012566:	e0 68 04 be 	mov	r8,1214
8001256a:	30 1a       	mov	r10,1
8001256c:	1a d8       	st.w	--sp,r8
8001256e:	31 0b       	mov	r11,16
80012570:	e0 6c 00 80 	mov	r12,128
80012574:	fe b0 aa bc 	rcall	80007aec <mns_trace>
80012578:	2f fd       	sub	sp,-4
8001257a:	cd 8b       	rjmp	8001252a <ScmHandleConnectSocketsResult+0xa>
8001257c:	00 00       	add	r0,r0
8001257e:	3a 9c       	mov	r12,-87

80012580 <ScmHandleResult>:
80012580:	eb cd 40 c0 	pushm	r6-r7,lr
80012584:	20 1d       	sub	sp,4
80012586:	18 97       	mov	r7,r12
80012588:	58 0c       	cp.w	r12,0
8001258a:	c3 e0       	breq	80012606 <ScmHandleResult+0x86>
    ASSERT(msg_ptr);

    tmp_cb_ptr = NULL;
    tmp2_cb_ptr = NULL;

    WAIT4CS();
8001258c:	31 5c       	mov	r12,21
8001258e:	fe b0 aa 94 	rcall	80007ab6 <mns_take>
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
80012592:	4a 38       	lddpc	r8,8001261c <ScmHandleResult+0x9c>
80012594:	8e 49       	ld.sh	r9,r7[0x8]
80012596:	90 6a       	ld.sh	r10,r8[0xc]
80012598:	f2 0a 19 00 	cp.h	r10,r9
8001259c:	c0 70       	breq	800125aa <ScmHandleResult+0x2a>
                break;
        }
        wscm.cb_ptr     = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
8001259e:	31 5c       	mov	r12,21
800125a0:	fe b0 aa 8c 	rcall	80007ab8 <mns_give>
    {
        tmp2_cb_ptr(NSR_S_OK, 0, NULL);
    }

    T_MOD_EXIT(SCM_18);
}
800125a4:	2f fd       	sub	sp,-4
800125a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    tmp2_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        switch (wscm.cb_func_id)
800125aa:	e0 6a 04 04 	mov	r10,1028
800125ae:	f4 09 19 00 	cp.h	r9,r10
800125b2:	c1 00       	breq	800125d2 <ScmHandleResult+0x52>
                    tmp2_cb_ptr = (TScmListCB *) wscm.cb_ptr;
                    break;
                }
            /*lint -e(616,825) control flows into case/default intentionally */
            default:
                tmp_cb_ptr = wscm.cb_ptr;
800125b4:	70 26       	ld.w	r6,r8[0x8]
                break;
        }
        wscm.cb_ptr     = NULL;
800125b6:	30 07       	mov	r7,0
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800125b8:	31 5c       	mov	r12,21
            default:
                tmp_cb_ptr = wscm.cb_ptr;
                break;
        }
        wscm.cb_ptr     = NULL;
        wscm.api_locked = MNS_FALSE;
800125ba:	f1 67 00 0f 	st.b	r8[15],r7
            /*lint -e(616,825) control flows into case/default intentionally */
            default:
                tmp_cb_ptr = wscm.cb_ptr;
                break;
        }
        wscm.cb_ptr     = NULL;
800125be:	91 27       	st.w	r8[0x8],r7
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800125c0:	fe b0 aa 7c 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
800125c4:	58 06       	cp.w	r6,0
800125c6:	ce f0       	breq	800125a4 <ScmHandleResult+0x24>
    {
        tmp_cb_ptr(NSR_S_OK);
800125c8:	0e 9c       	mov	r12,r7
800125ca:	5d 16       	icall	r6
    {
        tmp2_cb_ptr(NSR_S_OK, 0, NULL);
    }

    T_MOD_EXIT(SCM_18);
}
800125cc:	2f fd       	sub	sp,-4
800125ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        switch (wscm.cb_func_id)
        {
            case FUNCID_INIC_DESTROYSOCKET:
                if (MNS_FALSE != wscm.api_ext)
800125d2:	f1 3a 00 10 	ld.ub	r10,r8[16]
800125d6:	30 09       	mov	r9,0
800125d8:	f2 0a 18 00 	cp.b	r10,r9
800125dc:	ce c0       	breq	800125b4 <ScmHandleResult+0x34>
            /*lint -e(616,825) control flows into case/default intentionally */
            default:
                tmp_cb_ptr = wscm.cb_ptr;
                break;
        }
        wscm.cb_ptr     = NULL;
800125de:	30 0a       	mov	r10,0
        {
            case FUNCID_INIC_DESTROYSOCKET:
                if (MNS_FALSE != wscm.api_ext)
                {
                    wscm.api_ext = MNS_FALSE;
                    tmp2_cb_ptr = (TScmListCB *) wscm.cb_ptr;
800125e0:	70 27       	ld.w	r7,r8[0x8]
            default:
                tmp_cb_ptr = wscm.cb_ptr;
                break;
        }
        wscm.cb_ptr     = NULL;
        wscm.api_locked = MNS_FALSE;
800125e2:	f1 6a 00 0f 	st.b	r8[15],r10
            /*lint -e(616,825) control flows into case/default intentionally */
            default:
                tmp_cb_ptr = wscm.cb_ptr;
                break;
        }
        wscm.cb_ptr     = NULL;
800125e6:	91 2a       	st.w	r8[0x8],r10
        switch (wscm.cb_func_id)
        {
            case FUNCID_INIC_DESTROYSOCKET:
                if (MNS_FALSE != wscm.api_ext)
                {
                    wscm.api_ext = MNS_FALSE;
800125e8:	f1 69 00 10 	st.b	r8[16],r9
                break;
        }
        wscm.cb_ptr     = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800125ec:	50 0a       	stdsp	sp[0x0],r10
800125ee:	31 5c       	mov	r12,21
800125f0:	fe b0 aa 64 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
    {
        tmp_cb_ptr(NSR_S_OK);
    }
    else if (tmp2_cb_ptr)
800125f4:	40 0a       	lddsp	r10,sp[0x0]
800125f6:	58 07       	cp.w	r7,0
800125f8:	cd 60       	breq	800125a4 <ScmHandleResult+0x24>
    {
        tmp2_cb_ptr(NSR_S_OK, 0, NULL);
800125fa:	14 9b       	mov	r11,r10
800125fc:	14 9c       	mov	r12,r10
800125fe:	5d 17       	icall	r7
    }

    T_MOD_EXIT(SCM_18);
}
80012600:	2f fd       	sub	sp,-4
80012602:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    TMnsStdCB  *tmp_cb_ptr;
    TScmListCB *tmp2_cb_ptr;

    T_MOD_ENTRY(SCM_18);

    ASSERT(msg_ptr);
80012606:	e0 68 04 41 	mov	r8,1089
8001260a:	30 1a       	mov	r10,1
8001260c:	1a d8       	st.w	--sp,r8
8001260e:	31 0b       	mov	r11,16
80012610:	e0 6c 00 80 	mov	r12,128
80012614:	fe b0 aa 6c 	rcall	80007aec <mns_trace>
80012618:	2f fd       	sub	sp,-4
8001261a:	cb 9b       	rjmp	8001258c <ScmHandleResult+0xc>
8001261c:	00 00       	add	r0,r0
8001261e:	3a 9c       	mov	r12,-87

80012620 <ScmGetBoundary>:
80012620:	eb cd 40 80 	pushm	r7,lr
80012624:	31 5c       	mov	r12,21
80012626:	fe b0 aa 48 	rcall	80007ab6 <mns_take>
8001262a:	48 58       	lddpc	r8,8001263c <ScmGetBoundary+0x1c>
    byte result;

    T_API_ENTRY(SCM_11);
    WAIT4CS();
    result = wscm.bandwidth.current;
    REL_CS();
8001262c:	31 5c       	mov	r12,21
{
    byte result;

    T_API_ENTRY(SCM_11);
    WAIT4CS();
    result = wscm.bandwidth.current;
8001262e:	f1 37 00 19 	ld.ub	r7,r8[25]
    REL_CS();
80012632:	fe b0 aa 43 	rcall	80007ab8 <mns_give>
    T_API_EXIT(SCM_11);

    return(result);
}
80012636:	0e 9c       	mov	r12,r7
80012638:	e3 cd 80 80 	ldm	sp++,r7,pc
8001263c:	00 00       	add	r0,r0
8001263e:	3a 9c       	mov	r12,-87

80012640 <ScmConnectSocketsExt>:
80012640:	d4 31       	pushm	r0-r7,lr
80012642:	4a 23       	lddpc	r3,800126c8 <ScmConnectSocketsExt+0x88>
80012644:	18 97       	mov	r7,r12
80012646:	16 96       	mov	r6,r11

#ifdef SCM_32
byte ScmConnectSocketsExt( byte input_handle, byte output_handle,
                           bool default_mute,
                           TScmConnectSocketsCB *cb_ptr )
{
80012648:	14 94       	mov	r4,r10
8001264a:	12 95       	mov	r5,r9

    go = MNS_FALSE;
    result = ERR_NO;
    cb_res = NSR_S_OK;

    WAIT4CS();
8001264c:	31 5c       	mov	r12,21
8001264e:	fe b0 aa 34 	rcall	80007ab6 <mns_take>
    if (MNS_FALSE == wscm.api_locked)
80012652:	e7 31 00 0f 	ld.ub	r1,r3[15]
80012656:	58 01       	cp.w	r1,0
80012658:	c2 a1       	brne	800126ac <ScmConnectSocketsExt+0x6c>
    {
        wscm.api_locked  = MNS_TRUE;
8001265a:	30 18       	mov	r8,1
        go = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id  = FUNCID_INIC_CONNECTSOCKETS;
    }
    REL_CS();
8001265c:	31 5c       	mov	r12,21
    cb_res = NSR_S_OK;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
    {
        wscm.api_locked  = MNS_TRUE;
8001265e:	e7 68 00 0f 	st.b	r3[15],r8
        go = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
80012662:	87 25       	st.w	r3[0x8],r5
        wscm.cb_func_id  = FUNCID_INIC_CONNECTSOCKETS;
80012664:	e0 60 04 05 	mov	r0,1029
80012668:	a6 60       	st.h	r3[0xc],r0
    }
    REL_CS();
8001266a:	fe b0 aa 27 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != go)
    {
        TMsgTx*     msg_ptr;
        msg_ptr = MsgGetTxPtrExt(3);
8001266e:	30 3c       	mov	r12,3
80012670:	fe b0 b4 16 	rcall	80008e9c <MsgGetTxPtrExt>
80012674:	18 92       	mov	r2,r12

        if (msg_ptr)
80012676:	c1 20       	breq	8001269a <ScmConnectSocketsExt+0x5a>
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
80012678:	30 18       	mov	r8,1
8001267a:	b8 38       	st.h	r12[0x6],r8
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_CONNECTSOCKETS;
            msg_ptr->Operation  = OP_STARTRESULT;
8001267c:	30 28       	mov	r8,2
        msg_ptr = MsgGetTxPtrExt(3);

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
8001267e:	f9 61 00 0a 	st.b	r12[10],r1
            msg_ptr->Func_ID    = FUNCID_INIC_CONNECTSOCKETS;
            msg_ptr->Operation  = OP_STARTRESULT;
80012682:	f9 68 00 0c 	st.b	r12[12],r8

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_CONNECTSOCKETS;
80012686:	b8 40       	st.h	r12[0x8],r0
            msg_ptr->Operation  = OP_STARTRESULT;
            msg_ptr->Data[0]    = input_handle;
80012688:	78 08       	ld.w	r8,r12[0x0]
8001268a:	b0 87       	st.b	r8[0x0],r7
            msg_ptr->Data[1]    = output_handle;
8001268c:	78 08       	ld.w	r8,r12[0x0]
8001268e:	b0 96       	st.b	r8[0x1],r6
            msg_ptr->Data[2]    = (MNS_FALSE != default_mute) ? (byte)0x01 : (byte)0x00;
80012690:	78 08       	ld.w	r8,r12[0x0]
80012692:	b0 a4       	st.b	r8[0x2],r4

            MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
80012694:	fe b0 b7 48 	rcall	80009524 <MsgSend3>
80012698:	d8 3a       	popm	r0-r7,pc,r12=0
        }
        else
        {
            result = ERR_BUFOV;
            cb_res = NSR_E_BUSY;
            WAIT4CS();
8001269a:	31 5c       	mov	r12,21
8001269c:	fe b0 aa 0d 	rcall	80007ab6 <mns_take>
            wscm.api_locked = MNS_FALSE;
            wscm.cb_ptr     = NULL;
            wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
800126a0:	fe 78 ee ee 	mov	r8,-4370
        {
            result = ERR_BUFOV;
            cb_res = NSR_E_BUSY;
            WAIT4CS();
            wscm.api_locked = MNS_FALSE;
            wscm.cb_ptr     = NULL;
800126a4:	87 22       	st.w	r3[0x8],r2
        else
        {
            result = ERR_BUFOV;
            cb_res = NSR_E_BUSY;
            WAIT4CS();
            wscm.api_locked = MNS_FALSE;
800126a6:	e7 62 00 0f 	st.b	r3[15],r2
            wscm.cb_ptr     = NULL;
            wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
800126aa:	a6 68       	st.h	r3[0xc],r8
            REL_CS();
800126ac:	31 5c       	mov	r12,21
800126ae:	fe b0 aa 05 	rcall	80007ab8 <mns_give>
    {
        result = ERR_BUFOV;
        cb_res = NSR_E_BUSY;
    }

    if ( (ERR_NO != result) && cb_ptr ) /* call cb in all error cases */
800126b2:	58 05       	cp.w	r5,0
800126b4:	c0 31       	brne	800126ba <ScmConnectSocketsExt+0x7a>
800126b6:	30 4c       	mov	r12,4
800126b8:	d8 32       	popm	r0-r7,pc
    {
        cb_ptr(cb_res, 0);
800126ba:	30 0b       	mov	r11,0
800126bc:	e0 6c 81 00 	mov	r12,33024
800126c0:	5d 15       	icall	r5
800126c2:	30 4c       	mov	r12,4
    }

    T_API_EXIT(SCM_32);
    return(result);
}
800126c4:	d8 32       	popm	r0-r7,pc
800126c6:	d7 03       	nop
800126c8:	00 00       	add	r0,r0
800126ca:	3a 9c       	mov	r12,-87

800126cc <ScmSendHandleMsg>:
800126cc:	eb cd 40 fc 	pushm	r2-r7,lr
800126d0:	49 f5       	lddpc	r5,8001274c <ScmSendHandleMsg+0x80>
800126d2:	18 97       	mov	r7,r12
800126d4:	16 96       	mov	r6,r11
800126d6:	14 92       	mov	r2,r10
800126d8:	31 5c       	mov	r12,21
800126da:	fe b0 a9 ee 	rcall	80007ab6 <mns_take>
    go      = MNS_FALSE;
    result  = ERR_NO;
    cb_res  = NSR_S_OK;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
800126de:	eb 33 00 0f 	ld.ub	r3,r5[15]
800126e2:	58 03       	cp.w	r3,0
800126e4:	c2 51       	brne	8001272e <ScmSendHandleMsg+0x62>
    {
        wscm.api_locked  = MNS_TRUE;
800126e6:	30 18       	mov	r8,1
        go               = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id  = func_id;
    }
    REL_CS();
800126e8:	31 5c       	mov	r12,21
    cb_res  = NSR_S_OK;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
    {
        wscm.api_locked  = MNS_TRUE;
800126ea:	eb 68 00 0f 	st.b	r5[15],r8
        go               = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
800126ee:	8b 26       	st.w	r5[0x8],r6
        wscm.cb_func_id  = func_id;
800126f0:	aa 62       	st.h	r5[0xc],r2
    }
    REL_CS();
800126f2:	fe b0 a9 e3 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != go)
    {
        TMsgTx *msg_ptr;
        msg_ptr = MsgGetTxPtrExt(1);
800126f6:	30 1c       	mov	r12,1
800126f8:	fe b0 b3 d2 	rcall	80008e9c <MsgGetTxPtrExt>
800126fc:	18 94       	mov	r4,r12

        if (msg_ptr)
800126fe:	c0 f0       	breq	8001271c <ScmSendHandleMsg+0x50>
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
80012700:	30 18       	mov	r8,1
80012702:	b8 38       	st.h	r12[0x6],r8
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = func_id;
            msg_ptr->Operation  = OP_STARTRESULT;
80012704:	30 28       	mov	r8,2
        msg_ptr = MsgGetTxPtrExt(1);

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
80012706:	f9 63 00 0a 	st.b	r12[10],r3
            msg_ptr->Func_ID    = func_id;
            msg_ptr->Operation  = OP_STARTRESULT;
8001270a:	f9 68 00 0c 	st.b	r12[12],r8

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = func_id;
8001270e:	b8 42       	st.h	r12[0x8],r2
            msg_ptr->Operation  = OP_STARTRESULT;
            msg_ptr->Data[0]    = handle;
80012710:	78 08       	ld.w	r8,r12[0x0]
80012712:	b0 87       	st.b	r8[0x0],r7

            MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
80012714:	fe b0 b7 08 	rcall	80009524 <MsgSend3>
80012718:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
        }
        else
        {
            result  = ERR_BUFOV;
            cb_res  = NSR_E_BUSY;
            WAIT4CS();
8001271c:	31 5c       	mov	r12,21
8001271e:	fe b0 a9 cc 	rcall	80007ab6 <mns_take>
            wscm.api_locked  = MNS_FALSE;
            wscm.cb_ptr      = NULL;
            wscm.cb_func_id  = INIC_SHADOW_INVALID_WORD;
80012722:	fe 78 ee ee 	mov	r8,-4370
        {
            result  = ERR_BUFOV;
            cb_res  = NSR_E_BUSY;
            WAIT4CS();
            wscm.api_locked  = MNS_FALSE;
            wscm.cb_ptr      = NULL;
80012726:	8b 24       	st.w	r5[0x8],r4
        else
        {
            result  = ERR_BUFOV;
            cb_res  = NSR_E_BUSY;
            WAIT4CS();
            wscm.api_locked  = MNS_FALSE;
80012728:	eb 64 00 0f 	st.b	r5[15],r4
            wscm.cb_ptr      = NULL;
            wscm.cb_func_id  = INIC_SHADOW_INVALID_WORD;
8001272c:	aa 68       	st.h	r5[0xc],r8
            REL_CS();
8001272e:	31 5c       	mov	r12,21
80012730:	fe b0 a9 c4 	rcall	80007ab8 <mns_give>
    {
        result  = ERR_BUFOV;
        cb_res  = NSR_E_BUSY;
    }

    if ( (ERR_NO != result) && cb_ptr)
80012734:	58 06       	cp.w	r6,0
80012736:	c0 41       	brne	8001273e <ScmSendHandleMsg+0x72>
80012738:	30 4c       	mov	r12,4
8001273a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        cb_ptr(cb_res);
8001273e:	e0 6c 81 00 	mov	r12,33024
80012742:	5d 16       	icall	r6
80012744:	30 4c       	mov	r12,4
    }

    T_API_EXIT(SCM_5);
    return(result);
}
80012746:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001274a:	d7 03       	nop
8001274c:	00 00       	add	r0,r0
8001274e:	3a 9c       	mov	r12,-87

80012750 <ScmHandleSourceDropStatus>:
80012750:	eb cd 40 c0 	pushm	r6-r7,lr
80012754:	18 97       	mov	r7,r12
80012756:	58 0c       	cp.w	r12,0
80012758:	c1 70       	breq	80012786 <ScmHandleSourceDropStatus+0x36>
8001275a:	49 16       	lddpc	r6,8001279c <ScmHandleSourceDropStatus+0x4c>
8001275c:	6c 58       	ld.w	r8,r6[0x14]
8001275e:	70 08       	ld.w	r8,r8[0x0]
{
    T_LIB_ENTRY(SCM_28);

    ASSERT(msg_ptr);

    if (wscm.cfg_ptr->on_error_fptr && EHCISTATE_IS_ATTACHED())
80012760:	58 08       	cp.w	r8,0
80012762:	c0 70       	breq	80012770 <ScmHandleSourceDropStatus+0x20>
80012764:	fe b0 c3 c6 	rcall	8000aef0 <MnsGetEHCIState>
80012768:	30 28       	mov	r8,2
8001276a:	f0 0c 18 00 	cp.b	r12,r8
8001276e:	c0 30       	breq	80012774 <ScmHandleSourceDropStatus+0x24>
80012770:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    {
        wscm.cfg_ptr->on_error_fptr(NSR_E_SOURCE_DROP, msg_ptr->Data[0]);
80012774:	6e 09       	ld.w	r9,r7[0x0]
80012776:	6c 58       	ld.w	r8,r6[0x14]
80012778:	13 8b       	ld.ub	r11,r9[0x0]
8001277a:	70 08       	ld.w	r8,r8[0x0]
8001277c:	e0 6c ab 01 	mov	r12,43777
80012780:	5d 18       	icall	r8
80012782:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
#ifdef SCM_28
void ScmHandleSourceDropStatus(TMsgRx *msg_ptr)
{
    T_LIB_ENTRY(SCM_28);

    ASSERT(msg_ptr);
80012786:	e0 68 05 e3 	mov	r8,1507
8001278a:	30 1a       	mov	r10,1
8001278c:	1a d8       	st.w	--sp,r8
8001278e:	31 0b       	mov	r11,16
80012790:	e0 6c 00 80 	mov	r12,128
80012794:	fe b0 a9 ac 	rcall	80007aec <mns_trace>
80012798:	2f fd       	sub	sp,-4
8001279a:	ce 0b       	rjmp	8001275a <ScmHandleSourceDropStatus+0xa>
8001279c:	00 00       	add	r0,r0
8001279e:	3a 9c       	mov	r12,-87

800127a0 <ScmHandleCreateSocketResult>:
800127a0:	eb cd 40 f8 	pushm	r3-r7,lr
800127a4:	18 97       	mov	r7,r12
800127a6:	58 0c       	cp.w	r12,0
{
    TScmCreateSocketCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_19);

    ASSERT(msg_ptr);
800127a8:	c6 50       	breq	80012872 <ScmHandleCreateSocketResult+0xd2>

    tmp_cb_ptr = NULL;

    WAIT4CS();
800127aa:	31 5c       	mov	r12,21
800127ac:	fe b0 a9 85 	rcall	80007ab6 <mns_take>
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
800127b0:	4b 63       	lddpc	r3,80012888 <ScmHandleCreateSocketResult+0xe8>
800127b2:	8e 49       	ld.sh	r9,r7[0x8]
800127b4:	86 68       	ld.sh	r8,r3[0xc]
800127b6:	f0 09 19 00 	cp.h	r9,r8
800127ba:	c0 60       	breq	800127c6 <ScmHandleCreateSocketResult+0x26>
    {
        tmp_cb_ptr       = (TScmCreateSocketCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800127bc:	31 5c       	mov	r12,21
800127be:	fe b0 a9 7d 	rcall	80007ab8 <mns_give>
800127c2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmCreateSocketCB *) wscm.cb_ptr;
800127c6:	66 26       	ld.w	r6,r3[0x8]
        wscm.cb_ptr = NULL;
800127c8:	30 05       	mov	r5,0
        wscm.api_locked = MNS_FALSE;
    }
    REL_CS();
800127ca:	31 5c       	mov	r12,21

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = (TScmCreateSocketCB *) wscm.cb_ptr;
        wscm.cb_ptr = NULL;
800127cc:	87 25       	st.w	r3[0x8],r5
        wscm.api_locked = MNS_FALSE;
800127ce:	e7 65 00 0f 	st.b	r3[15],r5
    }
    REL_CS();
800127d2:	fe b0 a9 73 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
800127d6:	58 06       	cp.w	r6,0
800127d8:	cf 50       	breq	800127c2 <ScmHandleCreateSocketResult+0x22>
    {
        if (msg_ptr->Length == 1)                /* without ResultList */
800127da:	8e 29       	ld.sh	r9,r7[0x4]
800127dc:	30 18       	mov	r8,1
800127de:	f0 09 19 00 	cp.h	r9,r8
800127e2:	c3 40       	breq	8001284a <ScmHandleCreateSocketResult+0xaa>
        else  /* with ResultList */
        {
            byte  list_len = 0;
            word *list_ptr = NULL;

            WAIT4CS();
800127e4:	31 5c       	mov	r12,21
800127e6:	fe b0 a9 68 	rcall	80007ab6 <mns_take>
            if (wscm.result_list_ptr)
800127ea:	66 15       	ld.w	r5,r3[0x4]
800127ec:	58 05       	cp.w	r5,0
800127ee:	c3 60       	breq	8001285a <ScmHandleCreateSocketResult+0xba>
            {
                byte i = 0;

                list_ptr = wscm.result_list_ptr;

                if (MNS_FALSE != MostIsSupported(NSF_CONN_LABELS))
800127f0:	32 0c       	mov	r12,32
800127f2:	fe b0 c3 61 	rcall	8000aeb4 <MostIsSupported>
800127f6:	c1 90       	breq	80012828 <ScmHandleCreateSocketResult+0x88>
                {
                    list_len = 1;

                    *list_ptr  = (word) msg_ptr->Data[2] << 8;
800127f8:	6e 08       	ld.w	r8,r7[0x0]
800127fa:	f1 28 00 02 	ld.sb	r8,r8[2]
800127fe:	a9 68       	lsl	r8,0x8
80012800:	aa 08       	st.h	r5[0x0],r8
                    *list_ptr |= (word) msg_ptr->Data[3];
80012802:	30 14       	mov	r4,1
80012804:	6e 09       	ld.w	r9,r7[0x0]
80012806:	13 b9       	ld.ub	r9,r9[0x3]
80012808:	12 48       	or	r8,r9
8001280a:	aa 08       	st.h	r5[0x0],r8
                    {
                        *list_ptr++ = (word)msg_ptr->Data[2+i];
                    }
                }

                list_ptr = wscm.result_list_ptr;
8001280c:	66 15       	ld.w	r5,r3[0x4]
                wscm.result_list_ptr = NULL;
8001280e:	30 08       	mov	r8,0
80012810:	87 18       	st.w	r3[0x4],r8
            }
            else
            {
                FAILED_ASSERT();
            }
            REL_CS();
80012812:	31 5c       	mov	r12,21
80012814:	fe b0 a9 52 	rcall	80007ab8 <mns_give>

            tmp_cb_ptr(NSR_S_OK,                        /* result */
80012818:	6e 08       	ld.w	r8,r7[0x0]
8001281a:	0a 99       	mov	r9,r5
8001281c:	08 9a       	mov	r10,r4
8001281e:	11 8b       	ld.ub	r11,r8[0x0]
80012820:	30 0c       	mov	r12,0
80012822:	5d 16       	icall	r6
80012824:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
                    *list_ptr  = (word) msg_ptr->Data[2] << 8;
                    *list_ptr |= (word) msg_ptr->Data[3];
                }
                else
                {
                    list_len = (byte) msg_ptr->Length - 2;
80012828:	0f da       	ld.ub	r10,r7[0x5]
8001282a:	f4 c4 00 02 	sub	r4,r10,2
8001282e:	5c 54       	castu.b	r4

                    for (; i < list_len; ++i)
80012830:	ce e0       	breq	8001280c <ScmHandleCreateSocketResult+0x6c>
    T_MOD_EXIT(SCM_18);
}
#endif

#ifdef SCM_19
void ScmHandleCreateSocketResult(TMsgRx *msg_ptr)
80012832:	20 3a       	sub	r10,3
80012834:	30 28       	mov	r8,2
80012836:	5c 5a       	castu.b	r10
80012838:	2f da       	sub	r10,-3
                {
                    list_len = (byte) msg_ptr->Length - 2;

                    for (; i < list_len; ++i)
                    {
                        *list_ptr++ = (word)msg_ptr->Data[2+i];
8001283a:	6e 09       	ld.w	r9,r7[0x0]
8001283c:	f2 08 07 09 	ld.ub	r9,r9[r8]
80012840:	0a b9       	st.h	r5++,r9
80012842:	2f f8       	sub	r8,-1
                }
                else
                {
                    list_len = (byte) msg_ptr->Length - 2;

                    for (; i < list_len; ++i)
80012844:	14 38       	cp.w	r8,r10
80012846:	cf a1       	brne	8001283a <ScmHandleCreateSocketResult+0x9a>
80012848:	ce 2b       	rjmp	8001280c <ScmHandleCreateSocketResult+0x6c>

    if (tmp_cb_ptr)
    {
        if (msg_ptr->Length == 1)                /* without ResultList */
        {
            tmp_cb_ptr(NSR_S_OK,                 /* result */
8001284a:	6e 08       	ld.w	r8,r7[0x0]
8001284c:	0a 99       	mov	r9,r5
8001284e:	11 8b       	ld.ub	r11,r8[0x0]
80012850:	0a 9a       	mov	r10,r5
80012852:	0a 9c       	mov	r12,r5
80012854:	5d 16       	icall	r6
80012856:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
                list_ptr = wscm.result_list_ptr;
                wscm.result_list_ptr = NULL;
            }
            else
            {
                FAILED_ASSERT();
8001285a:	e0 68 04 a8 	mov	r8,1192
8001285e:	30 1a       	mov	r10,1
80012860:	1a d8       	st.w	--sp,r8
80012862:	31 0b       	mov	r11,16
80012864:	e0 6c 00 80 	mov	r12,128
80012868:	0a 94       	mov	r4,r5
8001286a:	fe b0 a9 41 	rcall	80007aec <mns_trace>
8001286e:	2f fd       	sub	sp,-4
80012870:	cd 1b       	rjmp	80012812 <ScmHandleCreateSocketResult+0x72>
{
    TScmCreateSocketCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_19);

    ASSERT(msg_ptr);
80012872:	e0 68 04 70 	mov	r8,1136
80012876:	30 1a       	mov	r10,1
80012878:	1a d8       	st.w	--sp,r8
8001287a:	31 0b       	mov	r11,16
8001287c:	e0 6c 00 80 	mov	r12,128
80012880:	fe b0 a9 36 	rcall	80007aec <mns_trace>
80012884:	2f fd       	sub	sp,-4
80012886:	c9 2b       	rjmp	800127aa <ScmHandleCreateSocketResult+0xa>
80012888:	00 00       	add	r0,r0
8001288a:	3a 9c       	mov	r12,-87

8001288c <ScmHandleMuteModeStatus>:
8001288c:	eb cd 40 e0 	pushm	r5-r7,lr
80012890:	18 97       	mov	r7,r12
80012892:	58 0c       	cp.w	r12,0
80012894:	c2 b0       	breq	800128ea <ScmHandleMuteModeStatus+0x5e>
80012896:	31 5c       	mov	r12,21
80012898:	fe b0 a9 0f 	rcall	80007ab6 <mns_take>
    ASSERT(msg_ptr);

    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
8001289c:	49 98       	lddpc	r8,80012900 <ScmHandleMuteModeStatus+0x74>
8001289e:	8e 4a       	ld.sh	r10,r7[0x8]
800128a0:	90 69       	ld.sh	r9,r8[0xc]
800128a2:	f2 0a 19 00 	cp.h	r10,r9
800128a6:	c0 d0       	breq	800128c0 <ScmHandleMuteModeStatus+0x34>
    {
        tmp_cb_ptr       = wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    wscm.mute_mode = msg_ptr->Data[0];
800128a8:	6e 09       	ld.w	r9,r7[0x0]
800128aa:	13 89       	ld.ub	r9,r9[0x0]
    REL_CS();
800128ac:	31 5c       	mov	r12,21
    {
        tmp_cb_ptr       = wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    wscm.mute_mode = msg_ptr->Data[0];
800128ae:	f1 69 00 0e 	st.b	r8[14],r9
    REL_CS();
800128b2:	fe b0 a9 03 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
    {
        tmp_cb_ptr(NSR_S_OK);
    }
    MnsNtfCheck(NTF_MUTEMODE);
800128b6:	30 2c       	mov	r12,2
800128b8:	fe b0 c2 da 	rcall	8000ae6c <MnsNtfCheck>

    T_MOD_EXIT(SCM_21);
}
800128bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    tmp_cb_ptr = NULL;

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr       = wscm.cb_ptr;
800128c0:	70 25       	ld.w	r5,r8[0x8]
        wscm.cb_ptr = NULL;
800128c2:	30 06       	mov	r6,0
800128c4:	91 26       	st.w	r8[0x8],r6
        wscm.api_locked = MNS_FALSE;
800128c6:	f1 66 00 0f 	st.b	r8[15],r6
    }
    wscm.mute_mode = msg_ptr->Data[0];
800128ca:	6e 09       	ld.w	r9,r7[0x0]
800128cc:	13 89       	ld.ub	r9,r9[0x0]
    REL_CS();
800128ce:	31 5c       	mov	r12,21
    {
        tmp_cb_ptr       = wscm.cb_ptr;
        wscm.cb_ptr = NULL;
        wscm.api_locked = MNS_FALSE;
    }
    wscm.mute_mode = msg_ptr->Data[0];
800128d0:	f1 69 00 0e 	st.b	r8[14],r9
    REL_CS();
800128d4:	fe b0 a8 f2 	rcall	80007ab8 <mns_give>

    if (tmp_cb_ptr)
800128d8:	58 05       	cp.w	r5,0
800128da:	ce e0       	breq	800128b6 <ScmHandleMuteModeStatus+0x2a>
    {
        tmp_cb_ptr(NSR_S_OK);
800128dc:	0c 9c       	mov	r12,r6
800128de:	5d 15       	icall	r5
    }
    MnsNtfCheck(NTF_MUTEMODE);
800128e0:	30 2c       	mov	r12,2
800128e2:	fe b0 c2 c5 	rcall	8000ae6c <MnsNtfCheck>

    T_MOD_EXIT(SCM_21);
}
800128e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    TMnsStdCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_21);

    ASSERT(msg_ptr);
800128ea:	e0 68 04 db 	mov	r8,1243
800128ee:	30 1a       	mov	r10,1
800128f0:	1a d8       	st.w	--sp,r8
800128f2:	31 0b       	mov	r11,16
800128f4:	e0 6c 00 80 	mov	r12,128
800128f8:	fe b0 a8 fa 	rcall	80007aec <mns_trace>
800128fc:	2f fd       	sub	sp,-4
800128fe:	cc cb       	rjmp	80012896 <ScmHandleMuteModeStatus+0xa>
80012900:	00 00       	add	r0,r0
80012902:	3a 9c       	mov	r12,-87

80012904 <ScmCreateSocket>:
80012904:	d4 31       	pushm	r0-r7,lr
80012906:	18 95       	mov	r5,r12
80012908:	16 97       	mov	r7,r11
8001290a:	58 0c       	cp.w	r12,0
8001290c:	e0 80 00 e9 	breq	80012ade <ScmCreateSocket+0x1da>
80012910:	31 5c       	mov	r12,21
80012912:	fe f4 03 da 	ld.w	r4,pc[986]
    result = ERR_NO;
    cb_res = NSR_S_OK;
    go     = MNS_FALSE;
    release_lock = MNS_FALSE;

    WAIT4CS();
80012916:	fe b0 a8 d0 	rcall	80007ab6 <mns_take>
    if (MNS_FALSE == wscm.api_locked)
8001291a:	e9 33 00 0f 	ld.ub	r3,r4[15]
8001291e:	06 90       	mov	r0,r3
80012920:	58 03       	cp.w	r3,0
80012922:	c4 01       	brne	800129a2 <ScmCreateSocket+0x9e>
        wscm.api_locked  = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id  = FUNCID_INIC_CREATESOCKET;
        go = MNS_TRUE;
    }
    REL_CS();
80012924:	31 5c       	mov	r12,21

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
    {
        wscm.api_locked  = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
80012926:	89 27       	st.w	r4[0x8],r7
    release_lock = MNS_FALSE;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
    {
        wscm.api_locked  = MNS_TRUE;
80012928:	30 11       	mov	r1,1
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id  = FUNCID_INIC_CREATESOCKET;
8001292a:	e0 62 04 03 	mov	r2,1027
    release_lock = MNS_FALSE;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
    {
        wscm.api_locked  = MNS_TRUE;
8001292e:	e9 61 00 0f 	st.b	r4[15],r1
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id  = FUNCID_INIC_CREATESOCKET;
80012932:	a8 62       	st.h	r4[0xc],r2
        go = MNS_TRUE;
    }
    REL_CS();
80012934:	fe b0 a8 c2 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != go)
    {
        TMsgTx *msg_ptr;
        msg_ptr = MsgGetTxPtrExt(40);
80012938:	32 8c       	mov	r12,40
8001293a:	fe b0 b2 b1 	rcall	80008e9c <MsgGetTxPtrExt>
8001293e:	18 96       	mov	r6,r12

        if (msg_ptr)
80012940:	c7 50       	breq	80012a2a <ScmCreateSocket+0x126>
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
80012942:	30 18       	mov	r8,1
80012944:	b8 38       	st.h	r12[0x6],r8
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_CREATESOCKET;
            msg_ptr->Operation  = OP_STARTRESULT;
80012946:	30 28       	mov	r8,2
        msg_ptr = MsgGetTxPtrExt(40);

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
80012948:	f9 63 00 0a 	st.b	r12[10],r3
            msg_ptr->Func_ID    = FUNCID_INIC_CREATESOCKET;
            msg_ptr->Operation  = OP_STARTRESULT;
8001294c:	f9 68 00 0c 	st.b	r12[12],r8

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_CREATESOCKET;
80012950:	b8 42       	st.h	r12[0x8],r2
            msg_ptr->Operation  = OP_STARTRESULT;
            msg_ptr->Data[0]    = desc_ptr->port_id;
80012952:	78 08       	ld.w	r8,r12[0x0]
80012954:	0b 89       	ld.ub	r9,r5[0x0]
80012956:	b0 89       	st.b	r8[0x0],r9
            msg_ptr->Data[1]    = desc_ptr->direction;
80012958:	0b 99       	ld.ub	r9,r5[0x1]
8001295a:	78 08       	ld.w	r8,r12[0x0]
8001295c:	b0 99       	st.b	r8[0x1],r9
            msg_ptr->Data[2]    = desc_ptr->datatype;
8001295e:	0b a9       	ld.ub	r9,r5[0x2]
80012960:	78 08       	ld.w	r8,r12[0x0]
80012962:	b0 a9       	st.b	r8[0x2],r9
            msg_ptr->Data[3]    = HB(desc_ptr->blockwidth);
80012964:	0b c9       	ld.ub	r9,r5[0x4]
80012966:	78 08       	ld.w	r8,r12[0x0]
80012968:	b0 b9       	st.b	r8[0x3],r9
            msg_ptr->Data[4]    = LB(desc_ptr->blockwidth);
8001296a:	8a 29       	ld.sh	r9,r5[0x4]
8001296c:	78 08       	ld.w	r8,r12[0x0]
8001296e:	b0 c9       	st.b	r8[0x4],r9
            msg_ptr->Length     = 5;
80012970:	30 58       	mov	r8,5
80012972:	b8 28       	st.h	r12[0x4],r8
            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id)
80012974:	0b 83       	ld.ub	r3,r5[0x0]
80012976:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8001297a:	58 33       	cp.w	r3,3
8001297c:	e0 80 00 bc 	breq	80012af4 <ScmCreateSocket+0x1f0>
80012980:	e0 8a 00 24 	brle	800129c8 <ScmCreateSocket+0xc4>
80012984:	58 53       	cp.w	r3,5
80012986:	e0 80 00 ce 	breq	80012b22 <ScmCreateSocket+0x21e>
8001298a:	c6 95       	brlt	80012a5c <ScmCreateSocket+0x158>
8001298c:	58 63       	cp.w	r3,6
8001298e:	c7 31       	brne	80012a74 <ScmCreateSocket+0x170>
                    break;
                #endif

                #ifdef _OS81110_ISO
                case SCM_PORT_ID_RMCK:
                    msg_ptr->Data[5] = desc_ptr->rmck.data_sample_freq_ref;
80012990:	eb 39 00 26 	ld.ub	r9,r5[38]
80012994:	78 08       	ld.w	r8,r12[0x0]
80012996:	b0 d9       	st.b	r8[0x5],r9
                    msg_ptr->Length  = 6;
80012998:	b8 23       	st.h	r12[0x4],r3
                    MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
8001299a:	30 06       	mov	r6,0
8001299c:	fe b0 b5 c4 	rcall	80009524 <MsgSend3>
                    break;
800129a0:	c1 28       	rjmp	800129c4 <ScmCreateSocket+0xc0>
        wscm.api_locked  = MNS_TRUE;
        wscm.cb_ptr      = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id  = FUNCID_INIC_CREATESOCKET;
        go = MNS_TRUE;
    }
    REL_CS();
800129a2:	31 5c       	mov	r12,21
800129a4:	fe b0 a8 8a 	rcall	80007ab8 <mns_give>
800129a8:	58 07       	cp.w	r7,0
800129aa:	5f 18       	srne	r8
800129ac:	fe 75 81 00 	mov	r5,-32512
800129b0:	30 46       	mov	r6,4
        wscm.cb_ptr     = NULL;
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
        REL_CS();
    }

    if ( (ERR_NO != result) && cb_ptr)
800129b2:	58 08       	cp.w	r8,0
800129b4:	c0 80       	breq	800129c4 <ScmCreateSocket+0xc0>
    {
        cb_ptr(cb_res, 0, 0, NULL);
800129b6:	30 09       	mov	r9,0
800129b8:	0a 9c       	mov	r12,r5
800129ba:	12 9a       	mov	r10,r9
800129bc:	e2 1c 87 00 	andl	r12,0x8700,COH
800129c0:	12 9b       	mov	r11,r9
800129c2:	5d 17       	icall	r7
    }

    T_API_EXIT(SCM_8);
    return(result);
}
800129c4:	0c 9c       	mov	r12,r6
800129c6:	d8 32       	popm	r0-r7,pc
            msg_ptr->Data[1]    = desc_ptr->direction;
            msg_ptr->Data[2]    = desc_ptr->datatype;
            msg_ptr->Data[3]    = HB(desc_ptr->blockwidth);
            msg_ptr->Data[4]    = LB(desc_ptr->blockwidth);
            msg_ptr->Length     = 5;
            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id)
800129c8:	58 03       	cp.w	r3,0
800129ca:	c5 31       	brne	80012a70 <ScmCreateSocket+0x16c>
            {
                case SCM_PORT_ID_MEDIALB:
                    msg_ptr->Data[5] = HB(desc_ptr->medialb.channel_addr);
800129cc:	0b e9       	ld.ub	r9,r5[0x6]
800129ce:	78 08       	ld.w	r8,r12[0x0]
800129d0:	b0 d9       	st.b	r8[0x5],r9
                    msg_ptr->Data[6] = LB(desc_ptr->medialb.channel_addr);
800129d2:	8a 39       	ld.sh	r9,r5[0x6]
800129d4:	78 08       	ld.w	r8,r12[0x0]
800129d6:	b0 e9       	st.b	r8[0x6],r9
                    msg_ptr->Length  = 7;
800129d8:	30 78       	mov	r8,7
800129da:	b8 28       	st.h	r12[0x4],r8

                    if ((SCM_TYPE_SYNC == desc_ptr->datatype) &&
800129dc:	0b a8       	ld.ub	r8,r5[0x2]
800129de:	58 08       	cp.w	r8,0
800129e0:	e0 80 00 b5 	breq	80012b4a <ScmCreateSocket+0x246>
                            msg_ptr->Data[7] = desc_ptr->medialb.offset;
                            msg_ptr->Length  = 8;
                        }
                    }
                    #ifdef _OS81110_ISO
                    else if(SCM_TYPE_ISOPACKET == desc_ptr->datatype)
800129e4:	30 39       	mov	r9,3
800129e6:	f2 08 18 00 	cp.b	r8,r9
800129ea:	e0 80 00 f6 	breq	80012bd6 <ScmCreateSocket+0x2d2>
                        msg_ptr->Length  = 10;
                    }
                    #endif

                    #ifdef _OS81110_ISO
                    else if(SCM_TYPE_ISODFDATA == desc_ptr->datatype)
800129ee:	30 59       	mov	r9,5
800129f0:	f2 08 18 00 	cp.b	r8,r9
800129f4:	e0 80 01 4b 	breq	80012c8a <ScmCreateSocket+0x386>
                        msg_ptr->Length  = 11;
                    }
                    #endif

                    #ifdef _OS81110_ISO
                    else if(SCM_TYPE_ISODFPHASE == desc_ptr->datatype)
800129f8:	30 49       	mov	r9,4
800129fa:	f2 08 18 00 	cp.b	r8,r9
800129fe:	c1 01       	brne	80012a1e <ScmCreateSocket+0x11a>
                    {
                        msg_ptr->Data[7] = HB(desc_ptr->medialb.iso_packet_size);
80012a00:	eb 39 00 0a 	ld.ub	r9,r5[10]
80012a04:	6c 08       	ld.w	r8,r6[0x0]
80012a06:	b0 f9       	st.b	r8[0x7],r9
                        msg_ptr->Data[8] = LB(desc_ptr->medialb.iso_packet_size);
80012a08:	8a 59       	ld.sh	r9,r5[0xa]
80012a0a:	6c 08       	ld.w	r8,r6[0x0]
80012a0c:	f1 69 00 08 	st.b	r8[8],r9
                        msg_ptr->Data[9] = desc_ptr->medialb.data_sample_freq_ref;
80012a10:	eb 39 00 0c 	ld.ub	r9,r5[12]
80012a14:	6c 08       	ld.w	r8,r6[0x0]
80012a16:	f1 69 00 09 	st.b	r8[9],r9
                        msg_ptr->Length  = 10;
80012a1a:	30 a8       	mov	r8,10
80012a1c:	ac 28       	st.h	r6[0x4],r8
                    if(SCM_TYPE_PACKET == desc_ptr->datatype)
                    {
                        msg_ptr->Data[3]    = (byte)0xFF;
                        msg_ptr->Data[4]    = (byte)0xFF;
                    }
                    MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
80012a1e:	0c 9c       	mov	r12,r6
80012a20:	fe b0 b5 82 	rcall	80009524 <MsgSend3>
80012a24:	30 06       	mov	r6,0
        cb_ptr(cb_res, 0, 0, NULL);
    }

    T_API_EXIT(SCM_8);
    return(result);
}
80012a26:	0c 9c       	mov	r12,r6
80012a28:	d8 32       	popm	r0-r7,pc
        REL_CS();
    }

    if ( (ERR_NO != result) && cb_ptr)
    {
        cb_ptr(cb_res, 0, 0, NULL);
80012a2a:	fe 75 81 00 	mov	r5,-32512
80012a2e:	30 46       	mov	r6,4
        cb_res = NSR_E_BUSY;
    }

    if ( MNS_FALSE != release_lock )
    {
        WAIT4CS();
80012a30:	31 5c       	mov	r12,21
80012a32:	fe b0 a8 42 	rcall	80007ab6 <mns_take>
        wscm.api_locked = MNS_FALSE;
        wscm.cb_ptr     = NULL;
80012a36:	30 08       	mov	r8,0
80012a38:	89 28       	st.w	r4[0x8],r8
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
80012a3a:	fe 78 ee ee 	mov	r8,-4370
    }

    if ( MNS_FALSE != release_lock )
    {
        WAIT4CS();
        wscm.api_locked = MNS_FALSE;
80012a3e:	30 03       	mov	r3,0
        wscm.cb_ptr     = NULL;
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
80012a40:	a8 68       	st.h	r4[0xc],r8
    }

    if ( MNS_FALSE != release_lock )
    {
        WAIT4CS();
        wscm.api_locked = MNS_FALSE;
80012a42:	e9 63 00 0f 	st.b	r4[15],r3
        wscm.cb_ptr     = NULL;
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
        REL_CS();
80012a46:	31 5c       	mov	r12,21
80012a48:	fe b0 a8 38 	rcall	80007ab8 <mns_give>
80012a4c:	e6 06 18 00 	cp.b	r6,r3
80012a50:	5f 19       	srne	r9
80012a52:	58 07       	cp.w	r7,0
80012a54:	5f 18       	srne	r8
80012a56:	f3 e8 00 08 	and	r8,r9,r8
80012a5a:	ca cb       	rjmp	800129b2 <ScmCreateSocket+0xae>
                    break;
                #endif

                #ifdef _OS81110_SPI
                case SCM_PORT_ID_SPI:
                    if(SCM_TYPE_PACKET == desc_ptr->datatype)
80012a5c:	0b a8       	ld.ub	r8,r5[0x2]
80012a5e:	e2 08 18 00 	cp.b	r8,r1
80012a62:	cd e1       	brne	80012a1e <ScmCreateSocket+0x11a>
                    {
                        msg_ptr->Data[3]    = (byte)0xFF;
80012a64:	78 09       	ld.w	r9,r12[0x0]
80012a66:	3f f8       	mov	r8,-1
80012a68:	b2 b8       	st.b	r9[0x3],r8
                        msg_ptr->Data[4]    = (byte)0xFF;
80012a6a:	78 09       	ld.w	r9,r12[0x0]
80012a6c:	b2 c8       	st.b	r9[0x4],r8
80012a6e:	cd 8b       	rjmp	80012a1e <ScmCreateSocket+0x11a>
            msg_ptr->Data[1]    = desc_ptr->direction;
            msg_ptr->Data[2]    = desc_ptr->datatype;
            msg_ptr->Data[3]    = HB(desc_ptr->blockwidth);
            msg_ptr->Data[4]    = LB(desc_ptr->blockwidth);
            msg_ptr->Length     = 5;
            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id)
80012a70:	58 23       	cp.w	r3,2
80012a72:	c1 20       	breq	80012a96 <ScmCreateSocket+0x192>
                    MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
                    break;
                #endif

                default:
                    FAILED_ASSERT();
80012a74:	30 1a       	mov	r10,1
80012a76:	31 0b       	mov	r11,16
80012a78:	e0 68 02 c3 	mov	r8,707
80012a7c:	1a d8       	st.w	--sp,r8
80012a7e:	e0 6c 00 80 	mov	r12,128
80012a82:	fe b0 a8 35 	rcall	80007aec <mns_trace>
                    result = ERR_PARAM;
                    cb_res = NSR_E_PARAM;
                    MsgTxUnused(msg_ptr);
80012a86:	0c 9c       	mov	r12,r6
80012a88:	fe 75 86 00 	mov	r5,-31232
80012a8c:	fe b0 b2 54 	rcall	80008f34 <MsgTxUnused>
80012a90:	30 16       	mov	r6,1
80012a92:	2f fd       	sub	sp,-4
80012a94:	cc eb       	rjmp	80012a30 <ScmCreateSocket+0x12c>
                case SCM_PORT_ID_MOST:
                    {
                    byte most_preallocated;
                    byte most_preallocated_pos = 5;

                    if (MNS_FALSE != MostIsSupported(NSF_CONN_LABELS))
80012a96:	32 0c       	mov	r12,32
80012a98:	fe b0 c2 0e 	rcall	8000aeb4 <MostIsSupported>
80012a9c:	c5 11       	brne	80012b3e <ScmCreateSocket+0x23a>
                            }
                        }
                    }
                    else
                    {
                        if (SCM_IN == desc_ptr->direction)
80012a9e:	0b 98       	ld.ub	r8,r5[0x1]
80012aa0:	e0 08 18 00 	cp.b	r8,r0
80012aa4:	c0 70       	breq	80012ab2 <ScmCreateSocket+0x1ae>
                        {
                            most_preallocated = SCM_PA_SBC;
                        }
                        else
                        {
                            most_preallocated = (desc_ptr->most.flags & SCM_MOST_FLAGS_SOURCE_CONNECT) ? SCM_PA_SBC : SCM_PA_NOT;
80012aa6:	eb 33 00 10 	ld.ub	r3,r5[16]
80012aaa:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80012aae:	f9 b3 01 02 	movne	r3,2
                        }
                    }

                    switch (desc_ptr->datatype)
80012ab2:	0b a8       	ld.ub	r8,r5[0x2]
80012ab4:	30 49       	mov	r9,4
80012ab6:	f2 08 18 00 	cp.b	r8,r9
80012aba:	e0 80 00 d4 	breq	80012c62 <ScmCreateSocket+0x35e>
80012abe:	e0 8b 00 5c 	brhi	80012b76 <ScmCreateSocket+0x272>
80012ac2:	30 09       	mov	r9,0
80012ac4:	f2 08 18 00 	cp.b	r8,r9
80012ac8:	c5 f0       	breq	80012b86 <ScmCreateSocket+0x282>
80012aca:	30 39       	mov	r9,3
80012acc:	f2 08 18 00 	cp.b	r8,r9
80012ad0:	e0 80 00 be 	breq	80012c4c <ScmCreateSocket+0x348>
                            msg_ptr->Data[5] = desc_ptr->most.data_sample_freq_ref;
                            most_preallocated_pos = 6;
                            break;
                        #endif
                        default:
                            FAILED_ASSERT();
80012ad4:	30 1a       	mov	r10,1
80012ad6:	31 0b       	mov	r11,16
80012ad8:	e0 68 02 5a 	mov	r8,602
80012adc:	cd 0b       	rjmp	80012a7c <ScmCreateSocket+0x178>
    TMnsResult cb_res;
    bool go;
    bool release_lock;

    T_API_ENTRY(SCM_8);
    ASSERT(desc_ptr);
80012ade:	e0 68 01 bf 	mov	r8,447
80012ae2:	30 1a       	mov	r10,1
80012ae4:	1a d8       	st.w	--sp,r8
80012ae6:	31 0b       	mov	r11,16
80012ae8:	e0 6c 00 80 	mov	r12,128
80012aec:	fe b0 a8 00 	rcall	80007aec <mns_trace>
80012af0:	2f fd       	sub	sp,-4
80012af2:	c0 fb       	rjmp	80012910 <ScmCreateSocket+0xc>
                    }
                    }
                    break;

                case SCM_PORT_ID_STREAM: /*lint !e616 control flows into case/default intenionally! */
                    msg_ptr->Data[5] = desc_ptr->streaming.interface_id;
80012af4:	eb 3a 00 20 	ld.ub	r10,r5[32]
80012af8:	78 09       	ld.w	r9,r12[0x0]
80012afa:	b2 da       	st.b	r9[0x5],r10
                    msg_ptr->Length  = 6;
80012afc:	30 69       	mov	r9,6
80012afe:	b8 29       	st.h	r12[0x4],r9

                    if(SCM_TYPE_SYNC == desc_ptr->datatype)
80012b00:	0b a9       	ld.ub	r9,r5[0x2]
80012b02:	58 09       	cp.w	r9,0
80012b04:	c2 a0       	breq	80012b58 <ScmCreateSocket+0x254>
                            msg_ptr->Data[6] = desc_ptr->streaming.offset;
                            msg_ptr->Length  = 7;
                        }
                    }
                    #ifdef _OS81110_ISO
                    else if(SCM_TYPE_ISODFDATA == desc_ptr->datatype)
80012b06:	f0 09 18 00 	cp.b	r9,r8
80012b0a:	c0 50       	breq	80012b14 <ScmCreateSocket+0x210>
                    {
                        msg_ptr->Data[6] = desc_ptr->streaming.data_sample_freq_ref;
                        msg_ptr->Length = 7;
                    }
                    else if(SCM_TYPE_ISODFPHASE == desc_ptr->datatype)
80012b0c:	30 48       	mov	r8,4
80012b0e:	f0 09 18 00 	cp.b	r9,r8
80012b12:	c8 61       	brne	80012a1e <ScmCreateSocket+0x11a>
                    {
                        msg_ptr->Data[6] = desc_ptr->streaming.data_sample_freq_ref;
80012b14:	eb 39 00 22 	ld.ub	r9,r5[34]
80012b18:	6c 08       	ld.w	r8,r6[0x0]
80012b1a:	b0 e9       	st.b	r8[0x6],r9
                        msg_ptr->Length = 7;
80012b1c:	30 78       	mov	r8,7
80012b1e:	ac 28       	st.h	r6[0x4],r8
80012b20:	c7 fb       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                    MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
                    break;

                #ifdef _OS81110_ISO
                case SCM_PORT_ID_TRANSPORT:
                    msg_ptr->Data[5] = HB(desc_ptr->transport.iso_packet_size);
80012b22:	78 08       	ld.w	r8,r12[0x0]
80012b24:	eb 39 00 24 	ld.ub	r9,r5[36]
80012b28:	b0 d9       	st.b	r8[0x5],r9
                    msg_ptr->Data[6] = LB(desc_ptr->transport.iso_packet_size);
80012b2a:	78 08       	ld.w	r8,r12[0x0]
80012b2c:	eb 09 00 24 	ld.sh	r9,r5[36]
80012b30:	b0 e9       	st.b	r8[0x6],r9
                    msg_ptr->Length  = 7;
80012b32:	30 78       	mov	r8,7
                    MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
80012b34:	30 06       	mov	r6,0

                #ifdef _OS81110_ISO
                case SCM_PORT_ID_TRANSPORT:
                    msg_ptr->Data[5] = HB(desc_ptr->transport.iso_packet_size);
                    msg_ptr->Data[6] = LB(desc_ptr->transport.iso_packet_size);
                    msg_ptr->Length  = 7;
80012b36:	b8 28       	st.h	r12[0x4],r8
                    MsgSend3(msg_ptr);  /* handler will release the lock and call cb_ptr */
80012b38:	fe b0 b4 f6 	rcall	80009524 <MsgSend3>
                    break;
80012b3c:	c4 4b       	rjmp	800129c4 <ScmCreateSocket+0xc0>
                    byte most_preallocated;
                    byte most_preallocated_pos = 5;

                    if (MNS_FALSE != MostIsSupported(NSF_CONN_LABELS))
                    {
                        if (SCM_OUT == desc_ptr->direction)
80012b3e:	0b 98       	ld.ub	r8,r5[0x1]
80012b40:	e2 08 18 00 	cp.b	r8,r1
80012b44:	c3 d1       	brne	80012bbe <ScmCreateSocket+0x2ba>
80012b46:	30 03       	mov	r3,0
80012b48:	cb 5b       	rjmp	80012ab2 <ScmCreateSocket+0x1ae>
                case SCM_PORT_ID_MEDIALB:
                    msg_ptr->Data[5] = HB(desc_ptr->medialb.channel_addr);
                    msg_ptr->Data[6] = LB(desc_ptr->medialb.channel_addr);
                    msg_ptr->Length  = 7;

                    if ((SCM_TYPE_SYNC == desc_ptr->datatype) &&
80012b4a:	30 1c       	mov	r12,1
80012b4c:	fe b0 c1 b4 	rcall	8000aeb4 <MostIsSupported>
80012b50:	e0 81 00 b2 	brne	80012cb4 <ScmCreateSocket+0x3b0>
80012b54:	0b a8       	ld.ub	r8,r5[0x2]
80012b56:	c4 7b       	rjmp	800129e4 <ScmCreateSocket+0xe0>
                    msg_ptr->Data[5] = desc_ptr->streaming.interface_id;
                    msg_ptr->Length  = 6;

                    if(SCM_TYPE_SYNC == desc_ptr->datatype)
                    {
                        if ((MNS_FALSE != MostIsSupported(NSF_EXT_SOCKETS)) &&
80012b58:	30 1c       	mov	r12,1
80012b5a:	fe b0 c1 ad 	rcall	8000aeb4 <MostIsSupported>
80012b5e:	fe 90 ff 60 	breq	80012a1e <ScmCreateSocket+0x11a>
                            desc_ptr->streaming.offset)
80012b62:	eb 38 00 21 	ld.ub	r8,r5[33]
                    msg_ptr->Data[5] = desc_ptr->streaming.interface_id;
                    msg_ptr->Length  = 6;

                    if(SCM_TYPE_SYNC == desc_ptr->datatype)
                    {
                        if ((MNS_FALSE != MostIsSupported(NSF_EXT_SOCKETS)) &&
80012b66:	58 08       	cp.w	r8,0
80012b68:	fe 90 ff 5b 	breq	80012a1e <ScmCreateSocket+0x11a>
                            desc_ptr->streaming.offset)
                        {
                            msg_ptr->Data[6] = desc_ptr->streaming.offset;
80012b6c:	6c 09       	ld.w	r9,r6[0x0]
80012b6e:	b2 e8       	st.b	r9[0x6],r8
                            msg_ptr->Length  = 7;
80012b70:	30 78       	mov	r8,7
80012b72:	ac 28       	st.h	r6[0x4],r8
80012b74:	c5 5b       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                        {
                            most_preallocated = (desc_ptr->most.flags & SCM_MOST_FLAGS_SOURCE_CONNECT) ? SCM_PA_SBC : SCM_PA_NOT;
                        }
                    }

                    switch (desc_ptr->datatype)
80012b76:	30 59       	mov	r9,5
80012b78:	f2 08 18 00 	cp.b	r8,r9
80012b7c:	c7 a0       	breq	80012c70 <ScmCreateSocket+0x36c>
80012b7e:	30 69       	mov	r9,6
80012b80:	f2 08 18 00 	cp.b	r8,r9
80012b84:	ca 81       	brne	80012ad4 <ScmCreateSocket+0x1d0>
                        #endif
                        default:
                            FAILED_ASSERT();
                            result = ERR_PARAM;
                            cb_res = NSR_E_PARAM;
                            MsgTxUnused(msg_ptr);
80012b86:	30 6b       	mov	r11,6
80012b88:	30 59       	mov	r9,5

                    if (msg_ptr)
                    {
                        byte i = 0;

                        switch (most_preallocated)
80012b8a:	30 28       	mov	r8,2
80012b8c:	f0 03 18 00 	cp.b	r3,r8
80012b90:	c4 40       	breq	80012c18 <ScmCreateSocket+0x314>
80012b92:	30 38       	mov	r8,3
80012b94:	f0 03 18 00 	cp.b	r3,r8
80012b98:	c2 f0       	breq	80012bf6 <ScmCreateSocket+0x2f2>
80012b9a:	30 18       	mov	r8,1
80012b9c:	f0 03 18 00 	cp.b	r3,r8
80012ba0:	c2 b0       	breq	80012bf6 <ScmCreateSocket+0x2f2>
                        {
                            case SCM_PA_NOT:        /* not preallocated */
                                msg_ptr->Data[most_preallocated_pos++] = most_preallocated;
80012ba2:	6c 08       	ld.w	r8,r6[0x0]
80012ba4:	30 0a       	mov	r10,0
80012ba6:	f0 09 0b 0a 	st.b	r8[r9],r10
                                msg_ptr->Length  = most_preallocated_pos;
80012baa:	ac 2b       	st.h	r6[0x4],r11
                                WAIT4CS();
80012bac:	31 5c       	mov	r12,21
80012bae:	fe b0 a7 84 	rcall	80007ab6 <mns_take>
                                wscm.result_list_ptr = desc_ptr->most.result_list_ptr;
80012bb2:	6a 68       	ld.w	r8,r5[0x18]
                                REL_CS();
80012bb4:	31 5c       	mov	r12,21
                        {
                            case SCM_PA_NOT:        /* not preallocated */
                                msg_ptr->Data[most_preallocated_pos++] = most_preallocated;
                                msg_ptr->Length  = most_preallocated_pos;
                                WAIT4CS();
                                wscm.result_list_ptr = desc_ptr->most.result_list_ptr;
80012bb6:	89 18       	st.w	r4[0x4],r8
                                REL_CS();
80012bb8:	fe b0 a7 80 	rcall	80007ab8 <mns_give>
                                break;
80012bbc:	c3 1b       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                        {
                            most_preallocated = SCM_PA_NOT;
                        }
                        else
                        {
                            if ((MNS_FALSE != MostIsSupported(NSF_MOST_150)) &&
80012bbe:	e0 6c 40 00 	mov	r12,16384
80012bc2:	fe b0 c1 79 	rcall	8000aeb4 <MostIsSupported>
80012bc6:	c6 00       	breq	80012c86 <ScmCreateSocket+0x382>
                                (desc_ptr->most.flags & SCM_MOST_FLAGS_MULTIPLE_CONNECTIONS))
80012bc8:	eb 38 00 10 	ld.ub	r8,r5[16]
80012bcc:	ed b8 00 01 	bld	r8,0x1
80012bd0:	c5 b1       	brne	80012c86 <ScmCreateSocket+0x382>
80012bd2:	30 33       	mov	r3,3
80012bd4:	c6 fb       	rjmp	80012ab2 <ScmCreateSocket+0x1ae>
                        }
                    }
                    #ifdef _OS81110_ISO
                    else if(SCM_TYPE_ISOPACKET == desc_ptr->datatype)
                    {
                        msg_ptr->Data[7] = HB(desc_ptr->medialb.iso_packet_size);
80012bd6:	eb 39 00 0a 	ld.ub	r9,r5[10]
80012bda:	6c 08       	ld.w	r8,r6[0x0]
80012bdc:	b0 f9       	st.b	r8[0x7],r9
                        msg_ptr->Data[8] = LB(desc_ptr->medialb.iso_packet_size);
80012bde:	8a 59       	ld.sh	r9,r5[0xa]
80012be0:	6c 08       	ld.w	r8,r6[0x0]
80012be2:	f1 69 00 08 	st.b	r8[8],r9
                        msg_ptr->Data[9] = (MNS_FALSE != desc_ptr->medialb.flow_control_enable) ? (byte)0x01 : (byte)0x00;
80012be6:	eb 39 00 0d 	ld.ub	r9,r5[13]
80012bea:	6c 08       	ld.w	r8,r6[0x0]
80012bec:	f1 69 00 09 	st.b	r8[9],r9
                        msg_ptr->Length  = 10;
80012bf0:	30 a8       	mov	r8,10
80012bf2:	ac 28       	st.h	r6[0x4],r8
80012bf4:	c1 5b       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                                wscm.result_list_ptr = desc_ptr->most.result_list_ptr;
                                REL_CS();
                                break;
                            case SCM_PA_CL:         /* preallocated - connection label      */
                            case SCM_PA_CL_MULTCON: /*              - multiple connections  */
                                msg_ptr->Data[most_preallocated_pos++] = most_preallocated;
80012bf6:	6c 08       	ld.w	r8,r6[0x0]
80012bf8:	f0 09 0b 03 	st.b	r8[r9],r3
                                msg_ptr->Data[most_preallocated_pos++] = HB(desc_ptr->most.list_ptr[0]);
80012bfc:	6a 58       	ld.w	r8,r5[0x14]
80012bfe:	11 89       	ld.ub	r9,r8[0x0]
80012c00:	6c 08       	ld.w	r8,r6[0x0]
80012c02:	f0 0b 0b 09 	st.b	r8[r11],r9
                                msg_ptr->Data[most_preallocated_pos++] = LB(desc_ptr->most.list_ptr[0]);
80012c06:	6a 58       	ld.w	r8,r5[0x14]
                                REL_CS();
                                break;
                            case SCM_PA_CL:         /* preallocated - connection label      */
                            case SCM_PA_CL_MULTCON: /*              - multiple connections  */
                                msg_ptr->Data[most_preallocated_pos++] = most_preallocated;
                                msg_ptr->Data[most_preallocated_pos++] = HB(desc_ptr->most.list_ptr[0]);
80012c08:	2f fb       	sub	r11,-1
                                msg_ptr->Data[most_preallocated_pos++] = LB(desc_ptr->most.list_ptr[0]);
80012c0a:	90 09       	ld.sh	r9,r8[0x0]
80012c0c:	6c 08       	ld.w	r8,r6[0x0]
80012c0e:	f0 0b 0b 09 	st.b	r8[r11],r9
                                msg_ptr->Length  = most_preallocated_pos;
80012c12:	2f fb       	sub	r11,-1
80012c14:	ac 2b       	st.h	r6[0x4],r11
                                break;
80012c16:	c0 4b       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                            case SCM_PA_SBC:        /* preallocated - single Byte channels */
                                msg_ptr->Data[most_preallocated_pos++] = most_preallocated;
80012c18:	6c 08       	ld.w	r8,r6[0x0]
80012c1a:	f0 09 0b 03 	st.b	r8[r9],r3

                                for (; i < desc_ptr->most.list_len; ++i)
80012c1e:	eb 39 00 11 	ld.ub	r9,r5[17]
80012c22:	58 09       	cp.w	r9,0
80012c24:	c1 10       	breq	80012c46 <ScmCreateSocket+0x342>
80012c26:	30 08       	mov	r8,0
                                {
                                    msg_ptr->Data[most_preallocated_pos+i] = (byte) desc_ptr->most.list_ptr[i];
80012c28:	6c 09       	ld.w	r9,r6[0x0]
80012c2a:	6a 5a       	ld.w	r10,r5[0x14]
80012c2c:	16 09       	add	r9,r11
80012c2e:	f4 08 04 1a 	ld.sh	r10,r10[r8<<0x1]
80012c32:	f2 08 0b 0a 	st.b	r9[r8],r10
                                msg_ptr->Length  = most_preallocated_pos;
                                break;
                            case SCM_PA_SBC:        /* preallocated - single Byte channels */
                                msg_ptr->Data[most_preallocated_pos++] = most_preallocated;

                                for (; i < desc_ptr->most.list_len; ++i)
80012c36:	2f f8       	sub	r8,-1
80012c38:	eb 39 00 11 	ld.ub	r9,r5[17]
80012c3c:	5c 58       	castu.b	r8
80012c3e:	f0 09 18 00 	cp.b	r9,r8
80012c42:	fe 9b ff f3 	brhi	80012c28 <ScmCreateSocket+0x324>
                                {
                                    msg_ptr->Data[most_preallocated_pos+i] = (byte) desc_ptr->most.list_ptr[i];
                                }

                                msg_ptr->Length = most_preallocated_pos + desc_ptr->most.list_len;
80012c46:	16 09       	add	r9,r11
80012c48:	ac 29       	st.h	r6[0x4],r9
80012c4a:	ce aa       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                            break;
                        #endif

                        #ifdef _OS81110_ISO
                        case SCM_TYPE_ISOPACKET:
                            msg_ptr->Data[5] = HB(desc_ptr->most.iso_packet_size);
80012c4c:	eb 39 00 1c 	ld.ub	r9,r5[28]
80012c50:	6c 08       	ld.w	r8,r6[0x0]
80012c52:	b0 d9       	st.b	r8[0x5],r9
                            msg_ptr->Data[6] = LB(desc_ptr->most.iso_packet_size);
80012c54:	eb 09 00 1c 	ld.sh	r9,r5[28]
80012c58:	6c 08       	ld.w	r8,r6[0x0]
80012c5a:	30 8b       	mov	r11,8
80012c5c:	b0 e9       	st.b	r8[0x6],r9
80012c5e:	30 79       	mov	r9,7
                            most_preallocated_pos = 7;
                            break;
80012c60:	c9 5b       	rjmp	80012b8a <ScmCreateSocket+0x286>
                            msg_ptr->Data[5] = desc_ptr->most.data_frame_blockwidth;
                            msg_ptr->Data[6] = desc_ptr->most.data_sample_freq_ref;
                            most_preallocated_pos = 7;
                            break;
                        case SCM_TYPE_ISODFPHASE:
                            msg_ptr->Data[5] = desc_ptr->most.data_sample_freq_ref;
80012c62:	eb 39 00 1f 	ld.ub	r9,r5[31]
80012c66:	6c 08       	ld.w	r8,r6[0x0]
80012c68:	30 7b       	mov	r11,7
80012c6a:	b0 d9       	st.b	r8[0x5],r9
80012c6c:	30 69       	mov	r9,6
                            most_preallocated_pos = 6;
                            break;
80012c6e:	c8 eb       	rjmp	80012b8a <ScmCreateSocket+0x286>
                            msg_ptr->Data[5] = HB(desc_ptr->most.iso_packet_size);
                            msg_ptr->Data[6] = LB(desc_ptr->most.iso_packet_size);
                            most_preallocated_pos = 7;
                            break;
                        case SCM_TYPE_ISODFDATA:
                            msg_ptr->Data[5] = desc_ptr->most.data_frame_blockwidth;
80012c70:	eb 39 00 1e 	ld.ub	r9,r5[30]
80012c74:	6c 08       	ld.w	r8,r6[0x0]
80012c76:	b0 d9       	st.b	r8[0x5],r9
                            msg_ptr->Data[6] = desc_ptr->most.data_sample_freq_ref;
80012c78:	eb 39 00 1f 	ld.ub	r9,r5[31]
80012c7c:	6c 08       	ld.w	r8,r6[0x0]
80012c7e:	30 8b       	mov	r11,8
80012c80:	b0 e9       	st.b	r8[0x6],r9
80012c82:	30 79       	mov	r9,7
                            most_preallocated_pos = 7;
                            break;
80012c84:	c8 3b       	rjmp	80012b8a <ScmCreateSocket+0x286>
                        {
                            most_preallocated = SCM_PA_SBC;
                        }
                        else
                        {
                            most_preallocated = (desc_ptr->most.flags & SCM_MOST_FLAGS_SOURCE_CONNECT) ? SCM_PA_SBC : SCM_PA_NOT;
80012c86:	30 13       	mov	r3,1
80012c88:	c1 5b       	rjmp	80012ab2 <ScmCreateSocket+0x1ae>
                    #endif

                    #ifdef _OS81110_ISO
                    else if(SCM_TYPE_ISODFDATA == desc_ptr->datatype)
                    {
                        msg_ptr->Data[7] = HB(desc_ptr->medialb.iso_packet_size);
80012c8a:	eb 39 00 0a 	ld.ub	r9,r5[10]
80012c8e:	6c 08       	ld.w	r8,r6[0x0]
80012c90:	b0 f9       	st.b	r8[0x7],r9
                        msg_ptr->Data[8] = LB(desc_ptr->medialb.iso_packet_size);
80012c92:	8a 59       	ld.sh	r9,r5[0xa]
80012c94:	6c 08       	ld.w	r8,r6[0x0]
80012c96:	f1 69 00 08 	st.b	r8[8],r9
                        msg_ptr->Data[9] = desc_ptr->medialb.data_sample_freq_ref;
80012c9a:	eb 39 00 0c 	ld.ub	r9,r5[12]
80012c9e:	6c 08       	ld.w	r8,r6[0x0]
80012ca0:	f1 69 00 09 	st.b	r8[9],r9
                        msg_ptr->Data[10]= (MNS_FALSE != desc_ptr->medialb.flow_control_enable) ? (byte)0x01 : (byte)0x00;
80012ca4:	eb 39 00 0d 	ld.ub	r9,r5[13]
80012ca8:	6c 08       	ld.w	r8,r6[0x0]
80012caa:	f1 69 00 0a 	st.b	r8[10],r9
                        msg_ptr->Length  = 11;
80012cae:	30 b8       	mov	r8,11
80012cb0:	ac 28       	st.h	r6[0x4],r8
80012cb2:	cb 6a       	rjmp	80012a1e <ScmCreateSocket+0x11a>
                    msg_ptr->Length  = 7;

                    if ((SCM_TYPE_SYNC == desc_ptr->datatype) &&
                        (MNS_FALSE != MostIsSupported(NSF_EXT_SOCKETS)))
                    {
                        if (desc_ptr->medialb.channel_blockwidth)
80012cb4:	eb 38 00 09 	ld.ub	r8,r5[9]
80012cb8:	e0 08 18 00 	cp.b	r8,r0
80012cbc:	c0 d0       	breq	80012cd6 <ScmCreateSocket+0x3d2>
                        {
                            msg_ptr->Data[7] = desc_ptr->medialb.offset;
80012cbe:	eb 39 00 08 	ld.ub	r9,r5[8]
80012cc2:	6c 08       	ld.w	r8,r6[0x0]
80012cc4:	b0 f9       	st.b	r8[0x7],r9
                            msg_ptr->Data[8] = desc_ptr->medialb.channel_blockwidth;
80012cc6:	eb 39 00 09 	ld.ub	r9,r5[9]
80012cca:	6c 08       	ld.w	r8,r6[0x0]
80012ccc:	f1 69 00 08 	st.b	r8[8],r9
                            msg_ptr->Length  = 9;
80012cd0:	30 98       	mov	r8,9
80012cd2:	ac 28       	st.h	r6[0x4],r8
80012cd4:	ca 5a       	rjmp	80012a1e <ScmCreateSocket+0x11a>

                        }
                        else if (desc_ptr->medialb.offset)
80012cd6:	eb 38 00 08 	ld.ub	r8,r5[8]
80012cda:	58 08       	cp.w	r8,0
80012cdc:	fe 90 fe a1 	breq	80012a1e <ScmCreateSocket+0x11a>
                        {
                            msg_ptr->Data[7] = desc_ptr->medialb.offset;
80012ce0:	6c 09       	ld.w	r9,r6[0x0]
80012ce2:	b2 f8       	st.b	r9[0x7],r8
                            msg_ptr->Length  = 8;
80012ce4:	30 88       	mov	r8,8
80012ce6:	ac 28       	st.h	r6[0x4],r8
80012ce8:	c9 ba       	rjmp	80012a1e <ScmCreateSocket+0x11a>
80012cea:	d7 03       	nop
80012cec:	00 00       	add	r0,r0
80012cee:	3a 9c       	mov	r12,-87

80012cf0 <ScmOpenPort>:
80012cf0:	eb cd 40 fc 	pushm	r2-r7,lr
80012cf4:	18 96       	mov	r6,r12
80012cf6:	16 95       	mov	r5,r11
80012cf8:	58 0c       	cp.w	r12,0
80012cfa:	c7 90       	breq	80012dec <ScmOpenPort+0xfc>
80012cfc:	31 5c       	mov	r12,21
80012cfe:	fe b0 a6 dc 	rcall	80007ab6 <mns_take>
80012d02:	4e 37       	lddpc	r7,80012e8c <ScmOpenPort+0x19c>
80012d04:	ef 34 00 0f 	ld.ub	r4,r7[15]
80012d08:	08 92       	mov	r2,r4
80012d0a:	58 04       	cp.w	r4,0
    cb_res          = NSR_S_OK;
    go              = MNS_FALSE;
    release_lock    = MNS_FALSE;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
80012d0c:	c4 81       	brne	80012d9c <ScmOpenPort+0xac>
    {
        wscm.api_locked = MNS_TRUE;
80012d0e:	30 18       	mov	r8,1
        wscm.cb_ptr     = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id = FUNCID_INIC_OPENPORT;
        go              = MNS_TRUE;
    }
    REL_CS();
80012d10:	31 5c       	mov	r12,21
    release_lock    = MNS_FALSE;

    WAIT4CS();
    if (MNS_FALSE == wscm.api_locked)
    {
        wscm.api_locked = MNS_TRUE;
80012d12:	ef 68 00 0f 	st.b	r7[15],r8
        wscm.cb_ptr     = (TMnsStdCB *) cb_ptr;
80012d16:	8f 25       	st.w	r7[0x8],r5
        wscm.cb_func_id = FUNCID_INIC_OPENPORT;
80012d18:	e0 63 04 00 	mov	r3,1024
80012d1c:	ae 63       	st.h	r7[0xc],r3
        go              = MNS_TRUE;
    }
    REL_CS();
80012d1e:	fe b0 a6 cd 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != go)
    {
        TMsgTx* msg_ptr;
        msg_ptr = MsgGetTxPtrExt(5);
80012d22:	30 5c       	mov	r12,5
80012d24:	fe b0 b0 bc 	rcall	80008e9c <MsgGetTxPtrExt>
80012d28:	18 98       	mov	r8,r12

        if (msg_ptr)
80012d2a:	c5 d0       	breq	80012de4 <ScmOpenPort+0xf4>
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
80012d2c:	f9 64 00 0a 	st.b	r12[10],r4
            msg_ptr->Func_ID    = FUNCID_INIC_OPENPORT;
80012d30:	b8 43       	st.h	r12[0x8],r3
        TMsgTx* msg_ptr;
        msg_ptr = MsgGetTxPtrExt(5);

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
80012d32:	30 19       	mov	r9,1
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_OPENPORT;
            msg_ptr->Operation  = OP_STARTRESULT;
80012d34:	30 2a       	mov	r10,2
        TMsgTx* msg_ptr;
        msg_ptr = MsgGetTxPtrExt(5);

        if (msg_ptr)
        {
            msg_ptr->Tgt_Adr    = MSG_TGT_INIC;
80012d36:	b8 39       	st.h	r12[0x6],r9
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_OPENPORT;
            msg_ptr->Operation  = OP_STARTRESULT;
80012d38:	f9 6a 00 0c 	st.b	r12[12],r10
            msg_ptr->Data[0]    = desc_ptr->port_id;
80012d3c:	78 09       	ld.w	r9,r12[0x0]
80012d3e:	0d 8b       	ld.ub	r11,r6[0x0]
80012d40:	b2 8b       	st.b	r9[0x0],r11

            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id) /* masked out instances */
80012d42:	0d 89       	ld.ub	r9,r6[0x0]
80012d44:	f3 d9 c0 05 	bfextu	r9,r9,0x0,0x5
80012d48:	58 49       	cp.w	r9,4
80012d4a:	c6 b0       	breq	80012e20 <ScmOpenPort+0x130>
80012d4c:	e0 8a 00 39 	brle	80012dbe <ScmOpenPort+0xce>
80012d50:	58 59       	cp.w	r9,5
80012d52:	e0 80 00 94 	breq	80012e7a <ScmOpenPort+0x18a>
80012d56:	58 69       	cp.w	r9,6
80012d58:	c7 20       	breq	80012e3c <ScmOpenPort+0x14c>

                default:
                    release_lock = MNS_TRUE;
                    result = ERR_PARAM;
                    cb_res = NSR_E_PARAM;
                    MsgTxUnused(msg_ptr);
80012d5a:	10 9c       	mov	r12,r8
80012d5c:	fe b0 b0 ec 	rcall	80008f34 <MsgTxUnused>
                    FAILED_ASSERT();
80012d60:	e0 68 01 90 	mov	r8,400
80012d64:	30 1a       	mov	r10,1
80012d66:	1a d8       	st.w	--sp,r8
80012d68:	31 0b       	mov	r11,16
80012d6a:	e0 6c 00 80 	mov	r12,128
80012d6e:	fe 74 86 00 	mov	r4,-31232
80012d72:	fe b0 a6 bd 	rcall	80007aec <mns_trace>
80012d76:	30 16       	mov	r6,1
80012d78:	2f fd       	sub	sp,-4
         cb_res = NSR_E_BUSY;
    }

    if ( MNS_FALSE != release_lock )
    {
        WAIT4CS();
80012d7a:	31 5c       	mov	r12,21
80012d7c:	fe b0 a6 9d 	rcall	80007ab6 <mns_take>
        wscm.api_locked = MNS_FALSE;
80012d80:	30 08       	mov	r8,0
80012d82:	ef 68 00 0f 	st.b	r7[15],r8
        wscm.cb_ptr     = NULL;
80012d86:	30 08       	mov	r8,0
80012d88:	8f 28       	st.w	r7[0x8],r8
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
80012d8a:	fe 78 ee ee 	mov	r8,-4370
        REL_CS();
80012d8e:	31 5c       	mov	r12,21
    if ( MNS_FALSE != release_lock )
    {
        WAIT4CS();
        wscm.api_locked = MNS_FALSE;
        wscm.cb_ptr     = NULL;
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
80012d90:	ae 68       	st.h	r7[0xc],r8
        REL_CS();
80012d92:	fe b0 a6 93 	rcall	80007ab8 <mns_give>
80012d96:	58 05       	cp.w	r5,0
80012d98:	5f 18       	srne	r8
80012d9a:	c0 98       	rjmp	80012dac <ScmOpenPort+0xbc>
        wscm.api_locked = MNS_TRUE;
        wscm.cb_ptr     = (TMnsStdCB *) cb_ptr;
        wscm.cb_func_id = FUNCID_INIC_OPENPORT;
        go              = MNS_TRUE;
    }
    REL_CS();
80012d9c:	31 5c       	mov	r12,21
80012d9e:	fe b0 a6 8d 	rcall	80007ab8 <mns_give>
80012da2:	58 05       	cp.w	r5,0
80012da4:	5f 18       	srne	r8
80012da6:	fe 74 81 00 	mov	r4,-32512
80012daa:	30 46       	mov	r6,4
        wscm.cb_ptr     = NULL;
        wscm.cb_func_id = INIC_SHADOW_INVALID_WORD;
        REL_CS();
    }

    if ( (ERR_NO != result) && cb_ptr)
80012dac:	58 08       	cp.w	r8,0
80012dae:	c0 50       	breq	80012db8 <ScmOpenPort+0xc8>
    {
        cb_ptr(cb_res);
80012db0:	08 9c       	mov	r12,r4
80012db2:	e2 1c 87 00 	andl	r12,0x8700,COH
80012db6:	5d 15       	icall	r5
    }

    T_API_EXIT(SCM_7);
    return(result);
}
80012db8:	0c 9c       	mov	r12,r6
80012dba:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
            msg_ptr->FBlock_ID  = FBLOCK_INIC;
            msg_ptr->Func_ID    = FUNCID_INIC_OPENPORT;
            msg_ptr->Operation  = OP_STARTRESULT;
            msg_ptr->Data[0]    = desc_ptr->port_id;

            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id) /* masked out instances */
80012dbe:	58 09       	cp.w	r9,0
80012dc0:	c2 10       	breq	80012e02 <ScmOpenPort+0x112>
80012dc2:	58 39       	cp.w	r9,3
80012dc4:	cc b1       	brne	80012d5a <ScmOpenPort+0x6a>
                    msg_ptr->Length  = 4;
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
                    break;

                case SCM_PORT_ID_STREAM:
                    msg_ptr->Data[1] = desc_ptr->config.streaming.clock_drive_mode;
80012dc6:	78 09       	ld.w	r9,r12[0x0]
80012dc8:	0d 9a       	ld.ub	r10,r6[0x1]
80012dca:	b2 9a       	st.b	r9[0x1],r10
                    msg_ptr->Data[2] = desc_ptr->config.streaming.port_mode;
80012dcc:	78 09       	ld.w	r9,r12[0x0]
80012dce:	0d aa       	ld.ub	r10,r6[0x2]
80012dd0:	b2 aa       	st.b	r9[0x2],r10
                    msg_ptr->Data[3] = desc_ptr->config.streaming.data_format;
80012dd2:	78 09       	ld.w	r9,r12[0x0]
80012dd4:	0d ba       	ld.ub	r10,r6[0x3]
80012dd6:	b2 ba       	st.b	r9[0x3],r10
                    msg_ptr->Length  = 4;
80012dd8:	30 49       	mov	r9,4
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012dda:	30 06       	mov	r6,0

                case SCM_PORT_ID_STREAM:
                    msg_ptr->Data[1] = desc_ptr->config.streaming.clock_drive_mode;
                    msg_ptr->Data[2] = desc_ptr->config.streaming.port_mode;
                    msg_ptr->Data[3] = desc_ptr->config.streaming.data_format;
                    msg_ptr->Length  = 4;
80012ddc:	b8 29       	st.h	r12[0x4],r9
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012dde:	fe b0 b3 a3 	rcall	80009524 <MsgSend3>
                    break;
80012de2:	ce bb       	rjmp	80012db8 <ScmOpenPort+0xc8>
    if (MNS_FALSE != go)
    {
        TMsgTx* msg_ptr;
        msg_ptr = MsgGetTxPtrExt(5);

        if (msg_ptr)
80012de4:	fe 74 81 00 	mov	r4,-32512
80012de8:	30 46       	mov	r6,4
80012dea:	cc 8b       	rjmp	80012d7a <ScmOpenPort+0x8a>
    TMnsResult  cb_res;
    bool        go;
    bool        release_lock;

    T_API_ENTRY(SCM_7);
    ASSERT(desc_ptr);
80012dec:	e0 68 01 36 	mov	r8,310
80012df0:	30 1a       	mov	r10,1
80012df2:	1a d8       	st.w	--sp,r8
80012df4:	31 0b       	mov	r11,16
80012df6:	e0 6c 00 80 	mov	r12,128
80012dfa:	fe b0 a6 79 	rcall	80007aec <mns_trace>
80012dfe:	2f fd       	sub	sp,-4
80012e00:	c7 eb       	rjmp	80012cfc <ScmOpenPort+0xc>
            msg_ptr->Data[0]    = desc_ptr->port_id;

            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id) /* masked out instances */
            {
                 case SCM_PORT_ID_MEDIALB:
                    msg_ptr->Data[1] = (byte)MEDIALB_AUTO;
80012e02:	78 0a       	ld.w	r10,r12[0x0]
80012e04:	3f fb       	mov	r11,-1
80012e06:	b4 9b       	st.b	r10[0x1],r11
                    msg_ptr->Data[2] = desc_ptr->config.medialb.port_mode;
80012e08:	0d 9b       	ld.ub	r11,r6[0x1]
80012e0a:	78 0a       	ld.w	r10,r12[0x0]
80012e0c:	b4 ab       	st.b	r10[0x2],r11
                    msg_ptr->Data[3] = desc_ptr->config.medialb.clock_config;
80012e0e:	0d ab       	ld.ub	r11,r6[0x2]
80012e10:	78 0a       	ld.w	r10,r12[0x0]
                    msg_ptr->Length  = 4;
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012e12:	12 96       	mov	r6,r9
            switch (SCM_PORT_ID_INST_MASK & desc_ptr->port_id) /* masked out instances */
            {
                 case SCM_PORT_ID_MEDIALB:
                    msg_ptr->Data[1] = (byte)MEDIALB_AUTO;
                    msg_ptr->Data[2] = desc_ptr->config.medialb.port_mode;
                    msg_ptr->Data[3] = desc_ptr->config.medialb.clock_config;
80012e14:	b4 bb       	st.b	r10[0x3],r11
                    msg_ptr->Length  = 4;
80012e16:	30 49       	mov	r9,4
80012e18:	b8 29       	st.h	r12[0x4],r9
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012e1a:	fe b0 b3 85 	rcall	80009524 <MsgSend3>
                    break;
80012e1e:	cc db       	rjmp	80012db8 <ScmOpenPort+0xc8>
                    break;
                #endif

                #ifdef _OS81110_SPI
                case SCM_PORT_ID_SPI:
                    msg_ptr->Data[1] = desc_ptr->config.spi.port_mode;
80012e20:	0d 9b       	ld.ub	r11,r6[0x1]
80012e22:	78 0a       	ld.w	r10,r12[0x0]
80012e24:	b4 9b       	st.b	r10[0x1],r11
                    msg_ptr->Data[2] = desc_ptr->config.spi.clock_mode;
80012e26:	0d ab       	ld.ub	r11,r6[0x2]
80012e28:	78 0a       	ld.w	r10,r12[0x0]
80012e2a:	b4 ab       	st.b	r10[0x2],r11
                    msg_ptr->Data[3] = desc_ptr->config.spi.interrupt_threshold;
80012e2c:	0d bb       	ld.ub	r11,r6[0x3]
80012e2e:	78 0a       	ld.w	r10,r12[0x0]
80012e30:	b4 bb       	st.b	r10[0x3],r11
                    msg_ptr->Length  = 4;
80012e32:	b8 29       	st.h	r12[0x4],r9
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012e34:	30 06       	mov	r6,0
80012e36:	fe b0 b3 77 	rcall	80009524 <MsgSend3>
                    break;
80012e3a:	cb fb       	rjmp	80012db8 <ScmOpenPort+0xc8>
                    break;
                #endif

                #ifdef _OS81110_ISO
                case SCM_PORT_ID_RMCK:
                    msg_ptr->Data[1] = desc_ptr->config.rmck.drive_mode;
80012e3c:	0d ab       	ld.ub	r11,r6[0x2]
80012e3e:	78 09       	ld.w	r9,r12[0x0]
80012e40:	b2 9b       	st.b	r9[0x1],r11
                    msg_ptr->Length = 2;
80012e42:	30 29       	mov	r9,2
80012e44:	b8 29       	st.h	r12[0x4],r9
                    if( SCM_RMCK_SCKFSY_INIC_OUT == desc_ptr->config.rmck.drive_mode )
80012e46:	0d a9       	ld.ub	r9,r6[0x2]
80012e48:	e8 09 18 00 	cp.b	r9,r4
80012e4c:	c1 21       	brne	80012e70 <ScmOpenPort+0x180>
                    {
                        msg_ptr->Data[2] = desc_ptr->config.rmck.divider;
80012e4e:	0d 9b       	ld.ub	r11,r6[0x1]
80012e50:	78 09       	ld.w	r9,r12[0x0]
80012e52:	b2 ab       	st.b	r9[0x2],r11
                        msg_ptr->Data[3] = desc_ptr->config.rmck.clock_source;
80012e54:	0d bb       	ld.ub	r11,r6[0x3]
80012e56:	78 09       	ld.w	r9,r12[0x0]
80012e58:	b2 bb       	st.b	r9[0x3],r11
                        msg_ptr->Length = 4;
80012e5a:	30 49       	mov	r9,4
80012e5c:	b8 29       	st.h	r12[0x4],r9
                        if (SCM_RMCK_ISOC_LINKED_TO_PORT==desc_ptr->config.rmck.clock_source)
80012e5e:	0d b9       	ld.ub	r9,r6[0x3]
80012e60:	f4 09 18 00 	cp.b	r9,r10
80012e64:	c0 61       	brne	80012e70 <ScmOpenPort+0x180>
                        {
                            msg_ptr->Data[4] = desc_ptr->config.rmck.linked_to_port_id;
80012e66:	0d ca       	ld.ub	r10,r6[0x4]
80012e68:	78 09       	ld.w	r9,r12[0x0]
80012e6a:	b2 ca       	st.b	r9[0x4],r10
                            msg_ptr->Length = 5;
80012e6c:	30 59       	mov	r9,5
80012e6e:	b8 29       	st.h	r12[0x4],r9
                        }
                    }
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012e70:	10 9c       	mov	r12,r8
80012e72:	30 06       	mov	r6,0
80012e74:	fe b0 b3 58 	rcall	80009524 <MsgSend3>
                    break;
80012e78:	ca 0b       	rjmp	80012db8 <ScmOpenPort+0xc8>
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
                    break;

                #ifdef _OS81110_ISO
                case SCM_PORT_ID_TRANSPORT:
                    msg_ptr->Data[1] = desc_ptr->config.transport.port_mode;
80012e7a:	78 09       	ld.w	r9,r12[0x0]
80012e7c:	0d 9a       	ld.ub	r10,r6[0x1]
80012e7e:	b2 9a       	st.b	r9[0x1],r10
                    msg_ptr->Length  = 2;
80012e80:	30 29       	mov	r9,2
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012e82:	30 06       	mov	r6,0
                    break;

                #ifdef _OS81110_ISO
                case SCM_PORT_ID_TRANSPORT:
                    msg_ptr->Data[1] = desc_ptr->config.transport.port_mode;
                    msg_ptr->Length  = 2;
80012e84:	b8 29       	st.h	r12[0x4],r9
                    MsgSend3(msg_ptr);   /* handler will release the lock and call cb_ptr */
80012e86:	fe b0 b3 4f 	rcall	80009524 <MsgSend3>
                    break;
80012e8a:	c9 7b       	rjmp	80012db8 <ScmOpenPort+0xc8>
80012e8c:	00 00       	add	r0,r0
80012e8e:	3a 9c       	mov	r12,-87

80012e90 <ScmGoProtected>:
80012e90:	d4 01       	pushm	lr
80012e92:	31 5c       	mov	r12,21
80012e94:	fe b0 a6 11 	rcall	80007ab6 <mns_take>
80012e98:	3e e9       	mov	r9,-18
80012e9a:	49 78       	lddpc	r8,80012ef4 <ScmGoProtected+0x64>
80012e9c:	f1 69 00 1f 	st.b	r8[31],r9
80012ea0:	f1 69 00 0e 	st.b	r8[14],r9
80012ea4:	f1 69 00 18 	st.b	r8[24],r9
        wscm.cb_func_id            = INIC_SHADOW_INVALID_WORD;
        wscm.mute_mode             = INIC_SHADOW_INVALID_BYTE;
        wscm.api_locked            = MNS_FALSE;
        wscm.api_ext               = MNS_FALSE;
        wscm.bandwidth.preset      = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.current     = INIC_SHADOW_INVALID_BYTE;
80012ea8:	f1 69 00 19 	st.b	r8[25],r9
        wscm.bandwidth.total       = INIC_SHADOW_INVALID_BYTE;
80012eac:	f1 69 00 1a 	st.b	r8[26],r9
        wscm.bandwidth.free        = INIC_SHADOW_INVALID_WORD;
        wscm.bandwidth.packet      = INIC_SHADOW_INVALID_BYTE;
80012eb0:	f1 69 00 1e 	st.b	r8[30],r9
void ScmGoProtected(void)
{
    T_MOD_ENTRY(SCM_4);

    WAIT4CS();
        wscm.result_list_ptr       = NULL;
80012eb4:	30 09       	mov	r9,0
        wscm.bandwidth.packet      = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.used        = INIC_SHADOW_INVALID_BYTE;
        wscm.pm.state             &= SCM_PM_KILL_WAIT_STATE; /* kill wait states */
        wscm.pm.handle.in          = SCM_HANDLE_INVALID;
        wscm.pm.handle.out         = SCM_HANDLE_INVALID;
        wscm.pm.mediaLBportOpen    = MNS_FALSE;
80012eb6:	f1 69 00 94 	st.b	r8[148],r9
void ScmGoProtected(void)
{
    T_MOD_ENTRY(SCM_4);

    WAIT4CS();
        wscm.result_list_ptr       = NULL;
80012eba:	91 19       	st.w	r8[0x4],r9
        wscm.cb_ptr                = NULL;
80012ebc:	91 29       	st.w	r8[0x8],r9
        wscm.cb_func_id            = INIC_SHADOW_INVALID_WORD;
        wscm.mute_mode             = INIC_SHADOW_INVALID_BYTE;
        wscm.api_locked            = MNS_FALSE;
80012ebe:	f1 69 00 0f 	st.b	r8[15],r9
        wscm.api_ext               = MNS_FALSE;
80012ec2:	f1 69 00 10 	st.b	r8[16],r9
    T_MOD_ENTRY(SCM_4);

    WAIT4CS();
        wscm.result_list_ptr       = NULL;
        wscm.cb_ptr                = NULL;
        wscm.cb_func_id            = INIC_SHADOW_INVALID_WORD;
80012ec6:	fe 79 ee ee 	mov	r9,-4370
        wscm.api_locked            = MNS_FALSE;
        wscm.api_ext               = MNS_FALSE;
        wscm.bandwidth.preset      = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.current     = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.total       = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.free        = INIC_SHADOW_INVALID_WORD;
80012eca:	f1 59 00 1c 	st.h	r8[28],r9
    T_MOD_ENTRY(SCM_4);

    WAIT4CS();
        wscm.result_list_ptr       = NULL;
        wscm.cb_ptr                = NULL;
        wscm.cb_func_id            = INIC_SHADOW_INVALID_WORD;
80012ece:	b0 69       	st.h	r8[0xc],r9
        wscm.bandwidth.current     = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.total       = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.free        = INIC_SHADOW_INVALID_WORD;
        wscm.bandwidth.packet      = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.used        = INIC_SHADOW_INVALID_BYTE;
        wscm.pm.state             &= SCM_PM_KILL_WAIT_STATE; /* kill wait states */
80012ed0:	f1 39 00 7d 	ld.ub	r9,r8[125]
80012ed4:	f1 59 00 7c 	st.h	r8[124],r9
        wscm.pm.handle.in          = SCM_HANDLE_INVALID;
80012ed8:	3f f9       	mov	r9,-1
        wscm.pm.handle.out         = SCM_HANDLE_INVALID;
        wscm.pm.mediaLBportOpen    = MNS_FALSE;
    REL_CS();
80012eda:	31 5c       	mov	r12,21
        wscm.bandwidth.free        = INIC_SHADOW_INVALID_WORD;
        wscm.bandwidth.packet      = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.used        = INIC_SHADOW_INVALID_BYTE;
        wscm.pm.state             &= SCM_PM_KILL_WAIT_STATE; /* kill wait states */
        wscm.pm.handle.in          = SCM_HANDLE_INVALID;
        wscm.pm.handle.out         = SCM_HANDLE_INVALID;
80012edc:	f1 69 00 21 	st.b	r8[33],r9
        wscm.bandwidth.total       = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.free        = INIC_SHADOW_INVALID_WORD;
        wscm.bandwidth.packet      = INIC_SHADOW_INVALID_BYTE;
        wscm.bandwidth.used        = INIC_SHADOW_INVALID_BYTE;
        wscm.pm.state             &= SCM_PM_KILL_WAIT_STATE; /* kill wait states */
        wscm.pm.handle.in          = SCM_HANDLE_INVALID;
80012ee0:	f1 69 00 20 	st.b	r8[32],r9
        wscm.pm.handle.out         = SCM_HANDLE_INVALID;
        wscm.pm.mediaLBportOpen    = MNS_FALSE;
    REL_CS();
80012ee4:	fe b0 a5 ea 	rcall	80007ab8 <mns_give>

    MnsServiceInitComplete(MNS_PHASE_RESET, MNS_P_SRV_WSCM);
80012ee8:	e0 6b 00 80 	mov	r11,128
80012eec:	30 1c       	mov	r12,1
80012eee:	fe b0 c4 e7 	rcall	8000b8bc <MnsServiceInitComplete>

    T_MOD_EXIT(SCM_4);
}
80012ef2:	d8 02       	popm	pc
80012ef4:	00 00       	add	r0,r0
80012ef6:	3a 9c       	mov	r12,-87

80012ef8 <ScmSetPendingEvent>:
80012ef8:	d4 01       	pushm	lr
80012efa:	e0 69 00 80 	mov	r9,128
80012efe:	5c 7c       	castu.h	r12
80012f00:	48 3a       	lddpc	r10,80012f0c <ScmSetPendingEvent+0x14>
80012f02:	31 4b       	mov	r11,20
void ScmSetPendingEvent(word event_flag)
{
    T_LIB_ENTRY(SCM_2);

    T_REQUEST(event_flag);
    MnsSetPendingEventFlag(event_flag, MX_WSCM_PE,
80012f04:	fe b0 c2 3c 	rcall	8000b37c <MnsSetPendingEventFlag>
                           &wscm.pending_events, MNS_P_SRV_WSCM);
    T_LIB_EXIT(SCM_2);
}
80012f08:	d8 02       	popm	pc
80012f0a:	d7 03       	nop
80012f0c:	00 00       	add	r0,r0
80012f0e:	3a 9c       	mov	r12,-87

80012f10 <ScmPMCheck>:
80012f10:	d4 31       	pushm	r0-r7,lr
80012f12:	20 2d       	sub	sp,8
    byte out_socket;
    word most_bandwidth;

    T_MOD_ENTRY(SCM_38);

    WAIT4CS();
80012f14:	31 5c       	mov	r12,21
80012f16:	fe b0 a5 d0 	rcall	80007ab6 <mns_take>
    mode           = wscm.cfg_ptr->packet.mode;
80012f1a:	fe f7 02 fe 	ld.w	r7,pc[766]
80012f1e:	6e 58       	ld.w	r8,r7[0x14]
    in_socket      = wscm.pm.handle.in;
    out_socket     = wscm.pm.handle.out;
    most_bandwidth = (word) (wscm.bandwidth.packet << 2);
    REL_CS();
80012f20:	31 5c       	mov	r12,21
    word most_bandwidth;

    T_MOD_ENTRY(SCM_38);

    WAIT4CS();
    mode           = wscm.cfg_ptr->packet.mode;
80012f22:	f1 36 00 0c 	ld.ub	r6,r8[12]
    in_socket      = wscm.pm.handle.in;
80012f26:	ef 33 00 20 	ld.ub	r3,r7[32]
    out_socket     = wscm.pm.handle.out;
80012f2a:	ef 34 00 21 	ld.ub	r4,r7[33]
    most_bandwidth = (word) (wscm.bandwidth.packet << 2);
80012f2e:	ef 35 00 1e 	ld.ub	r5,r7[30]
    REL_CS();
80012f32:	fe b0 a5 c3 	rcall	80007ab8 <mns_give>

    if (SCM_PM_NONE != mode)
80012f36:	58 06       	cp.w	r6,0
80012f38:	c1 10       	breq	80012f5a <ScmPMCheck+0x4a>
    {
        bool failure = MNS_FALSE;

        word mlb_bandwidth = 0;

        switch (wscm.cfg_ptr->packet.clock_config)
80012f3a:	6e 58       	ld.w	r8,r7[0x14]
80012f3c:	f1 38 00 0d 	ld.ub	r8,r8[13]
80012f40:	58 78       	cp.w	r8,7
80012f42:	e0 88 00 0e 	brls	80012f5e <ScmPMCheck+0x4e>
        case SCM_PORT_CFG_MLB_8192_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_8192_FS;
            break;

        default:
            FAILED_ASSERT();
80012f46:	e0 68 07 a1 	mov	r8,1953
80012f4a:	30 1a       	mov	r10,1
80012f4c:	1a d8       	st.w	--sp,r8
80012f4e:	31 0b       	mov	r11,16
80012f50:	e0 6c 00 80 	mov	r12,128
80012f54:	fe b0 a5 cc 	rcall	80007aec <mns_trace>
80012f58:	2f fd       	sub	sp,-4
            }
        }
    }

    T_MOD_EXIT(SCM_38);
}
80012f5a:	2f ed       	sub	sp,-8
80012f5c:	d8 32       	popm	r0-r7,pc
    {
        bool failure = MNS_FALSE;

        word mlb_bandwidth = 0;

        switch (wscm.cfg_ptr->packet.clock_config)
80012f5e:	fe f9 02 be 	ld.w	r9,pc[702]
80012f62:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
            mlb_bandwidth = SCM_MLB_PM_BW_3072_FS;
            break;

        case SCM_PORT_CFG_MLB_4096_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_4096_FS;
            break;
80012f66:	e0 61 02 78 	mov	r1,632
        if (MNS_FALSE == failure)
        {
            bool stop_higher_layers = MNS_FALSE;
            word state = SCM_PM_NEW_BORN;
            word statebuf = SCM_PM_NEW_BORN;
            byte current_interface = PmsGetFifoInterface(PMS_M_FIFO_CTRL);
80012f6a:	e0 6c 00 c0 	mov	r12,192
80012f6e:	fe b0 cd 1f 	rcall	8000c9ac <PmsGetFifoInterface>
80012f72:	50 1c       	stdsp	sp[0x4],r12

    WAIT4CS();
    mode           = wscm.cfg_ptr->packet.mode;
    in_socket      = wscm.pm.handle.in;
    out_socket     = wscm.pm.handle.out;
    most_bandwidth = (word) (wscm.bandwidth.packet << 2);
80012f74:	a3 65       	lsl	r5,0x2
            bool stop_higher_layers = MNS_FALSE;
            word state = SCM_PM_NEW_BORN;
            word statebuf = SCM_PM_NEW_BORN;
            byte current_interface = PmsGetFifoInterface(PMS_M_FIFO_CTRL);

            if (most_bandwidth)
80012f76:	c4 21       	brne	80012ffa <ScmPMCheck+0xea>
                    wscm.pm.statebuf = SCM_PM_NEW_BORN;
                }
                REL_CS();
            }

            WAIT4CS();
80012f78:	31 5c       	mov	r12,21
80012f7a:	fe b0 a5 9e 	rcall	80007ab6 <mns_take>
            state = wscm.pm.state;
            statebuf = wscm.pm.statebuf;
            stop_higher_layers = ((SCM_HANDLE_INVALID == wscm.pm.handle.in)                        ||
80012f7e:	ef 39 00 20 	ld.ub	r9,r7[32]
                }
                REL_CS();
            }

            WAIT4CS();
            state = wscm.pm.state;
80012f82:	ef 05 00 7c 	ld.sh	r5,r7[124]
            statebuf = wscm.pm.statebuf;
80012f86:	ef 06 00 7e 	ld.sh	r6,r7[126]
            stop_higher_layers = ((SCM_HANDLE_INVALID == wscm.pm.handle.in)                        ||
80012f8a:	3f f8       	mov	r8,-1
80012f8c:	f0 09 18 00 	cp.b	r9,r8
80012f90:	e0 80 00 fa 	breq	80013184 <ScmPMCheck+0x274>
80012f94:	fe f9 02 84 	ld.w	r9,pc[644]
80012f98:	f3 39 00 21 	ld.ub	r9,r9[33]
80012f9c:	f0 09 18 00 	cp.b	r9,r8
80012fa0:	e0 80 00 f2 	breq	80013184 <ScmPMCheck+0x274>
                                  (SCM_HANDLE_INVALID == wscm.pm.handle.out)                       ||
                                  ((SCM_PM_D_IN_SOCKET | SCM_PM_D_OUT_SOCKET) &  wscm.pm.statebuf) ||
                                  ((SCM_PM_D_IN_SOCKET | SCM_PM_D_OUT_SOCKET) &  wscm.pm.state)) ?
80012fa4:	5c 75       	castu.h	r5
            }

            WAIT4CS();
            state = wscm.pm.state;
            statebuf = wscm.pm.statebuf;
            stop_higher_layers = ((SCM_HANDLE_INVALID == wscm.pm.handle.in)                        ||
80012fa6:	ed e5 10 08 	or	r8,r6,r5
80012faa:	e2 18 00 0a 	andl	r8,0xa,COH
80012fae:	e0 81 00 ec 	brne	80013186 <ScmPMCheck+0x276>
                                  (SCM_HANDLE_INVALID == wscm.pm.handle.out)                       ||
                                  ((SCM_PM_D_IN_SOCKET | SCM_PM_D_OUT_SOCKET) &  wscm.pm.statebuf) ||
                                  ((SCM_PM_D_IN_SOCKET | SCM_PM_D_OUT_SOCKET) &  wscm.pm.state)) ?
                                  MNS_TRUE : MNS_FALSE;
            REL_CS();
80012fb2:	31 5c       	mov	r12,21
80012fb4:	fe b0 a5 82 	rcall	80007ab8 <mns_give>
                DataNIStateNetOn(MNS_FALSE);
                #endif
            }


            if (state & SCM_PM_KILL_WAIT_STATE)
80012fb8:	eb d5 c0 08 	bfextu	r5,r5,0x0,0x8
80012fbc:	e0 81 00 f9 	brne	800131ae <ScmPMCheck+0x29e>
            {
                ScmSetPendingEvent(WSCM_P_PM);
            }

            if (statebuf)
80012fc0:	58 06       	cp.w	r6,0
80012fc2:	e0 81 00 ee 	brne	8001319e <ScmPMCheck+0x28e>
                MostSetTimer(&(wscm.pm.timer), TIME_PM_RECHECK, MNS_FALSE);
            }
            else
            {
                /* reset wait-time */
                MostSetTimer(&(wscm.pm.timer),  (word)0, MNS_FALSE);
80012fc6:	0c 9a       	mov	r10,r6
80012fc8:	ee cc ff 80 	sub	r12,r7,-128
80012fcc:	0c 9b       	mov	r11,r6
80012fce:	fe b0 c0 6d 	rcall	8000b0a8 <MostSetTimer>
            }
        }
    }

    T_MOD_EXIT(SCM_38);
}
80012fd2:	2f ed       	sub	sp,-8
80012fd4:	d8 32       	popm	r0-r7,pc
            mlb_bandwidth = SCM_MLB_PM_BW_2048_FS;
            break;

        case SCM_PORT_CFG_MLB_3072_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_3072_FS;
            break;
80012fd6:	e0 61 01 c8 	mov	r1,456

        case SCM_PORT_CFG_MLB_4096_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_4096_FS;
            break;
80012fda:	cc 8b       	rjmp	80012f6a <ScmPMCheck+0x5a>
            mlb_bandwidth = SCM_MLB_PM_BW_1024_FS;
            break;

        case SCM_PORT_CFG_MLB_2048_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_2048_FS;
            break;
80012fdc:	e0 61 01 50 	mov	r1,336

        case SCM_PORT_CFG_MLB_3072_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_3072_FS;
            break;
80012fe0:	cc 5b       	rjmp	80012f6a <ScmPMCheck+0x5a>
            mlb_bandwidth = SCM_MLB_PM_BW_512_FS;
            break;

        case SCM_PORT_CFG_MLB_1024_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_1024_FS;
            break;
80012fe2:	e0 61 00 dc 	mov	r1,220

        case SCM_PORT_CFG_MLB_2048_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_2048_FS;
            break;
80012fe6:	cc 2b       	rjmp	80012f6a <ScmPMCheck+0x5a>
    {
        bool failure = MNS_FALSE;

        word mlb_bandwidth = 0;

        switch (wscm.cfg_ptr->packet.clock_config)
80012fe8:	37 41       	mov	r1,116
            mlb_bandwidth = SCM_MLB_PM_BW_512_FS;
            break;

        case SCM_PORT_CFG_MLB_1024_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_1024_FS;
            break;
80012fea:	cc 0b       	rjmp	80012f6a <ScmPMCheck+0x5a>
    {
        bool failure = MNS_FALSE;

        word mlb_bandwidth = 0;

        switch (wscm.cfg_ptr->packet.clock_config)
80012fec:	33 41       	mov	r1,52
80012fee:	cb eb       	rjmp	80012f6a <ScmPMCheck+0x5a>
        case SCM_PORT_CFG_MLB_8192_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_8192_FS;
            break;

        default:
            FAILED_ASSERT();
80012ff0:	31 41       	mov	r1,20
80012ff2:	cb cb       	rjmp	80012f6a <ScmPMCheck+0x5a>
            mlb_bandwidth = SCM_MLB_PM_BW_4096_FS;
            break;

        case SCM_PORT_CFG_MLB_6144_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_6144_FS;
            break;
80012ff4:	e0 61 03 00 	mov	r1,768

        case SCM_PORT_CFG_MLB_8192_FS:
            mlb_bandwidth = SCM_MLB_PM_BW_8192_FS;
            break;
80012ff8:	cb 9b       	rjmp	80012f6a <ScmPMCheck+0x5a>
            if (most_bandwidth)
            {
                word in_bandwidth = 0;
                word out_bandwidth = 0;

                word half_mlb_band = mlb_bandwidth >> 3;    /* devided by 8 -> number of quadlets for each socket */
80012ffa:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
80012ffe:	e0 08 16 03 	lsr	r8,r0,0x3
                half_mlb_band <<= 2;                        /* multiplied with 4 -> blockwidth in bytes for each socket */
80013002:	a3 68       	lsl	r8,0x2

                WAIT4CS();
80013004:	31 5c       	mov	r12,21
80013006:	50 08       	stdsp	sp[0x0],r8
80013008:	fe b0 a5 57 	rcall	80007ab6 <mns_take>

                in_bandwidth  =  wscm.cfg_ptr->packet.in.bandwidth;
8001300c:	6e 59       	ld.w	r9,r7[0x14]
                out_bandwidth =  wscm.cfg_ptr->packet.out.bandwidth;

                if ((in_bandwidth >= mlb_bandwidth)||(in_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH))
8001300e:	40 08       	lddsp	r8,sp[0x0]
                half_mlb_band <<= 2;                        /* multiplied with 4 -> blockwidth in bytes for each socket */

                WAIT4CS();

                in_bandwidth  =  wscm.cfg_ptr->packet.in.bandwidth;
                out_bandwidth =  wscm.cfg_ptr->packet.out.bandwidth;
80013010:	f3 36 00 14 	ld.ub	r6,r9[20]
                word half_mlb_band = mlb_bandwidth >> 3;    /* devided by 8 -> number of quadlets for each socket */
                half_mlb_band <<= 2;                        /* multiplied with 4 -> blockwidth in bytes for each socket */

                WAIT4CS();

                in_bandwidth  =  wscm.cfg_ptr->packet.in.bandwidth;
80013014:	f3 32 00 10 	ld.ub	r2,r9[16]
                out_bandwidth =  wscm.cfg_ptr->packet.out.bandwidth;

                if ((in_bandwidth >= mlb_bandwidth)||(in_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH))
80013018:	e4 01 19 00 	cp.h	r1,r2
8001301c:	e0 88 00 cc 	brls	800131b4 <ScmPMCheck+0x2a4>
80013020:	f3 d2 c0 02 	bfextu	r9,r2,0x0,0x2
                {
                    in_bandwidth = 0;   /* must be reconfigured */
                }
                if ((out_bandwidth >= mlb_bandwidth)||(out_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH))
80013024:	ec 01 19 00 	cp.h	r1,r6
80013028:	e0 8b 00 c9 	brhi	800131ba <ScmPMCheck+0x2aa>
8001302c:	30 06       	mov	r6,0
8001302e:	0c 9a       	mov	r10,r6
                {
                    out_bandwidth = 0;   /* must be reconfigured */
                }
                if (!((in_bandwidth & 3) == 0)) /* in_bandwidth mod 4 /= 0 */
80013030:	58 09       	cp.w	r9,0
80013032:	f9 b2 01 00 	movne	r2,0
                {
                    in_bandwidth = 0;  /* must be reconfigured */
                }
                if (!((out_bandwidth & 3) == 0)) /* out_bandwidth mod 4 /= 0 */
80013036:	58 0a       	cp.w	r10,0
80013038:	f9 b6 01 00 	movne	r6,0
                {
                    out_bandwidth = 0;  /* must be reconfigured */
                }

                if ((in_bandwidth==0) && (out_bandwidth==0))
8001303c:	30 09       	mov	r9,0
8001303e:	ed e2 10 0a 	or	r10,r6,r2
80013042:	f2 0a 19 00 	cp.h	r10,r9
80013046:	c0 41       	brne	8001304e <ScmPMCheck+0x13e>
80013048:	ed d8 b0 10 	bfexts	r6,r8,0x0,0x10
8001304c:	0c 92       	mov	r2,r6
                {
                    in_bandwidth  = half_mlb_band;
                    out_bandwidth = half_mlb_band;
                }
                if (in_bandwidth == 0) /* and out_bandwidth not ! */
8001304e:	58 02       	cp.w	r2,0
80013050:	c0 a1       	brne	80013064 <ScmPMCheck+0x154>
                {
                    in_bandwidth = mlb_bandwidth-out_bandwidth;  /* adjust out_bandwidth */
80013052:	e2 06 01 02 	sub	r2,r1,r6
                    in_bandwidth = (in_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH) ?
80013056:	e0 69 01 80 	mov	r9,384
8001305a:	f2 02 19 00 	cp.h	r2,r9
8001305e:	f2 02 17 b0 	movhi	r2,r9
80013062:	5c 82       	casts.h	r2
                                   SCM_MLB_PM_MAX_BLOCKWIDTH : in_bandwidth;
                }
                if (out_bandwidth == 0) /* and in_bandwidth not ! */
80013064:	58 06       	cp.w	r6,0
80013066:	c0 a1       	brne	8001307a <ScmPMCheck+0x16a>
                {
                    out_bandwidth = mlb_bandwidth-in_bandwidth;  /* adjust in_bandwidth */
80013068:	e2 02 01 06 	sub	r6,r1,r2
                    out_bandwidth = (out_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH) ?
8001306c:	e0 69 01 80 	mov	r9,384
80013070:	f2 06 19 00 	cp.h	r6,r9
80013074:	f2 06 17 b0 	movhi	r6,r9
80013078:	5c 86       	casts.h	r6
                                    SCM_MLB_PM_MAX_BLOCKWIDTH : out_bandwidth;
                }
                /* now both in_bandwidth and out_bandwidth are "valid"  */
                /* adjust the sum: */

                if ((in_bandwidth + out_bandwidth) > mlb_bandwidth)  /* the sum is too big */
8001307a:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
8001307e:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80013082:	f4 09 00 09 	add	r9,r10,r9
80013086:	00 39       	cp.w	r9,r0
80013088:	e0 8a 00 17 	brle	800130b6 <ScmPMCheck+0x1a6>
                {
                    if ((in_bandwidth > half_mlb_band) && (out_bandwidth > half_mlb_band))
8001308c:	f0 02 19 00 	cp.h	r2,r8
80013090:	f9 b9 0b 01 	movhi	r9,1
80013094:	f9 b9 08 00 	movls	r9,0
80013098:	f0 06 19 00 	cp.h	r6,r8
8001309c:	f9 ba 0b 01 	movhi	r10,1
800130a0:	f9 ba 08 00 	movls	r10,0
800130a4:	12 6a       	and	r10,r9
800130a6:	30 09       	mov	r9,0
800130a8:	f2 0a 18 00 	cp.b	r10,r9
800130ac:	e0 80 00 97 	breq	800131da <ScmPMCheck+0x2ca>
800130b0:	ed d8 b0 10 	bfexts	r6,r8,0x0,0x10
800130b4:	0c 92       	mov	r2,r6
                    {
                        out_bandwidth = mlb_bandwidth - in_bandwidth;
                    }
                }

                REL_CS();
800130b6:	31 5c       	mov	r12,21
800130b8:	fe b0 a5 00 	rcall	80007ab8 <mns_give>

                if (MNS_FALSE != MostIsSupported(NSF_MOST_25))
800130bc:	30 8c       	mov	r12,8
800130be:	fe b0 be fb 	rcall	8000aeb4 <MostIsSupported>
800130c2:	c0 c0       	breq	800130da <ScmPMCheck+0x1ca>
800130c4:	e4 05 19 00 	cp.h	r5,r2
800130c8:	ea 02 17 30 	movlo	r2,r5
800130cc:	5c 82       	casts.h	r2
                {
                    if (in_bandwidth > most_bandwidth)
                    {
                        in_bandwidth = most_bandwidth;
                    }
                    if (out_bandwidth > most_bandwidth)
800130ce:	ea 06 19 00 	cp.h	r6,r5
800130d2:	e0 88 00 04 	brls	800130da <ScmPMCheck+0x1ca>
800130d6:	ed d5 b0 10 	bfexts	r6,r5,0x0,0x10
                        out_bandwidth = most_bandwidth;
                    }
                }


                WAIT4CS();
800130da:	31 5c       	mov	r12,21
800130dc:	fe b0 a4 ed 	rcall	80007ab6 <mns_take>

                if (current_interface != PMS_IFACE_GENERAL )
800130e0:	30 18       	mov	r8,1
800130e2:	40 19       	lddsp	r9,sp[0x4]
800130e4:	f0 09 18 00 	cp.b	r9,r8
800130e8:	c7 60       	breq	800131d4 <ScmPMCheck+0x2c4>
                {
                     if (!(SCM_PM_WC_MLB_PORT & wscm.pm.state))
800130ea:	ef 18 00 7c 	ld.uh	r8,r7[124]
800130ee:	4c ba       	lddpc	r10,80013218 <ScmPMCheck+0x308>
800130f0:	10 99       	mov	r9,r8
800130f2:	e2 19 01 00 	andl	r9,0x100,COH
800130f6:	c0 e1       	brne	80013112 <ScmPMCheck+0x202>
                     {
                        /*if "MediaLB port" not open*/
                        if (MNS_FALSE == wscm.pm.mediaLBportOpen)
800130f8:	f5 3b 00 94 	ld.ub	r11,r10[148]
800130fc:	f2 0b 18 00 	cp.b	r11,r9
80013100:	c0 91       	brne	80013112 <ScmPMCheck+0x202>
                        {
                            if (!(SCM_PM_C_MLB_PORT & wscm.pm.state))
80013102:	ed b8 00 00 	bld	r8,0x0
80013106:	c0 60       	breq	80013112 <ScmPMCheck+0x202>
                            {
                                /* set Flag to open MediaLB port */
                                wscm.pm.statebuf |= SCM_PM_C_MLB_PORT;
80013108:	f5 09 00 7e 	ld.sh	r9,r10[126]
8001310c:	a1 a9       	sbr	r9,0x0
8001310e:	f5 59 00 7e 	st.h	r10[126],r9
                            }
                        }
                     }
                }

                if (!(SCM_PM_WC_IN_SOCKET & wscm.pm.state))
80013112:	ed b8 00 0a 	bld	r8,0xa
80013116:	c1 10       	breq	80013138 <ScmPMCheck+0x228>
                {
                    /* if "in" socket exists */
                    if (SCM_HANDLE_INVALID != in_socket)
80013118:	3f f9       	mov	r9,-1
8001311a:	f2 03 18 00 	cp.b	r3,r9
8001311e:	c6 60       	breq	800131ea <ScmPMCheck+0x2da>
                    {
                        /* if the bandwidth differs */
                        if (in_bandwidth > wscm.pm.desc.in.blockwidth)
80013120:	4b e8       	lddpc	r8,80013218 <ScmPMCheck+0x308>
80013122:	ef 09 00 28 	ld.sh	r9,r7[40]
80013126:	e4 09 19 00 	cp.h	r9,r2
8001312a:	c0 72       	brcc	80013138 <ScmPMCheck+0x228>
                        {
                            /* schedule destruction and creation of the socket */
                            wscm.pm.statebuf |= (SCM_PM_D_IN_SOCKET | SCM_PM_C_IN_SOCKET);
8001312c:	f1 09 00 7e 	ld.sh	r9,r8[126]
80013130:	e8 19 00 06 	orl	r9,0x6
80013134:	f1 59 00 7e 	st.h	r8[126],r9
                        /* schedule creation of the socket */
                        wscm.pm.statebuf |= SCM_PM_C_IN_SOCKET;
                    }
                }

                wscm.pm.desc.in.blockwidth = in_bandwidth;
80013138:	ef 52 00 28 	st.h	r7[40],r2

                if(!(SCM_PM_WC_OUT_SOCKET & wscm.pm.state))
8001313c:	ef 18 00 7c 	ld.uh	r8,r7[124]
                        /* schedule creation of the socket */
                        wscm.pm.statebuf |= SCM_PM_C_IN_SOCKET;
                    }
                }

                wscm.pm.desc.in.blockwidth = in_bandwidth;
80013140:	4b 6a       	lddpc	r10,80013218 <ScmPMCheck+0x308>

                if(!(SCM_PM_WC_OUT_SOCKET & wscm.pm.state))
80013142:	ed b8 00 0c 	bld	r8,0xc
80013146:	c1 00       	breq	80013166 <ScmPMCheck+0x256>
                {
                    /* if "out" socket exists */
                    if (SCM_HANDLE_INVALID != out_socket)
80013148:	3f f9       	mov	r9,-1
8001314a:	f2 04 18 00 	cp.b	r4,r9
8001314e:	c5 70       	breq	800131fc <ScmPMCheck+0x2ec>
                    {
                        /* if the bandwidth differs */
                        if (out_bandwidth > wscm.pm.desc.out.blockwidth)
80013150:	f5 08 00 50 	ld.sh	r8,r10[80]
80013154:	ec 08 19 00 	cp.h	r8,r6
80013158:	c0 72       	brcc	80013166 <ScmPMCheck+0x256>
                        {
                            /* schedule destruction and creation of the socket */
                            wscm.pm.statebuf |= (SCM_PM_D_OUT_SOCKET | SCM_PM_C_OUT_SOCKET);
8001315a:	f5 08 00 7e 	ld.sh	r8,r10[126]
8001315e:	e8 18 00 18 	orl	r8,0x18
80013162:	f5 58 00 7e 	st.h	r10[126],r8
                        /* schedule creation of the socket */
                        wscm.pm.statebuf |= SCM_PM_C_OUT_SOCKET;
                    }
                }

                wscm.pm.desc.out.blockwidth = out_bandwidth;
80013166:	ef 56 00 50 	st.h	r7[80],r6

                /* Are all messages received? */
                if (SCM_PM_WAIT == (SCM_PM_WAIT & wscm.pm.statebuf))
8001316a:	ef 08 00 7e 	ld.sh	r8,r7[126]
                        /* schedule creation of the socket */
                        wscm.pm.statebuf |= SCM_PM_C_OUT_SOCKET;
                    }
                }

                wscm.pm.desc.out.blockwidth = out_bandwidth;
8001316e:	4a ba       	lddpc	r10,80013218 <ScmPMCheck+0x308>

                /* Are all messages received? */
                if (SCM_PM_WAIT == (SCM_PM_WAIT & wscm.pm.statebuf))
80013170:	10 99       	mov	r9,r8
80013172:	e2 19 01 14 	andl	r9,0x114,COH
80013176:	e0 49 01 14 	cp.w	r9,276
8001317a:	c2 30       	breq	800131c0 <ScmPMCheck+0x2b0>
                {
                    /* write the new states*/
                    wscm.pm.state |= (wscm.pm.statebuf & ~SCM_PM_W_BANDWIDTH);
                    wscm.pm.statebuf = SCM_PM_NEW_BORN;
                }
                REL_CS();
8001317c:	31 5c       	mov	r12,21
8001317e:	fe b0 a4 9d 	rcall	80007ab8 <mns_give>
80013182:	cf ba       	rjmp	80012f78 <ScmPMCheck+0x68>
80013184:	5c 75       	castu.h	r5
            stop_higher_layers = ((SCM_HANDLE_INVALID == wscm.pm.handle.in)                        ||
                                  (SCM_HANDLE_INVALID == wscm.pm.handle.out)                       ||
                                  ((SCM_PM_D_IN_SOCKET | SCM_PM_D_OUT_SOCKET) &  wscm.pm.statebuf) ||
                                  ((SCM_PM_D_IN_SOCKET | SCM_PM_D_OUT_SOCKET) &  wscm.pm.state)) ?
                                  MNS_TRUE : MNS_FALSE;
            REL_CS();
80013186:	31 5c       	mov	r12,21
80013188:	fe b0 a4 98 	rcall	80007ab8 <mns_give>


            if (MNS_FALSE != stop_higher_layers)
            {
                MnsDistribEvent(MNS_P_SRV_WSCM, WSCM_P_SRV_CHECK);
8001318c:	e0 6c 00 80 	mov	r12,128
80013190:	31 0b       	mov	r11,16
80013192:	fe b0 bd b5 	rcall	8000acfc <MnsDistribEvent>
                #ifdef ADS_10
                DataNIStateNetOn(MNS_FALSE);
80013196:	30 0c       	mov	r12,0
80013198:	fe b0 f0 bc 	rcall	80011310 <DataNIStateNetOn>
8001319c:	c0 eb       	rjmp	80012fb8 <ScmPMCheck+0xa8>
            }

            if (statebuf)
            {
                /* set wait-time */
                MostSetTimer(&(wscm.pm.timer), TIME_PM_RECHECK, MNS_FALSE);
8001319e:	ee cc ff 80 	sub	r12,r7,-128
800131a2:	30 0a       	mov	r10,0
800131a4:	e0 6b 00 c8 	mov	r11,200
800131a8:	fe b0 bf 80 	rcall	8000b0a8 <MostSetTimer>
800131ac:	cd 7a       	rjmp	80012f5a <ScmPMCheck+0x4a>
            }


            if (state & SCM_PM_KILL_WAIT_STATE)
            {
                ScmSetPendingEvent(WSCM_P_PM);
800131ae:	30 4c       	mov	r12,4
800131b0:	ca 4e       	rcall	80012ef8 <ScmSetPendingEvent>
800131b2:	c0 7b       	rjmp	80012fc0 <ScmPMCheck+0xb0>
800131b4:	30 09       	mov	r9,0
                WAIT4CS();

                in_bandwidth  =  wscm.cfg_ptr->packet.in.bandwidth;
                out_bandwidth =  wscm.cfg_ptr->packet.out.bandwidth;

                if ((in_bandwidth >= mlb_bandwidth)||(in_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH))
800131b6:	12 92       	mov	r2,r9
800131b8:	c3 6b       	rjmp	80013024 <ScmPMCheck+0x114>
800131ba:	f5 d6 c0 02 	bfextu	r10,r6,0x0,0x2
                {
                    in_bandwidth = 0;   /* must be reconfigured */
                }
                if ((out_bandwidth >= mlb_bandwidth)||(out_bandwidth > SCM_MLB_PM_MAX_BLOCKWIDTH))
800131be:	c3 9b       	rjmp	80013030 <ScmPMCheck+0x120>
800131c0:	f5 09 00 7c 	ld.sh	r9,r10[124]

                /* Are all messages received? */
                if (SCM_PM_WAIT == (SCM_PM_WAIT & wscm.pm.statebuf))
                {
                    /* write the new states*/
                    wscm.pm.state |= (wscm.pm.statebuf & ~SCM_PM_W_BANDWIDTH);
800131c4:	a9 c8       	cbr	r8,0x8
800131c6:	12 48       	or	r8,r9
800131c8:	f5 58 00 7c 	st.h	r10[124],r8
800131cc:	30 08       	mov	r8,0
                    wscm.pm.statebuf = SCM_PM_NEW_BORN;
800131ce:	f5 58 00 7e 	st.h	r10[126],r8
800131d2:	cd 5b       	rjmp	8001317c <ScmPMCheck+0x26c>
800131d4:	ef 18 00 7c 	ld.uh	r8,r7[124]
                }


                WAIT4CS();

                if (current_interface != PMS_IFACE_GENERAL )
800131d8:	c9 db       	rjmp	80013112 <ScmPMCheck+0x202>
800131da:	ec 02 19 00 	cp.h	r2,r6
                    if ((in_bandwidth > half_mlb_band) && (out_bandwidth > half_mlb_band))
                    {
                        in_bandwidth  = half_mlb_band;
                        out_bandwidth = half_mlb_band;
                    }
                    else if (in_bandwidth > out_bandwidth)
800131de:	e0 88 00 18 	brls	8001320e <ScmPMCheck+0x2fe>
800131e2:	e2 06 01 02 	sub	r2,r1,r6
                    {
                        in_bandwidth = mlb_bandwidth - out_bandwidth;
800131e6:	5c 82       	casts.h	r2
800131e8:	c6 7b       	rjmp	800130b6 <ScmPMCheck+0x1a6>
800131ea:	ed b8 00 02 	bld	r8,0x2
                        {
                            /* schedule destruction and creation of the socket */
                            wscm.pm.statebuf |= (SCM_PM_D_IN_SOCKET | SCM_PM_C_IN_SOCKET);
                        }
                    }
                    else if (!(SCM_PM_C_IN_SOCKET & wscm.pm.state))
800131ee:	ca 50       	breq	80013138 <ScmPMCheck+0x228>
800131f0:	ef 08 00 7e 	ld.sh	r8,r7[126]
                    {
                        /* schedule creation of the socket */
                        wscm.pm.statebuf |= SCM_PM_C_IN_SOCKET;
800131f4:	a3 a8       	sbr	r8,0x2
800131f6:	ef 58 00 7e 	st.h	r7[126],r8
800131fa:	c9 fb       	rjmp	80013138 <ScmPMCheck+0x228>
800131fc:	ed b8 00 04 	bld	r8,0x4
                        {
                            /* schedule destruction and creation of the socket */
                            wscm.pm.statebuf |= (SCM_PM_D_OUT_SOCKET | SCM_PM_C_OUT_SOCKET);
                        }
                    }
                    else if (!(SCM_PM_C_OUT_SOCKET & wscm.pm.state))
80013200:	cb 30       	breq	80013166 <ScmPMCheck+0x256>
80013202:	f5 08 00 7e 	ld.sh	r8,r10[126]
                    {
                        /* schedule creation of the socket */
                        wscm.pm.statebuf |= SCM_PM_C_OUT_SOCKET;
80013206:	a5 a8       	sbr	r8,0x4
80013208:	f5 58 00 7e 	st.h	r10[126],r8
8001320c:	ca db       	rjmp	80013166 <ScmPMCheck+0x256>
8001320e:	e2 02 01 06 	sub	r6,r1,r2
                    {
                        in_bandwidth = mlb_bandwidth - out_bandwidth;
                    }
                    else /* in_bandwidth < out_bandwidth */
                    {
                        out_bandwidth = mlb_bandwidth - in_bandwidth;
80013212:	5c 86       	casts.h	r6
80013214:	c5 1b       	rjmp	800130b6 <ScmPMCheck+0x1a6>
80013216:	d7 03       	nop
80013218:	00 00       	add	r0,r0
8001321a:	3a 9c       	mov	r12,-87
8001321c:	80 06       	ld.sh	r6,r0[0x0]
8001321e:	ff 2c eb cd 	ld.sb	r12,pc[-5171]

80013220 <ScmHandleSCErrorStatus>:
80013220:	eb cd 40 e0 	pushm	r5-r7,lr
80013224:	18 97       	mov	r7,r12
80013226:	58 0c       	cp.w	r12,0
80013228:	c6 40       	breq	800132f0 <ScmHandleSCErrorStatus+0xd0>
8001322a:	6e 08       	ld.w	r8,r7[0x0]
8001322c:	3f fa       	mov	r10,-1
8001322e:	11 89       	ld.ub	r9,r8[0x0]
80013230:	f4 09 18 00 	cp.b	r9,r10
80013234:	c3 30       	breq	8001329a <ScmHandleSCErrorStatus+0x7a>
80013236:	11 98       	ld.ub	r8,r8[0x1]
80013238:	30 1a       	mov	r10,1
8001323a:	f4 08 18 00 	cp.b	r8,r10
8001323e:	c2 20       	breq	80013282 <ScmHandleSCErrorStatus+0x62>
80013240:	30 29       	mov	r9,2
80013242:	f2 08 18 00 	cp.b	r8,r9
    result   = NSR_E_FAILED;
    check_pm = MNS_FALSE;

    if(!((0xFF == msg_ptr->Data[0]) && (0x00 == msg_ptr->Data[1])))
    {
        switch(msg_ptr->Data[1])
80013246:	c1 a0       	breq	8001327a <ScmHandleSCErrorStatus+0x5a>
                result = NSR_E_MOST_BANDWIDTH;
                break;

            default:
                /* unknown */
                FAILED_ASSERT();
80013248:	e0 68 06 1e 	mov	r8,1566
8001324c:	30 1a       	mov	r10,1
8001324e:	1a d8       	st.w	--sp,r8
80013250:	31 0b       	mov	r11,16
80013252:	e0 6c 00 80 	mov	r12,128
80013256:	fe 76 80 00 	mov	r6,-32768
8001325a:	fe b0 a4 49 	rcall	80007aec <mns_trace>
8001325e:	4a b5       	lddpc	r5,80013308 <ScmHandleSCErrorStatus+0xe8>
80013260:	2f fd       	sub	sp,-4
        if(MNS_FALSE != check_pm)
        {
            ScmPMCheck();
        }

        if (wscm.cfg_ptr->on_error_fptr && EHCISTATE_IS_ATTACHED())
80013262:	6a 58       	ld.w	r8,r5[0x14]
80013264:	70 08       	ld.w	r8,r8[0x0]
80013266:	58 08       	cp.w	r8,0
80013268:	c0 70       	breq	80013276 <ScmHandleSCErrorStatus+0x56>
8001326a:	fe b0 be 43 	rcall	8000aef0 <MnsGetEHCIState>
8001326e:	30 28       	mov	r8,2
80013270:	f0 0c 18 00 	cp.b	r12,r8
80013274:	c2 60       	breq	800132c0 <ScmHandleSCErrorStatus+0xa0>
80013276:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    result   = NSR_E_FAILED;
    check_pm = MNS_FALSE;

    if(!((0xFF == msg_ptr->Data[0]) && (0x00 == msg_ptr->Data[1])))
    {
        switch(msg_ptr->Data[1])
8001327a:	fe 76 ac 02 	mov	r6,-21502
8001327e:	4a 35       	lddpc	r5,80013308 <ScmHandleSCErrorStatus+0xe8>
80013280:	cf 1b       	rjmp	80013262 <ScmHandleSCErrorStatus+0x42>
        {
            case SCM_SCERROR_MLB:
                switch (msg_ptr->Data[0])
80013282:	3f 08       	mov	r8,-16
80013284:	f0 09 18 00 	cp.b	r9,r8
80013288:	c2 70       	breq	800132d6 <ScmHandleSCErrorStatus+0xb6>
8001328a:	3f 18       	mov	r8,-15
8001328c:	f0 09 18 00 	cp.b	r9,r8
80013290:	c0 a0       	breq	800132a4 <ScmHandleSCErrorStatus+0x84>
            wscm.cfg_ptr->on_error_fptr(result, msg_ptr->Data[0]);
        }
    }

    T_LIB_EXIT(SCM_29);
}
80013292:	fe 76 ac 01 	mov	r6,-21503
80013296:	49 d5       	lddpc	r5,80013308 <ScmHandleSCErrorStatus+0xe8>
80013298:	ce 5b       	rjmp	80013262 <ScmHandleSCErrorStatus+0x42>
    ASSERT(msg_ptr);

    result   = NSR_E_FAILED;
    check_pm = MNS_FALSE;

    if(!((0xFF == msg_ptr->Data[0]) && (0x00 == msg_ptr->Data[1])))
8001329a:	11 98       	ld.ub	r8,r8[0x1]
8001329c:	58 08       	cp.w	r8,0
8001329e:	cc d1       	brne	80013238 <ScmHandleSCErrorStatus+0x18>
800132a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                        break;

                    case SCM_HANDLE_PACKET_OUT:
                        result = NSR_E_PACKET_OUT;
                        check_pm = MNS_TRUE;
                        WAIT4CS();
800132a4:	31 5c       	mov	r12,21
800132a6:	fe b0 a4 08 	rcall	80007ab6 <mns_take>
                        wscm.pm.handle.out = SCM_HANDLE_INVALID;
800132aa:	3f f8       	mov	r8,-1
800132ac:	49 75       	lddpc	r5,80013308 <ScmHandleSCErrorStatus+0xe8>
                        REL_CS();
800132ae:	31 5c       	mov	r12,21

                    case SCM_HANDLE_PACKET_OUT:
                        result = NSR_E_PACKET_OUT;
                        check_pm = MNS_TRUE;
                        WAIT4CS();
                        wscm.pm.handle.out = SCM_HANDLE_INVALID;
800132b0:	eb 68 00 21 	st.b	r5[33],r8
                        REL_CS();
800132b4:	fe 76 ac 05 	mov	r6,-21499
800132b8:	fe b0 a4 00 	rcall	80007ab8 <mns_give>
                break;
        }

        if(MNS_FALSE != check_pm)
        {
            ScmPMCheck();
800132bc:	c2 ae       	rcall	80012f10 <ScmPMCheck>
800132be:	cd 2b       	rjmp	80013262 <ScmHandleSCErrorStatus+0x42>
800132c0:	6e 09       	ld.w	r9,r7[0x0]
        }

        if (wscm.cfg_ptr->on_error_fptr && EHCISTATE_IS_ATTACHED())
        {
            wscm.cfg_ptr->on_error_fptr(result, msg_ptr->Data[0]);
800132c2:	0c 9c       	mov	r12,r6
800132c4:	49 18       	lddpc	r8,80013308 <ScmHandleSCErrorStatus+0xe8>
800132c6:	13 8b       	ld.ub	r11,r9[0x0]
800132c8:	70 58       	ld.w	r8,r8[0x14]
800132ca:	e2 1c ac 07 	andl	r12,0xac07,COH
800132ce:	70 08       	ld.w	r8,r8[0x0]
800132d0:	5d 18       	icall	r8
800132d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800132d6:	31 5c       	mov	r12,21
                switch (msg_ptr->Data[0])
                {
                    case SCM_HANDLE_PACKET_IN:
                        result = NSR_E_PACKET_IN;
                        check_pm = MNS_TRUE;
                        WAIT4CS();
800132d8:	fe b0 a3 ef 	rcall	80007ab6 <mns_take>
800132dc:	3f f8       	mov	r8,-1
                        wscm.pm.handle.in = SCM_HANDLE_INVALID;
800132de:	48 b5       	lddpc	r5,80013308 <ScmHandleSCErrorStatus+0xe8>
800132e0:	31 5c       	mov	r12,21
                        REL_CS();
800132e2:	eb 68 00 20 	st.b	r5[32],r8
                {
                    case SCM_HANDLE_PACKET_IN:
                        result = NSR_E_PACKET_IN;
                        check_pm = MNS_TRUE;
                        WAIT4CS();
                        wscm.pm.handle.in = SCM_HANDLE_INVALID;
800132e6:	fe 76 ac 04 	mov	r6,-21500
                        REL_CS();
800132ea:	fe b0 a3 e7 	rcall	80007ab8 <mns_give>
800132ee:	ce 7b       	rjmp	800132bc <ScmHandleSCErrorStatus+0x9c>
                        break;
800132f0:	e0 68 05 f6 	mov	r8,1526
    TMnsResult result;
    bool check_pm;

    T_LIB_ENTRY(SCM_29);

    ASSERT(msg_ptr);
800132f4:	30 1a       	mov	r10,1
800132f6:	1a d8       	st.w	--sp,r8
800132f8:	31 0b       	mov	r11,16
800132fa:	e0 6c 00 80 	mov	r12,128
800132fe:	fe b0 a3 f7 	rcall	80007aec <mns_trace>
80013302:	2f fd       	sub	sp,-4
80013304:	c9 3b       	rjmp	8001322a <ScmHandleSCErrorStatus+0xa>
80013306:	d7 03       	nop
80013308:	00 00       	add	r0,r0
8001330a:	3a 9c       	mov	r12,-87

8001330c <ScmHandleBandwidthStatus>:
8001330c:	d4 21       	pushm	r4-r7,lr
8001330e:	18 96       	mov	r6,r12
80013310:	58 0c       	cp.w	r12,0
80013312:	e0 80 00 94 	breq	8001343a <ScmHandleBandwidthStatus+0x12e>
80013316:	30 8c       	mov	r12,8
80013318:	fe b0 bd ce 	rcall	8000aeb4 <MostIsSupported>
8001331c:	4c d7       	lddpc	r7,80013450 <ScmHandleBandwidthStatus+0x144>
8001331e:	18 94       	mov	r4,r12

    ASSERT(msg_ptr);
    tmp_cb_ptr = NULL;
    most25 = MostIsSupported(NSF_MOST_25);

    WAIT4CS();
80013320:	31 5c       	mov	r12,21
80013322:	fe b0 a3 ca 	rcall	80007ab6 <mns_take>
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
80013326:	8c 49       	ld.sh	r9,r6[0x8]
80013328:	8e 68       	ld.sh	r8,r7[0xc]
8001332a:	f0 09 19 00 	cp.h	r9,r8
8001332e:	f9 b5 01 00 	movne	r5,0
    {
        tmp_cb_ptr           = wscm.cb_ptr;
        wscm.cb_ptr     = NULL;
80013332:	f9 b8 00 00 	moveq	r8,0
        wscm.api_locked = MNS_FALSE;
80013336:	ef f8 0e 0f 	st.beq	r7[0xf],r8
    most25 = MostIsSupported(NSF_MOST_25);

    WAIT4CS();
    if (msg_ptr->Func_ID ==  wscm.cb_func_id)
    {
        tmp_cb_ptr           = wscm.cb_ptr;
8001333a:	ef f5 00 02 	ld.weq	r5,r7[0x8]
        wscm.cb_ptr     = NULL;
8001333e:	ef f8 0a 02 	st.weq	r7[0x8],r8
        wscm.api_locked = MNS_FALSE;
    }

    /* if new bamdwidth */
    if(wscm.bandwidth.packet != (byte)(msg_ptr->Data[2] - msg_ptr->Data[1]))
80013342:	6c 08       	ld.w	r8,r6[0x0]
80013344:	11 ab       	ld.ub	r11,r8[0x2]
80013346:	11 9a       	ld.ub	r10,r8[0x1]
80013348:	4c 29       	lddpc	r9,80013450 <ScmHandleBandwidthStatus+0x144>
8001334a:	f6 0a 01 0a 	sub	r10,r11,r10
8001334e:	ef 3b 00 1e 	ld.ub	r11,r7[30]
80013352:	f4 0b 18 00 	cp.b	r11,r10
80013356:	c0 70       	breq	80013364 <ScmHandleBandwidthStatus+0x58>
    {
        wscm.pm.statebuf |= SCM_PM_W_BANDWIDTH;
80013358:	f3 08 00 7e 	ld.sh	r8,r9[126]
8001335c:	a9 a8       	sbr	r8,0x8
8001335e:	f3 58 00 7e 	st.h	r9[126],r8
80013362:	6c 08       	ld.w	r8,r6[0x0]
    }

    wscm.bandwidth.preset  = msg_ptr->Data[0];                                              /* AssignBWInit */
80013364:	11 88       	ld.ub	r8,r8[0x0]
80013366:	ef 68 00 18 	st.b	r7[24],r8
    wscm.bandwidth.current = msg_ptr->Data[1];                                              /* AssignBW     */
8001336a:	6c 08       	ld.w	r8,r6[0x0]
8001336c:	11 98       	ld.ub	r8,r8[0x1]
8001336e:	ef 68 00 19 	st.b	r7[25],r8
    wscm.bandwidth.total   = msg_ptr->Data[2];                                              /* TotalBW      */
80013372:	6c 09       	ld.w	r9,r6[0x0]
80013374:	13 aa       	ld.ub	r10,r9[0x2]
80013376:	ef 6a 00 1a 	st.b	r7[26],r10
    wscm.bandwidth.free    = (word)(msg_ptr->Data[3] << 8);                                 /* AssignBWFree HB */
8001337a:	6c 09       	ld.w	r9,r6[0x0]
8001337c:	f3 29 00 03 	ld.sb	r9,r9[3]
80013380:	a9 69       	lsl	r9,0x8
80013382:	ef 59 00 1c 	st.h	r7[28],r9
    wscm.bandwidth.free   |= (word) msg_ptr->Data[4];                                       /* AssignBWFree LB */
80013386:	6c 0b       	ld.w	r11,r6[0x0]
80013388:	17 cb       	ld.ub	r11,r11[0x4]
8001338a:	16 49       	or	r9,r11
    wscm.bandwidth.used    = (byte)(wscm.bandwidth.current - (wscm.bandwidth.free >> 2));
8001338c:	f7 d9 c0 4e 	bfextu	r11,r9,0x2,0xe

    wscm.bandwidth.preset  = msg_ptr->Data[0];                                              /* AssignBWInit */
    wscm.bandwidth.current = msg_ptr->Data[1];                                              /* AssignBW     */
    wscm.bandwidth.total   = msg_ptr->Data[2];                                              /* TotalBW      */
    wscm.bandwidth.free    = (word)(msg_ptr->Data[3] << 8);                                 /* AssignBWFree HB */
    wscm.bandwidth.free   |= (word) msg_ptr->Data[4];                                       /* AssignBWFree LB */
80013390:	ef 59 00 1c 	st.h	r7[28],r9
    wscm.bandwidth.used    = (byte)(wscm.bandwidth.current - (wscm.bandwidth.free >> 2));
80013394:	f0 0b 01 0b 	sub	r11,r8,r11
80013398:	ef 6b 00 1f 	st.b	r7[31],r11

    if ((0 == wscm.bandwidth.current) && (MNS_FALSE != most25))
8001339c:	58 08       	cp.w	r8,0
8001339e:	c0 31       	brne	800133a4 <ScmHandleBandwidthStatus+0x98>
800133a0:	58 04       	cp.w	r4,0
800133a2:	c3 e1       	brne	8001341e <ScmHandleBandwidthStatus+0x112>
    {
        wscm.bandwidth.packet  = 0;
    }
    else
    {
        wscm.bandwidth.packet  = (byte)(wscm.bandwidth.total - wscm.bandwidth.current);
800133a4:	f4 08 01 08 	sub	r8,r10,r8
800133a8:	ef 68 00 1e 	st.b	r7[30],r8
    }
    REL_CS();
800133ac:	31 5c       	mov	r12,21
800133ae:	fe b0 a3 85 	rcall	80007ab8 <mns_give>
    /* MSVAL_E_NETON shall only be communicated when the
     * boundary is valid
     * -> implicit check if MSVAL_E_NETON was / shall be reported
     * see also VmsvHandleNIStateChange() and MostGetState()
     */
    (void)MostGetState();
800133b2:	fe b0 e5 05 	rcall	8000fdbc <MostGetState>

    if (tmp_cb_ptr)
800133b6:	58 05       	cp.w	r5,0
800133b8:	c0 30       	breq	800133be <ScmHandleBandwidthStatus+0xb2>
    {
        tmp_cb_ptr(NSR_S_OK);
800133ba:	30 0c       	mov	r12,0
800133bc:	5d 15       	icall	r5
    }

    ScmPMCheck();
800133be:	fe b0 fd a9 	rcall	80012f10 <ScmPMCheck>

    if (!EHCISTATE_IS_ATTACHED())
800133c2:	fe b0 bd 97 	rcall	8000aef0 <MnsGetEHCIState>
800133c6:	30 28       	mov	r8,2
800133c8:	f0 0c 18 00 	cp.b	r12,r8
800133cc:	c2 d1       	brne	80013426 <ScmHandleBandwidthStatus+0x11a>
    }
    else
    {
        word max_bw = 0;

        if (wscm.cfg_ptr->bandwidth_changed_fptr)
800133ce:	6e 58       	ld.w	r8,r7[0x14]
800133d0:	4a 0b       	lddpc	r11,80013450 <ScmHandleBandwidthStatus+0x144>
800133d2:	70 16       	ld.w	r6,r8[0x4]
800133d4:	58 06       	cp.w	r6,0
800133d6:	c1 00       	breq	800133f6 <ScmHandleBandwidthStatus+0xea>
        {
            wscm.cfg_ptr->bandwidth_changed_fptr(
800133d8:	f7 38 00 1f 	ld.ub	r8,r11[31]
800133dc:	f7 3c 00 18 	ld.ub	r12,r11[24]
800133e0:	1a d8       	st.w	--sp,r8
800133e2:	f7 38 00 1e 	ld.ub	r8,r11[30]
800133e6:	f7 19 00 1c 	ld.uh	r9,r11[28]
800133ea:	f7 3a 00 1a 	ld.ub	r10,r11[26]
800133ee:	f7 3b 00 19 	ld.ub	r11,r11[25]
800133f2:	5d 16       	icall	r6
800133f4:	2f fd       	sub	sp,-4
              wscm.bandwidth.preset, wscm.bandwidth.current,
              wscm.bandwidth.total, wscm.bandwidth.free,
              wscm.bandwidth.packet, wscm.bandwidth.used);
        }

        max_bw = (word) (wscm.bandwidth.current << 2);
800133f6:	ef 36 00 19 	ld.ub	r6,r7[25]
        if(MNS_FALSE != MostIsSupported(NSF_MOST_50))
800133fa:	31 0c       	mov	r12,16
800133fc:	fe b0 bd 5c 	rcall	8000aeb4 <MostIsSupported>
              wscm.bandwidth.preset, wscm.bandwidth.current,
              wscm.bandwidth.total, wscm.bandwidth.free,
              wscm.bandwidth.packet, wscm.bandwidth.used);
        }

        max_bw = (word) (wscm.bandwidth.current << 2);
80013400:	a3 66       	lsl	r6,0x2
        if(MNS_FALSE != MostIsSupported(NSF_MOST_50))
        {
            max_bw++; /* left over byte */
        }

        if (wscm.cfg_ptr->on_error_fptr && (wscm.bandwidth.free == max_bw))
80013402:	6e 58       	ld.w	r8,r7[0x14]
        }

        max_bw = (word) (wscm.bandwidth.current << 2);
        if(MNS_FALSE != MostIsSupported(NSF_MOST_50))
        {
            max_bw++; /* left over byte */
80013404:	58 0c       	cp.w	r12,0
80013406:	f7 b6 01 ff 	subne	r6,-1
        }

        if (wscm.cfg_ptr->on_error_fptr && (wscm.bandwidth.free == max_bw))
8001340a:	70 08       	ld.w	r8,r8[0x0]
8001340c:	58 08       	cp.w	r8,0
8001340e:	c0 70       	breq	8001341c <ScmHandleBandwidthStatus+0x110>
80013410:	49 09       	lddpc	r9,80013450 <ScmHandleBandwidthStatus+0x144>
80013412:	f3 09 00 1c 	ld.sh	r9,r9[28]
80013416:	ec 09 19 00 	cp.h	r9,r6
8001341a:	c0 a0       	breq	8001342e <ScmHandleBandwidthStatus+0x122>
8001341c:	d8 22       	popm	r4-r7,pc
    wscm.bandwidth.free   |= (word) msg_ptr->Data[4];                                       /* AssignBWFree LB */
    wscm.bandwidth.used    = (byte)(wscm.bandwidth.current - (wscm.bandwidth.free >> 2));

    if ((0 == wscm.bandwidth.current) && (MNS_FALSE != most25))
    {
        wscm.bandwidth.packet  = 0;
8001341e:	48 d9       	lddpc	r9,80013450 <ScmHandleBandwidthStatus+0x144>
80013420:	f3 68 00 1e 	st.b	r9[30],r8
    wscm.bandwidth.total   = msg_ptr->Data[2];                                              /* TotalBW      */
    wscm.bandwidth.free    = (word)(msg_ptr->Data[3] << 8);                                 /* AssignBWFree HB */
    wscm.bandwidth.free   |= (word) msg_ptr->Data[4];                                       /* AssignBWFree LB */
    wscm.bandwidth.used    = (byte)(wscm.bandwidth.current - (wscm.bandwidth.free >> 2));

    if ((0 == wscm.bandwidth.current) && (MNS_FALSE != most25))
80013424:	cc 4b       	rjmp	800133ac <ScmHandleBandwidthStatus+0xa0>

    ScmPMCheck();

    if (!EHCISTATE_IS_ATTACHED())
    {
        MnsNtfCheck(NTF_BANDWIDTH);
80013426:	30 1c       	mov	r12,1
80013428:	fe b0 bd 22 	rcall	8000ae6c <MnsNtfCheck>
8001342c:	d8 22       	popm	r4-r7,pc
            max_bw++; /* left over byte */
        }

        if (wscm.cfg_ptr->on_error_fptr && (wscm.bandwidth.free == max_bw))
        {
            wscm.cfg_ptr->on_error_fptr(NSR_E_MOST_DEALLOCATED_ALL,
8001342e:	e0 6b 00 ff 	mov	r11,255
80013432:	e0 6c ac 03 	mov	r12,44035
80013436:	5d 18       	icall	r8
80013438:	d8 22       	popm	r4-r7,pc
    bool      most25;
    TMnsStdCB *tmp_cb_ptr;

    T_MOD_ENTRY(SCM_24);

    ASSERT(msg_ptr);
8001343a:	e0 68 05 1a 	mov	r8,1306
8001343e:	30 1a       	mov	r10,1
80013440:	1a d8       	st.w	--sp,r8
80013442:	31 0b       	mov	r11,16
80013444:	e0 6c 00 80 	mov	r12,128
80013448:	fe b0 a3 52 	rcall	80007aec <mns_trace>
8001344c:	2f fd       	sub	sp,-4
8001344e:	c6 4b       	rjmp	80013316 <ScmHandleBandwidthStatus+0xa>
80013450:	00 00       	add	r0,r0
80013452:	3a 9c       	mov	r12,-87

80013454 <ScmPMCreateResult>:
80013454:	eb cd 40 f8 	pushm	r3-r7,lr
80013458:	16 93       	mov	r3,r11
8001345a:	18 95       	mov	r5,r12
8001345c:	31 5c       	mov	r12,21
8001345e:	fe b0 a3 2c 	rcall	80007ab6 <mns_take>
80013462:	31 5c       	mov	r12,21
80013464:	4c 57       	lddpc	r7,80013578 <ScmPMCreateResult+0x124>
80013466:	30 06       	mov	r6,0
80013468:	ef 04 00 7c 	ld.sh	r4,r7[124]
8001346c:	fe b0 a3 26 	rcall	80007ab8 <mns_give>
80013470:	ec 05 19 00 	cp.h	r5,r6

    WAIT4CS();
    state = wscm.pm.state;
    REL_CS();

    if(NSR_SUCCESS(result))
80013474:	c2 65       	brlt	800134c0 <ScmPMCreateResult+0x6c>
    {
        if (SCM_PM_WC_IN_SOCKET & state)
80013476:	5c 74       	castu.h	r4
80013478:	ed b4 00 0a 	bld	r4,0xa
8001347c:	c6 00       	breq	8001353c <ScmPMCreateResult+0xe8>
            wscm.pm.handle.in = socket_handle;
            REL_CS();

            ScmSetPendingEvent(WSCM_P_PM);
        }
        else if (SCM_PM_WC_OUT_SOCKET & state)
8001347e:	e2 14 10 00 	andl	r4,0x1000,COH
80013482:	c1 30       	breq	800134a8 <ScmPMCreateResult+0x54>
        {
            WAIT4CS();
80013484:	31 5c       	mov	r12,21
80013486:	fe b0 a3 18 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WC_OUT_SOCKET;
8001348a:	ef 08 00 7c 	ld.sh	r8,r7[124]
            wscm.pm.handle.out = socket_handle;
8001348e:	ef 63 00 21 	st.b	r7[33],r3
            ScmSetPendingEvent(WSCM_P_PM);
        }
        else if (SCM_PM_WC_OUT_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WC_OUT_SOCKET;
80013492:	ad c8       	cbr	r8,0xc
80013494:	ef 58 00 7c 	st.h	r7[124],r8
            wscm.pm.handle.out = socket_handle;
            REL_CS();
80013498:	31 5c       	mov	r12,21
8001349a:	fe b0 a3 0f 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
8001349e:	30 4c       	mov	r12,4
800134a0:	fe b0 fd 2c 	rcall	80012ef8 <ScmSetPendingEvent>
800134a4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
800134a8:	e0 68 09 0c 	mov	r8,2316
            ScmSetPendingEvent(WSCM_P_PM);
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
800134ac:	1a d8       	st.w	--sp,r8
800134ae:	30 1a       	mov	r10,1
800134b0:	31 0b       	mov	r11,16
800134b2:	e0 6c 00 80 	mov	r12,128
800134b6:	fe b0 a3 1b 	rcall	80007aec <mns_trace>
800134ba:	2f fd       	sub	sp,-4
800134bc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
        {
            /* wasn't waiting */
            FAILED_ASSERT();
        }
    }
    else if (NSR_E_ERR_BUSY == result)
800134c0:	fe 78 a0 40 	mov	r8,-24512
800134c4:	f0 05 19 00 	cp.h	r5,r8
800134c8:	c2 20       	breq	8001350c <ScmPMCreateResult+0xb8>
        {
            /* wasn't waiting */
            FAILED_ASSERT();
        }
    }
    else if (NSR_E_BUSY != result)
800134ca:	fe 78 81 00 	mov	r8,-32512
800134ce:	f0 05 19 00 	cp.h	r5,r8
800134d2:	c1 b0       	breq	80013508 <ScmPMCreateResult+0xb4>
    {
        word statebuf;
        /* no fancy recovery yet */
        FAILED_ASSERT();
800134d4:	e0 68 09 2e 	mov	r8,2350
800134d8:	30 1a       	mov	r10,1
800134da:	1a d8       	st.w	--sp,r8
800134dc:	31 0b       	mov	r11,16
800134de:	e0 6c 00 80 	mov	r12,128
800134e2:	fe b0 a3 05 	rcall	80007aec <mns_trace>
        WAIT4CS();
800134e6:	31 5c       	mov	r12,21
800134e8:	fe b0 a2 e7 	rcall	80007ab6 <mns_take>
        wscm.pm.state = SCM_PM_NEW_BORN;
        statebuf = wscm.pm.statebuf;
        REL_CS();
800134ec:	31 5c       	mov	r12,21
    {
        word statebuf;
        /* no fancy recovery yet */
        FAILED_ASSERT();
        WAIT4CS();
        wscm.pm.state = SCM_PM_NEW_BORN;
800134ee:	ef 56 00 7c 	st.h	r7[124],r6
        statebuf = wscm.pm.statebuf;
800134f2:	ef 07 00 7e 	ld.sh	r7,r7[126]
        REL_CS();
800134f6:	fe b0 a2 e1 	rcall	80007ab8 <mns_give>

        if (SCM_PM_W_BANDWIDTH == (statebuf & SCM_PM_W_BANDWIDTH))
800134fa:	e2 17 01 00 	andl	r7,0x100,COH
800134fe:	2f fd       	sub	sp,-4
80013500:	58 07       	cp.w	r7,0
80013502:	c0 30       	breq	80013508 <ScmPMCreateResult+0xb4>
        {
            ScmPMCheck();
80013504:	fe b0 fd 06 	rcall	80012f10 <ScmPMCheck>
80013508:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
        }
    }
    else if (NSR_E_ERR_BUSY == result)
    {
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WC_IN_SOCKET & state)
8001350c:	5c 74       	castu.h	r4
8001350e:	ed b4 00 0a 	bld	r4,0xa
80013512:	c2 10       	breq	80013554 <ScmPMCreateResult+0x100>
            wscm.pm.state |= SCM_PM_C_IN_SOCKET;
            REL_CS();

            ScmSetPendingEvent(WSCM_P_PM);
        }
        else if (SCM_PM_WC_OUT_SOCKET & state)
80013514:	e2 14 10 00 	andl	r4,0x1000,COH
80013518:	c1 b0       	breq	8001354e <ScmPMCreateResult+0xfa>
        {
            WAIT4CS();
8001351a:	31 5c       	mov	r12,21
8001351c:	fe b0 a2 cd 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WC_OUT_SOCKET;
            wscm.pm.state |= SCM_PM_C_OUT_SOCKET;
80013520:	ef 08 00 7c 	ld.sh	r8,r7[124]
80013524:	ad c8       	cbr	r8,0xc
80013526:	a5 a8       	sbr	r8,0x4
            REL_CS();
80013528:	31 5c       	mov	r12,21
        }
        else if (SCM_PM_WC_OUT_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WC_OUT_SOCKET;
            wscm.pm.state |= SCM_PM_C_OUT_SOCKET;
8001352a:	ef 58 00 7c 	st.h	r7[124],r8
            REL_CS();
8001352e:	fe b0 a2 c5 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
80013532:	30 4c       	mov	r12,4
80013534:	fe b0 fc e2 	rcall	80012ef8 <ScmSetPendingEvent>
80013538:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    if(NSR_SUCCESS(result))
    {
        if (SCM_PM_WC_IN_SOCKET & state)
        {
            WAIT4CS();
8001353c:	31 5c       	mov	r12,21
8001353e:	fe b0 a2 bc 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WC_IN_SOCKET;
80013542:	ef 08 00 7c 	ld.sh	r8,r7[124]
            wscm.pm.handle.in = socket_handle;
80013546:	ef 63 00 20 	st.b	r7[32],r3
    if(NSR_SUCCESS(result))
    {
        if (SCM_PM_WC_IN_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WC_IN_SOCKET;
8001354a:	ab c8       	cbr	r8,0xa
8001354c:	ca 4b       	rjmp	80013494 <ScmPMCreateResult+0x40>
            ScmSetPendingEvent(WSCM_P_PM);
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
8001354e:	e0 68 09 27 	mov	r8,2343
80013552:	ca db       	rjmp	800134ac <ScmPMCreateResult+0x58>
    else if (NSR_E_ERR_BUSY == result)
    {
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WC_IN_SOCKET & state)
        {
            WAIT4CS();
80013554:	31 5c       	mov	r12,21
80013556:	fe b0 a2 b0 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WC_IN_SOCKET;
            wscm.pm.state |= SCM_PM_C_IN_SOCKET;
8001355a:	ef 08 00 7c 	ld.sh	r8,r7[124]
8001355e:	ab c8       	cbr	r8,0xa
80013560:	a3 a8       	sbr	r8,0x2
            REL_CS();
80013562:	31 5c       	mov	r12,21
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WC_IN_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WC_IN_SOCKET;
            wscm.pm.state |= SCM_PM_C_IN_SOCKET;
80013564:	ef 58 00 7c 	st.h	r7[124],r8
            REL_CS();
80013568:	fe b0 a2 a8 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
8001356c:	30 4c       	mov	r12,4
8001356e:	fe b0 fc c5 	rcall	80012ef8 <ScmSetPendingEvent>
80013572:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80013576:	d7 03       	nop
80013578:	00 00       	add	r0,r0
8001357a:	3a 9c       	mov	r12,-87

8001357c <ScmPMDestroyResult>:
8001357c:	d4 21       	pushm	r4-r7,lr
8001357e:	18 95       	mov	r5,r12
80013580:	31 5c       	mov	r12,21
80013582:	fe b0 a2 9a 	rcall	80007ab6 <mns_take>
80013586:	31 5c       	mov	r12,21
80013588:	4c f7       	lddpc	r7,800136c4 <ScmPMDestroyResult+0x148>
8001358a:	30 06       	mov	r6,0
8001358c:	ef 04 00 7c 	ld.sh	r4,r7[124]
    T_MOD_ENTRY(SCM_41);

    resume = MNS_FALSE;
    WAIT4CS();
    state = wscm.pm.state;
    REL_CS();
80013590:	fe b0 a2 94 	rcall	80007ab8 <mns_give>

    if(NSR_SUCCESS(result))
80013594:	ec 05 19 00 	cp.h	r5,r6
80013598:	c2 55       	brlt	800135e2 <ScmPMDestroyResult+0x66>
    {
        if (SCM_PM_WD_IN_SOCKET & state)
8001359a:	5c 74       	castu.h	r4
8001359c:	ed b4 00 09 	bld	r4,0x9
800135a0:	c3 e0       	breq	8001361c <ScmPMDestroyResult+0xa0>
            wscm.pm.state &= ~SCM_PM_WD_IN_SOCKET;
            wscm.pm.handle.in = SCM_HANDLE_INVALID;
            REL_CS();
            resume = MNS_TRUE;
        }
        else if (SCM_PM_WD_OUT_SOCKET & state)
800135a2:	e2 14 08 00 	andl	r4,0x800,COH
800135a6:	c1 30       	breq	800135cc <ScmPMDestroyResult+0x50>
            REL_CS();
            resume = MNS_TRUE;
        }
        else if (SCM_PM_WD_OUT_SOCKET & state)
        {
            WAIT4CS();
800135a8:	31 5c       	mov	r12,21
800135aa:	fe b0 a2 86 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WD_OUT_SOCKET;
800135ae:	ef 08 00 7c 	ld.sh	r8,r7[124]
800135b2:	ab d8       	cbr	r8,0xb
800135b4:	ef 58 00 7c 	st.h	r7[124],r8
            wscm.pm.handle.out = SCM_HANDLE_INVALID;
800135b8:	3f f8       	mov	r8,-1
            REL_CS();
800135ba:	31 5c       	mov	r12,21
        }
        else if (SCM_PM_WD_OUT_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WD_OUT_SOCKET;
            wscm.pm.handle.out = SCM_HANDLE_INVALID;
800135bc:	ef 68 00 21 	st.b	r7[33],r8
            REL_CS();
800135c0:	fe b0 a2 7c 	rcall	80007ab8 <mns_give>
            FAILED_ASSERT();
        }

        if (MNS_FALSE != resume)
        {
            ScmSetPendingEvent(WSCM_P_PM);
800135c4:	30 4c       	mov	r12,4
800135c6:	fe b0 fc 99 	rcall	80012ef8 <ScmSetPendingEvent>
800135ca:	d8 22       	popm	r4-r7,pc
            resume = MNS_TRUE;
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
800135cc:	e0 68 09 60 	mov	r8,2400
            resume = MNS_TRUE;
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
800135d0:	1a d8       	st.w	--sp,r8
800135d2:	30 1a       	mov	r10,1
800135d4:	31 0b       	mov	r11,16
800135d6:	e0 6c 00 80 	mov	r12,128
800135da:	fe b0 a2 89 	rcall	80007aec <mns_trace>
800135de:	2f fd       	sub	sp,-4
800135e0:	d8 22       	popm	r4-r7,pc
        if (MNS_FALSE != resume)
        {
            ScmSetPendingEvent(WSCM_P_PM);
        }
    }
    else  if (NSR_E_ERR_BUSY == result)
800135e2:	fe 78 a0 40 	mov	r8,-24512
800135e6:	f0 05 19 00 	cp.h	r5,r8
800135ea:	c2 b0       	breq	80013640 <ScmPMDestroyResult+0xc4>
        {
            /* wasn't waiting */
            FAILED_ASSERT();
        }
    }
    else if ((NSR_E_DYS_INVALID_HANDLE == result) ||
800135ec:	fe 78 a2 05 	mov	r8,-24059
800135f0:	f0 05 19 00 	cp.h	r5,r8
800135f4:	5f 09       	sreq	r9
800135f6:	fe 78 a2 03 	mov	r8,-24061
800135fa:	f0 05 19 00 	cp.h	r5,r8
800135fe:	5f 08       	sreq	r8
80013600:	10 49       	or	r9,r8
80013602:	ec 09 18 00 	cp.b	r9,r6
80013606:	c3 40       	breq	8001366e <ScmPMDestroyResult+0xf2>
             (NSR_E_DYS_INTERNAL == result))
    {
        /* the socket doesn't exist or has been destroyed */
        if (SCM_PM_WD_IN_SOCKET & state)
80013608:	5c 74       	castu.h	r4
8001360a:	ed b4 00 09 	bld	r4,0x9
8001360e:	c0 70       	breq	8001361c <ScmPMDestroyResult+0xa0>
            wscm.pm.state &= ~SCM_PM_WD_IN_SOCKET;
            wscm.pm.handle.in = SCM_HANDLE_INVALID;
            REL_CS();
            resume = MNS_TRUE;
        }
        else if (SCM_PM_WD_OUT_SOCKET & state)
80013610:	e2 14 08 00 	andl	r4,0x800,COH
80013614:	cc a1       	brne	800135a8 <ScmPMDestroyResult+0x2c>
            resume = MNS_TRUE;
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
80013616:	e0 68 09 9a 	mov	r8,2458
8001361a:	cd bb       	rjmp	800135d0 <ScmPMDestroyResult+0x54>
             (NSR_E_DYS_INTERNAL == result))
    {
        /* the socket doesn't exist or has been destroyed */
        if (SCM_PM_WD_IN_SOCKET & state)
        {
            WAIT4CS();
8001361c:	31 5c       	mov	r12,21
8001361e:	fe b0 a2 4c 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WD_IN_SOCKET;
80013622:	ef 08 00 7c 	ld.sh	r8,r7[124]
80013626:	a9 d8       	cbr	r8,0x9
80013628:	ef 58 00 7c 	st.h	r7[124],r8
            wscm.pm.handle.in = SCM_HANDLE_INVALID;
8001362c:	3f f8       	mov	r8,-1
            REL_CS();
8001362e:	31 5c       	mov	r12,21
        /* the socket doesn't exist or has been destroyed */
        if (SCM_PM_WD_IN_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WD_IN_SOCKET;
            wscm.pm.handle.in = SCM_HANDLE_INVALID;
80013630:	ef 68 00 20 	st.b	r7[32],r8
            REL_CS();
80013634:	fe b0 a2 42 	rcall	80007ab8 <mns_give>
            FAILED_ASSERT();
        }

        if (MNS_FALSE != resume)
        {
            ScmSetPendingEvent(WSCM_P_PM);
80013638:	30 4c       	mov	r12,4
8001363a:	fe b0 fc 5f 	rcall	80012ef8 <ScmSetPendingEvent>
8001363e:	d8 22       	popm	r4-r7,pc
        }
    }
    else  if (NSR_E_ERR_BUSY == result)
    {
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WD_IN_SOCKET & state)
80013640:	5c 74       	castu.h	r4
80013642:	ed b4 00 09 	bld	r4,0x9
80013646:	c2 f0       	breq	800136a4 <ScmPMDestroyResult+0x128>
            wscm.pm.state |= SCM_PM_D_IN_SOCKET;
            REL_CS();

            ScmSetPendingEvent(WSCM_P_PM);
        }
        else if (SCM_PM_WD_OUT_SOCKET & state)
80013648:	e2 14 08 00 	andl	r4,0x800,COH
8001364c:	c2 90       	breq	8001369e <ScmPMDestroyResult+0x122>
        {
            WAIT4CS();
8001364e:	31 5c       	mov	r12,21
80013650:	fe b0 a2 33 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WD_OUT_SOCKET;
            wscm.pm.state |= SCM_PM_D_OUT_SOCKET;
80013654:	ef 08 00 7c 	ld.sh	r8,r7[124]
80013658:	ab d8       	cbr	r8,0xb
8001365a:	a3 b8       	sbr	r8,0x3
            REL_CS();
8001365c:	31 5c       	mov	r12,21
        }
        else if (SCM_PM_WD_OUT_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WD_OUT_SOCKET;
            wscm.pm.state |= SCM_PM_D_OUT_SOCKET;
8001365e:	ef 58 00 7c 	st.h	r7[124],r8
            REL_CS();
80013662:	fe b0 a2 2b 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
80013666:	30 4c       	mov	r12,4
80013668:	fe b0 fc 48 	rcall	80012ef8 <ScmSetPendingEvent>
8001366c:	d8 22       	popm	r4-r7,pc
        if (MNS_FALSE != resume)
        {
            ScmSetPendingEvent(WSCM_P_PM);
        }
    }
    else if (NSR_E_BUSY != result)
8001366e:	fe 78 81 00 	mov	r8,-32512
80013672:	f0 05 19 00 	cp.h	r5,r8
80013676:	c1 30       	breq	8001369c <ScmPMDestroyResult+0x120>
    {
        /* no fancy recovery yet */
        FAILED_ASSERT();
80013678:	e0 68 09 a5 	mov	r8,2469
8001367c:	30 1a       	mov	r10,1
8001367e:	1a d8       	st.w	--sp,r8
80013680:	31 0b       	mov	r11,16
80013682:	e0 6c 00 80 	mov	r12,128
80013686:	fe b0 a2 33 	rcall	80007aec <mns_trace>
        WAIT4CS();
8001368a:	31 5c       	mov	r12,21
8001368c:	fe b0 a2 15 	rcall	80007ab6 <mns_take>
        wscm.pm.state = SCM_PM_NEW_BORN;
        REL_CS();
80013690:	31 5c       	mov	r12,21
    else if (NSR_E_BUSY != result)
    {
        /* no fancy recovery yet */
        FAILED_ASSERT();
        WAIT4CS();
        wscm.pm.state = SCM_PM_NEW_BORN;
80013692:	ef 56 00 7c 	st.h	r7[124],r6
        REL_CS();
80013696:	fe b0 a2 11 	rcall	80007ab8 <mns_give>
8001369a:	2f fd       	sub	sp,-4
8001369c:	d8 22       	popm	r4-r7,pc
            ScmSetPendingEvent(WSCM_P_PM);
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
8001369e:	e0 68 09 80 	mov	r8,2432
800136a2:	c9 7b       	rjmp	800135d0 <ScmPMDestroyResult+0x54>
    else  if (NSR_E_ERR_BUSY == result)
    {
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WD_IN_SOCKET & state)
        {
            WAIT4CS();
800136a4:	31 5c       	mov	r12,21
800136a6:	fe b0 a2 08 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WD_IN_SOCKET;
            wscm.pm.state |= SCM_PM_D_IN_SOCKET;
800136aa:	ef 08 00 7c 	ld.sh	r8,r7[124]
800136ae:	a9 d8       	cbr	r8,0x9
800136b0:	a1 b8       	sbr	r8,0x1
            REL_CS();
800136b2:	31 5c       	mov	r12,21
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WD_IN_SOCKET & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WD_IN_SOCKET;
            wscm.pm.state |= SCM_PM_D_IN_SOCKET;
800136b4:	ef 58 00 7c 	st.h	r7[124],r8
            REL_CS();
800136b8:	fe b0 a2 00 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
800136bc:	30 4c       	mov	r12,4
800136be:	fe b0 fc 1d 	rcall	80012ef8 <ScmSetPendingEvent>
800136c2:	d8 22       	popm	r4-r7,pc
800136c4:	00 00       	add	r0,r0
800136c6:	3a 9c       	mov	r12,-87

800136c8 <ScmPMOpenPortResult>:
800136c8:	d4 21       	pushm	r4-r7,lr
800136ca:	18 95       	mov	r5,r12
800136cc:	31 5c       	mov	r12,21
800136ce:	fe b0 a1 f4 	rcall	80007ab6 <mns_take>
800136d2:	31 5c       	mov	r12,21
800136d4:	4a e7       	lddpc	r7,8001378c <ScmPMOpenPortResult+0xc4>
800136d6:	30 06       	mov	r6,0
    word state;

    T_MOD_ENTRY(SCM_45);

    WAIT4CS();
    state = wscm.pm.state;
800136d8:	ef 04 00 7c 	ld.sh	r4,r7[124]
    REL_CS();
800136dc:	fe b0 a1 ee 	rcall	80007ab8 <mns_give>

    if(NSR_SUCCESS(result))
800136e0:	ec 05 19 00 	cp.h	r5,r6
800136e4:	c2 15       	brlt	80013726 <ScmPMOpenPortResult+0x5e>
    {
        if (SCM_PM_WC_MLB_PORT & state)
800136e6:	e2 14 01 00 	andl	r4,0x100,COH
800136ea:	c0 c1       	brne	80013702 <ScmPMOpenPortResult+0x3a>
            ScmSetPendingEvent(WSCM_P_PM);
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
800136ec:	e0 68 0a 13 	mov	r8,2579
            ScmSetPendingEvent(WSCM_P_PM);
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
800136f0:	1a d8       	st.w	--sp,r8
800136f2:	30 1a       	mov	r10,1
800136f4:	31 0b       	mov	r11,16
800136f6:	e0 6c 00 80 	mov	r12,128
800136fa:	fe b0 a1 f9 	rcall	80007aec <mns_trace>
800136fe:	2f fd       	sub	sp,-4
80013700:	d8 22       	popm	r4-r7,pc

    if(NSR_SUCCESS(result))
    {
        if (SCM_PM_WC_MLB_PORT & state)
        {
            WAIT4CS();
80013702:	31 5c       	mov	r12,21
80013704:	fe b0 a1 d9 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WC_MLB_PORT;
80013708:	ef 08 00 7c 	ld.sh	r8,r7[124]
8001370c:	a9 c8       	cbr	r8,0x8
8001370e:	ef 58 00 7c 	st.h	r7[124],r8
            wscm.pm.mediaLBportOpen = MNS_TRUE;
80013712:	30 18       	mov	r8,1
            REL_CS();
80013714:	31 5c       	mov	r12,21
    {
        if (SCM_PM_WC_MLB_PORT & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WC_MLB_PORT;
            wscm.pm.mediaLBportOpen = MNS_TRUE;
80013716:	ef 68 00 94 	st.b	r7[148],r8
            REL_CS();
8001371a:	fe b0 a1 cf 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
8001371e:	30 4c       	mov	r12,4
80013720:	fe b0 fb ec 	rcall	80012ef8 <ScmSetPendingEvent>
80013724:	d8 22       	popm	r4-r7,pc
        {
            /* wasn't waiting */
            FAILED_ASSERT();
        }
    }
    else if (NSR_E_ERR_BUSY == result)
80013726:	fe 78 a0 40 	mov	r8,-24512
8001372a:	f0 05 19 00 	cp.h	r5,r8
8001372e:	c1 90       	breq	80013760 <ScmPMOpenPortResult+0x98>
        {
            /* wasn't waiting */
            FAILED_ASSERT();
        }
    }
    else if (NSR_E_BUSY != result)
80013730:	fe 78 81 00 	mov	r8,-32512
80013734:	f0 05 19 00 	cp.h	r5,r8
80013738:	c1 30       	breq	8001375e <ScmPMOpenPortResult+0x96>
    {
        /* no fancy recovery yet */
        FAILED_ASSERT();
8001373a:	e0 68 0a 2b 	mov	r8,2603
8001373e:	30 1a       	mov	r10,1
80013740:	1a d8       	st.w	--sp,r8
80013742:	31 0b       	mov	r11,16
80013744:	e0 6c 00 80 	mov	r12,128
80013748:	fe b0 a1 d2 	rcall	80007aec <mns_trace>

        WAIT4CS();
8001374c:	31 5c       	mov	r12,21
8001374e:	fe b0 a1 b4 	rcall	80007ab6 <mns_take>
        wscm.pm.state = SCM_PM_NEW_BORN;
        REL_CS();
80013752:	31 5c       	mov	r12,21
    {
        /* no fancy recovery yet */
        FAILED_ASSERT();

        WAIT4CS();
        wscm.pm.state = SCM_PM_NEW_BORN;
80013754:	ef 56 00 7c 	st.h	r7[124],r6
        REL_CS();
80013758:	fe b0 a1 b0 	rcall	80007ab8 <mns_give>
8001375c:	2f fd       	sub	sp,-4
8001375e:	d8 22       	popm	r4-r7,pc
        }
    }
    else if (NSR_E_ERR_BUSY == result)
    {
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WC_MLB_PORT & state)
80013760:	e2 14 01 00 	andl	r4,0x100,COH
80013764:	c1 10       	breq	80013786 <ScmPMOpenPortResult+0xbe>
        {
            WAIT4CS();
80013766:	31 5c       	mov	r12,21
80013768:	fe b0 a1 a7 	rcall	80007ab6 <mns_take>
            wscm.pm.state &= ~SCM_PM_WC_MLB_PORT;
            wscm.pm.state |= SCM_PM_C_MLB_PORT;
8001376c:	ef 08 00 7c 	ld.sh	r8,r7[124]
80013770:	a9 c8       	cbr	r8,0x8
80013772:	a1 a8       	sbr	r8,0x0
            REL_CS();
80013774:	31 5c       	mov	r12,21
        /* INIC is busy, so we have to retry */
        if (SCM_PM_WC_MLB_PORT & state)
        {
            WAIT4CS();
            wscm.pm.state &= ~SCM_PM_WC_MLB_PORT;
            wscm.pm.state |= SCM_PM_C_MLB_PORT;
80013776:	ef 58 00 7c 	st.h	r7[124],r8
            REL_CS();
8001377a:	fe b0 a1 9f 	rcall	80007ab8 <mns_give>

            ScmSetPendingEvent(WSCM_P_PM);
8001377e:	30 4c       	mov	r12,4
80013780:	fe b0 fb bc 	rcall	80012ef8 <ScmSetPendingEvent>
80013784:	d8 22       	popm	r4-r7,pc
        }
        else
        {
            /* wasn't waiting */
            FAILED_ASSERT();
80013786:	e0 68 0a 25 	mov	r8,2597
8001378a:	cb 3b       	rjmp	800136f0 <ScmPMOpenPortResult+0x28>
8001378c:	00 00       	add	r0,r0
8001378e:	3a 9c       	mov	r12,-87

80013790 <ScmPMRecheck>:
80013790:	eb cd 40 80 	pushm	r7,lr
80013794:	31 5c       	mov	r12,21
80013796:	fe b0 a1 90 	rcall	80007ab6 <mns_take>
8001379a:	48 e8       	lddpc	r8,800137d0 <ScmPMRecheck+0x40>
8001379c:	f1 07 00 7e 	ld.sh	r7,r8[126]
    state = SCM_PM_NEW_BORN;

    WAIT4CS();

    /* if any state left over? */
    if (SCM_PM_NEW_BORN != wscm.pm.statebuf)
800137a0:	58 07       	cp.w	r7,0
800137a2:	c0 d1       	brne	800137bc <ScmPMRecheck+0x2c>
800137a4:	f1 07 00 7c 	ld.sh	r7,r8[124]
        wscm.pm.statebuf = SCM_PM_NEW_BORN;
    }

    state = wscm.pm.state;

    REL_CS();
800137a8:	31 5c       	mov	r12,21
800137aa:	fe b0 a1 87 	rcall	80007ab8 <mns_give>

    if (state & SCM_PM_KILL_WAIT_STATE)
800137ae:	5c 57       	castu.b	r7
800137b0:	c0 40       	breq	800137b8 <ScmPMRecheck+0x28>
    {
        ScmSetPendingEvent(WSCM_P_PM);
800137b2:	30 4c       	mov	r12,4
800137b4:	fe b0 fb a2 	rcall	80012ef8 <ScmSetPendingEvent>
800137b8:	e3 cd 80 80 	ldm	sp++,r7,pc
    WAIT4CS();

    /* if any state left over? */
    if (SCM_PM_NEW_BORN != wscm.pm.statebuf)
    {
        wscm.pm.state |= (wscm.pm.statebuf & ~SCM_PM_W_BANDWIDTH);
800137bc:	f1 09 00 7c 	ld.sh	r9,r8[124]
800137c0:	a9 c7       	cbr	r7,0x8
800137c2:	12 47       	or	r7,r9
        wscm.pm.statebuf = SCM_PM_NEW_BORN;
800137c4:	30 09       	mov	r9,0
    WAIT4CS();

    /* if any state left over? */
    if (SCM_PM_NEW_BORN != wscm.pm.statebuf)
    {
        wscm.pm.state |= (wscm.pm.statebuf & ~SCM_PM_W_BANDWIDTH);
800137c6:	f1 57 00 7c 	st.h	r8[124],r7
        wscm.pm.statebuf = SCM_PM_NEW_BORN;
800137ca:	f1 59 00 7e 	st.h	r8[126],r9
800137ce:	ce db       	rjmp	800137a8 <ScmPMRecheck+0x18>
800137d0:	00 00       	add	r0,r0
800137d2:	3a 9c       	mov	r12,-87

800137d4 <ScmService>:
800137d4:	eb cd 40 f8 	pushm	r3-r7,lr
800137d8:	fe f7 02 50 	ld.w	r7,pc[592]
800137dc:	31 08       	mov	r8,16
800137de:	30 19       	mov	r9,1
static word ScmGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(SCM_3);
    result = MnsGetNextEventFlagToCall(MX_WSCM_PE,
800137e0:	ee ca ff fe 	sub	r10,r7,-2
800137e4:	0e 9b       	mov	r11,r7
800137e6:	31 4c       	mov	r12,20
800137e8:	fe b0 bd 2a 	rcall	8000b23c <MnsGetNextEventFlagToCall>
    event_to_handle = ScmGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
800137ec:	30 28       	mov	r8,2
static word ScmGetNextEventToHandle(void)
{
    word result;

    T_MOD_ENTRY(SCM_3);
    result = MnsGetNextEventFlagToCall(MX_WSCM_PE,
800137ee:	5c 8c       	casts.h	r12
    event_to_handle = ScmGetNextEventToHandle();
    request_flag    = MNS_FALSE;

    T_SERVICE(event_to_handle);

    switch (event_to_handle)
800137f0:	f0 0c 19 00 	cp.h	r12,r8
800137f4:	c3 c0       	breq	8001386c <ScmService+0x98>
800137f6:	30 48       	mov	r8,4
800137f8:	f0 0c 19 00 	cp.h	r12,r8
800137fc:	c2 30       	breq	80013842 <ScmService+0x6e>
800137fe:	30 18       	mov	r8,1
80013800:	f0 0c 19 00 	cp.h	r12,r8
80013804:	c1 60       	breq	80013830 <ScmService+0x5c>
        case WSCM_P_PM:
            ScmPMService();
            break;

        default:
            FAILED_ASSERT();
80013806:	e0 68 00 e1 	mov	r8,225
8001380a:	30 1a       	mov	r10,1
8001380c:	1a d8       	st.w	--sp,r8
8001380e:	31 0b       	mov	r11,16
80013810:	e0 6c 00 80 	mov	r12,128
80013814:	fe b0 a1 6c 	rcall	80007aec <mns_trace>
80013818:	2f fd       	sub	sp,-4
            event_to_handle = WSCM_P_NONE;
            break;
    }

    TAKE_EVENTS();
8001381a:	31 4c       	mov	r12,20
8001381c:	fe b0 a1 4d 	rcall	80007ab6 <mns_take>
    request_flag = (WSCM_P_NONE != wscm.pending_events) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();
80013820:	31 4c       	mov	r12,20
            event_to_handle = WSCM_P_NONE;
            break;
    }

    TAKE_EVENTS();
    request_flag = (WSCM_P_NONE != wscm.pending_events) ? MNS_TRUE : MNS_FALSE;
80013822:	8e 07       	ld.sh	r7,r7[0x0]
    GIVE_EVENTS();
80013824:	fe b0 a1 4a 	rcall	80007ab8 <mns_give>

    if (MNS_FALSE != request_flag)
80013828:	58 07       	cp.w	r7,0
8001382a:	c0 61       	brne	80013836 <ScmService+0x62>
8001382c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    T_SERVICE(event_to_handle);

    switch (event_to_handle)
    {
        case WSCM_P_GO_PROTECTED:
            ScmGoProtected();
80013830:	fe b0 fb 30 	rcall	80012e90 <ScmGoProtected>
            break;
80013834:	cf 3b       	rjmp	8001381a <ScmService+0x46>
    request_flag = (WSCM_P_NONE != wscm.pending_events) ? MNS_TRUE : MNS_FALSE;
    GIVE_EVENTS();

    if (MNS_FALSE != request_flag)
    {
        MnsSetPendingService(MNS_P_SRV_WSCM);
80013836:	e0 6c 00 80 	mov	r12,128
8001383a:	fe b0 bd 67 	rcall	8000b308 <MnsSetPendingService>
8001383e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    count          = 0;
    reschedule     = MNS_FALSE;
    set_wait_state = MNS_FALSE;
    done           = MNS_FALSE;

    WAIT4CS();
80013842:	31 5c       	mov	r12,21
80013844:	fe b0 a1 39 	rcall	80007ab6 <mns_take>
    in_socket = wscm.pm.handle.in;
    out_socket = wscm.pm.handle.out;

    /* get the first bit to work on (not during wait states)*/
    if (wscm.pm.state)
80013848:	ef 09 00 7c 	ld.sh	r9,r7[124]
    reschedule     = MNS_FALSE;
    set_wait_state = MNS_FALSE;
    done           = MNS_FALSE;

    WAIT4CS();
    in_socket = wscm.pm.handle.in;
8001384c:	ef 34 00 20 	ld.ub	r4,r7[32]
    out_socket = wscm.pm.handle.out;
80013850:	ef 35 00 21 	ld.ub	r5,r7[33]

    /* get the first bit to work on (not during wait states)*/
    if (wscm.pm.state)
80013854:	58 09       	cp.w	r9,0
80013856:	c1 10       	breq	80013878 <ScmService+0xa4>
    {
        /* no wait state is set and at least one other state is set  */
        if (!(wscm.pm.state & SCM_PM_KILL_STATE) && (wscm.pm.state & SCM_PM_KILL_WAIT_STATE))
80013858:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
8001385c:	14 98       	mov	r8,r10
8001385e:	e2 18 ff 00 	andl	r8,0xff00,COH
80013862:	c1 80       	breq	80013892 <ScmService+0xbe>
    }
    else
    {
        done = MNS_TRUE;
    }
    REL_CS();
80013864:	31 5c       	mov	r12,21
80013866:	fe b0 a1 29 	rcall	80007ab8 <mns_give>
8001386a:	cd 8b       	rjmp	8001381a <ScmService+0x46>
        case WSCM_P_GO_PROTECTED:
            ScmGoProtected();
            break;

        case WSCM_P_NTF_COMPLETE:
            MnsServiceInitComplete(MNS_PHASE_INIT, MNS_P_SRV_WSCM);
8001386c:	e0 6b 00 80 	mov	r11,128
80013870:	30 2c       	mov	r12,2
80013872:	fe b0 c0 25 	rcall	8000b8bc <MnsServiceInitComplete>
            break;
80013876:	cd 2b       	rjmp	8001381a <ScmService+0x46>
    }
    else
    {
        done = MNS_TRUE;
    }
    REL_CS();
80013878:	31 5c       	mov	r12,21
8001387a:	fe b0 a1 1f 	rcall	80007ab8 <mns_give>
            ScmSetPendingEvent(WSCM_P_PM);
        }
    }
    else if (MNS_FALSE != done)
    {
        PmsSetFifoInterface(PMS_M_FIFO_MDP, PMS_IFACE_GENERAL);
8001387e:	30 1b       	mov	r11,1
80013880:	32 0c       	mov	r12,32
80013882:	fe b0 d8 9d 	rcall	8000e9bc <PmsSetFifoInterface>
        MnsDistribEvent(MNS_P_SRV_WSCM, WSCM_P_PM_DONE);
80013886:	30 8b       	mov	r11,8
80013888:	e0 6c 00 80 	mov	r12,128
8001388c:	fe b0 ba 38 	rcall	8000acfc <MnsDistribEvent>
80013890:	cc 5b       	rjmp	8001381a <ScmService+0x46>

    /* get the first bit to work on (not during wait states)*/
    if (wscm.pm.state)
    {
        /* no wait state is set and at least one other state is set  */
        if (!(wscm.pm.state & SCM_PM_KILL_STATE) && (wscm.pm.state & SCM_PM_KILL_WAIT_STATE))
80013892:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80013896:	ce 70       	breq	80013864 <ScmService+0x90>
        {
            while (count < 8)
            {
                check = (byte)(1 << count++);
80013898:	30 1c       	mov	r12,1

                if (check & wscm.pm.state)
8001389a:	12 93       	mov	r3,r9
8001389c:	10 9b       	mov	r11,r8
        /* no wait state is set and at least one other state is set  */
        if (!(wscm.pm.state & SCM_PM_KILL_STATE) && (wscm.pm.state & SCM_PM_KILL_WAIT_STATE))
        {
            while (count < 8)
            {
                check = (byte)(1 << count++);
8001389e:	f8 08 09 46 	lsl	r6,r12,r8
    }
    else
    {
        done = MNS_TRUE;
    }
    REL_CS();
800138a2:	2f f8       	sub	r8,-1
        /* no wait state is set and at least one other state is set  */
        if (!(wscm.pm.state & SCM_PM_KILL_STATE) && (wscm.pm.state & SCM_PM_KILL_WAIT_STATE))
        {
            while (count < 8)
            {
                check = (byte)(1 << count++);
800138a4:	5c 56       	castu.b	r6

                if (check & wscm.pm.state)
800138a6:	ed e9 00 0a 	and	r10,r6,r9
800138aa:	f6 0a 19 00 	cp.h	r10,r11
800138ae:	c3 20       	breq	80013912 <ScmService+0x13e>
                {
                    wscm.pm.state &= ~check;
800138b0:	ec 08 11 ff 	rsub	r8,r6,-1
800138b4:	06 68       	and	r8,r3
    }
    else
    {
        done = MNS_TRUE;
    }
    REL_CS();
800138b6:	31 5c       	mov	r12,21
            {
                check = (byte)(1 << count++);

                if (check & wscm.pm.state)
                {
                    wscm.pm.state &= ~check;
800138b8:	ef 58 00 7c 	st.h	r7[124],r8
    }
    else
    {
        done = MNS_TRUE;
    }
    REL_CS();
800138bc:	fe b0 a0 fe 	rcall	80007ab8 <mns_give>

    /* if there is something todo */
    if (check)
    {
        switch (check)
800138c0:	30 43       	mov	r3,4
800138c2:	e6 06 19 00 	cp.h	r6,r3
800138c6:	e0 80 00 8e 	breq	800139e2 <ScmService+0x20e>
800138ca:	e0 8b 00 2c 	brhi	80013922 <ScmService+0x14e>
800138ce:	30 18       	mov	r8,1
800138d0:	f0 06 19 00 	cp.h	r6,r8
800138d4:	e0 80 00 a0 	breq	80013a14 <ScmService+0x240>
800138d8:	30 28       	mov	r8,2
800138da:	f0 06 19 00 	cp.h	r6,r8
800138de:	c7 00       	breq	800139be <ScmService+0x1ea>
                SCM_PM_RUN(ScmCreateSocket(&(wscm.pm.desc.out), ScmPMCreateResult));
                break;

            default:
                /* unknown */
                FAILED_ASSERT();
800138e0:	e0 68 08 c2 	mov	r8,2242
800138e4:	30 1a       	mov	r10,1
800138e6:	1a d8       	st.w	--sp,r8
800138e8:	31 0b       	mov	r11,16
800138ea:	e0 6c 00 80 	mov	r12,128
800138ee:	fe b0 a0 ff 	rcall	80007aec <mns_trace>
                break;
        }

        WAIT4CS();
800138f2:	31 5c       	mov	r12,21
800138f4:	fe b0 a0 e1 	rcall	80007ab6 <mns_take>
800138f8:	2f fd       	sub	sp,-4
800138fa:	ef 06 00 7c 	ld.sh	r6,r7[124]
        }

        /* check if we need to run again */
        check = wscm.pm.state;

        REL_CS();
800138fe:	31 5c       	mov	r12,21

        if (check & SCM_PM_KILL_WAIT_STATE)
80013900:	5c 56       	castu.b	r6
        }

        /* check if we need to run again */
        check = wscm.pm.state;

        REL_CS();
80013902:	fe b0 a0 db 	rcall	80007ab8 <mns_give>

        if (check & SCM_PM_KILL_WAIT_STATE)
80013906:	58 06       	cp.w	r6,0
80013908:	c8 90       	breq	8001381a <ScmService+0x46>
        {
            ScmSetPendingEvent(WSCM_P_PM);
8001390a:	30 4c       	mov	r12,4
8001390c:	fe b0 fa f6 	rcall	80012ef8 <ScmSetPendingEvent>
80013910:	c8 5b       	rjmp	8001381a <ScmService+0x46>
    if (wscm.pm.state)
    {
        /* no wait state is set and at least one other state is set  */
        if (!(wscm.pm.state & SCM_PM_KILL_STATE) && (wscm.pm.state & SCM_PM_KILL_WAIT_STATE))
        {
            while (count < 8)
80013912:	58 88       	cp.w	r8,8
80013914:	cc 51       	brne	8001389e <ScmService+0xca>
    }
    else
    {
        done = MNS_TRUE;
    }
    REL_CS();
80013916:	31 5c       	mov	r12,21
80013918:	fe b0 a0 d0 	rcall	80007ab8 <mns_give>

    /* if there is something todo */
    if (check)
8001391c:	58 06       	cp.w	r6,0
8001391e:	cd 11       	brne	800138c0 <ScmService+0xec>
80013920:	c7 db       	rjmp	8001381a <ScmService+0x46>
    {
        switch (check)
80013922:	30 88       	mov	r8,8
80013924:	f0 06 19 00 	cp.h	r6,r8
80013928:	c2 80       	breq	80013978 <ScmService+0x1a4>
8001392a:	31 08       	mov	r8,16
8001392c:	f0 06 19 00 	cp.h	r6,r8
80013930:	cd 81       	brne	800138e0 <ScmService+0x10c>
                SCM_PM_RUN(ScmDestroySocket(out_socket, ScmPMDestroyResult));
                break;

            case SCM_PM_C_OUT_SOCKET:
                /* create "out" socket */
                ASSERT(SCM_HANDLE_INVALID == out_socket);
80013932:	3f f8       	mov	r8,-1
80013934:	f0 05 18 00 	cp.b	r5,r8
80013938:	c0 b0       	breq	8001394e <ScmService+0x17a>
8001393a:	e0 68 08 bc 	mov	r8,2236
8001393e:	30 1a       	mov	r10,1
80013940:	1a d8       	st.w	--sp,r8
80013942:	31 0b       	mov	r11,16
80013944:	e0 6c 00 80 	mov	r12,128
80013948:	fe b0 a0 d2 	rcall	80007aec <mns_trace>
8001394c:	2f fd       	sub	sp,-4
                SCM_PM_RUN(ScmCreateSocket(&(wscm.pm.desc.out), ScmPMCreateResult));
8001394e:	fe cb 04 fa 	sub	r11,pc,1274
80013952:	ee cc ff b4 	sub	r12,r7,-76
80013956:	fe b0 f7 d7 	rcall	80012904 <ScmCreateSocket>
8001395a:	30 48       	mov	r8,4
8001395c:	f0 0c 18 00 	cp.b	r12,r8
                /* unknown */
                FAILED_ASSERT();
                break;
        }

        WAIT4CS();
80013960:	c1 b0       	breq	80013996 <ScmService+0x1c2>
80013962:	31 5c       	mov	r12,21
80013964:	fe b0 a0 a9 	rcall	80007ab6 <mns_take>

        /* set the wait state bit for this task, if we were able to run */
        if (MNS_FALSE != set_wait_state)
        {
            wscm.pm.state |= (word)(check << 8);
80013968:	ef 08 00 7c 	ld.sh	r8,r7[124]
8001396c:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80013970:	5c 86       	casts.h	r6
80013972:	ef 56 00 7c 	st.h	r7[124],r6
                SCM_PM_RUN(ScmCreateSocket(&(wscm.pm.desc.in), ScmPMCreateResult));
                break;

            case SCM_PM_D_OUT_SOCKET:
                /* destroy "out" socket */
                ASSERT(SCM_HANDLE_INVALID != out_socket);
80013976:	cc 4b       	rjmp	800138fe <ScmService+0x12a>
80013978:	3f f8       	mov	r8,-1
8001397a:	f0 05 18 00 	cp.b	r5,r8
                SCM_PM_RUN(ScmDestroySocket(out_socket, ScmPMDestroyResult));
8001397e:	c1 50       	breq	800139a8 <ScmService+0x1d4>
80013980:	0a 9c       	mov	r12,r5
80013982:	e0 6a 04 04 	mov	r10,1028
80013986:	fe cb 04 0a 	sub	r11,pc,1034
8001398a:	fe b0 f6 a1 	rcall	800126cc <ScmSendHandleMsg>
8001398e:	30 48       	mov	r8,4
80013990:	f0 0c 18 00 	cp.b	r12,r8
                /* unknown */
                FAILED_ASSERT();
                break;
        }

        WAIT4CS();
80013994:	ce 71       	brne	80013962 <ScmService+0x18e>
80013996:	31 5c       	mov	r12,21
            wscm.pm.state |= (word)(check << 8);
        }
        /* ... otherwise we need to reschedule this task */
        else if (MNS_FALSE != reschedule)
        {
            wscm.pm.state |= check;
80013998:	fe b0 a0 8f 	rcall	80007ab6 <mns_take>
8001399c:	ef 08 00 7c 	ld.sh	r8,r7[124]
800139a0:	10 46       	or	r6,r8
800139a2:	ef 56 00 7c 	st.h	r7[124],r6
                SCM_PM_RUN(ScmCreateSocket(&(wscm.pm.desc.in), ScmPMCreateResult));
                break;

            case SCM_PM_D_OUT_SOCKET:
                /* destroy "out" socket */
                ASSERT(SCM_HANDLE_INVALID != out_socket);
800139a6:	ca cb       	rjmp	800138fe <ScmService+0x12a>
800139a8:	e0 68 08 b6 	mov	r8,2230
800139ac:	30 1a       	mov	r10,1
800139ae:	1a d8       	st.w	--sp,r8
800139b0:	31 0b       	mov	r11,16
800139b2:	e0 6c 00 80 	mov	r12,128
800139b6:	fe b0 a0 9b 	rcall	80007aec <mns_trace>
                SCM_PM_RUN(ScmOpenPort(&(wscm.pm.desc.portdesc), ScmPMOpenPortResult));
                break;

            case SCM_PM_D_IN_SOCKET:
                /* destroy "in" socket */
                ASSERT(SCM_HANDLE_INVALID != in_socket);
800139ba:	2f fd       	sub	sp,-4
800139bc:	ce 2b       	rjmp	80013980 <ScmService+0x1ac>
800139be:	3f f8       	mov	r8,-1
800139c0:	f0 04 18 00 	cp.b	r4,r8
                SCM_PM_RUN(ScmDestroySocket(in_socket, ScmPMDestroyResult));
800139c4:	c0 30       	breq	800139ca <ScmService+0x1f6>
                SCM_PM_RUN(ScmOpenPort(&(wscm.pm.desc.portdesc), ScmPMOpenPortResult));
                break;

            case SCM_PM_D_IN_SOCKET:
                /* destroy "in" socket */
                ASSERT(SCM_HANDLE_INVALID != in_socket);
800139c6:	08 9c       	mov	r12,r4
800139c8:	cd db       	rjmp	80013982 <ScmService+0x1ae>
800139ca:	e0 68 08 aa 	mov	r8,2218
800139ce:	e0 6c 00 80 	mov	r12,128
800139d2:	1a d8       	st.w	--sp,r8
800139d4:	30 1a       	mov	r10,1
800139d6:	31 0b       	mov	r11,16
                SCM_PM_RUN(ScmDestroySocket(in_socket, ScmPMDestroyResult));
800139d8:	fe b0 a0 8a 	rcall	80007aec <mns_trace>
                SCM_PM_RUN(ScmOpenPort(&(wscm.pm.desc.portdesc), ScmPMOpenPortResult));
                break;

            case SCM_PM_D_IN_SOCKET:
                /* destroy "in" socket */
                ASSERT(SCM_HANDLE_INVALID != in_socket);
800139dc:	08 9c       	mov	r12,r4
                SCM_PM_RUN(ScmDestroySocket(in_socket, ScmPMDestroyResult));
                break;

            case SCM_PM_C_IN_SOCKET:
                /* create "in" socket */
                ASSERT(SCM_HANDLE_INVALID == in_socket);
800139de:	2f fd       	sub	sp,-4
800139e0:	cd 1b       	rjmp	80013982 <ScmService+0x1ae>
800139e2:	3f f8       	mov	r8,-1
800139e4:	f0 04 18 00 	cp.b	r4,r8
800139e8:	c0 b0       	breq	800139fe <ScmService+0x22a>
800139ea:	e0 68 08 b0 	mov	r8,2224
800139ee:	30 1a       	mov	r10,1
800139f0:	1a d8       	st.w	--sp,r8
800139f2:	31 0b       	mov	r11,16
800139f4:	e0 6c 00 80 	mov	r12,128
800139f8:	fe b0 a0 7a 	rcall	80007aec <mns_trace>
                SCM_PM_RUN(ScmCreateSocket(&(wscm.pm.desc.in), ScmPMCreateResult));
800139fc:	2f fd       	sub	sp,-4
800139fe:	fe cb 05 aa 	sub	r11,pc,1450
80013a02:	ee cc ff dc 	sub	r12,r7,-36
80013a06:	fe b0 f7 7f 	rcall	80012904 <ScmCreateSocket>
80013a0a:	30 48       	mov	r8,4
80013a0c:	f0 0c 18 00 	cp.b	r12,r8
    {
        switch (check)
        {
            case SCM_PM_C_MLB_PORT:
                /* open MediaLB port */
                SCM_PM_RUN(ScmOpenPort(&(wscm.pm.desc.portdesc), ScmPMOpenPortResult));
80013a10:	ca 91       	brne	80013962 <ScmService+0x18e>
80013a12:	cc 2b       	rjmp	80013996 <ScmService+0x1c2>
80013a14:	fe cb 03 4c 	sub	r11,pc,844
80013a18:	ee cc ff 8c 	sub	r12,r7,-116
80013a1c:	fe b0 f9 6a 	rcall	80012cf0 <ScmOpenPort>
80013a20:	e6 0c 18 00 	cp.b	r12,r3
80013a24:	c9 f1       	brne	80013962 <ScmService+0x18e>
80013a26:	cb 8b       	rjmp	80013996 <ScmService+0x1c2>
80013a28:	00 00       	add	r0,r0
80013a2a:	3a 9c       	mov	r12,-87

80013a2c <ScmInit>:
80013a2c:	eb cd 40 e0 	pushm	r5-r7,lr
80013a30:	30 0a       	mov	r10,0
80013a32:	18 97       	mov	r7,r12
80013a34:	30 7b       	mov	r11,7
80013a36:	e0 6c 00 80 	mov	r12,128
80013a3a:	fe b0 a0 59 	rcall	80007aec <mns_trace>
80013a3e:	31 4c       	mov	r12,20
80013a40:	fe b0 a0 3b 	rcall	80007ab6 <mns_take>
80013a44:	4a 46       	lddpc	r6,80013ad4 <ScmInit+0xa8>
80013a46:	30 05       	mov	r5,0
80013a48:	31 4c       	mov	r12,20
80013a4a:	ac 05       	st.h	r6[0x0],r5
80013a4c:	ac 15       	st.h	r6[0x2],r5
80013a4e:	fe b0 a0 35 	rcall	80007ab8 <mns_give>
80013a52:	31 5c       	mov	r12,21
80013a54:	fe b0 a0 31 	rcall	80007ab6 <mns_take>
80013a58:	30 18       	mov	r8,1
80013a5a:	8d 57       	st.w	r6[0x14],r7
80013a5c:	ed 65 00 0f 	st.b	r6[15],r5
80013a60:	ed 65 00 24 	st.b	r6[36],r5
    WAIT4CS();
    wscm.cfg_ptr                            = cfg_ptr;
    wscm.api_locked                         = MNS_FALSE;

    wscm.pm.desc.in.port_id                 = SCM_PORT_ID_MEDIALB;
    wscm.pm.desc.in.direction               = SCM_IN;
80013a64:	ed 65 00 25 	st.b	r6[37],r5
    wscm.pm.desc.in.datatype                = SCM_TYPE_PACKET;
80013a68:	ed 68 00 26 	st.b	r6[38],r8
    wscm.pm.desc.in.blockwidth              = cfg_ptr->packet.in.bandwidth;
80013a6c:	ef 39 00 10 	ld.ub	r9,r7[16]
80013a70:	ed 59 00 28 	st.h	r6[40],r9
    wscm.pm.desc.in.medialb.channel_addr    = cfg_ptr->packet.in.address;
80013a74:	8e 79       	ld.sh	r9,r7[0xe]

    wscm.pm.desc.out.port_id                = SCM_PORT_ID_MEDIALB;
    wscm.pm.desc.out.direction              = SCM_OUT;
    wscm.pm.desc.out.datatype               = SCM_TYPE_PACKET;
80013a76:	ed 68 00 4e 	st.b	r6[78],r8

    wscm.pm.desc.in.port_id                 = SCM_PORT_ID_MEDIALB;
    wscm.pm.desc.in.direction               = SCM_IN;
    wscm.pm.desc.in.datatype                = SCM_TYPE_PACKET;
    wscm.pm.desc.in.blockwidth              = cfg_ptr->packet.in.bandwidth;
    wscm.pm.desc.in.medialb.channel_addr    = cfg_ptr->packet.in.address;
80013a7a:	ed 59 00 2a 	st.h	r6[42],r9

    wscm.pm.desc.out.port_id                = SCM_PORT_ID_MEDIALB;
80013a7e:	ed 65 00 4c 	st.b	r6[76],r5
    wscm.pm.desc.out.direction              = SCM_OUT;
80013a82:	ed 68 00 4d 	st.b	r6[77],r8
    wscm.pm.desc.out.datatype               = SCM_TYPE_PACKET;
    wscm.pm.desc.out.blockwidth             = cfg_ptr->packet.out.bandwidth;
80013a86:	ef 38 00 14 	ld.ub	r8,r7[20]
80013a8a:	ed 58 00 50 	st.h	r6[80],r8
    wscm.pm.desc.out.medialb.channel_addr   = cfg_ptr->packet.out.address;
80013a8e:	ef 08 00 12 	ld.sh	r8,r7[18]

    wscm.pm.desc.portdesc.port_id                       = SCM_PORT_ID_MEDIALB;
80013a92:	ed 65 00 74 	st.b	r6[116],r5

    wscm.pm.desc.out.port_id                = SCM_PORT_ID_MEDIALB;
    wscm.pm.desc.out.direction              = SCM_OUT;
    wscm.pm.desc.out.datatype               = SCM_TYPE_PACKET;
    wscm.pm.desc.out.blockwidth             = cfg_ptr->packet.out.bandwidth;
    wscm.pm.desc.out.medialb.channel_addr   = cfg_ptr->packet.out.address;
80013a96:	ed 58 00 52 	st.h	r6[82],r8

    wscm.pm.desc.portdesc.port_id                       = SCM_PORT_ID_MEDIALB;
    wscm.pm.desc.portdesc.config.medialb.port_mode      = SCM_PORT_CFG_MLB_MODE_CTL;
80013a9a:	ed 65 00 75 	st.b	r6[117],r5
    wscm.pm.desc.portdesc.config.medialb.clock_config   = cfg_ptr->packet.clock_config;
80013a9e:	ef 38 00 0d 	ld.ub	r8,r7[13]

    wscm.pm.state                           = SCM_PM_NEW_BORN;
    wscm.pm.statebuf                        = SCM_PM_NEW_BORN;
    mode                                    = wscm.cfg_ptr->packet.mode;
    wscm.pm.mediaLBportOpen                 = MNS_FALSE;
    REL_CS();
80013aa2:	31 5c       	mov	r12,21
    wscm.pm.desc.out.blockwidth             = cfg_ptr->packet.out.bandwidth;
    wscm.pm.desc.out.medialb.channel_addr   = cfg_ptr->packet.out.address;

    wscm.pm.desc.portdesc.port_id                       = SCM_PORT_ID_MEDIALB;
    wscm.pm.desc.portdesc.config.medialb.port_mode      = SCM_PORT_CFG_MLB_MODE_CTL;
    wscm.pm.desc.portdesc.config.medialb.clock_config   = cfg_ptr->packet.clock_config;
80013aa4:	ed 68 00 76 	st.b	r6[118],r8

    wscm.pm.state                           = SCM_PM_NEW_BORN;
80013aa8:	ed 55 00 7c 	st.h	r6[124],r5
    wscm.pm.statebuf                        = SCM_PM_NEW_BORN;
80013aac:	ed 55 00 7e 	st.h	r6[126],r5
    mode                                    = wscm.cfg_ptr->packet.mode;
80013ab0:	ef 37 00 0c 	ld.ub	r7,r7[12]
    wscm.pm.mediaLBportOpen                 = MNS_FALSE;
80013ab4:	ed 65 00 94 	st.b	r6[148],r5
    REL_CS();
80013ab8:	fe b0 a0 00 	rcall	80007ab8 <mns_give>

    if(SCM_PM_NONE != mode)
80013abc:	58 07       	cp.w	r7,0
80013abe:	c0 80       	breq	80013ace <ScmInit+0xa2>
    {
        MostRegisterTimer(&(wscm.pm.timer),ScmPMRecheck, 0);
80013ac0:	ec cc ff 80 	sub	r12,r6,-128
80013ac4:	30 0a       	mov	r10,0
80013ac6:	fe cb 03 36 	sub	r11,pc,822
80013aca:	fe b0 bb 65 	rcall	8000b194 <MostRegisterTimer>
80013ace:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80013ad2:	d7 03       	nop
80013ad4:	00 00       	add	r0,r0
80013ad6:	3a 9c       	mov	r12,-87

80013ad8 <CmdInit>:
    /* Init InstIDShadow[] */
    /*------------------------------------------ */
    #if (NUM_FBLOCKS_SHADOW > 0)
    for (i=(byte)0;i<(byte)NUM_FBLOCKS_SHADOW;i++)
    {
        InstIDShadow[i] = InstIDsShadowDefault[i];              /* Get InstIDs default values (RomRead) */
80013ad8:	48 59       	lddpc	r9,80013aec <CmdInit+0x14>
80013ada:	30 0a       	mov	r10,0
80013adc:	b2 8a       	st.b	r9[0x0],r10
    #ifdef NB_CB15
    NbRestoreShadowInstIDs(&InstIDShadow[0]);
    #endif
    #endif

    Cmd_FBlock_Tab_Ptr_Holder  = NULL;                            /* the values need to be initialized */
80013ade:	48 59       	lddpc	r9,80013af0 <CmdInit+0x18>
80013ae0:	30 08       	mov	r8,0
80013ae2:	93 08       	st.w	r9[0x0],r8
    Cmd_FBlock_Position_Holder = (byte)0;
80013ae4:	48 49       	lddpc	r9,80013af4 <CmdInit+0x1c>
80013ae6:	b2 88       	st.b	r9[0x0],r8
}
80013ae8:	5e fc       	retal	r12
80013aea:	d7 03       	nop
80013aec:	00 00       	add	r0,r0
80013aee:	4a 28       	lddpc	r8,80013b74 <CmdErrorMsg>
80013af0:	00 00       	add	r0,r0
80013af2:	4a 2c       	lddpc	r12,80013b78 <CmdErrorMsg+0x4>
80013af4:	00 00       	add	r0,r0
80013af6:	4a 29       	lddpc	r9,80013b7c <CmdErrorMsg+0x8>

80013af8 <CmdEncodeWord>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
80013af8:	17 88       	ld.ub	r8,r11[0x0]
80013afa:	b8 88       	st.b	r12[0x0],r8
    *ptr_tgt    = (byte)(*ptr_src & (word)0xFF);    /* prepare LB */
80013afc:	96 08       	ld.sh	r8,r11[0x0]
80013afe:	b8 98       	st.b	r12[0x1],r8
}
80013b00:	5e fc       	retal	r12

80013b02 <CmdDecodeWord>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_4
void CmdDecodeWord(word *ptr_tgt, byte *ptr_src)
{
    *ptr_tgt    = (word)((word)(*ptr_src++) << 8);  /* prepare HB */
80013b02:	f7 28 00 00 	ld.sb	r8,r11[0]
80013b06:	a9 68       	lsl	r8,0x8
80013b08:	b8 08       	st.h	r12[0x0],r8
    *ptr_tgt   += (*ptr_src);                       /* prepare LB */
80013b0a:	17 99       	ld.ub	r9,r11[0x1]
80013b0c:	f2 08 00 08 	add	r8,r9,r8
80013b10:	b8 08       	st.h	r12[0x0],r8
}
80013b12:	5e fc       	retal	r12

80013b14 <CmdEncodeLong>:
    word  high_part;
    word  low_part;
    dword help;
    byte i;

    help = *ptr_src;
80013b14:	76 09       	ld.w	r9,r11[0x0]
80013b16:	30 08       	mov	r8,0

    for (i=(byte)0;i<(byte)16;i++)
80013b18:	31 0a       	mov	r10,16
80013b1a:	2f f8       	sub	r8,-1
    {
        help = help >> 1;
80013b1c:	a1 99       	lsr	r9,0x1
    dword help;
    byte i;

    help = *ptr_src;

    for (i=(byte)0;i<(byte)16;i++)
80013b1e:	5c 58       	castu.b	r8
80013b20:	f4 08 18 00 	cp.b	r8,r10
80013b24:	cf b1       	brne	80013b1a <CmdEncodeLong+0x6>
    {
        help = help >> 1;
    }
    high_part = (word)help;
80013b26:	5c 89       	casts.h	r9
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
    *ptr_tgt    = (byte)(*ptr_src & (word)0xFF);    /* prepare LB */
80013b28:	b8 99       	st.b	r12[0x1],r9
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
80013b2a:	f3 d9 c1 08 	bfextu	r9,r9,0x8,0x8
80013b2e:	b8 89       	st.b	r12[0x0],r9
    }
    high_part = (word)help;

    CmdEncodeWord(ptr_tgt,&high_part);

    ptr_tgt += 2;
80013b30:	2f ec       	sub	r12,-2
    low_part = (word)(*ptr_src);
80013b32:	96 18       	ld.sh	r8,r11[0x2]
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
    *ptr_tgt    = (byte)(*ptr_src & (word)0xFF);    /* prepare LB */
80013b34:	b8 98       	st.b	r12[0x1],r8
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
80013b36:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80013b3a:	b8 88       	st.b	r12[0x0],r8

    ptr_tgt += 2;
    low_part = (word)(*ptr_src);

    CmdEncodeWord(ptr_tgt,&low_part);
}
80013b3c:	5e fc       	retal	r12

80013b3e <CmdDecodeLong>:
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_10
void CmdDecodeLong(dword *ptr_tgt, byte *ptr_src)
{
80013b3e:	d4 01       	pushm	lr
    word low_part;
    dword help;
    byte i;

    CmdDecodeWord(&high_part, ptr_src);
    ptr_src += 2;
80013b40:	f6 c8 ff fe 	sub	r8,r11,-2
    CmdDecodeWord(&low_part, ptr_src);

    help = (dword)high_part;
80013b44:	17 9a       	ld.ub	r10,r11[0x1]
80013b46:	17 89       	ld.ub	r9,r11[0x0]
/*--------------------------------------------------------------------------*/
#ifdef CMD_4
void CmdDecodeWord(word *ptr_tgt, byte *ptr_src)
{
    *ptr_tgt    = (word)((word)(*ptr_src++) << 8);  /* prepare HB */
    *ptr_tgt   += (*ptr_src);                       /* prepare LB */
80013b48:	11 9e       	ld.ub	lr,r8[0x1]

    CmdDecodeWord(&high_part, ptr_src);
    ptr_src += 2;
    CmdDecodeWord(&low_part, ptr_src);

    help = (dword)high_part;
80013b4a:	a9 69       	lsl	r9,0x8
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_4
void CmdDecodeWord(word *ptr_tgt, byte *ptr_src)
{
    *ptr_tgt    = (word)((word)(*ptr_src++) << 8);  /* prepare HB */
80013b4c:	11 8b       	ld.ub	r11,r8[0x0]

    CmdDecodeWord(&high_part, ptr_src);
    ptr_src += 2;
    CmdDecodeWord(&low_part, ptr_src);

    help = (dword)high_part;
80013b4e:	f4 09 00 09 	add	r9,r10,r9
80013b52:	30 08       	mov	r8,0
80013b54:	5c 79       	castu.h	r9

    for (i=(byte)0;i<(byte)16;i++)
80013b56:	31 0a       	mov	r10,16
80013b58:	2f f8       	sub	r8,-1
    {
        help = help << 1;
80013b5a:	a1 79       	lsl	r9,0x1
    ptr_src += 2;
    CmdDecodeWord(&low_part, ptr_src);

    help = (dword)high_part;

    for (i=(byte)0;i<(byte)16;i++)
80013b5c:	5c 58       	castu.b	r8
80013b5e:	f4 08 18 00 	cp.b	r8,r10
80013b62:	cf b1       	brne	80013b58 <CmdDecodeLong+0x1a>
    {
        help = help << 1;
    }

    *ptr_tgt = help | (dword)low_part;
80013b64:	f6 08 15 08 	lsl	r8,r11,0x8
80013b68:	fc 08 00 08 	add	r8,lr,r8
80013b6c:	5c 78       	castu.h	r8
80013b6e:	10 49       	or	r9,r8
80013b70:	99 09       	st.w	r12[0x0],r9
}
80013b72:	d8 02       	popm	pc

80013b74 <CmdErrorMsg>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_5
byte CmdErrorMsg(pTMsgTx Tx_Ptr, byte ErrorID)
{
    Tx_Ptr->Data[0] = ErrorID;
80013b74:	78 08       	ld.w	r8,r12[0x0]
80013b76:	b0 8b       	st.b	r8[0x0],r11
    Tx_Ptr->Length  = (word)1;
80013b78:	30 18       	mov	r8,1
80013b7a:	b8 28       	st.h	r12[0x4],r8
    return(OP_ERROR);
}
80013b7c:	30 fc       	mov	r12,15
80013b7e:	5e fc       	retal	r12

80013b80 <CmdErrorByte>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_6
byte CmdErrorByte(pTMsgTx Tx_Ptr, byte ErrorID, byte param)
{
    Tx_Ptr->Data[0] = ErrorID;
80013b80:	78 08       	ld.w	r8,r12[0x0]
80013b82:	b0 8b       	st.b	r8[0x0],r11
    Tx_Ptr->Data[1] = param;
80013b84:	78 08       	ld.w	r8,r12[0x0]
80013b86:	b0 9a       	st.b	r8[0x1],r10
    Tx_Ptr->Length  = (word)2;
80013b88:	30 28       	mov	r8,2
80013b8a:	b8 28       	st.h	r12[0x4],r8
    return(OP_ERROR);
}
80013b8c:	30 fc       	mov	r12,15
80013b8e:	5e fc       	retal	r12

80013b90 <CmdErrorParamWrong>:
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_14
byte CmdErrorParamWrong(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
{
80013b90:	d4 01       	pushm	lr
    #if (MAX_MSG_TX_DATA < 256)
    if (num > (byte)(MAX_MSG_TX_DATA-2))
80013b92:	33 08       	mov	r8,48
80013b94:	f0 09 18 00 	cp.b	r9,r8
80013b98:	e0 8b 00 17 	brhi	80013bc6 <CmdErrorParamWrong+0x36>
    {
        return(OP_ERROR);
    }
    #endif

    tx_ptr->Data[0] = ERR_PARAM_WRONG;                              /* Data[0] */
80013b9c:	78 08       	ld.w	r8,r12[0x0]
80013b9e:	30 6e       	mov	lr,6
80013ba0:	b0 8e       	st.b	r8[0x0],lr
byte CmdErrorParam_W_NA(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
{
    byte* dest_ptr;
    byte i;

    dest_ptr = &tx_ptr->Data[1];
80013ba2:	78 0e       	ld.w	lr,r12[0x0]
80013ba4:	fc c8 ff ff 	sub	r8,lr,-1

    *dest_ptr++ = index;                /* Data[1] */
80013ba8:	b0 8b       	st.b	r8[0x0],r11

    for (i=(byte)0;i<num;i++)                 /* Data[2] .. Data[num+1] */
80013baa:	58 09       	cp.w	r9,0
80013bac:	c0 b0       	breq	80013bc2 <CmdErrorParamWrong+0x32>
/*               pointer at first Byte of parameter, number of bytes        */
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_14
byte CmdErrorParamWrong(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
80013bae:	2f de       	sub	lr,-3
80013bb0:	f2 cb 00 01 	sub	r11,r9,1
    byte* dest_ptr;
    byte i;

    dest_ptr = &tx_ptr->Data[1];

    *dest_ptr++ = index;                /* Data[1] */
80013bb4:	2f f8       	sub	r8,-1
/*               pointer at first Byte of parameter, number of bytes        */
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_14
byte CmdErrorParamWrong(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
80013bb6:	5c 5b       	castu.b	r11
80013bb8:	16 0e       	add	lr,r11

    *dest_ptr++ = index;                /* Data[1] */

    for (i=(byte)0;i<num;i++)                 /* Data[2] .. Data[num+1] */
    {
        *dest_ptr++ = *param_ptr++;
80013bba:	15 3b       	ld.ub	r11,r10++
80013bbc:	10 cb       	st.b	r8++,r11

    dest_ptr = &tx_ptr->Data[1];

    *dest_ptr++ = index;                /* Data[1] */

    for (i=(byte)0;i<num;i++)                 /* Data[2] .. Data[num+1] */
80013bbe:	1c 38       	cp.w	r8,lr
80013bc0:	cf d1       	brne	80013bba <CmdErrorParamWrong+0x2a>
    {
        *dest_ptr++ = *param_ptr++;
    }

    tx_ptr->Length = (word)2 + (word)num;
80013bc2:	2f e9       	sub	r9,-2
80013bc4:	b8 29       	st.h	r12[0x4],r9
    #endif

    tx_ptr->Data[0] = ERR_PARAM_WRONG;                              /* Data[0] */

    return( CmdErrorParam_W_NA(tx_ptr, index, param_ptr, num) );    /* prepare Data[1] .. Data[num+1] and length */
}
80013bc6:	30 fc       	mov	r12,15
80013bc8:	d8 02       	popm	pc

80013bca <CmdErrorParamNotAvailable>:
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_15
byte CmdErrorParamNotAvailable(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
{
80013bca:	d4 01       	pushm	lr
    #if (MAX_MSG_TX_DATA < 256)
    if (num > (byte)(MAX_MSG_TX_DATA-2))
80013bcc:	33 08       	mov	r8,48
80013bce:	f0 09 18 00 	cp.b	r9,r8
80013bd2:	e0 8b 00 17 	brhi	80013c00 <CmdErrorParamNotAvailable+0x36>
    {
        return(OP_ERROR);
    }
    #endif

    tx_ptr->Data[0] = ERR_PARAM_NOTAVAILABLE;                       /* Data[0] */
80013bd6:	78 08       	ld.w	r8,r12[0x0]
80013bd8:	30 7e       	mov	lr,7
80013bda:	b0 8e       	st.b	r8[0x0],lr
byte CmdErrorParam_W_NA(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
{
    byte* dest_ptr;
    byte i;

    dest_ptr = &tx_ptr->Data[1];
80013bdc:	78 0e       	ld.w	lr,r12[0x0]
80013bde:	fc c8 ff ff 	sub	r8,lr,-1

    *dest_ptr++ = index;                /* Data[1] */
80013be2:	b0 8b       	st.b	r8[0x0],r11

    for (i=(byte)0;i<num;i++)                 /* Data[2] .. Data[num+1] */
80013be4:	58 09       	cp.w	r9,0
80013be6:	c0 b0       	breq	80013bfc <CmdErrorParamNotAvailable+0x32>
/*               pointer at first Byte of parameter, number of bytes        */
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_15
byte CmdErrorParamNotAvailable(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
80013be8:	2f de       	sub	lr,-3
80013bea:	f2 cb 00 01 	sub	r11,r9,1
    byte* dest_ptr;
    byte i;

    dest_ptr = &tx_ptr->Data[1];

    *dest_ptr++ = index;                /* Data[1] */
80013bee:	2f f8       	sub	r8,-1
/*               pointer at first Byte of parameter, number of bytes        */
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_15
byte CmdErrorParamNotAvailable(pTMsgTx tx_ptr, byte index, byte* param_ptr, byte num)
80013bf0:	5c 5b       	castu.b	r11
80013bf2:	16 0e       	add	lr,r11

    *dest_ptr++ = index;                /* Data[1] */

    for (i=(byte)0;i<num;i++)                 /* Data[2] .. Data[num+1] */
    {
        *dest_ptr++ = *param_ptr++;
80013bf4:	15 3b       	ld.ub	r11,r10++
80013bf6:	10 cb       	st.b	r8++,r11

    dest_ptr = &tx_ptr->Data[1];

    *dest_ptr++ = index;                /* Data[1] */

    for (i=(byte)0;i<num;i++)                 /* Data[2] .. Data[num+1] */
80013bf8:	1c 38       	cp.w	r8,lr
80013bfa:	cf d1       	brne	80013bf4 <CmdErrorParamNotAvailable+0x2a>
    {
        *dest_ptr++ = *param_ptr++;
    }

    tx_ptr->Length = (word)2 + (word)num;
80013bfc:	2f e9       	sub	r9,-2
80013bfe:	b8 29       	st.h	r12[0x4],r9
    #endif

    tx_ptr->Data[0] = ERR_PARAM_NOTAVAILABLE;                       /* Data[0] */

    return ( CmdErrorParam_W_NA(tx_ptr, index, param_ptr, num) );   /* prepare Data[1] .. Data[num+1] and length */
}
80013c00:	30 fc       	mov	r12,15
80013c02:	d8 02       	popm	pc

80013c04 <CmdEncodeStrRam>:
    byte *DestPtr;
    word Length;


    Length = (word)*SrcPtr++;           /* Length HB */
    Length = (word)(Length << 8);
80013c04:	f7 2a 00 00 	ld.sb	r10,r11[0]
{
    byte *DestPtr;
    word Length;


    Length = (word)*SrcPtr++;           /* Length HB */
80013c08:	16 98       	mov	r8,r11
    Length = (word)(Length << 8);
80013c0a:	a9 6a       	lsl	r10,0x8
80013c0c:	2f f8       	sub	r8,-1
    Length += (word)*SrcPtr++;          /* Length LB */
80013c0e:	11 89       	ld.ub	r9,r8[0x0]
80013c10:	f2 0a 00 0a 	add	r10,r9,r10
80013c14:	5c 8a       	casts.h	r10


    Tx_Ptr->Length = (word)Length;
80013c16:	b8 2a       	st.h	r12[0x4],r10
    DestPtr = &Tx_Ptr->Data[0];
80013c18:	78 09       	ld.w	r9,r12[0x0]


    while (Length)
80013c1a:	5e 0c       	reteq	r12
/* Parameter(s): ptr on Tx buf, ptr on string/interface description         */
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_13
void CmdEncodeStrRam(pTMsgTx Tx_Ptr, byte *SrcPtr)
80013c1c:	2f db       	sub	r11,-3
80013c1e:	20 1a       	sub	r10,1
    word Length;


    Length = (word)*SrcPtr++;           /* Length HB */
    Length = (word)(Length << 8);
    Length += (word)*SrcPtr++;          /* Length LB */
80013c20:	2f f8       	sub	r8,-1
/* Parameter(s): ptr on Tx buf, ptr on string/interface description         */
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_13
void CmdEncodeStrRam(pTMsgTx Tx_Ptr, byte *SrcPtr)
80013c22:	5c 7a       	castu.h	r10
80013c24:	14 0b       	add	r11,r10
    DestPtr = &Tx_Ptr->Data[0];


    while (Length)
    {
        *DestPtr++ = *SrcPtr++;
80013c26:	11 3a       	ld.ub	r10,r8++
80013c28:	12 ca       	st.b	r9++,r10

    Tx_Ptr->Length = (word)Length;
    DestPtr = &Tx_Ptr->Data[0];


    while (Length)
80013c2a:	16 38       	cp.w	r8,r11
80013c2c:	cf d1       	brne	80013c26 <CmdEncodeStrRam+0x22>
80013c2e:	5e fc       	retal	r12

80013c30 <CmdInsertSenderHandle>:
/*               0x01: handle not copied, since buffer too small            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_20
byte CmdInsertSenderHandle(pTMsgTx tx_ptr, byte handle_hb, byte handle_lb)
{
80013c30:	eb cd 40 e0 	pushm	r5-r7,lr
    word length;
    word i;

    length   = tx_ptr->Length;

    if (length > ((word)MAX_MSG_TX_DATA - (word)2))
80013c34:	33 08       	mov	r8,48
    byte* dest_ptr;
    byte* src_ptr;
    word length;
    word i;

    length   = tx_ptr->Length;
80013c36:	98 2e       	ld.sh	lr,r12[0x4]

    if (length > ((word)MAX_MSG_TX_DATA - (word)2))
80013c38:	f0 0e 19 00 	cp.h	lr,r8
80013c3c:	e0 8b 00 23 	brhi	80013c82 <CmdInsertSenderHandle+0x52>
    {
        return((byte)1);                          /* Error:  Buffer too small */
    }

    if (length)
80013c40:	58 0e       	cp.w	lr,0
80013c42:	c1 70       	breq	80013c70 <CmdInsertSenderHandle+0x40>
    {
        src_ptr  = &tx_ptr->Data[length-(word)1];
80013c44:	f1 de c0 10 	bfextu	r8,lr,0x0,0x10
80013c48:	78 09       	ld.w	r9,r12[0x0]
80013c4a:	20 18       	sub	r8,1
/* Returns     : 0x00: ok                                                   */
/*               0x01: handle not copied, since buffer too small            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_20
byte CmdInsertSenderHandle(pTMsgTx tx_ptr, byte handle_hb, byte handle_lb)
80013c4c:	fc c6 00 01 	sub	r6,lr,1
        return((byte)1);                          /* Error:  Buffer too small */
    }

    if (length)
    {
        src_ptr  = &tx_ptr->Data[length-(word)1];
80013c50:	f2 08 00 08 	add	r8,r9,r8
/* Returns     : 0x00: ok                                                   */
/*               0x01: handle not copied, since buffer too small            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_20
byte CmdInsertSenderHandle(pTMsgTx tx_ptr, byte handle_hb, byte handle_lb)
80013c54:	5c 76       	castu.h	r6
    }

    if (length)
    {
        src_ptr  = &tx_ptr->Data[length-(word)1];
        dest_ptr = src_ptr + 2;
80013c56:	f0 c5 ff fe 	sub	r5,r8,-2
/* Returns     : 0x00: ok                                                   */
/*               0x01: handle not copied, since buffer too small            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_20
byte CmdInsertSenderHandle(pTMsgTx tx_ptr, byte handle_hb, byte handle_lb)
80013c5a:	5c d6       	com	r6
80013c5c:	f0 06 00 07 	add	r7,r8,r6
        src_ptr  = &tx_ptr->Data[length-(word)1];
        dest_ptr = src_ptr + 2;

        for (i=(word)0;i<length;i++)
        {
            *dest_ptr-- = *src_ptr--;
80013c60:	11 89       	ld.ub	r9,r8[0x0]
80013c62:	b0 a9       	st.b	r8[0x2],r9
80013c64:	20 18       	sub	r8,1
    if (length)
    {
        src_ptr  = &tx_ptr->Data[length-(word)1];
        dest_ptr = src_ptr + 2;

        for (i=(word)0;i<length;i++)
80013c66:	0e 38       	cp.w	r8,r7
80013c68:	cf c1       	brne	80013c60 <CmdInsertSenderHandle+0x30>
80013c6a:	ea 06 00 08 	add	r8,r5,r6
80013c6e:	c0 38       	rjmp	80013c74 <CmdInsertSenderHandle+0x44>
            *dest_ptr-- = *src_ptr--;
        }
    }
    else
    {
        dest_ptr = &tx_ptr->Data[1];
80013c70:	78 08       	ld.w	r8,r12[0x0]
80013c72:	2f f8       	sub	r8,-1
    }

    *dest_ptr-- = handle_lb;
    *dest_ptr   = handle_hb;
80013c74:	f1 6b ff ff 	st.b	r8[-1],r11
    else
    {
        dest_ptr = &tx_ptr->Data[1];
    }

    *dest_ptr-- = handle_lb;
80013c78:	b0 8a       	st.b	r8[0x0],r10
    *dest_ptr   = handle_hb;

    tx_ptr->Length = length + (word)2;
80013c7a:	2f ee       	sub	lr,-2
80013c7c:	b8 2e       	st.h	r12[0x4],lr
80013c7e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    word length;
    word i;

    length   = tx_ptr->Length;

    if (length > ((word)MAX_MSG_TX_DATA - (word)2))
80013c82:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80013c86:	d7 03       	nop

80013c88 <CmdInsertSenderHandlePtr>:
/*               0x01: handle not copied, since buffer too small            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_21
byte CmdInsertSenderHandlePtr(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
80013c88:	d4 01       	pushm	lr
    return( CmdInsertSenderHandle( tx_ptr, rx_ptr->Data[0], rx_ptr->Data[1] ) );
80013c8a:	76 08       	ld.w	r8,r11[0x0]
80013c8c:	11 8b       	ld.ub	r11,r8[0x0]
80013c8e:	11 9a       	ld.ub	r10,r8[0x1]
80013c90:	cd 0f       	rcall	80013c30 <CmdInsertSenderHandle>
80013c92:	d8 02       	popm	pc

80013c94 <CmdAutoInsertSenderHandlePtr>:
}
80013c94:	eb cd 40 c0 	pushm	r6-r7,lr
80013c98:	30 28       	mov	r8,2
80013c9a:	f7 39 00 0c 	ld.ub	r9,r11[12]
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_22
void CmdAutoInsertSenderHandlePtr(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
80013c9e:	18 97       	mov	r7,r12
    byte op_tx;             /* operation type of tx message */
    byte op_rx;             /* operation type of received message */
    bool ins_handle;        /* insert sender handle ? */

    op_rx = rx_ptr->Operation;
80013ca0:	20 69       	sub	r9,6
80013ca2:	f0 09 18 00 	cp.b	r9,r8
80013ca6:	e0 8b 00 16 	brhi	80013cd2 <CmdAutoInsertSenderHandlePtr+0x3e>

    if  (                                       /* insert the sender handle only, in case of... */
          ( (OP_STARTACK       == op_rx)        /* a) Operation StartAck */
         || (OP_ABORTACK       == op_rx)        /* b) Operation AbortAck */
         || (OP_STARTRESULTACK == op_rx) )      /* c) Operation StartResultAck */
         && ((word)2  <= rx_ptr->Length)        /* check if rx message contains a sender handle */
80013caa:	96 29       	ld.sh	r9,r11[0x4]
80013cac:	30 18       	mov	r8,1
80013cae:	f0 09 19 00 	cp.h	r9,r8
80013cb2:	e0 88 00 10 	brls	80013cd2 <CmdAutoInsertSenderHandlePtr+0x3e>
        )
    {
        op_tx = tx_ptr->Operation;
        ins_handle = MNS_FALSE;

        switch (op_tx)                          /* check for operation type of tx msg */
80013cb6:	f9 38 00 0c 	ld.ub	r8,r12[12]
80013cba:	30 c9       	mov	r9,12
80013cbc:	f2 08 18 00 	cp.b	r8,r9
80013cc0:	c1 40       	breq	80013ce8 <CmdAutoInsertSenderHandlePtr+0x54>
80013cc2:	30 f9       	mov	r9,15
80013cc4:	f2 08 18 00 	cp.b	r8,r9
80013cc8:	c0 e0       	breq	80013ce4 <CmdAutoInsertSenderHandlePtr+0x50>
80013cca:	30 b9       	mov	r9,11
80013ccc:	f2 08 18 00 	cp.b	r8,r9
80013cd0:	c0 30       	breq	80013cd6 <CmdAutoInsertSenderHandlePtr+0x42>
80013cd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80013cd6:	30 a6       	mov	r6,10
                break;
        }

        if (MNS_FALSE != ins_handle)
        {
            (void)CmdInsertSenderHandlePtr(tx_ptr, rx_ptr);     /* copy sender handle from rx msg to tx msg */
80013cd8:	0e 9c       	mov	r12,r7
80013cda:	cd 7f       	rcall	80013c88 <CmdInsertSenderHandlePtr>
80013cdc:	ef 66 00 0c 	st.b	r7[12],r6
            tx_ptr->Operation = op_tx;                          /* write new operation type of tx msg */
80013ce0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80013ce4:	30 96       	mov	r6,9
        }
    }
}
80013ce6:	cf 9b       	rjmp	80013cd8 <CmdAutoInsertSenderHandlePtr+0x44>
80013ce8:	30 d6       	mov	r6,13
        )
    {
        op_tx = tx_ptr->Operation;
        ins_handle = MNS_FALSE;

        switch (op_tx)                          /* check for operation type of tx msg */
80013cea:	cf 7b       	rjmp	80013cd8 <CmdAutoInsertSenderHandlePtr+0x44>

80013cec <CmdGetFunctionIds>:
80013cec:	d4 31       	pushm	r0-r7,lr
80013cee:	e0 66 0e ff 	mov	r6,3839
80013cf2:	2f 8b       	sub	r11,-8
                                        /* the termination mark is visible    */



    /* search till end of table (0xFFFF) or till first supplier specific function found */
    while( (func_ptr->Func < (word)0xF00) && (MNS_FALSE == overflow) )
80013cf4:	96 09       	ld.sh	r9,r11[0x0]
80013cf6:	ec 09 19 00 	cp.h	r9,r6
80013cfa:	e0 8b 00 9d 	brhi	80013e34 <CmdGetFunctionIds+0x148>
    {
                                    /* RLE-Format-> only changes are visible  */
        changed = MNS_FALSE;
        if(func_ptr->Func < counter)
80013cfe:	58 09       	cp.w	r9,0
80013d00:	e0 80 00 93 	breq	80013e26 <CmdGetFunctionIds+0x13a>
        {
            /* table not sorted ! */
            return(CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC));
80013d04:	30 0e       	mov	lr,0
80013d06:	30 17       	mov	r7,1
80013d08:	1c 94       	mov	r4,lr
80013d0a:	0e 98       	mov	r8,r7
80013d0c:	1c 93       	mov	r3,lr
80013d0e:	1c 95       	mov	r5,lr
            changed = MNS_TRUE;
        }

        if( MNS_FALSE != changed )
        {
            switch(position)
80013d10:	0e 91       	mov	r1,r7
                                        /* 4 Bit of the current one. At least */
                                        /* the 8 Bit LSB in the next pos.     */
                    tempValue = (byte)(counter >> 8);
                    tempByte |= tempValue;
                    tempValue = (byte)counter;
                    if (i < (word)MAX_MSG_TX_DATA)
80013d12:	33 12       	mov	r2,49
                    else
                    {
                        overflow = MNS_TRUE;
                    }

                    if (i < (word)MAX_MSG_TX_DATA)
80013d14:	33 20       	mov	r0,50
80013d16:	c2 18       	rjmp	80013d58 <CmdGetFunctionIds+0x6c>
        else if( (func_ptr->Func == counter) && (MNS_FALSE == presenceStatus))
        {
            presenceStatus = MNS_TRUE;
            changed = MNS_TRUE;
        }
        else if( (func_ptr->Func != counter) && (MNS_FALSE != presenceStatus))
80013d18:	30 07       	mov	r7,0
            changed = MNS_TRUE;
        }

        if( MNS_FALSE != changed )
        {
            switch(position)
80013d1a:	e2 05 18 00 	cp.b	r5,r1
80013d1e:	c2 a0       	breq	80013d72 <CmdGetFunctionIds+0x86>
                case CMD_EVEN_POS:
                                      /* 8 of 12 bit can be written and the   */
                                      /* last 4 bit must be stored until the  */
                                      /* next function Id                     */
                    tempValue = (byte)(counter >> 4);
                    tempByte  = (byte)((word)(counter << 4));
80013d20:	f0 03 15 04 	lsl	r3,r8,0x4
80013d24:	5c 53       	castu.b	r3
                    if (i < (word)MAX_MSG_TX_DATA)
80013d26:	e4 0e 19 00 	cp.h	lr,r2
80013d2a:	e0 88 00 46 	brls	80013db6 <CmdGetFunctionIds+0xca>
80013d2e:	30 15       	mov	r5,1
80013d30:	0a 9a       	mov	r10,r5
                    break;

            }
        }

        if (counter >= func_ptr->Func)
80013d32:	f2 08 19 00 	cp.h	r8,r9
80013d36:	c0 63       	brcs	80013d42 <CmdGetFunctionIds+0x56>
        {
            lastFunc = func_ptr->Func + (word)1;
80013d38:	2f f9       	sub	r9,-1
            func_ptr++;
80013d3a:	2f 8b       	sub	r11,-8
            }
        }

        if (counter >= func_ptr->Func)
        {
            lastFunc = func_ptr->Func + (word)1;
80013d3c:	e9 d9 b0 10 	bfexts	r4,r9,0x0,0x10
            func_ptr++;
80013d40:	96 09       	ld.sh	r9,r11[0x0]
                                        /* the termination mark is visible    */



    /* search till end of table (0xFFFF) or till first supplier specific function found */
    while( (func_ptr->Func < (word)0xF00) && (MNS_FALSE == overflow) )
80013d42:	ec 09 19 00 	cp.h	r9,r6
80013d46:	e0 8b 00 47 	brhi	80013dd4 <CmdGetFunctionIds+0xe8>
80013d4a:	58 0a       	cp.w	r10,0
80013d4c:	c4 41       	brne	80013dd4 <CmdGetFunctionIds+0xe8>
        {
            lastFunc = func_ptr->Func + (word)1;
            func_ptr++;
        }

        counter++;
80013d4e:	2f f8       	sub	r8,-1
80013d50:	5c 88       	casts.h	r8
    /* search till end of table (0xFFFF) or till first supplier specific function found */
    while( (func_ptr->Func < (word)0xF00) && (MNS_FALSE == overflow) )
    {
                                    /* RLE-Format-> only changes are visible  */
        changed = MNS_FALSE;
        if(func_ptr->Func < counter)
80013d52:	f0 09 19 00 	cp.h	r9,r8
80013d56:	c6 83       	brcs	80013e26 <CmdGetFunctionIds+0x13a>
        {
            /* table not sorted ! */
            return(CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC));
        }
        else if( (func_ptr->Func == counter) && (MNS_FALSE == presenceStatus))
80013d58:	f2 08 19 00 	cp.h	r8,r9
80013d5c:	c0 50       	breq	80013d66 <CmdGetFunctionIds+0x7a>
        {
            presenceStatus = MNS_TRUE;
            changed = MNS_TRUE;
        }
        else if( (func_ptr->Func != counter) && (MNS_FALSE != presenceStatus))
80013d5e:	58 07       	cp.w	r7,0
80013d60:	cd c1       	brne	80013d18 <CmdGetFunctionIds+0x2c>
        return(CmdErrorMsg(tx_ptr, ERR_PROCESSING)); /* Processing Error */
    }
    else
    {
        tx_ptr->Length = i;
        return(OP_STATUS);
80013d62:	30 0a       	mov	r10,0
80013d64:	ce 7b       	rjmp	80013d32 <CmdGetFunctionIds+0x46>
        if(func_ptr->Func < counter)
        {
            /* table not sorted ! */
            return(CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC));
        }
        else if( (func_ptr->Func == counter) && (MNS_FALSE == presenceStatus))
80013d66:	58 07       	cp.w	r7,0
80013d68:	cf d1       	brne	80013d62 <CmdGetFunctionIds+0x76>
80013d6a:	30 17       	mov	r7,1
            changed = MNS_TRUE;
        }

        if( MNS_FALSE != changed )
        {
            switch(position)
80013d6c:	e2 05 18 00 	cp.b	r5,r1
80013d70:	cd 81       	brne	80013d20 <CmdGetFunctionIds+0x34>
                case CMD_ODD_POS:
                                        /* 4 Bit of former function plus      */
                                        /* 4 Bit of the current one. At least */
                                        /* the 8 Bit LSB in the next pos.     */
                    tempValue = (byte)(counter >> 8);
                    tempByte |= tempValue;
80013d72:	f5 d8 c1 08 	bfextu	r10,r8,0x8,0x8
80013d76:	14 43       	or	r3,r10
                    tempValue = (byte)counter;
                    if (i < (word)MAX_MSG_TX_DATA)
80013d78:	e4 0e 19 00 	cp.h	lr,r2
80013d7c:	e0 8b 00 1a 	brhi	80013db0 <CmdGetFunctionIds+0xc4>
                    {
                        tx_ptr->Data[i] = tempByte;
80013d80:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
80013d84:	78 0a       	ld.w	r10,r12[0x0]
80013d86:	f4 09 0b 03 	st.b	r10[r9],r3
                        i++;
80013d8a:	2f fe       	sub	lr,-1
80013d8c:	5c 8e       	casts.h	lr
                    else
                    {
                        overflow = MNS_TRUE;
                    }

                    if (i < (word)MAX_MSG_TX_DATA)
80013d8e:	e0 0e 19 00 	cp.h	lr,r0
80013d92:	c0 e0       	breq	80013dae <CmdGetFunctionIds+0xc2>
                    {
                        tx_ptr->Data[i] = tempValue;
                        i++;
80013d94:	fc ca ff ff 	sub	r10,lr,-1
                        overflow = MNS_TRUE;
                    }

                    if (i < (word)MAX_MSG_TX_DATA)
                    {
                        tx_ptr->Data[i] = tempValue;
80013d98:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
                        i++;
80013d9c:	fd da b0 10 	bfexts	lr,r10,0x0,0x10
                        overflow = MNS_TRUE;
                    }

                    if (i < (word)MAX_MSG_TX_DATA)
                    {
                        tx_ptr->Data[i] = tempValue;
80013da0:	78 0a       	ld.w	r10,r12[0x0]
                        i++;
80013da2:	30 05       	mov	r5,0
                        overflow = MNS_TRUE;
                    }

                    if (i < (word)MAX_MSG_TX_DATA)
                    {
                        tx_ptr->Data[i] = tempValue;
80013da4:	f4 09 0b 08 	st.b	r10[r9],r8
                        i++;
80013da8:	0a 9a       	mov	r10,r5
80013daa:	96 09       	ld.sh	r9,r11[0x0]
80013dac:	cc 3b       	rjmp	80013d32 <CmdGetFunctionIds+0x46>
80013dae:	96 09       	ld.sh	r9,r11[0x0]
80013db0:	30 1a       	mov	r10,1
80013db2:	30 05       	mov	r5,0
80013db4:	cb fb       	rjmp	80013d32 <CmdGetFunctionIds+0x46>
                    tempValue = (byte)(counter >> 4);
                    tempByte  = (byte)((word)(counter << 4));
                    if (i < (word)MAX_MSG_TX_DATA)
                    {
                        tx_ptr->Data[i] = tempValue;
                        i++;
80013db6:	fc ca ff ff 	sub	r10,lr,-1
                                      /* next function Id                     */
                    tempValue = (byte)(counter >> 4);
                    tempByte  = (byte)((word)(counter << 4));
                    if (i < (word)MAX_MSG_TX_DATA)
                    {
                        tx_ptr->Data[i] = tempValue;
80013dba:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
80013dbe:	eb d8 c0 8c 	bfextu	r5,r8,0x4,0xc
                        i++;
80013dc2:	fd da b0 10 	bfexts	lr,r10,0x0,0x10
                                      /* next function Id                     */
                    tempValue = (byte)(counter >> 4);
                    tempByte  = (byte)((word)(counter << 4));
                    if (i < (word)MAX_MSG_TX_DATA)
                    {
                        tx_ptr->Data[i] = tempValue;
80013dc6:	78 0a       	ld.w	r10,r12[0x0]
80013dc8:	f4 09 0b 05 	st.b	r10[r9],r5
                        i++;
80013dcc:	30 0a       	mov	r10,0
80013dce:	30 15       	mov	r5,1
80013dd0:	96 09       	ld.sh	r9,r11[0x0]
80013dd2:	cb 0b       	rjmp	80013d32 <CmdGetFunctionIds+0x46>
                                        /* the termination mark is visible    */



    /* search till end of table (0xFFFF) or till first supplier specific function found */
    while( (func_ptr->Func < (word)0xF00) && (MNS_FALSE == overflow) )
80013dd4:	08 9b       	mov	r11,r4
80013dd6:	f3 de b0 10 	bfexts	r9,lr,0x0,0x10
80013dda:	5c 8b       	casts.h	r11

        counter++;

    }

    if (i < (word)MAX_MSG_TX_DATA)
80013ddc:	33 18       	mov	r8,49
80013dde:	f0 0e 19 00 	cp.h	lr,r8
80013de2:	e0 88 00 09 	brls	80013df4 <CmdGetFunctionIds+0x108>
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_5
byte CmdErrorMsg(pTMsgTx Tx_Ptr, byte ErrorID)
{
    Tx_Ptr->Data[0] = ErrorID;
80013de6:	78 08       	ld.w	r8,r12[0x0]
80013de8:	34 29       	mov	r9,66
80013dea:	b0 89       	st.b	r8[0x0],r9
    Tx_Ptr->Length  = (word)1;
80013dec:	30 18       	mov	r8,1
80013dee:	b8 28       	st.h	r12[0x4],r8
80013df0:	30 fc       	mov	r12,15
        overflow = MNS_TRUE;
    }

    if (MNS_FALSE != overflow)
    {
        return(CmdErrorMsg(tx_ptr, ERR_PROCESSING)); /* Processing Error */
80013df2:	d8 32       	popm	r0-r7,pc

    }

    if (i < (word)MAX_MSG_TX_DATA)
    {
        tx_ptr->Data[i] = (byte)(lastFunc >> 4);
80013df4:	fd d9 c0 10 	bfextu	lr,r9,0x0,0x10
80013df8:	f7 db c0 8c 	bfextu	r11,r11,0x4,0xc
80013dfc:	78 07       	ld.w	r7,r12[0x0]
80013dfe:	ee 0e 0b 0b 	st.b	r7[lr],r11

        counter++;

    }

    if (i < (word)MAX_MSG_TX_DATA)
80013e02:	2f f9       	sub	r9,-1
80013e04:	5c 89       	casts.h	r9
    else
    {
        overflow = MNS_TRUE;
    }

    if (i < (word)MAX_MSG_TX_DATA)
80013e06:	f0 09 19 00 	cp.h	r9,r8
80013e0a:	fe 9b ff ee 	brhi	80013de6 <CmdGetFunctionIds+0xfa>
    {
        tx_ptr->Data[i] = (byte)((word)(lastFunc << 4));
80013e0e:	a5 64       	lsl	r4,0x4
80013e10:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
80013e14:	78 0b       	ld.w	r11,r12[0x0]
80013e16:	f6 08 0b 04 	st.b	r11[r8],r4
    else
    {
        overflow = MNS_TRUE;
    }

    if (MNS_FALSE != overflow)
80013e1a:	58 0a       	cp.w	r10,0
80013e1c:	ce 51       	brne	80013de6 <CmdGetFunctionIds+0xfa>
    {
        return(CmdErrorMsg(tx_ptr, ERR_PROCESSING)); /* Processing Error */
    }
    else
    {
        tx_ptr->Length = i;
80013e1e:	2f f9       	sub	r9,-1
80013e20:	b8 29       	st.h	r12[0x4],r9
80013e22:	30 cc       	mov	r12,12
        return(OP_STATUS);
    }
}
80013e24:	d8 32       	popm	r0-r7,pc
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_5
byte CmdErrorMsg(pTMsgTx Tx_Ptr, byte ErrorID)
{
    Tx_Ptr->Data[0] = ErrorID;
80013e26:	78 08       	ld.w	r8,r12[0x0]
80013e28:	30 b9       	mov	r9,11
80013e2a:	b0 89       	st.b	r8[0x0],r9
    Tx_Ptr->Length  = (word)1;
80013e2c:	30 18       	mov	r8,1
80013e2e:	b8 28       	st.h	r12[0x4],r8
80013e30:	30 fc       	mov	r12,15
                                    /* RLE-Format-> only changes are visible  */
        changed = MNS_FALSE;
        if(func_ptr->Func < counter)
        {
            /* table not sorted ! */
            return(CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC));
80013e32:	d8 32       	popm	r0-r7,pc

    }

    if (i < (word)MAX_MSG_TX_DATA)
    {
        tx_ptr->Data[i] = (byte)(lastFunc >> 4);
80013e34:	78 09       	ld.w	r9,r12[0x0]
80013e36:	30 08       	mov	r8,0
80013e38:	b2 88       	st.b	r9[0x0],r8
        overflow = MNS_TRUE;
    }

    if (i < (word)MAX_MSG_TX_DATA)
    {
        tx_ptr->Data[i] = (byte)((word)(lastFunc << 4));
80013e3a:	30 19       	mov	r9,1
80013e3c:	78 0a       	ld.w	r10,r12[0x0]
80013e3e:	b4 98       	st.b	r10[0x1],r8
80013e40:	ce fb       	rjmp	80013e1e <CmdGetFunctionIds+0x132>
80013e42:	d7 03       	nop

80013e44 <CmdRxInterpreter>:
/*                                required but not free                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_2
byte CmdRxInterpreter(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80013e44:	d4 31       	pushm	r0-r7,lr
80013e46:	20 4d       	sub	sp,16

    /*----------------------------- */



    FBlock_Rx = Rx_Ptr->FBlock_ID;                                      /* get FBlock_ID from Rx buffer */
80013e48:	f7 34 00 0a 	ld.ub	r4,r11[10]
    Inst_Rx   = Rx_Ptr->Inst_ID;                                        /* get Inst_ID from Rx buffer */
80013e4c:	f7 33 00 0b 	ld.ub	r3,r11[11]
    Func_Rx   = Rx_Ptr->Func_ID;                                        /* get Function_ID from Rx buffer */
80013e50:	96 42       	ld.sh	r2,r11[0x8]
/*                                required but not free                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_2
byte CmdRxInterpreter(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80013e52:	18 97       	mov	r7,r12
80013e54:	16 96       	mov	r6,r11


    FBlock_Rx = Rx_Ptr->FBlock_ID;                                      /* get FBlock_ID from Rx buffer */
    Inst_Rx   = Rx_Ptr->Inst_ID;                                        /* get Inst_ID from Rx buffer */
    Func_Rx   = Rx_Ptr->Func_ID;                                        /* get Function_ID from Rx buffer */
    Op_Rx     = Rx_Ptr->Operation;                                      /* get Operation from Rx buffer */
80013e56:	f7 3c 00 0c 	ld.ub	r12,r11[12]
80013e5a:	50 0c       	stdsp	sp[0x0],r12
    #ifdef CMD_ADD8
    Len_Rx    = Rx_Ptr->Length;
80013e5c:	96 2b       	ld.sh	r11,r11[0x4]
80013e5e:	50 3b       	stdsp	sp[0xc],r11


    /*----------------------------- */
    /*   Prepare Header for Tx_Msg */
    /*----------------------------- */
    Tx_Ptr->Tgt_Adr     = Rx_Ptr->Src_Adr;
80013e60:	8c 38       	ld.sh	r8,r6[0x6]
    Tx_Ptr->FBlock_ID   = FBlock_Rx;
80013e62:	ef 64 00 0a 	st.b	r7[10],r4


    /*----------------------------- */
    /*   Prepare Header for Tx_Msg */
    /*----------------------------- */
    Tx_Ptr->Tgt_Adr     = Rx_Ptr->Src_Adr;
80013e66:	ae 38       	st.h	r7[0x6],r8
    Tx_Ptr->FBlock_ID   = FBlock_Rx;
    Tx_Ptr->Func_ID     = Func_Rx;
80013e68:	ae 42       	st.h	r7[0x8],r2

    if (FBLOCK_NETBLOCK == FBlock_Rx)                                   /* InstID of FBlock NetBlock */
80013e6a:	30 18       	mov	r8,1
80013e6c:	f0 04 18 00 	cp.b	r4,r8
80013e70:	e0 80 01 11 	breq	80014092 <CmdRxInterpreter+0x24e>
    {
        Tx_Ptr->Inst_ID = MOST_GET_NODE_POS();                          /* has to be the NodePosition */
    }
    else                                                                /* when answering the report message */
    {
        Tx_Ptr->Inst_ID = Inst_Rx;
80013e74:	ef 63 00 0b 	st.b	r7[11],r3
                                                                        /*   1 = FBlock found not yet */
                                                                        /*   2 = FBlock found, but Inst found not yet */
                                                                        /*   0 = FBlock.InstID ok */


    if (   ((FBLOCK_ALL == FBlock_Rx) || (INST_ALL == Inst_Rx))         /* if the InstanceID is 0xFF and we are not looking at this */
80013e78:	3f f8       	mov	r8,-1
80013e7a:	f0 03 18 00 	cp.b	r3,r8
80013e7e:	5f 09       	sreq	r9
80013e80:	f0 04 18 00 	cp.b	r4,r8
80013e84:	5f 05       	sreq	r5
80013e86:	50 19       	stdsp	sp[0x4],r9
80013e88:	0a 49       	or	r9,r5
80013e8a:	50 29       	stdsp	sp[0x8],r9
80013e8c:	c4 70       	breq	80013f1a <CmdRxInterpreter+0xd6>
        &&  (Cmd_FBlock_Tab_Ptr_Holder) )                               /* message for the first time enter where we left last time */
80013e8e:	fe f8 04 0e 	ld.w	r8,pc[1038]
80013e92:	70 09       	ld.w	r9,r8[0x0]
                                                                        /*   1 = FBlock found not yet */
                                                                        /*   2 = FBlock found, but Inst found not yet */
                                                                        /*   0 = FBlock.InstID ok */


    if (   ((FBLOCK_ALL == FBlock_Rx) || (INST_ALL == Inst_Rx))         /* if the InstanceID is 0xFF and we are not looking at this */
80013e94:	58 09       	cp.w	r9,0
80013e96:	c4 20       	breq	80013f1a <CmdRxInterpreter+0xd6>
        &&  (Cmd_FBlock_Tab_Ptr_Holder) )                               /* message for the first time enter where we left last time */
    {
        FBlock_Tab_Ptr = Cmd_FBlock_Tab_Ptr_Holder;
        Tab_Counter = Cmd_FBlock_Position_Holder;  /* when reexamining the message we also need to make sure that Tab_Counter is properly decremented. */
80013e98:	fe fb 04 08 	ld.w	r11,pc[1032]
80013e9c:	17 8a       	ld.ub	r10,r11[0x0]


    /*-------------------------- */
    /*   Check: FBlockID.InstID */
    /*-------------------------- */
    if (Tab_Counter)
80013e9e:	58 0a       	cp.w	r10,0
80013ea0:	c4 71       	brne	80013f2e <CmdRxInterpreter+0xea>

    if ((INST_ALL == Inst_Rx) ||(FBLOCK_ALL == FBlock_Rx))      /* Application groupcast ? */
    {
        if ((byte)0 == Tab_Counter)                 /* this indicates that we finished searching the FBlock table without finding the sought FBlock */
        {
            Cmd_FBlock_Position_Holder = (byte)0;   /* so Cmd_FBlock_Position_Holder needs to be reset to 0 */
80013ea2:	b6 8a       	st.b	r11[0x0],r10
80013ea4:	30 11       	mov	r1,1
            if (NULL != Cmd_FBlock_Tab_Ptr_Holder)  /* if Cmd_FBlock_Tab_Ptr_Holder is not NULL then we found a matching FBlock on a previous run of the CmdRxInterpreter */
            {
                Cmd_FBlock_Tab_Ptr_Holder =  NULL;  /* so this value also needs to be reset to NULL */
80013ea6:	30 04       	mov	r4,0
80013ea8:	91 04       	st.w	r8[0x0],r4
        }
    }



    if ((byte)0 != Inst_Check)                                     /* if corresponding FBlockID.InstID not found */
80013eaa:	58 01       	cp.w	r1,0
80013eac:	c6 61       	brne	80013f78 <CmdRxInterpreter+0x134>

    /*------------------------------------------------ */

    if ((byte)0 == Report)                                        /* if no error occurred */
    {
        Func_Tab_Ptr = FBlock_Tab_Ptr->Func_Tab_Ptr;                    /* read pointer on Function_ID table (Romread) */
80013eae:	72 28       	ld.w	r8,r9[0x8]
        {
            Func_Tab = Func_Tab_Ptr->Func;                              /* read Function_ID from table (Romread) */

            Func_Tab_Ptr++;

            if (FUNC_TERMINATION == Func_Tab)                           /* end of table ? */
80013eb0:	3f fb       	mov	r11,-1
        /*------------------------ */
        /*   Check: Function ID */
        /*------------------------ */
        do
        {
            Func_Tab = Func_Tab_Ptr->Func;                              /* read Function_ID from table (Romread) */
80013eb2:	90 09       	ld.sh	r9,r8[0x0]

            Func_Tab_Ptr++;
80013eb4:	f0 ca ff f8 	sub	r10,r8,-8

            if (FUNC_TERMINATION == Func_Tab)                           /* end of table ? */
80013eb8:	f6 09 19 00 	cp.h	r9,r11
80013ebc:	c0 f0       	breq	80013eda <CmdRxInterpreter+0x96>
            {
                (void)CmdErrorMsg(Tx_Ptr, ERR_FKTID);                   /* FuncID not found */
                Report = OP_ERROR;
            }
        }while ((Func_Tab != Func_Rx) && ((byte)0 == Report));          /* repeat until required FuncID has been found */
80013ebe:	e4 09 19 00 	cp.h	r9,r2
80013ec2:	5f 19       	srne	r9
80013ec4:	e2 09 18 00 	cp.b	r9,r1
80013ec8:	e0 80 00 f3 	breq	800140ae <CmdRxInterpreter+0x26a>
80013ecc:	14 98       	mov	r8,r10
        /*------------------------ */
        /*   Check: Function ID */
        /*------------------------ */
        do
        {
            Func_Tab = Func_Tab_Ptr->Func;                              /* read Function_ID from table (Romread) */
80013ece:	90 09       	ld.sh	r9,r8[0x0]

            Func_Tab_Ptr++;
80013ed0:	f0 ca ff f8 	sub	r10,r8,-8

            if (FUNC_TERMINATION == Func_Tab)                           /* end of table ? */
80013ed4:	f6 09 19 00 	cp.h	r9,r11
80013ed8:	cf 31       	brne	80013ebe <CmdRxInterpreter+0x7a>
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_5
byte CmdErrorMsg(pTMsgTx Tx_Ptr, byte ErrorID)
{
    Tx_Ptr->Data[0] = ErrorID;
80013eda:	6e 08       	ld.w	r8,r7[0x0]
80013edc:	30 39       	mov	r9,3
80013ede:	b0 89       	st.b	r8[0x0],r9
    Tx_Ptr->Length  = (word)1;
80013ee0:	30 18       	mov	r8,1
80013ee2:	ae 28       	st.h	r7[0x4],r8
80013ee4:	30 02       	mov	r2,0
80013ee6:	30 f9       	mov	r9,15
    /*------------------------------- */
    if ( (byte)0 == (Report & CMD_TX_RETAIN) )          /* Flag not set, which signs that tx message will be completed by application ? */
    {
        if ( (Report & (byte)0xF) == OP_ERROR)          /* Is the response an error message ? */
        {
            if (!(Report & CMD_PASS))                   /* Avoid all error message on following conditions, but only if not passed through: */
80013ee8:	12 98       	mov	r8,r9
80013eea:	e2 18 00 10 	andl	r8,0x10,COH
80013eee:	e0 80 00 b1 	breq	80014050 <CmdRxInterpreter+0x20c>
                    Report = OP_NO_REPORT;
                }
            }
        }   /* if 'error message' */

        if (Report && ( (Op_Rx<OP_REPORTS)||(Report&CMD_PASS) ) )   /* Send message (answer, result, error or message passed on) */
80013ef2:	30 88       	mov	r8,8
80013ef4:	40 0a       	lddsp	r10,sp[0x0]
80013ef6:	f0 0a 18 00 	cp.b	r10,r8
80013efa:	e0 88 00 80 	brls	80013ffa <CmdRxInterpreter+0x1b6>
80013efe:	ed b9 00 04 	bld	r9,0x4
80013f02:	c7 c0       	breq	80013ffa <CmdRxInterpreter+0x1b6>
                MsgTxUnused(Tx_Ptr);
            }
        }
        else
        {
            CmdTxFilter((pTMsgTx)NULL, Rx_Ptr);     /* No result message -> Callback with NULL-Pointer and "rx ptr" */
80013f04:	0c 9b       	mov	r11,r6
80013f06:	30 0c       	mov	r12,0
80013f08:	fe b0 a1 03 	rcall	8000810e <CmdTxFilter>

            CmdTxNoResult(Rx_Ptr);                  /* No result message -> Callback only with "rx ptr" */
80013f0c:	0c 9c       	mov	r12,r6
80013f0e:	fe b0 a1 01 	rcall	80008110 <CmdTxNoResult>

            MsgTxUnused(Tx_Ptr);                    /* Set tx buffer line free since there is no message to send */
80013f12:	0e 9c       	mov	r12,r7
80013f14:	fe b0 a8 10 	rcall	80008f34 <MsgTxUnused>
80013f18:	c4 48       	rjmp	80013fa0 <CmdRxInterpreter+0x15c>
    }
    else    /* origin behaviour: */
    {
        FBlock_Tab_Ptr = FBlocks;                                           /* init pointer on FBlock_ID table */

        if (Op_Rx >= OP_REPORTS)
80013f1a:	30 8a       	mov	r10,8
80013f1c:	40 0b       	lddsp	r11,sp[0x0]
    if ( ((byte)0    == (CmdRx_RetVal & CMD_F_RETRIGGER)) &&
         (MNS_FALSE != cmd_repeat_int) )      /* if a repeat was called by the application, then don't increment the position holders */
    {                                       /* otherwise if a repeat is needed by the Command Interperter alone, then set the repeat flag and increment the position holders */
        CmdRx_RetVal |= CMD_F_RETRIGGER;    /* set the global repeat flag */
        Cmd_FBlock_Tab_Ptr_Holder++;        /* increment it so we start with the next position in the table */
        Cmd_FBlock_Position_Holder --;      /* decrement it so we adjust for are above increment */
80013f1e:	fe f9 03 86 	ld.w	r9,pc[902]
    }
    else    /* origin behaviour: */
    {
        FBlock_Tab_Ptr = FBlocks;                                           /* init pointer on FBlock_ID table */

        if (Op_Rx >= OP_REPORTS)
80013f22:	f6 0a 18 00 	cp.b	r10,r11
80013f26:	f9 ba 02 05 	movhs	r10,5
80013f2a:	f9 ba 03 06 	movlo	r10,6
80013f2e:	30 11       	mov	r1,1
    {
        do
        {
            FBlock_Tab = FBlock_Tab_Ptr->FBlock;                            /* read FBlock_ID from table (Romread) */

            if (    ( (FBLOCK_ALL       == FBlock_Rx)                       /* FBLOCK_ALL addresses all FBlocks but not      */
80013f30:	30 0b       	mov	r11,0
80013f32:	02 90       	mov	r0,r1
    /*-------------------------- */
    if (Tab_Counter)
    {
        do
        {
            FBlock_Tab = FBlock_Tab_Ptr->FBlock;                            /* read FBlock_ID from table (Romread) */
80013f34:	13 88       	ld.ub	r8,r9[0x0]
            }

            if (Inst_Check)                                                 /* if FBlock.InstID found not yet */
            {
                FBlock_Tab_Ptr++;
                Tab_Counter--;
80013f36:	f4 ce 00 01 	sub	lr,r10,1
    {
        do
        {
            FBlock_Tab = FBlock_Tab_Ptr->FBlock;                            /* read FBlock_ID from table (Romread) */

            if (    ( (FBLOCK_ALL       == FBlock_Rx)                       /* FBLOCK_ALL addresses all FBlocks but not      */
80013f3a:	e0 08 18 00 	cp.b	r8,r0
80013f3e:	5f 1c       	srne	r12
80013f40:	eb ec 00 0c 	and	r12,r5,r12
80013f44:	f6 0c 18 00 	cp.b	r12,r11
80013f48:	c4 00       	breq	80013fc8 <CmdRxInterpreter+0x184>
80013f4a:	3e fc       	mov	r12,-17
80013f4c:	f8 08 18 00 	cp.b	r8,r12
80013f50:	e0 8b 00 3c 	brhi	80013fc8 <CmdRxInterpreter+0x184>
                   && (FBLOCK_NETBLOCK  != FBlock_Tab)                      /* the NetBlock and no supplier specific FBlocks */
                   && ((byte)0xF0       >  FBlock_Tab) )
                 ||   (FBlock_Tab       == FBlock_Rx) )
            {
                Tx_Ptr->FBlock_ID = FBlock_Tab;                             /* set correct FBlockID for response message */
80013f54:	ef 68 00 0a 	st.b	r7[10],r8
                if ((byte)0 == Inst_Rx)                                     /* InstID == 0x00 ? */
80013f58:	58 03       	cp.w	r3,0
80013f5a:	c4 41       	brne	80013fe2 <CmdRxInterpreter+0x19e>
                {                                                           /* Received InstID 0x00 is treated as don't care */
                    if (FBlock_Tab_Ptr->Inst_Tab_Ptr)
80013f5c:	72 18       	ld.w	r8,r9[0x4]
80013f5e:	58 08       	cp.w	r8,0
80013f60:	c0 40       	breq	80013f68 <CmdRxInterpreter+0x124>
                else if (INST_ALL == Inst_Rx)                               /* otherwise check InstID */
                /* if InstID is 0xFF and the FBlockID already checks out then save the correct InstID in Tx_Ptr and set Inst_Check to 0 to leave the loop */
                {
                    if (FBlock_Tab_Ptr->Inst_Tab_Ptr)
                    {
                        Tx_Ptr->Inst_ID = *(FBlock_Tab_Ptr->Inst_Tab_Ptr);
80013f62:	11 88       	ld.ub	r8,r8[0x0]
80013f64:	ef 68 00 0b 	st.b	r7[11],r8
    if ( ((byte)0    == (CmdRx_RetVal & CMD_F_RETRIGGER)) &&
         (MNS_FALSE != cmd_repeat_int) )      /* if a repeat was called by the application, then don't increment the position holders */
    {                                       /* otherwise if a repeat is needed by the Command Interperter alone, then set the repeat flag and increment the position holders */
        CmdRx_RetVal |= CMD_F_RETRIGGER;    /* set the global repeat flag */
        Cmd_FBlock_Tab_Ptr_Holder++;        /* increment it so we start with the next position in the table */
        Cmd_FBlock_Position_Holder --;      /* decrement it so we adjust for are above increment */
80013f68:	30 01       	mov	r1,0

        }while (((byte)0 != Inst_Check) && ((byte)0 != Tab_Counter));       /* repeat until required FBlock.InstID has been found */
                                                                            /* or end of table has been reached */
    }

    if ((INST_ALL == Inst_Rx) ||(FBLOCK_ALL == FBlock_Rx))      /* Application groupcast ? */
80013f6a:	40 2c       	lddsp	r12,sp[0x8]
80013f6c:	58 0c       	cp.w	r12,0
80013f6e:	e0 81 00 88 	brne	8001407e <CmdRxInterpreter+0x23a>
            /* if no FBlocks are found and this was the first time through the table, then not setting Inst_Check to 0 will cause a search for FBlock_Shaddows */
        }
        else  /* otherwise we found a matching FBlock, but we're not done searching the table */
        {
            Cmd_FBlock_Tab_Ptr_Holder  = FBlock_Tab_Ptr;           /* save the current position */
            Cmd_FBlock_Position_Holder = Tab_Counter;              /* save the current Tab_Counter */
80013f72:	30 04       	mov	r4,0
        }
    }



    if ((byte)0 != Inst_Check)                                     /* if corresponding FBlockID.InstID not found */
80013f74:	58 01       	cp.w	r1,0
80013f76:	c9 c0       	breq	80013eae <CmdRxInterpreter+0x6a>
    {
        if (Op_Rx >= OP_REPORTS)                                    /* Unknown FBlock Shadow ? */
80013f78:	30 88       	mov	r8,8
80013f7a:	40 0b       	lddsp	r11,sp[0x0]
80013f7c:	f0 0b 18 00 	cp.b	r11,r8
80013f80:	e0 8b 00 58 	brhi	80014030 <CmdRxInterpreter+0x1ec>
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_5
byte CmdErrorMsg(pTMsgTx Tx_Ptr, byte ErrorID)
{
    Tx_Ptr->Data[0] = ErrorID;
80013f84:	6e 08       	ld.w	r8,r7[0x0]
80013f86:	b0 81       	st.b	r8[0x0],r1
    Tx_Ptr->Length  = (word)1;
80013f88:	30 f9       	mov	r9,15
80013f8a:	30 18       	mov	r8,1
80013f8c:	30 02       	mov	r2,0
80013f8e:	ae 28       	st.h	r7[0x4],r8
    }

    /*------------------------------- */
    /*  Complete Tx Message */
    /*------------------------------- */
    if ( (byte)0 == (Report & CMD_TX_RETAIN) )          /* Flag not set, which signs that tx message will be completed by application ? */
80013f90:	ed b9 00 06 	bld	r9,0x6
80013f94:	e0 81 00 ad 	brne	800140ee <CmdRxInterpreter+0x2aa>
            MsgTxUnused(Tx_Ptr);                    /* Set tx buffer line free since there is no message to send */
        }
    }
    else
    {
        CmdTxFilter((pTMsgTx)NULL, Rx_Ptr);         /* result message not yet. Has been retained by application */
80013f98:	0c 9b       	mov	r11,r6
80013f9a:	30 0c       	mov	r12,0
80013f9c:	fe b0 a0 b9 	rcall	8000810e <CmdTxFilter>
                                                    /*  -> Callback with NULL-Pointer and "rx ptr" */
    }


    if ( ((byte)0    == (CmdRx_RetVal & CMD_F_RETRIGGER)) &&
80013fa0:	30 08       	mov	r8,0
80013fa2:	f0 02 18 00 	cp.b	r2,r8
80013fa6:	c0 e5       	brlt	80013fc2 <CmdRxInterpreter+0x17e>
80013fa8:	58 04       	cp.w	r4,0
80013faa:	c0 c0       	breq	80013fc2 <CmdRxInterpreter+0x17e>
         (MNS_FALSE != cmd_repeat_int) )      /* if a repeat was called by the application, then don't increment the position holders */
    {                                       /* otherwise if a repeat is needed by the Command Interperter alone, then set the repeat flag and increment the position holders */
        CmdRx_RetVal |= CMD_F_RETRIGGER;    /* set the global repeat flag */
        Cmd_FBlock_Tab_Ptr_Holder++;        /* increment it so we start with the next position in the table */
80013fac:	fe f9 02 f0 	ld.w	r9,pc[752]
        Cmd_FBlock_Position_Holder --;      /* decrement it so we adjust for are above increment */
80013fb0:	fe f8 02 f0 	ld.w	r8,pc[752]

    if ( ((byte)0    == (CmdRx_RetVal & CMD_F_RETRIGGER)) &&
         (MNS_FALSE != cmd_repeat_int) )      /* if a repeat was called by the application, then don't increment the position holders */
    {                                       /* otherwise if a repeat is needed by the Command Interperter alone, then set the repeat flag and increment the position holders */
        CmdRx_RetVal |= CMD_F_RETRIGGER;    /* set the global repeat flag */
        Cmd_FBlock_Tab_Ptr_Holder++;        /* increment it so we start with the next position in the table */
80013fb4:	72 0a       	ld.w	r10,r9[0x0]


    if ( ((byte)0    == (CmdRx_RetVal & CMD_F_RETRIGGER)) &&
         (MNS_FALSE != cmd_repeat_int) )      /* if a repeat was called by the application, then don't increment the position holders */
    {                                       /* otherwise if a repeat is needed by the Command Interperter alone, then set the repeat flag and increment the position holders */
        CmdRx_RetVal |= CMD_F_RETRIGGER;    /* set the global repeat flag */
80013fb6:	a7 b2       	sbr	r2,0x7
        Cmd_FBlock_Tab_Ptr_Holder++;        /* increment it so we start with the next position in the table */
80013fb8:	2f 4a       	sub	r10,-12
80013fba:	93 0a       	st.w	r9[0x0],r10
        Cmd_FBlock_Position_Holder --;      /* decrement it so we adjust for are above increment */
80013fbc:	11 89       	ld.ub	r9,r8[0x0]
80013fbe:	20 19       	sub	r9,1
80013fc0:	b0 89       	st.b	r8[0x0],r9
    }

    return(CmdRx_RetVal);
}
80013fc2:	04 9c       	mov	r12,r2
80013fc4:	2f cd       	sub	sp,-16
80013fc6:	d8 32       	popm	r0-r7,pc
    {
        do
        {
            FBlock_Tab = FBlock_Tab_Ptr->FBlock;                            /* read FBlock_ID from table (Romread) */

            if (    ( (FBLOCK_ALL       == FBlock_Rx)                       /* FBLOCK_ALL addresses all FBlocks but not      */
80013fc8:	e8 08 18 00 	cp.b	r8,r4
80013fcc:	cc 40       	breq	80013f54 <CmdRxInterpreter+0x110>
            }

            if (Inst_Check)                                                 /* if FBlock.InstID found not yet */
            {
                FBlock_Tab_Ptr++;
                Tab_Counter--;
80013fce:	f5 de c0 08 	bfextu	r10,lr,0x0,0x8
                }
            }

            if (Inst_Check)                                                 /* if FBlock.InstID found not yet */
            {
                FBlock_Tab_Ptr++;
80013fd2:	2f 49       	sub	r9,-12
                Tab_Counter--;
            }

        }while (((byte)0 != Inst_Check) && ((byte)0 != Tab_Counter));       /* repeat until required FBlock.InstID has been found */
80013fd4:	f6 0a 18 00 	cp.b	r10,r11
80013fd8:	5f 18       	srne	r8
80013fda:	f6 08 18 00 	cp.b	r8,r11
80013fde:	ca b1       	brne	80013f34 <CmdRxInterpreter+0xf0>
80013fe0:	cc 5b       	rjmp	80013f6a <CmdRxInterpreter+0x126>
                    {
                        Tx_Ptr->Inst_ID = *(FBlock_Tab_Ptr->Inst_Tab_Ptr);  /* then prepare own InstID for reponse message, if valid InstID stored in table */
                    }
                    Inst_Check = (byte)0;                                   /* -> FBlock.InstID ok. */
                }
                else if (INST_ALL == Inst_Rx)                               /* otherwise check InstID */
80013fe2:	40 18       	lddsp	r8,sp[0x4]
80013fe4:	58 08       	cp.w	r8,0
80013fe6:	c1 a1       	brne	8001401a <CmdRxInterpreter+0x1d6>

                    Inst_Check = (byte)0;
                }
                else
                {
                    Inst_Tab_Ptr = FBlock_Tab_Ptr->Inst_Tab_Ptr;            /* (Romread) */
80013fe8:	72 18       	ld.w	r8,r9[0x4]

                    if (Inst_Tab_Ptr)
80013fea:	58 08       	cp.w	r8,0
80013fec:	cb e0       	breq	80013f68 <CmdRxInterpreter+0x124>
                    {
                        Inst_Tab = *(Inst_Tab_Ptr);                         /* read Inst_ID from RAM table */
80013fee:	11 88       	ld.ub	r8,r8[0x0]
80013ff0:	e6 08 18 00 	cp.b	r8,r3
80013ff4:	cb a0       	breq	80013f68 <CmdRxInterpreter+0x124>
80013ff6:	30 21       	mov	r1,2
80013ff8:	ce bb       	rjmp	80013fce <CmdRxInterpreter+0x18a>
            }
        }   /* if 'error message' */

        if (Report && ( (Op_Rx<OP_REPORTS)||(Report&CMD_PASS) ) )   /* Send message (answer, result, error or message passed on) */
        {                                                           /* but no error report on a report message */
            Tx_Ptr->Operation   = Report & (byte)0xF;             /* Forget about Flags (bits 4..7) */
80013ffa:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4

            CmdAutoInsertSenderHandlePtr(Tx_Ptr, Rx_Ptr);           /* insert sender handle automatically if necessary */
80013ffe:	0c 9b       	mov	r11,r6
80014000:	0e 9c       	mov	r12,r7
            }
        }   /* if 'error message' */

        if (Report && ( (Op_Rx<OP_REPORTS)||(Report&CMD_PASS) ) )   /* Send message (answer, result, error or message passed on) */
        {                                                           /* but no error report on a report message */
            Tx_Ptr->Operation   = Report & (byte)0xF;             /* Forget about Flags (bits 4..7) */
80014002:	ef 69 00 0c 	st.b	r7[12],r9

            CmdAutoInsertSenderHandlePtr(Tx_Ptr, Rx_Ptr);           /* insert sender handle automatically if necessary */
80014006:	c4 7e       	rcall	80013c94 <CmdAutoInsertSenderHandlePtr>
80014008:	0c 9b       	mov	r11,r6

            if ( CmdTxFilter(Tx_Ptr, Rx_Ptr) )       /* Callback to view result message */
8001400a:	0e 9c       	mov	r12,r7
8001400c:	fe b0 a0 81 	rcall	8000810e <CmdTxFilter>
80014010:	c8 10       	breq	80013f12 <CmdRxInterpreter+0xce>
80014012:	0e 9c       	mov	r12,r7
            {
                AmsMsgSend(Tx_Ptr);
80014014:	fe b0 ac b0 	rcall	80009974 <MsgSend>
80014018:	cc 4b       	rjmp	80013fa0 <CmdRxInterpreter+0x15c>
8001401a:	72 18       	ld.w	r8,r9[0x4]
                    Inst_Check = (byte)0;                                   /* -> FBlock.InstID ok. */
                }
                else if (INST_ALL == Inst_Rx)                               /* otherwise check InstID */
                /* if InstID is 0xFF and the FBlockID already checks out then save the correct InstID in Tx_Ptr and set Inst_Check to 0 to leave the loop */
                {
                    if (FBlock_Tab_Ptr->Inst_Tab_Ptr)
8001401c:	58 08       	cp.w	r8,0
8001401e:	ca 21       	brne	80013f62 <CmdRxInterpreter+0x11e>
80014020:	13 8c       	ld.ub	r12,r9[0x0]
                    {
                        Tx_Ptr->Inst_ID = *(FBlock_Tab_Ptr->Inst_Tab_Ptr);
                    }
                    else if (FBlock_Tab_Ptr->FBlock != FBLOCK_NETBLOCK)
80014022:	30 1b       	mov	r11,1
80014024:	f6 0c 18 00 	cp.b	r12,r11
80014028:	ca 00       	breq	80013f68 <CmdRxInterpreter+0x124>
8001402a:	ef 68 00 0b 	st.b	r7[11],r8
                    {
                        Tx_Ptr->Inst_ID = (byte)0x00;                       /* Set InstID (TX) to zero, but only when FBlockID not ID of NetBlock */
8001402e:	c9 db       	rjmp	80013f68 <CmdRxInterpreter+0x124>
80014030:	0c 9b       	mov	r11,r6

    if ((byte)0 != Inst_Check)                                     /* if corresponding FBlockID.InstID not found */
    {
        if (Op_Rx >= OP_REPORTS)                                    /* Unknown FBlock Shadow ? */
        {                                                           /* --> Call Application and get result */
            Report = CmdUnknownFBlockShadow(Tx_Ptr, Rx_Ptr);
80014032:	0e 9c       	mov	r12,r7
80014034:	fe b0 a2 90 	rcall	80008554 <CmdUnknownFBlockShadow>
80014038:	18 99       	mov	r9,r12

            CmdRx_RetVal |= (byte)(Report & CMD_F_MASK);                          /* save  CMD_RX_RETAIN and CMD_RX_REPEAT flag */
            Report &= (byte)(~CMD_F_MASK);                                          /* clear CMD_RX_RETAIN and CMD_RX_REPEAT flag */
8001403a:	18 92       	mov	r2,r12
    {
        if (Op_Rx >= OP_REPORTS)                                    /* Unknown FBlock Shadow ? */
        {                                                           /* --> Call Application and get result */
            Report = CmdUnknownFBlockShadow(Tx_Ptr, Rx_Ptr);

            CmdRx_RetVal |= (byte)(Report & CMD_F_MASK);                          /* save  CMD_RX_RETAIN and CMD_RX_REPEAT flag */
8001403c:	e2 19 00 5f 	andl	r9,0x5f,COH
            Report &= (byte)(~CMD_F_MASK);                                          /* clear CMD_RX_RETAIN and CMD_RX_REPEAT flag */
80014040:	e2 12 00 a0 	andl	r2,0xa0,COH
    {
        if (Op_Rx >= OP_REPORTS)                                    /* Unknown FBlock Shadow ? */
        {                                                           /* --> Call Application and get result */
            Report = CmdUnknownFBlockShadow(Tx_Ptr, Rx_Ptr);

            CmdRx_RetVal |= (byte)(Report & CMD_F_MASK);                          /* save  CMD_RX_RETAIN and CMD_RX_REPEAT flag */
80014044:	58 09       	cp.w	r9,0
            Report &= (byte)(~CMD_F_MASK);                                          /* clear CMD_RX_RETAIN and CMD_RX_REPEAT flag */


            if ((byte)0 == Report )
80014046:	ca 51       	brne	80013f90 <CmdRxInterpreter+0x14c>
80014048:	0e 9c       	mov	r12,r7
            {
                MsgTxUnused(Tx_Ptr);                                        /* Set tx buffer line free since there is no message to send */
8001404a:	fe b0 a7 75 	rcall	80008f34 <MsgTxUnused>
8001404e:	cb ab       	rjmp	80013fc2 <CmdRxInterpreter+0x17e>
                return(CmdRx_RetVal);
80014050:	10 9a       	mov	r10,r8
    {
        if ( (Report & (byte)0xF) == OP_ERROR)          /* Is the response an error message ? */
        {
            if (!(Report & CMD_PASS))                   /* Avoid all error message on following conditions, but only if not passed through: */
            {
                if (   (MSG_RCV_TYPE_BROADCAST == Rx_Ptr->Rcv_Type)     /* BroadcastMessage ? */
80014052:	ed 3b 00 0d 	ld.ub	r11,r6[13]
80014056:	30 18       	mov	r8,1
80014058:	20 2b       	sub	r11,2
8001405a:	f0 0b 18 00 	cp.b	r11,r8
8001405e:	f9 b8 0b 00 	movhi	r8,0
80014062:	eb e8 10 08 	or	r8,r5,r8
80014066:	f4 08 18 00 	cp.b	r8,r10
8001406a:	fe 91 ff 4d 	brne	80013f04 <CmdRxInterpreter+0xc0>
8001406e:	40 1b       	lddsp	r11,sp[0x4]
80014070:	58 0b       	cp.w	r11,0
80014072:	fe 91 ff 49 	brne	80013f04 <CmdRxInterpreter+0xc0>
80014076:	58 09       	cp.w	r9,0
                    Report = OP_NO_REPORT;
                }
            }
        }   /* if 'error message' */

        if (Report && ( (Op_Rx<OP_REPORTS)||(Report&CMD_PASS) ) )   /* Send message (answer, result, error or message passed on) */
80014078:	fe 91 ff 3d 	brne	80013ef2 <CmdRxInterpreter+0xae>
8001407c:	c4 4b       	rjmp	80013f04 <CmdRxInterpreter+0xc0>
8001407e:	58 0a       	cp.w	r10,0
                                                                            /* or end of table has been reached */
    }

    if ((INST_ALL == Inst_Rx) ||(FBLOCK_ALL == FBlock_Rx))      /* Application groupcast ? */
    {
        if ((byte)0 == Tab_Counter)                 /* this indicates that we finished searching the FBlock table without finding the sought FBlock */
80014080:	c0 e0       	breq	8001409c <CmdRxInterpreter+0x258>
80014082:	fe f8 02 1a 	ld.w	r8,pc[538]
            }
            /* if no FBlocks are found and this was the first time through the table, then not setting Inst_Check to 0 will cause a search for FBlock_Shaddows */
        }
        else  /* otherwise we found a matching FBlock, but we're not done searching the table */
        {
            Cmd_FBlock_Tab_Ptr_Holder  = FBlock_Tab_Ptr;           /* save the current position */
80014086:	30 14       	mov	r4,1
            Cmd_FBlock_Position_Holder = Tab_Counter;              /* save the current Tab_Counter */
80014088:	91 09       	st.w	r8[0x0],r9
            }
            /* if no FBlocks are found and this was the first time through the table, then not setting Inst_Check to 0 will cause a search for FBlock_Shaddows */
        }
        else  /* otherwise we found a matching FBlock, but we're not done searching the table */
        {
            Cmd_FBlock_Tab_Ptr_Holder  = FBlock_Tab_Ptr;           /* save the current position */
8001408a:	fe f8 02 16 	ld.w	r8,pc[534]
            Cmd_FBlock_Position_Holder = Tab_Counter;              /* save the current Tab_Counter */
8001408e:	b0 8a       	st.b	r8[0x0],r10
80014090:	c7 2b       	rjmp	80013f74 <CmdRxInterpreter+0x130>
80014092:	fe b0 ec 35 	rcall	800118fc <MostGetNodePos>
    Tx_Ptr->FBlock_ID   = FBlock_Rx;
    Tx_Ptr->Func_ID     = Func_Rx;

    if (FBLOCK_NETBLOCK == FBlock_Rx)                                   /* InstID of FBlock NetBlock */
    {
        Tx_Ptr->Inst_ID = MOST_GET_NODE_POS();                          /* has to be the NodePosition */
80014096:	ef 6c 00 0b 	st.b	r7[11],r12
8001409a:	ce fa       	rjmp	80013e78 <CmdRxInterpreter+0x34>
8001409c:	fe f8 02 04 	ld.w	r8,pc[516]

    if ((INST_ALL == Inst_Rx) ||(FBLOCK_ALL == FBlock_Rx))      /* Application groupcast ? */
    {
        if ((byte)0 == Tab_Counter)                 /* this indicates that we finished searching the FBlock table without finding the sought FBlock */
        {
            Cmd_FBlock_Position_Holder = (byte)0;   /* so Cmd_FBlock_Position_Holder needs to be reset to 0 */
800140a0:	b0 8a       	st.b	r8[0x0],r10
800140a2:	4f f8       	lddpc	r8,8001429c <CmdRxInterpreter+0x458>
            if (NULL != Cmd_FBlock_Tab_Ptr_Holder)  /* if Cmd_FBlock_Tab_Ptr_Holder is not NULL then we found a matching FBlock on a previous run of the CmdRxInterpreter */
800140a4:	70 0a       	ld.w	r10,r8[0x0]
800140a6:	58 0a       	cp.w	r10,0
800140a8:	fe 90 ff 65 	breq	80013f72 <CmdRxInterpreter+0x12e>
800140ac:	cf da       	rjmp	80013ea6 <CmdRxInterpreter+0x62>
800140ae:	70 13       	ld.w	r3,r8[0x4]

        if ((byte)0 == Report)                                              /* if no error occurred */
        {
            Func_Tab_Ptr--;

            Op_Tab_Ptr = Func_Tab_Ptr->Op_Tab_Ptr;                          /* read pointer on Operation-Type table (Romread) */
800140b0:	3f fa       	mov	r10,-1
            {
                Op_Tab = Op_Tab_Ptr->Operation;                             /* read Operation-Type from table (Romread) */

                Op_Tab_Ptr++;

                if (OP_TERMINATION == Op_Tab)                               /* end of table ? */
800140b2:	30 0b       	mov	r11,0
                {
                    (void)CmdErrorByte(Tx_Ptr, ERR_OPTYPE, Op_Rx);          /* OpType not found */
                    Report = OP_ERROR;
                }

            }while ((Op_Tab != Op_Rx) && ((byte)0 == Report));              /* repeat until required OpType has been found */
800140b4:	40 0c       	lddsp	r12,sp[0x0]
800140b6:	07 88       	ld.ub	r8,r3[0x0]
            /*------------------------ */
            /*   Check: Operation Type */
            /*------------------------ */
            do
            {
                Op_Tab = Op_Tab_Ptr->Operation;                             /* read Operation-Type from table (Romread) */
800140b8:	e6 c9 ff f0 	sub	r9,r3,-16

                Op_Tab_Ptr++;
800140bc:	f4 08 18 00 	cp.b	r8,r10

                if (OP_TERMINATION == Op_Tab)                               /* end of table ? */
800140c0:	c0 e0       	breq	800140dc <CmdRxInterpreter+0x298>
800140c2:	f8 08 18 00 	cp.b	r8,r12
                {
                    (void)CmdErrorByte(Tx_Ptr, ERR_OPTYPE, Op_Rx);          /* OpType not found */
                    Report = OP_ERROR;
                }

            }while ((Op_Tab != Op_Rx) && ((byte)0 == Report));              /* repeat until required OpType has been found */
800140c6:	5f 18       	srne	r8
800140c8:	f6 08 18 00 	cp.b	r8,r11
800140cc:	c1 60       	breq	800140f8 <CmdRxInterpreter+0x2b4>
800140ce:	12 93       	mov	r3,r9
800140d0:	07 88       	ld.ub	r8,r3[0x0]
            /*------------------------ */
            /*   Check: Operation Type */
            /*------------------------ */
            do
            {
                Op_Tab = Op_Tab_Ptr->Operation;                             /* read Operation-Type from table (Romread) */
800140d2:	e6 c9 ff f0 	sub	r9,r3,-16

                Op_Tab_Ptr++;
800140d6:	f4 08 18 00 	cp.b	r8,r10

                if (OP_TERMINATION == Op_Tab)                               /* end of table ? */
800140da:	cf 41       	brne	800140c2 <CmdRxInterpreter+0x27e>
800140dc:	6e 08       	ld.w	r8,r7[0x0]
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_6
byte CmdErrorByte(pTMsgTx Tx_Ptr, byte ErrorID, byte param)
{
    Tx_Ptr->Data[0] = ErrorID;
800140de:	30 49       	mov	r9,4
800140e0:	b0 89       	st.b	r8[0x0],r9
800140e2:	6e 08       	ld.w	r8,r7[0x0]
    Tx_Ptr->Data[1] = param;
800140e4:	40 0a       	lddsp	r10,sp[0x0]
800140e6:	b0 9a       	st.b	r8[0x1],r10
800140e8:	30 28       	mov	r8,2
    Tx_Ptr->Length  = (word)2;
800140ea:	ae 28       	st.h	r7[0x4],r8
800140ec:	cf ca       	rjmp	80013ee4 <CmdRxInterpreter+0xa0>
800140ee:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
    /*------------------------------- */
    /*  Complete Tx Message */
    /*------------------------------- */
    if ( (byte)0 == (Report & CMD_TX_RETAIN) )          /* Flag not set, which signs that tx message will be completed by application ? */
    {
        if ( (Report & (byte)0xF) == OP_ERROR)          /* Is the response an error message ? */
800140f2:	58 f8       	cp.w	r8,15
800140f4:	cc 11       	brne	80014076 <CmdRxInterpreter+0x232>
800140f6:	cf 9a       	rjmp	80013ee8 <CmdRxInterpreter+0xa4>
800140f8:	e7 38 00 0c 	ld.ub	r8,r3[12]
            #ifdef CMD_ADD8
            if ((byte)0 == Report)                                          /* if no error occurred */
            {
                Op_Tab_Ptr--;

                lcFlags = (Op_Tab_Ptr->LengthCheck) >> LC_SHIFT;            /* read flags from table (Romread) */
800140fc:	30 2a       	mov	r10,2
                lcValue = (Op_Tab_Ptr->LengthCheck) &  LC_MASK;

                switch (lcFlags)
800140fe:	f0 09 16 06 	lsr	r9,r8,0x6
80014102:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
            if ((byte)0 == Report)                                          /* if no error occurred */
            {
                Op_Tab_Ptr--;

                lcFlags = (Op_Tab_Ptr->LengthCheck) >> LC_SHIFT;            /* read flags from table (Romread) */
                lcValue = (Op_Tab_Ptr->LengthCheck) &  LC_MASK;
80014106:	f4 09 18 00 	cp.b	r9,r10

                switch (lcFlags)
8001410a:	c4 10       	breq	8001418c <CmdRxInterpreter+0x348>
8001410c:	30 3a       	mov	r10,3
8001410e:	f4 09 18 00 	cp.b	r9,r10
80014112:	c3 80       	breq	80014182 <CmdRxInterpreter+0x33e>
80014114:	30 1a       	mov	r10,1
80014116:	f4 09 18 00 	cp.b	r9,r10
8001411a:	c2 a0       	breq	8001416e <CmdRxInterpreter+0x32a>
8001411c:	07 91       	ld.ub	r1,r3[0x1]
            {
                #ifndef CMD_ADD8
                Op_Tab_Ptr--;
                #endif

                Flags = Op_Tab_Ptr->Flags;                                  /* read flags from table (Romread) */
8001411e:	02 90       	mov	r0,r1

                /*------------------------------- */
                /*   Set Property / Start Method */
                /*------------------------------- */
                if (Flags & OP_W_MASK)                                      /* write access required ? */
80014120:	e2 10 00 f0 	andl	r0,0xf0,COH
80014124:	c1 91       	brne	80014156 <CmdRxInterpreter+0x312>
80014126:	00 99       	mov	r9,r0
80014128:	00 92       	mov	r2,r0
8001412a:	3e f8       	mov	r8,-17


                /*--------------------------------------- */
                /*   Report Property / Result / Interface */
                /*--------------------------------------- */
                if (Flags >= OP_W_MHP_EXT)                   /* Does Flags sign a Mhp entry ? */
8001412c:	f0 01 18 00 	cp.b	r1,r8
80014130:	fe 9b ff 30 	brhi	80013f90 <CmdRxInterpreter+0x14c>
80014134:	58 09       	cp.w	r9,0
                    /* The message is therefore not serviced correctly.  */
                    /* If MHP entries are used in the Operation Tables of the CMD module, */
                    /* the respective interface (NS_CMD_MHP) must be enabled ! */
                    #endif
                }
                else if (((byte)0 == Report) && (Flags & OP_R_MASK) )    /* if no error occurred and reading access required */
80014136:	fe 91 ff 2d 	brne	80013f90 <CmdRxInterpreter+0x14c>
8001413a:	e3 d1 c0 04 	bfextu	r1,r1,0x0,0x4
8001413e:	fe 90 fe e3 	breq	80013f04 <CmdRxInterpreter+0xc0>
80014142:	66 28       	ld.w	r8,r3[0x8]
                    }
                    if ((byte)0 == Report)
                    #endif
                    {
                        #ifndef PTR_UNION_VOID
                        Read_Ptr_Tab = Op_Tab_Ptr->Read_Ptr;                        /* read pointer for read access (Romread) */
80014144:	20 11       	sub	r1,1
                        #endif

                        switch (Flags & OP_R_MASK)                                  /* switch by kind of reading access */
80014146:	58 61       	cp.w	r1,6
80014148:	e0 88 00 4e 	brls	800141e4 <CmdRxInterpreter+0x3a0>
8001414c:	12 98       	mov	r8,r9
8001414e:	00 48       	or	r8,r0
                                Report = OP_INTERFACE;
                                break;

                        }  /* switch (Flags & OP_R_MASK) */

                        CmdRx_RetVal |= (byte)(Report & CMD_F_MASK);                      /* save  CMD_RX_RETAIN and CMD_RX_REPEAT flag */
80014150:	e5 d8 c0 08 	bfextu	r2,r8,0x0,0x8
80014154:	c1 eb       	rjmp	80013f90 <CmdRxInterpreter+0x14c>
80014156:	66 18       	ld.w	r8,r3[0x4]
                /*   Set Property / Start Method */
                /*------------------------------- */
                if (Flags & OP_W_MASK)                                      /* write access required ? */
                {
                    #ifndef PTR_UNION_VOID
                    Write_Ptr_Tab = Op_Tab_Ptr->Write_Ptr;                          /* read pointer for write access (Romread) */
80014158:	e0 40 00 50 	cp.w	r0,80

                    #ifdef CMD_LEN_CHECK_ZERO
                    check_len = MNS_FALSE;                                              /* perform no length check */
                    #endif

                    switch (Flags & OP_W_MASK)                                      /* switch by kind of function call */
8001415c:	c2 f0       	breq	800141ba <CmdRxInterpreter+0x376>
8001415e:	e0 89 00 1d 	brgt	80014198 <CmdRxInterpreter+0x354>
80014162:	59 00       	cp.w	r0,16
80014164:	c3 70       	breq	800141d2 <CmdRxInterpreter+0x38e>
80014166:	30 09       	mov	r9,0
80014168:	12 92       	mov	r2,r9
8001416a:	04 90       	mov	r0,r2
                        case OP_W_IND_TX:                                           /* individual function, parameter: Tx_Ptr */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(pTMsgTx)) Op_Tab_Ptr->Write.FPtr ) (Tx_Ptr);
                            #else
                            Report = ( *(byte(*)(pTMsgTx)) Write_Ptr_Tab ) (Tx_Ptr);
8001416c:	cd fb       	rjmp	8001412a <CmdRxInterpreter+0x2e6>
8001416e:	40 39       	lddsp	r9,sp[0xc]
                lcValue = (Op_Tab_Ptr->LengthCheck) &  LC_MASK;

                switch (lcFlags)
                {
                    case CMD_LEN_EQ:                                        /* equal */
                        if (Len_Rx != lcValue)
80014170:	f2 08 19 00 	cp.h	r8,r9
80014174:	cd 40       	breq	8001411c <CmdRxInterpreter+0x2d8>
80014176:	6e 08       	ld.w	r8,r7[0x0]
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_5
byte CmdErrorMsg(pTMsgTx Tx_Ptr, byte ErrorID)
{
    Tx_Ptr->Data[0] = ErrorID;
80014178:	30 59       	mov	r9,5
8001417a:	b0 89       	st.b	r8[0x0],r9
8001417c:	30 18       	mov	r8,1
    Tx_Ptr->Length  = (word)1;
8001417e:	ae 28       	st.h	r7[0x4],r8
80014180:	cb 2a       	rjmp	80013ee4 <CmdRxInterpreter+0xa0>
80014182:	40 3b       	lddsp	r11,sp[0xc]
                            Report = OP_ERROR;
                        }
                        break;

                    case CMD_LEN_GE:                                        /* less or equal */
                        if (Len_Rx < lcValue)
80014184:	f0 0b 19 00 	cp.h	r11,r8
80014188:	cf 73       	brcs	80014176 <CmdRxInterpreter+0x332>
8001418a:	cc 9b       	rjmp	8001411c <CmdRxInterpreter+0x2d8>
8001418c:	40 3c       	lddsp	r12,sp[0xc]
                            Report = OP_ERROR;
                        }
                        break;

                    case CMD_LEN_LE:                                        /* less or equal */
                        if (Len_Rx > lcValue)
8001418e:	f0 0c 19 00 	cp.h	r12,r8
80014192:	fe 9b ff f2 	brhi	80014176 <CmdRxInterpreter+0x332>
80014196:	cc 3b       	rjmp	8001411c <CmdRxInterpreter+0x2d8>
80014198:	e0 40 00 90 	cp.w	r0,144

                    #ifdef CMD_LEN_CHECK_ZERO
                    check_len = MNS_FALSE;                                              /* perform no length check */
                    #endif

                    switch (Flags & OP_W_MASK)                                      /* switch by kind of function call */
8001419c:	c1 90       	breq	800141ce <CmdRxInterpreter+0x38a>
8001419e:	e0 40 00 d0 	cp.w	r0,208
800141a2:	ce 21       	brne	80014166 <CmdRxInterpreter+0x322>
800141a4:	0c 9b       	mov	r11,r6
                        case OP_W_IND_TXRX:                                         /* individual function, parameters: Tx_Ptr, Rx_Ptr */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(pTMsgTx, pTMsgRx)) Op_Tab_Ptr->Write.FPtr ) (Tx_Ptr, Rx_Ptr);
                            #else
                            Report = ( *(byte(*)(pTMsgTx, pTMsgRx)) Write_Ptr_Tab ) (Tx_Ptr, Rx_Ptr);
800141a6:	0e 9c       	mov	r12,r7
800141a8:	5d 18       	icall	r8
800141aa:	18 99       	mov	r9,r12
800141ac:	18 92       	mov	r2,r12
800141ae:	e2 19 00 5f 	andl	r9,0x5f,COH
800141b2:	e2 12 00 a0 	andl	r2,0xa0,COH
800141b6:	04 90       	mov	r0,r2
                        case OP_W_IND_TX:                                           /* individual function, parameter: Tx_Ptr */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(pTMsgTx)) Op_Tab_Ptr->Write.FPtr ) (Tx_Ptr);
                            #else
                            Report = ( *(byte(*)(pTMsgTx)) Write_Ptr_Tab ) (Tx_Ptr);
800141b8:	cb 9b       	rjmp	8001412a <CmdRxInterpreter+0x2e6>
800141ba:	0c 9c       	mov	r12,r6
                        case OP_W_IND_RX:                                           /* individual function, parameter: Rx_Ptr */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(pTMsgRx)) Op_Tab_Ptr->Write.FPtr ) (Rx_Ptr);
                            #else
                            Report = ( *(byte(*)(pTMsgRx)) Write_Ptr_Tab ) (Rx_Ptr);
800141bc:	5d 18       	icall	r8
                        case OP_W_IND_TX:                                           /* individual function, parameter: Tx_Ptr */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(pTMsgTx)) Op_Tab_Ptr->Write.FPtr ) (Tx_Ptr);
                            #else
                            Report = ( *(byte(*)(pTMsgTx)) Write_Ptr_Tab ) (Tx_Ptr);
800141be:	18 99       	mov	r9,r12
800141c0:	18 92       	mov	r2,r12
800141c2:	e2 19 00 5f 	andl	r9,0x5f,COH
800141c6:	e2 12 00 a0 	andl	r2,0xa0,COH
800141ca:	04 90       	mov	r0,r2
800141cc:	ca fb       	rjmp	8001412a <CmdRxInterpreter+0x2e6>
800141ce:	0e 9c       	mov	r12,r7
800141d0:	cf 6b       	rjmp	800141bc <CmdRxInterpreter+0x378>
800141d2:	5d 18       	icall	r8
                        case OP_W_IND_NONE:                                         /* individual function, parameter: none */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(void)) Op_Tab_Ptr->Write.FPtr ) ();
                            #else
                            Report = ( *(byte(*)(void)) Write_Ptr_Tab ) ();
800141d4:	18 99       	mov	r9,r12
800141d6:	18 92       	mov	r2,r12
800141d8:	e2 19 00 5f 	andl	r9,0x5f,COH
800141dc:	e2 12 00 a0 	andl	r2,0xa0,COH
800141e0:	04 90       	mov	r0,r2
                        case OP_W_IND_TX:                                           /* individual function, parameter: Tx_Ptr */

                            #ifdef PTR_UNION_VOID
                            Report = ( *(byte(*)(pTMsgTx)) Op_Tab_Ptr->Write.FPtr ) (Tx_Ptr);
                            #else
                            Report = ( *(byte(*)(pTMsgTx)) Write_Ptr_Tab ) (Tx_Ptr);
800141e2:	ca 4b       	rjmp	8001412a <CmdRxInterpreter+0x2e6>
800141e4:	4b 19       	lddpc	r9,800142a8 <CmdRxInterpreter+0x464>
                    {
                        #ifndef PTR_UNION_VOID
                        Read_Ptr_Tab = Op_Tab_Ptr->Read_Ptr;                        /* read pointer for read access (Romread) */
                        #endif

                        switch (Flags & OP_R_MASK)                                  /* switch by kind of reading access */
800141e6:	f2 01 03 2f 	ld.w	pc,r9[r1<<0x2]
800141ea:	11 89       	ld.ub	r9,r8[0x0]
                            case OP_R_BOOL:                                         /* read access on Bool type */

                                #ifdef PTR_UNION_VOID
                                Tx_Ptr->Data[0] = (byte)(*(bool*)Op_Tab_Ptr->Read.DPtr);
                                #else
                                Tx_Ptr->Data[0] = (byte)(*(bool*)Read_Ptr_Tab);
800141ec:	6e 08       	ld.w	r8,r7[0x0]
800141ee:	b0 89       	st.b	r8[0x0],r9
800141f0:	30 18       	mov	r8,1
                                #endif
                                Tx_Ptr->Length  = (word)1;
800141f2:	30 c9       	mov	r9,12
800141f4:	ae 28       	st.h	r7[0x4],r8
800141f6:	30 08       	mov	r8,0
800141f8:	ca bb       	rjmp	8001414e <CmdRxInterpreter+0x30a>
                                Report          = OP_STATUS;
                                break;
800141fa:	0c 9b       	mov	r11,r6
                            case OP_R_IND_TXRX:                                     /* individual function, parameters: Tx_Ptr, Rx_Ptr */

                                #ifdef PTR_UNION_VOID
                                Report = ( *(byte(*)(pTMsgTx, pTMsgRx)) Op_Tab_Ptr->Read.FPtr ) (Tx_Ptr, Rx_Ptr);
                                #else
                                Report = ( *(byte(*)(pTMsgTx, pTMsgRx)) Read_Ptr_Tab ) (Tx_Ptr, Rx_Ptr);
800141fc:	0e 9c       	mov	r12,r7
800141fe:	5d 18       	icall	r8
80014200:	18 99       	mov	r9,r12
80014202:	18 98       	mov	r8,r12
80014204:	e2 19 00 5f 	andl	r9,0x5f,COH
80014208:	e2 18 00 a0 	andl	r8,0xa0,COH
8001420c:	ca 1b       	rjmp	8001414e <CmdRxInterpreter+0x30a>
                                #endif
                                break;
8001420e:	0e 9c       	mov	r12,r7
                            case OP_R_IND_TX:                                       /* individual function, parameter: Tx_Ptr */

                                #ifdef PTR_UNION_VOID
                                Report = ( *(byte(*)(pTMsgTx)) Op_Tab_Ptr->Read.FPtr ) (Tx_Ptr);
                                #else
                                Report = ( *(byte(*)(pTMsgTx)) Read_Ptr_Tab ) (Tx_Ptr);
80014210:	5d 18       	icall	r8
80014212:	18 99       	mov	r9,r12
80014214:	18 98       	mov	r8,r12
80014216:	e2 19 00 5f 	andl	r9,0x5f,COH
8001421a:	e2 18 00 a0 	andl	r8,0xa0,COH
8001421e:	c9 8b       	rjmp	8001414e <CmdRxInterpreter+0x30a>
                                #endif
                                break;
80014220:	f1 2a 00 00 	ld.sb	r10,r8[0]
    byte *DestPtr;
    word Length;


    Length = (word)*SrcPtr++;           /* Length HB (Romread) */
    Length = (word)(Length << 8);
80014224:	10 99       	mov	r9,r8
{
    byte *DestPtr;
    word Length;


    Length = (word)*SrcPtr++;           /* Length HB (Romread) */
80014226:	a9 6a       	lsl	r10,0x8
    Length = (word)(Length << 8);
80014228:	2f f9       	sub	r9,-1
8001422a:	13 8c       	ld.ub	r12,r9[0x0]
    Length += (word)*SrcPtr++;          /* Length LB */
8001422c:	14 0c       	add	r12,r10
8001422e:	5c 8c       	casts.h	r12
80014230:	ae 2c       	st.h	r7[0x4],r12


    Tx_Ptr->Length = (word)Length;
80014232:	6e 0a       	ld.w	r10,r7[0x0]
    DestPtr = &Tx_Ptr->Data[0];
80014234:	c0 c0       	breq	8001424c <CmdRxInterpreter+0x408>


    while (Length)
80014236:	2f d8       	sub	r8,-3
/*                          0x01: Retrigger forced, since tx buffer         */
/*                                required but not free                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_2
byte CmdRxInterpreter(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
80014238:	f8 cb 00 01 	sub	r11,r12,1
8001423c:	2f f9       	sub	r9,-1
    word Length;


    Length = (word)*SrcPtr++;           /* Length HB (Romread) */
    Length = (word)(Length << 8);
    Length += (word)*SrcPtr++;          /* Length LB */
8001423e:	5c 7b       	castu.h	r11
/*                          0x01: Retrigger forced, since tx buffer         */
/*                                required but not free                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_2
byte CmdRxInterpreter(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
80014240:	f0 0b 00 0b 	add	r11,r8,r11
80014244:	13 38       	ld.ub	r8,r9++
    DestPtr = &Tx_Ptr->Data[0];


    while (Length)
    {
        *DestPtr++ = *SrcPtr++;         /* (Romread) */
80014246:	14 c8       	st.b	r10++,r8
80014248:	16 39       	cp.w	r9,r11

    Tx_Ptr->Length = (word)Length;
    DestPtr = &Tx_Ptr->Data[0];


    while (Length)
8001424a:	cf d1       	brne	80014244 <CmdRxInterpreter+0x400>
8001424c:	30 e9       	mov	r9,14
8001424e:	30 08       	mov	r8,0
80014250:	c7 fb       	rjmp	8001414e <CmdRxInterpreter+0x30a>
80014252:	11 8a       	ld.ub	r10,r8[0x0]
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
80014254:	6e 09       	ld.w	r9,r7[0x0]
                            case OP_R_WORD:                                         /* read access on Word type */

                                #ifdef PTR_UNION_VOID
                                CmdEncodeWord(&Tx_Ptr->Data[0], (word *)Op_Tab_Ptr->Read.DPtr);
                                #else
                                CmdEncodeWord(&Tx_Ptr->Data[0], (word *)Read_Ptr_Tab);
80014256:	b2 8a       	st.b	r9[0x0],r10
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
80014258:	90 08       	ld.sh	r8,r8[0x0]
    *ptr_tgt    = (byte)(*ptr_src & (word)0xFF);    /* prepare LB */
8001425a:	b2 98       	st.b	r9[0x1],r8
8001425c:	30 28       	mov	r8,2
                                #ifdef PTR_UNION_VOID
                                CmdEncodeWord(&Tx_Ptr->Data[0], (word *)Op_Tab_Ptr->Read.DPtr);
                                #else
                                CmdEncodeWord(&Tx_Ptr->Data[0], (word *)Read_Ptr_Tab);
                                #endif
                                Tx_Ptr->Length  = (word)2;
8001425e:	30 c9       	mov	r9,12
80014260:	ae 28       	st.h	r7[0x4],r8
80014262:	30 08       	mov	r8,0
80014264:	c7 5b       	rjmp	8001414e <CmdRxInterpreter+0x30a>
                                Report          = OP_STATUS;
                                break;
80014266:	6e 0c       	ld.w	r12,r7[0x0]
                            case OP_R_LONG:                                         /* read access on DWord type */

                                #ifdef PTR_UNION_VOID
                                CmdEncodeLong(&Tx_Ptr->Data[0], (dword *)Op_Tab_Ptr->Read.DPtr);
                                #else
                                CmdEncodeLong(&Tx_Ptr->Data[0], (dword *)Read_Ptr_Tab);
80014268:	70 0a       	ld.w	r10,r8[0x0]
    word  high_part;
    word  low_part;
    dword help;
    byte i;

    help = *ptr_src;
8001426a:	30 09       	mov	r9,0
8001426c:	31 0b       	mov	r11,16

    for (i=(byte)0;i<(byte)16;i++)
8001426e:	2f f9       	sub	r9,-1
80014270:	a1 9a       	lsr	r10,0x1
    {
        help = help >> 1;
80014272:	5c 59       	castu.b	r9
    dword help;
    byte i;

    help = *ptr_src;

    for (i=(byte)0;i<(byte)16;i++)
80014274:	f6 09 18 00 	cp.b	r9,r11
80014278:	cf b1       	brne	8001426e <CmdRxInterpreter+0x42a>
8001427a:	5c 8a       	casts.h	r10
    {
        help = help >> 1;
    }
    high_part = (word)help;
8001427c:	b8 9a       	st.b	r12[0x1],r10
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
    *ptr_tgt    = (byte)(*ptr_src & (word)0xFF);    /* prepare LB */
8001427e:	f5 da c1 08 	bfextu	r10,r10,0x8,0x8
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
80014282:	b8 8a       	st.b	r12[0x0],r10
80014284:	2f ec       	sub	r12,-2
    }
    high_part = (word)help;

    CmdEncodeWord(ptr_tgt,&high_part);

    ptr_tgt += 2;
80014286:	90 18       	ld.sh	r8,r8[0x2]
    low_part = (word)(*ptr_src);
80014288:	b8 98       	st.b	r12[0x1],r8
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
    *ptr_tgt    = (byte)(*ptr_src & (word)0xFF);    /* prepare LB */
8001428a:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef CMD_3
void CmdEncodeWord(byte *ptr_tgt, word *ptr_src)
{
    *ptr_tgt++  = (byte)(*ptr_src >> 8);            /* prepare HB */
8001428e:	b8 88       	st.b	r12[0x0],r8
80014290:	30 48       	mov	r8,4
                                #ifdef PTR_UNION_VOID
                                CmdEncodeLong(&Tx_Ptr->Data[0], (dword *)Op_Tab_Ptr->Read.DPtr);
                                #else
                                CmdEncodeLong(&Tx_Ptr->Data[0], (dword *)Read_Ptr_Tab);
                                #endif
                                Tx_Ptr->Length  = (word)4;
80014292:	30 c9       	mov	r9,12
80014294:	ae 28       	st.h	r7[0x4],r8
80014296:	30 08       	mov	r8,0
80014298:	c5 bb       	rjmp	8001414e <CmdRxInterpreter+0x30a>
                                Report          = OP_STATUS;
                                break;
8001429a:	d7 03       	nop
8001429c:	00 00       	add	r0,r0
8001429e:	4a 2c       	lddpc	r12,80014324 <MsgRxOutMsg+0x78>
800142a0:	00 00       	add	r0,r0
800142a2:	4a 29       	lddpc	r9,80014328 <MsgRxOutMsg+0x7c>
800142a4:	80 06       	ld.sh	r6,r0[0x0]
800142a6:	ff 94       	*unknown*
800142a8:	80 06       	ld.sh	r6,r0[0x0]
800142aa:	ff 78 d4 21 	stcond	pc[-11231],r8

800142ac <MsgRxOutMsg>:
800142ac:	d4 21       	pushm	r4-r7,lr
800142ae:	98 b8       	ld.uh	r8,r12[0x6]
800142b0:	18 97       	mov	r7,r12
800142b2:	e2 18 ff 00 	andl	r8,0xff00,COH
800142b6:	e0 48 03 00 	cp.w	r8,768
800142ba:	5f 09       	sreq	r9
800142bc:	e0 48 04 00 	cp.w	r8,1024
800142c0:	5f 08       	sreq	r8
800142c2:	12 48       	or	r8,r9
800142c4:	c2 41       	brne	8001430c <MsgRxOutMsg+0x60>
800142c6:	30 16       	mov	r6,1
        }
    }


    #ifdef NB_MIN
    if ((byte)1 == NbCheckPosValid(rx_ptr))                 /* FBlockIDs.Get and node position invalid? */
800142c8:	e0 a0 06 16 	rcall	80014ef4 <NbCheckPosValid>
800142cc:	ec 0c 18 00 	cp.b	r12,r6
800142d0:	c1 d0       	breq	8001430a <MsgRxOutMsg+0x5e>
        return(MSG_RX_TAKE);                                /* discard message */
    }
    #endif

    #ifdef NB_MIN
    if (    ((byte)2 == NbCheckPosValid(rx_ptr))            /* node position invalid and result depends on it? */
800142d2:	30 25       	mov	r5,2
800142d4:	0e 9c       	mov	r12,r7
800142d6:	e0 a0 06 0f 	rcall	80014ef4 <NbCheckPosValid>
800142da:	ea 0c 18 00 	cp.b	r12,r5
800142de:	c0 40       	breq	800142e6 <MsgRxOutMsg+0x3a>
        #ifdef MSV2_MIN
         || (MNS_FALSE == CheckConfigState())               /* node address temporarily invalid? */
800142e0:	e0 a0 05 14 	rcall	80014d08 <CheckConfigState>
        return(MSG_RX_TAKE);                                /* discard message */
    }
    #endif

    #ifdef NB_MIN
    if (    ((byte)2 == NbCheckPosValid(rx_ptr))            /* node position invalid and result depends on it? */
800142e4:	c1 71       	brne	80014312 <MsgRxOutMsg+0x66>
            case 0x03:
                return (MSG_RX_BUSY);                       /* force retrigger */

            case 0x01:
                MsgFreeRxMsg(rx_ptr);                       /* release rx message entry, */
                return(MSG_RX_TAKE);                        /* pointer was grabbed and message was interpreted */
800142e6:	30 2c       	mov	r12,2
        }
    }
    #endif

    return(MSG_RX_BUSY);                                    /* force retrigger, since there is no free tx buffer */
}
800142e8:	d8 22       	popm	r4-r7,pc
        #endif

        #ifdef CMD_CB2
        if (NULL == Cmd_FBlock_Tab_Ptr_Holder)                  /* avoid multiple calls of CmdRxFilter() in case of wildcard addressing */
        {
            reaction = CmdRxFilter(tx_ptr, rx_ptr);             /* callback application to filter message */
800142ea:	0e 9b       	mov	r11,r7
800142ec:	fe b0 a1 2c 	rcall	80008544 <CmdRxFilter>
                                                                /*              0x02: message was interpreted and tx buffer used */
                                                                /*              0x01: message was interpreted, but no tx msg required */
                                                                /*              0x00: message was checked (modified), */
                                                                /*                    and CmdRxInterpreter() must be called now */
                                                                /*                    (no tx msg required) */
            switch(reaction)
800142f0:	ea 0c 18 00 	cp.b	r12,r5
800142f4:	c3 80       	breq	80014364 <MsgRxOutMsg+0xb8>
800142f6:	30 38       	mov	r8,3
800142f8:	f0 0c 18 00 	cp.b	r12,r8
800142fc:	c3 90       	breq	8001436e <MsgRxOutMsg+0xc2>
800142fe:	ec 0c 18 00 	cp.b	r12,r6
80014302:	c1 31       	brne	80014328 <MsgRxOutMsg+0x7c>
                    AmsMsgSend(tx_ptr);                            /* send tx message */
                    MsgFreeRxMsg(rx_ptr);                       /* release rx message entry, */
                    return(MSG_RX_TAKE);                        /* pointer was grabbed and message was interpreted */

                case 0x01:
                    MsgTxUnused(tx_ptr);                        /* release tx message entry */
80014304:	08 9c       	mov	r12,r4
80014306:	fe b0 a6 17 	rcall	80008f34 <MsgTxUnused>
                    MsgFreeRxMsg(rx_ptr);                       /* release rx message entry, */
8001430a:	0e 9c       	mov	r12,r7
8001430c:	fe b0 a5 dc 	rcall	80008ec4 <MsgFreeRxMsg>
80014310:	da 2a       	popm	r4-r7,pc,r12=1
        return(MSG_RX_BUSY);                                /* force retrigger */
    }
    #endif


    tx_ptr = MsgGetTxPtr();
80014312:	33 2c       	mov	r12,50
80014314:	fe b0 a5 c4 	rcall	80008e9c <MsgGetTxPtrExt>
80014318:	18 94       	mov	r4,r12

    if (tx_ptr)
8001431a:	c1 b0       	breq	80014350 <MsgRxOutMsg+0xa4>
    {
        #ifdef AMS_TX_ADD9
        tx_ptr->MidLevelRetries = (byte)DEF_MID_LEVEL_RETRIES_INT_PROC;     /* set number of mid level retries */
8001431c:	f9 65 00 0d 	st.b	r12[13],r5
        #endif

        #ifdef CMD_CB2
        if (NULL == Cmd_FBlock_Tab_Ptr_Holder)                  /* avoid multiple calls of CmdRxFilter() in case of wildcard addressing */
80014320:	49 68       	lddpc	r8,80014378 <MsgRxOutMsg+0xcc>
80014322:	70 08       	ld.w	r8,r8[0x0]
80014324:	58 08       	cp.w	r8,0
80014326:	ce 20       	breq	800142ea <MsgRxOutMsg+0x3e>
                    break;
            }
        }
        #endif

        reaction = CmdRxInterpreter(tx_ptr, rx_ptr);
80014328:	08 9c       	mov	r12,r4
8001432a:	0e 9b       	mov	r11,r7
8001432c:	fe b0 fd 8c 	rcall	80013e44 <CmdRxInterpreter>

        switch(reaction)
80014330:	32 08       	mov	r8,32
80014332:	f0 0c 18 00 	cp.b	r12,r8
80014336:	ce d0       	breq	80014310 <MsgRxOutMsg+0x64>
80014338:	3a 08       	mov	r8,-96
8001433a:	f0 0c 18 00 	cp.b	r12,r8
8001433e:	c0 70       	breq	8001434c <MsgRxOutMsg+0xa0>
80014340:	58 0c       	cp.w	r12,0
80014342:	cd 21       	brne	800142e6 <MsgRxOutMsg+0x3a>
        {
            case CMD_F_OK:
                MsgFreeRxMsg(rx_ptr);                       /* release message entry, */
80014344:	0e 9c       	mov	r12,r7
80014346:	fe b0 a5 bf 	rcall	80008ec4 <MsgFreeRxMsg>
8001434a:	da 2a       	popm	r4-r7,pc,r12=1
                return(MSG_RX_TAKE);                        /* pointer was grabbed and message was interpreted */
8001434c:	30 3c       	mov	r12,3

            case CMD_F_RX_RETAIN:                           /* message was interpreted, but application */
                return(MSG_RX_TAKE);                        /* retains rx buffer */

            case (CMD_F_RX_RETAIN | CMD_F_RETRIGGER):       /* same message must be repeated, but message has been */
                return(MSG_RX_INC_USAGE_CNT);               /* also retained */
8001434e:	d8 22       	popm	r4-r7,pc
        }
    }
    #ifdef CMD_CB2
    else
    {                                                       
        reaction = CmdRxFilter((pTMsgTx)NULL, rx_ptr);      /* callback application to filter message             */
80014350:	0e 9b       	mov	r11,r7
80014352:	fe b0 a0 f9 	rcall	80008544 <CmdRxFilter>
                                                            /*   reaction:  0x03: message was not interpreted and must be retriggered */
                                                            /*              0x01: message was interpreted,  */
        switch(reaction)
80014356:	ec 0c 18 00 	cp.b	r12,r6
8001435a:	cc 61       	brne	800142e6 <MsgRxOutMsg+0x3a>
        {
            case 0x03:
                return (MSG_RX_BUSY);                       /* force retrigger */

            case 0x01:
                MsgFreeRxMsg(rx_ptr);                       /* release rx message entry, */
8001435c:	0e 9c       	mov	r12,r7
8001435e:	fe b0 a5 b3 	rcall	80008ec4 <MsgFreeRxMsg>
80014362:	cd 7b       	rjmp	80014310 <MsgRxOutMsg+0x64>
                case 0x03:
                    MsgTxUnused(tx_ptr);                        /* release tx message entry */
                    return(MSG_RX_BUSY);                        /* force retrigger */

                case 0x02:
                    AmsMsgSend(tx_ptr);                            /* send tx message */
80014364:	08 9c       	mov	r12,r4
80014366:	fe b0 ab 07 	rcall	80009974 <MsgSend>
                    MsgFreeRxMsg(rx_ptr);                       /* release rx message entry, */
8001436a:	0e 9c       	mov	r12,r7
8001436c:	cd 0b       	rjmp	8001430c <MsgRxOutMsg+0x60>
                                                                /*                    and CmdRxInterpreter() must be called now */
                                                                /*                    (no tx msg required) */
            switch(reaction)
            {
                case 0x03:
                    MsgTxUnused(tx_ptr);                        /* release tx message entry */
8001436e:	08 9c       	mov	r12,r4
80014370:	fe b0 a5 e2 	rcall	80008f34 <MsgTxUnused>
80014374:	30 2c       	mov	r12,2
                    return(MSG_RX_BUSY);                        /* force retrigger */
80014376:	d8 22       	popm	r4-r7,pc
80014378:	00 00       	add	r0,r0
8001437a:	4a 2c       	lddpc	r12,80014400 <ET_NtfMatrixSize_Get>

8001437c <ET_AutoWakeup_Get>:
| Returns     : OP_STATUS                                                      |
+------------------------------------------------------------------------------+
*/
byte ET_AutoWakeup_Get(pTMsgTx tx_ptr)
{
    tx_ptr->Data[ET_AWU_PARAM_DELAY]       = ET_AutoWakeup_Params.delay;
8001437c:	78 09       	ld.w	r9,r12[0x0]
8001437e:	48 98       	lddpc	r8,800143a0 <ET_AutoWakeup_Get+0x24>
80014380:	11 8a       	ld.ub	r10,r8[0x0]
80014382:	b2 8a       	st.b	r9[0x0],r10
    tx_ptr->Data[ET_AWU_PARAM_DIAGNOSIS]   = (MNS_FALSE != ET_AutoWakeup_Params.diag) ? (byte)0x01 : (byte)0x00;
80014384:	11 9a       	ld.ub	r10,r8[0x1]
80014386:	78 09       	ld.w	r9,r12[0x0]
80014388:	b2 9a       	st.b	r9[0x1],r10
    tx_ptr->Data[ET_AWU_PARAM_ATTENUATION] = (byte)0x00;
8001438a:	30 0a       	mov	r10,0
8001438c:	78 09       	ld.w	r9,r12[0x0]
8001438e:	b2 aa       	st.b	r9[0x2],r10
    tx_ptr->Data[ET_AWU_PARAM_DURATION]    = ET_AutoWakeup_Params.duration;
80014390:	11 a9       	ld.ub	r9,r8[0x2]
80014392:	78 08       	ld.w	r8,r12[0x0]
80014394:	b0 b9       	st.b	r8[0x3],r9
    tx_ptr->Length = ET_AWU_LENGTH;
80014396:	30 48       	mov	r8,4
80014398:	b8 28       	st.h	r12[0x4],r8

    return(OP_STATUS);
}
8001439a:	30 cc       	mov	r12,12
8001439c:	5e fc       	retal	r12
8001439e:	d7 03       	nop
800143a0:	00 00       	add	r0,r0
800143a2:	3b 34       	mov	r4,-77

800143a4 <ET_EchoMessage>:
| Returns     : OpType                                                         |
+------------------------------------------------------------------------------+
*/
#ifdef FUNCID_ET_ECHOMESSAGE
byte ET_EchoMessage(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
800143a4:	eb cd 40 80 	pushm	r7,lr
    word target_index;

    source_index = (word)0x00;
    target_index = (word)0x00;

    if(rx_ptr->Length > MAX_MSG_TX_DATA)
800143a8:	33 28       	mov	r8,50
800143aa:	96 29       	ld.sh	r9,r11[0x4]
800143ac:	f0 09 19 00 	cp.h	r9,r8
800143b0:	e0 8b 00 21 	brhi	800143f2 <ET_EchoMessage+0x4e>
800143b4:	30 08       	mov	r8,0
    {
        source_index = (word)(rx_ptr->Length - MAX_MSG_TX_DATA);
    }
    for(; source_index < rx_ptr->Length; source_index++)
800143b6:	f2 08 19 00 	cp.h	r8,r9
800143ba:	c2 02       	brcc	800143fa <ET_EchoMessage+0x56>
800143bc:	30 09       	mov	r9,0
    {
        tx_ptr->Data[target_index] = rx_ptr->Data[source_index];
800143be:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
800143c2:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
800143c6:	76 07       	ld.w	r7,r11[0x0]
800143c8:	ee 0e 07 07 	ld.ub	r7,r7[lr]
800143cc:	78 0e       	ld.w	lr,r12[0x0]
800143ce:	fc 0a 0b 07 	st.b	lr[r10],r7
        target_index++;
800143d2:	2f f9       	sub	r9,-1

    if(rx_ptr->Length > MAX_MSG_TX_DATA)
    {
        source_index = (word)(rx_ptr->Length - MAX_MSG_TX_DATA);
    }
    for(; source_index < rx_ptr->Length; source_index++)
800143d4:	2f f8       	sub	r8,-1
    {
        tx_ptr->Data[target_index] = rx_ptr->Data[source_index];
        target_index++;
800143d6:	5c 89       	casts.h	r9

    if(rx_ptr->Length > MAX_MSG_TX_DATA)
    {
        source_index = (word)(rx_ptr->Length - MAX_MSG_TX_DATA);
    }
    for(; source_index < rx_ptr->Length; source_index++)
800143d8:	5c 88       	casts.h	r8
800143da:	96 2a       	ld.sh	r10,r11[0x4]
800143dc:	f0 0a 19 00 	cp.h	r10,r8
800143e0:	fe 9b ff ef 	brhi	800143be <ET_EchoMessage+0x1a>
    {
        tx_ptr->Data[target_index] = rx_ptr->Data[source_index];
        target_index++;
    }
    tx_ptr->Length = target_index;
800143e4:	b8 29       	st.h	r12[0x4],r9
    tx_ptr->Operation = OP_RESULT;
800143e6:	30 c8       	mov	r8,12
800143e8:	f9 68 00 0c 	st.b	r12[12],r8

    return(tx_ptr->Operation);
}
800143ec:	30 cc       	mov	r12,12
800143ee:	e3 cd 80 80 	ldm	sp++,r7,pc
    source_index = (word)0x00;
    target_index = (word)0x00;

    if(rx_ptr->Length > MAX_MSG_TX_DATA)
    {
        source_index = (word)(rx_ptr->Length - MAX_MSG_TX_DATA);
800143f2:	f2 c8 00 32 	sub	r8,r9,50
800143f6:	5c 88       	casts.h	r8
800143f8:	cd fb       	rjmp	800143b6 <ET_EchoMessage+0x12>
    }
    for(; source_index < rx_ptr->Length; source_index++)
800143fa:	30 09       	mov	r9,0
800143fc:	cf 4b       	rjmp	800143e4 <ET_EchoMessage+0x40>
800143fe:	d7 03       	nop

80014400 <ET_NtfMatrixSize_Get>:
            min_val = temp_val;
        }
        pntf_tab_entry++;
    }

    tx_ptr->Data[NTF_PARAM_MIN] = min_val;
80014400:	78 0a       	ld.w	r10,r12[0x0]
    byte result;
    #endif

    #ifdef NTF_MIN
    pntf_tab_entry = &NtfFBlockTab[0];
    max_val = pntf_tab_entry->NumDev;
80014402:	48 a8       	lddpc	r8,80014428 <ET_NtfMatrixSize_Get+0x28>
            min_val = temp_val;
        }
        pntf_tab_entry++;
    }

    tx_ptr->Data[NTF_PARAM_MIN] = min_val;
80014404:	11 99       	ld.ub	r9,r8[0x1]
    pntf_tab_entry = &NtfFBlockTab[0];
    max_val = pntf_tab_entry->NumDev;
    min_val = max_val;
    for (i=(byte)0; i<NTF_MAX_FBLOCKS; i++)
    {
        temp_val = pntf_tab_entry->NumDev;
80014406:	f1 38 00 09 	ld.ub	r8,r8[9]
            min_val = temp_val;
        }
        pntf_tab_entry++;
    }

    tx_ptr->Data[NTF_PARAM_MIN] = min_val;
8001440a:	f0 09 18 00 	cp.b	r9,r8
8001440e:	f2 0b 17 30 	movlo	r11,r9
80014412:	f0 0b 17 20 	movhs	r11,r8
    tx_ptr->Data[NTF_PARAM_MAX] = max_val;
80014416:	f2 08 17 b0 	movhi	r8,r9
            min_val = temp_val;
        }
        pntf_tab_entry++;
    }

    tx_ptr->Data[NTF_PARAM_MIN] = min_val;
8001441a:	b4 8b       	st.b	r10[0x0],r11
    tx_ptr->Data[NTF_PARAM_MAX] = max_val;
8001441c:	78 0a       	ld.w	r10,r12[0x0]
8001441e:	b4 98       	st.b	r10[0x1],r8
    tx_ptr->Length = NTF_LENGTH;
80014420:	30 28       	mov	r8,2
80014422:	b8 28       	st.h	r12[0x4],r8
        retval = CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC);
    }
    #endif

    return(retval);
}
80014424:	30 cc       	mov	r12,12
80014426:	5e fc       	retal	r12
80014428:	80 07       	ld.sh	r7,r0[0x0]
8001442a:	08 5c       	eor	r12,r4

8001442c <ET_Version_Get>:
*/
#ifdef FUNCID_ET_VERSION
byte ET_Version_Get(pTMsgTx tx_ptr)
{
    byte retval;
    tx_ptr->Data[ET_VS_PARAM_MAJOR] = ET_VERSION_MAJOR;
8001442c:	78 08       	ld.w	r8,r12[0x0]
8001442e:	30 39       	mov	r9,3
80014430:	b0 89       	st.b	r8[0x0],r9
    tx_ptr->Data[ET_VS_PARAM_MINOR] = ET_VERSION_MINOR;
80014432:	30 09       	mov	r9,0
80014434:	78 08       	ld.w	r8,r12[0x0]
80014436:	b0 99       	st.b	r8[0x1],r9
    tx_ptr->Data[ET_VS_PARAM_BUILD] = ET_VERSION_BUILD;
80014438:	30 19       	mov	r9,1
8001443a:	78 08       	ld.w	r8,r12[0x0]
8001443c:	b0 a9       	st.b	r8[0x2],r9
    tx_ptr->Length = ET_VS_LENGTH;
8001443e:	30 38       	mov	r8,3
80014440:	b8 28       	st.h	r12[0x4],r8
    retval = OP_STATUS;

    return(retval);
}
80014442:	30 cc       	mov	r12,12
80014444:	5e fc       	retal	r12
80014446:	d7 03       	nop

80014448 <ET_Store_Diag_Result>:
+------------------------------------------------------------------------------+
*/
#ifdef FUNCID_ET_DIAGRESULT
void ET_Store_Diag_Result(byte diag_result, byte *info)
{
    ET_DiagResult = (byte)0xFF;
80014448:	48 d8       	lddpc	r8,8001447c <ET_Store_Diag_Result+0x34>
8001444a:	3f f9       	mov	r9,-1
8001444c:	b0 89       	st.b	r8[0x0],r9

    switch (diag_result)
8001444e:	30 1a       	mov	r10,1
80014450:	f4 0c 18 00 	cp.b	r12,r10
80014454:	c1 00       	breq	80014474 <ET_Store_Diag_Result+0x2c>
80014456:	c0 a3       	brcs	8001446a <ET_Store_Diag_Result+0x22>
80014458:	30 29       	mov	r9,2
8001445a:	f2 0c 18 00 	cp.b	r12,r9
8001445e:	c0 80       	breq	8001446e <ET_Store_Diag_Result+0x26>
80014460:	30 39       	mov	r9,3
80014462:	f2 0c 18 00 	cp.b	r12,r9
80014466:	5e 1c       	retne	r12
        case MSVAL_DIAG_FAILED:
            ET_DiagResult = DIAG_POOR;
            break;

        case MSVAL_DIAG_SIGNAL_NO_LOCK:
            ET_DiagResult = DIAG_POS0_SIGNAL;
80014468:	34 09       	mov	r9,64
8001446a:	b0 89       	st.b	r8[0x0],r9
8001446c:	5e fc       	retal	r12
        case MSVAL_DIAG_POS:
            ET_DiagResult = *(info+1);
            break;

        case MSVAL_DIAG_FAILED:
            ET_DiagResult = DIAG_POOR;
8001446e:	3f c9       	mov	r9,-4
80014470:	b0 89       	st.b	r8[0x0],r9
            break;
80014472:	5e fc       	retal	r12
        case MSVAL_DIAG_OK:
            ET_DiagResult = DIAG_OK;
            break;

        case MSVAL_DIAG_POS:
            ET_DiagResult = *(info+1);
80014474:	17 99       	ld.ub	r9,r11[0x1]
80014476:	b0 89       	st.b	r8[0x0],r9
            break;
80014478:	5e fc       	retal	r12
8001447a:	d7 03       	nop
8001447c:	00 00       	add	r0,r0
8001447e:	4a 30       	lddpc	r0,80014508 <ET_FBlockInfo_Get+0x88>

80014480 <ET_FBlockInfo_Get>:
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef FUNCID_ET_FBLOCKINFO
byte ET_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80014480:	eb cd 40 e0 	pushm	r5-r7,lr
80014484:	20 8d       	sub	sp,32
    word rx_id;
    byte name[] = "FBlock EnhancedTestability";
80014486:	4f c9       	lddpc	r9,80014674 <ET_FBlockInfo_Get+0x1f4>
80014488:	f3 3a 00 1a 	ld.ub	r10,r9[26]
8001448c:	fb 6a 00 1a 	st.b	sp[26],r10
80014490:	72 0a       	ld.w	r10,r9[0x0]
80014492:	50 0a       	stdsp	sp[0x0],r10
80014494:	72 1a       	ld.w	r10,r9[0x4]
80014496:	50 1a       	stdsp	sp[0x4],r10
80014498:	72 2a       	ld.w	r10,r9[0x8]
8001449a:	50 2a       	stdsp	sp[0x8],r10
8001449c:	72 3a       	ld.w	r10,r9[0xc]
8001449e:	50 3a       	stdsp	sp[0xc],r10
800144a0:	f2 e6 00 10 	ld.d	r6,r9[16]
800144a4:	fa e7 00 10 	st.d	sp[16],r6
800144a8:	f3 3a 00 18 	ld.ub	r10,r9[24]
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef FUNCID_ET_FBLOCKINFO
byte ET_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
800144ac:	16 96       	mov	r6,r11
    word rx_id;
    byte name[] = "FBlock EnhancedTestability";
800144ae:	fb 6a 00 18 	st.b	sp[24],r10
800144b2:	f3 39 00 19 	ld.ub	r9,r9[25]
800144b6:	fb 69 00 19 	st.b	sp[25],r9
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
800144ba:	6c 0a       	ld.w	r10,r6[0x0]
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */

    Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
800144bc:	78 0b       	ld.w	r11,r12[0x0]
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */
800144be:	15 95       	ld.ub	r5,r10[0x1]
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
800144c0:	15 89       	ld.ub	r9,r10[0x0]
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */

    Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
800144c2:	b6 89       	st.b	r11[0x0],r9
    Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
800144c4:	6c 0a       	ld.w	r10,r6[0x0]
800144c6:	15 9b       	ld.ub	r11,r10[0x1]
800144c8:	78 0a       	ld.w	r10,r12[0x0]
800144ca:	b4 9b       	st.b	r10[0x1],r11
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
800144cc:	a9 69       	lsl	r9,0x8
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */

    Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
    Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
    Tx_Ptr->Length  = (word)2;
800144ce:	30 2a       	mov	r10,2
800144d0:	b8 2a       	st.h	r12[0x4],r10
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */
800144d2:	12 05       	add	r5,r9
/*--------------------------------------------------------------------------*/
#ifdef FUNCID_ET_FBLOCKINFO
byte ET_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
    word rx_id;
    byte name[] = "FBlock EnhancedTestability";
800144d4:	1a 98       	mov	r8,sp
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef FUNCID_ET_FBLOCKINFO
byte ET_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
800144d6:	18 97       	mov	r7,r12
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */
800144d8:	5c 85       	casts.h	r5
    Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
    Tx_Ptr->Length  = (word)2;

    answer_prepared = MNS_TRUE;

    if (rx_id < 0x1000)                             /* FktID ?*/
800144da:	e0 69 0f ff 	mov	r9,4095
800144de:	f2 05 19 00 	cp.h	r5,r9
800144e2:	e0 8b 00 26 	brhi	8001452e <ET_FBlockInfo_Get+0xae>
    {
        Tx_Ptr->Length  = (word)3;
800144e6:	30 38       	mov	r8,3
800144e8:	b8 28       	st.h	r12[0x4],r8

        switch (rx_id)
800144ea:	e0 68 02 09 	mov	r8,521
800144ee:	f0 05 19 00 	cp.h	r5,r8
800144f2:	c6 50       	breq	800145bc <ET_FBlockInfo_Get+0x13c>
800144f4:	e0 88 00 30 	brls	80014554 <ET_FBlockInfo_Get+0xd4>
800144f8:	e0 68 02 16 	mov	r8,534
800144fc:	f0 05 19 00 	cp.h	r5,r8
80014500:	c3 e0       	breq	8001457c <ET_FBlockInfo_Get+0xfc>
80014502:	e0 8b 00 9f 	brhi	80014640 <ET_FBlockInfo_Get+0x1c0>
80014506:	e0 68 02 11 	mov	r8,529
8001450a:	f0 05 19 00 	cp.h	r5,r8
8001450e:	c5 70       	breq	800145bc <ET_FBlockInfo_Get+0x13c>
80014510:	e0 68 02 13 	mov	r8,531
80014514:	f0 05 19 00 	cp.h	r5,r8
80014518:	c3 20       	breq	8001457c <ET_FBlockInfo_Get+0xfc>
8001451a:	e0 68 02 0f 	mov	r8,527
8001451e:	f0 05 19 00 	cp.h	r5,r8
80014522:	c2 d0       	breq	8001457c <ET_FBlockInfo_Get+0xfc>
              #endif
                break;
          #endif

            default:
                Tx_Ptr->Data[2] = MAT_UNKNOWN;
80014524:	6e 08       	ld.w	r8,r7[0x0]
80014526:	30 09       	mov	r9,0
80014528:	30 0b       	mov	r11,0
8001452a:	b0 a9       	st.b	r8[0x2],r9
8001452c:	c4 c8       	rjmp	800145c4 <ET_FBlockInfo_Get+0x144>
                break;
        }
    }
    else
    {
        switch (rx_id)
8001452e:	fe 79 f0 03 	mov	r9,-4093
80014532:	f2 05 19 00 	cp.h	r5,r9
80014536:	c5 10       	breq	800145d8 <ET_FBlockInfo_Get+0x158>
80014538:	e0 88 00 27 	brls	80014586 <ET_FBlockInfo_Get+0x106>
8001453c:	fe 78 f0 04 	mov	r8,-4092
80014540:	f0 05 19 00 	cp.h	r5,r8
80014544:	c7 20       	breq	80014628 <ET_FBlockInfo_Get+0x1a8>
80014546:	fe 78 f0 06 	mov	r8,-4090
8001454a:	f0 05 19 00 	cp.h	r5,r8
8001454e:	c5 a0       	breq	80014602 <ET_FBlockInfo_Get+0x182>
80014550:	30 0b       	mov	r11,0
80014552:	c3 98       	rjmp	800145c4 <ET_FBlockInfo_Get+0x144>

    if (rx_id < 0x1000)                             /* FktID ?*/
    {
        Tx_Ptr->Length  = (word)3;

        switch (rx_id)
80014554:	e0 68 02 03 	mov	r8,515
80014558:	f0 05 19 00 	cp.h	r5,r8
8001455c:	c1 00       	breq	8001457c <ET_FBlockInfo_Get+0xfc>
8001455e:	e0 8b 00 29 	brhi	800145b0 <ET_FBlockInfo_Get+0x130>
80014562:	31 18       	mov	r8,17
80014564:	f0 05 19 00 	cp.h	r5,r8
80014568:	c2 a0       	breq	800145bc <ET_FBlockInfo_Get+0x13c>
8001456a:	e0 68 02 01 	mov	r8,513
8001456e:	f0 05 19 00 	cp.h	r5,r8
80014572:	c2 50       	breq	800145bc <ET_FBlockInfo_Get+0x13c>
80014574:	31 08       	mov	r8,16
80014576:	f0 05 19 00 	cp.h	r5,r8
8001457a:	cd 51       	brne	80014524 <ET_FBlockInfo_Get+0xa4>
                Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
                break;

            case FUNCID_ET_NOTIFICATIONMATRIXSIZE:
              #ifdef NTF_MIN
                Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
8001457c:	6e 08       	ld.w	r8,r7[0x0]
8001457e:	31 29       	mov	r9,18
80014580:	30 1b       	mov	r11,1
80014582:	b0 a9       	st.b	r8[0x2],r9
              #else
                Tx_Ptr->Data[2] = MAT_PARTLY_IMPLEMENTED_VERIFIED;
              #endif
                break;
80014584:	c2 08       	rjmp	800145c4 <ET_FBlockInfo_Get+0x144>
                break;
        }
    }
    else
    {
        switch (rx_id)
80014586:	fe 79 f0 01 	mov	r9,-4095
8001458a:	f2 05 19 00 	cp.h	r5,r9
8001458e:	ce 11       	brne	80014550 <ET_FBlockInfo_Get+0xd0>
        {
            case FBI_FBLOCK_NAME:
                Tx_Ptr->Data[2] = FRMT_ISO8859;
80014590:	78 09       	ld.w	r9,r12[0x0]
80014592:	30 1a       	mov	r10,1
80014594:	b2 aa       	st.b	r9[0x2],r10
80014596:	30 09       	mov	r9,0
                for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
                {
                    Tx_Ptr->Data[i+3] = (byte)name[i];
80014598:	6e 0a       	ld.w	r10,r7[0x0]
8001459a:	f0 09 07 0b 	ld.ub	r11,r8[r9]
8001459e:	12 0a       	add	r10,r9
800145a0:	b4 bb       	st.b	r10[0x3],r11
800145a2:	2f f9       	sub	r9,-1
    {
        switch (rx_id)
        {
            case FBI_FBLOCK_NAME:
                Tx_Ptr->Data[2] = FRMT_ISO8859;
                for(i=(byte)0; i<(byte)(sizeof(name)); ++i)
800145a4:	59 b9       	cp.w	r9,27
800145a6:	cf 91       	brne	80014598 <ET_FBlockInfo_Get+0x118>
                {
                    Tx_Ptr->Data[i+3] = (byte)name[i];
                }
                Tx_Ptr->Length = (word)i + (word)3;
800145a8:	31 e8       	mov	r8,30
800145aa:	30 1b       	mov	r11,1
800145ac:	ae 28       	st.h	r7[0x4],r8
                break;
800145ae:	c0 b8       	rjmp	800145c4 <ET_FBlockInfo_Get+0x144>

    if (rx_id < 0x1000)                             /* FktID ?*/
    {
        Tx_Ptr->Length  = (word)3;

        switch (rx_id)
800145b0:	e0 68 02 05 	mov	r8,517
800145b4:	f0 05 19 00 	cp.h	r5,r8
800145b8:	e0 8b 00 57 	brhi	80014666 <ET_FBlockInfo_Get+0x1e6>
            case FUNCID_ET_DSO:
          #endif
          #ifdef FUNCID_ET_DSIHOLD
            case FUNCID_ET_DSIHOLD:
          #endif
                Tx_Ptr->Data[2] = MAT_PARTLY_IMPLEMENTED_VERIFIED;
800145bc:	6e 08       	ld.w	r8,r7[0x0]
800145be:	31 19       	mov	r9,17
800145c0:	30 1b       	mov	r11,1
800145c2:	b0 a9       	st.b	r8[0x2],r9

        }
    }

    /* Call Application, because request cannot be answered by NetServices completely */
    if (MNS_FALSE == ET_FBlockInfo_Query(rx_id, answer_prepared, Tx_Ptr))                   /* unknown ID ? */
800145c4:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
800145c8:	0e 9a       	mov	r10,r7
800145ca:	fe b0 9d d9 	rcall	8000817c <ET_FBlockInfo_Query>
800145ce:	c2 40       	breq	80014616 <ET_FBlockInfo_Get+0x196>
800145d0:	30 cc       	mov	r12,12
    {
        return_value = OP_STATUS;
    }

    return(return_value);
}
800145d2:	2f 8d       	sub	sp,-32
800145d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                }
                Tx_Ptr->Length = (word)i + (word)3;
                break;

            case FBI_FBLOCK_VERSION:
                version[0] = ET_VERSION_MAJOR;
800145d8:	30 39       	mov	r9,3
                version[1] = ET_VERSION_MINOR;
                version[2] = ET_VERSION_BUILD;
800145da:	30 18       	mov	r8,1
                }
                Tx_Ptr->Length = (word)i + (word)3;
                break;

            case FBI_FBLOCK_VERSION:
                version[0] = ET_VERSION_MAJOR;
800145dc:	fb 69 00 1c 	st.b	sp[28],r9
                version[1] = ET_VERSION_MINOR;
                version[2] = ET_VERSION_BUILD;
800145e0:	fb 68 00 1e 	st.b	sp[30],r8
                Tx_Ptr->Length = (word)i + (word)3;
                break;

            case FBI_FBLOCK_VERSION:
                version[0] = ET_VERSION_MAJOR;
                version[1] = ET_VERSION_MINOR;
800145e4:	30 09       	mov	r9,0
800145e6:	fb 69 00 1d 	st.b	sp[29],r9
                version[2] = ET_VERSION_BUILD;

                Tx_Ptr->Data[2] = FRMT_ISO8859;
800145ea:	78 09       	ld.w	r9,r12[0x0]
800145ec:	b2 a8       	st.b	r9[0x2],r8
                version[1]  = GFB_VERSION_MINOR;
                version[2]  = GFB_VERSION_BUILD;

                Tx_Ptr->Data[2] = FRMT_ISO8859;

                i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
800145ee:	6e 0b       	ld.w	r11,r7[0x0]
800145f0:	fa cc ff e4 	sub	r12,sp,-28
800145f4:	2f db       	sub	r11,-3
800145f6:	fe b0 a3 35 	rcall	80008c60 <MsgVersionToISO8859>

                Tx_Ptr->Length  = (word)((word)i + (word)3);
800145fa:	30 1b       	mov	r11,1
800145fc:	2f dc       	sub	r12,-3
800145fe:	ae 2c       	st.h	r7[0x4],r12
                break;
80014600:	ce 2b       	rjmp	800145c4 <ET_FBlockInfo_Get+0x144>

            case FBI_FBLOCK_TYPE:
                Tx_Ptr->Data[2] = FRMT_ISO8859;
80014602:	78 08       	ld.w	r8,r12[0x0]
80014604:	30 19       	mov	r9,1
80014606:	b0 a9       	st.b	r8[0x2],r9
                Tx_Ptr->Data[3] = (byte)'\0';
80014608:	30 09       	mov	r9,0
8001460a:	78 08       	ld.w	r8,r12[0x0]
8001460c:	b0 b9       	st.b	r8[0x3],r9
                Tx_Ptr->Length  = (word)4;
8001460e:	30 1b       	mov	r11,1
80014610:	30 48       	mov	r8,4
80014612:	b8 28       	st.h	r12[0x4],r8
                break;
80014614:	cd 8b       	rjmp	800145c4 <ET_FBlockInfo_Get+0x144>
    }

    /* Call Application, because request cannot be answered by NetServices completely */
    if (MNS_FALSE == ET_FBlockInfo_Query(rx_id, answer_prepared, Tx_Ptr))                   /* unknown ID ? */
    {
        return_value = CmdErrorParamWrong( Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)2);     /* prepare error message   */
80014616:	6c 0a       	ld.w	r10,r6[0x0]
80014618:	0e 9c       	mov	r12,r7
8001461a:	30 29       	mov	r9,2
8001461c:	30 1b       	mov	r11,1
8001461e:	fe b0 fa b9 	rcall	80013b90 <CmdErrorParamWrong>
    {
        return_value = OP_STATUS;
    }

    return(return_value);
}
80014622:	2f 8d       	sub	sp,-32
80014624:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

                Tx_Ptr->Length  = (word)((word)i + (word)3);
                break;

            case FBI_MOST_VERSION:
                version[0]  = GFB_VERSION_MAJOR;
80014628:	30 38       	mov	r8,3
                version[1]  = GFB_VERSION_MINOR;
                version[2]  = GFB_VERSION_BUILD;
8001462a:	fb 6a 00 1e 	st.b	sp[30],r10

                Tx_Ptr->Length  = (word)((word)i + (word)3);
                break;

            case FBI_MOST_VERSION:
                version[0]  = GFB_VERSION_MAJOR;
8001462e:	fb 68 00 1c 	st.b	sp[28],r8
                version[1]  = GFB_VERSION_MINOR;
80014632:	30 08       	mov	r8,0
80014634:	fb 68 00 1d 	st.b	sp[29],r8
                version[2]  = GFB_VERSION_BUILD;

                Tx_Ptr->Data[2] = FRMT_ISO8859;
80014638:	30 19       	mov	r9,1
8001463a:	78 08       	ld.w	r8,r12[0x0]
8001463c:	b0 a9       	st.b	r8[0x2],r9
8001463e:	cd 8b       	rjmp	800145ee <ET_FBlockInfo_Get+0x16e>

    if (rx_id < 0x1000)                             /* FktID ?*/
    {
        Tx_Ptr->Length  = (word)3;

        switch (rx_id)
80014640:	e0 68 02 19 	mov	r8,537
80014644:	f0 05 19 00 	cp.h	r5,r8
80014648:	e0 88 00 09 	brls	8001465a <ET_FBlockInfo_Get+0x1da>
8001464c:	e0 68 0f 00 	mov	r8,3840
80014650:	f0 05 19 00 	cp.h	r5,r8
80014654:	fe 91 ff 68 	brne	80014524 <ET_FBlockInfo_Get+0xa4>
80014658:	c9 2b       	rjmp	8001457c <ET_FBlockInfo_Get+0xfc>
8001465a:	e0 68 02 18 	mov	r8,536
8001465e:	f0 05 19 00 	cp.h	r5,r8
80014662:	c8 d2       	brcc	8001457c <ET_FBlockInfo_Get+0xfc>
80014664:	ca cb       	rjmp	800145bc <ET_FBlockInfo_Get+0x13c>
80014666:	e0 68 02 07 	mov	r8,519
8001466a:	f0 05 19 00 	cp.h	r5,r8
8001466e:	fe 93 ff 5b 	brlo	80014524 <ET_FBlockInfo_Get+0xa4>
80014672:	c8 5b       	rjmp	8001457c <ET_FBlockInfo_Get+0xfc>
80014674:	80 07       	ld.sh	r7,r0[0x0]
80014676:	02 80       	andn	r0,r1

80014678 <ET_SuspMode_Set>:
80014678:	d4 01       	pushm	lr
8001467a:	30 29       	mov	r9,2
8001467c:	76 0a       	ld.w	r10,r11[0x0]
8001467e:	15 88       	ld.ub	r8,r10[0x0]
80014680:	f2 08 18 00 	cp.b	r8,r9
    if(rx_ptr->Length != (word)1)
    {
        return(CmdErrorMsg(tx_ptr, ERR_LENGTH));              /* return OP_ERROR */
    }
    #endif
    switch(rx_ptr->Data[0x00])
80014684:	e0 88 00 07 	brls	80014692 <ET_SuspMode_Set+0x1a>
            break;
        }
        default:
        {
            /* prepare error message: wrong parameter */
            retval = CmdErrorParamWrong(tx_ptr, (byte)0x01, &rx_ptr->Data[0x00], (byte)0x01);
80014688:	30 19       	mov	r9,1
8001468a:	12 9b       	mov	r11,r9
8001468c:	fe b0 fa 82 	rcall	80013b90 <CmdErrorParamWrong>
        }
    }


    return(retval);
}
80014690:	d8 02       	popm	pc
    {
        case ET_SHUTDOWNSUSPENDMODE_OFF:
        case ET_SHUTDOWNSUSPENDMODE_ON:
        case ET_SHUTDOWNSUSPENDMODE_DEFAULT:
        {
            ET_SuspMode = rx_ptr->Data[0x00];
80014692:	48 39       	lddpc	r9,8001469c <ET_SuspMode_Set+0x24>
80014694:	30 0c       	mov	r12,0
80014696:	b2 88       	st.b	r9[0x0],r8
            break;
80014698:	d8 02       	popm	pc
8001469a:	d7 03       	nop
8001469c:	00 00       	add	r0,r0
8001469e:	4a 31       	lddpc	r1,80014728 <ET_RxFilter+0x88>

800146a0 <ET_RxFilter>:
800146a0:	eb cd 40 80 	pushm	r7,lr
| Returns     : see RxFilterResult                                             |
+------------------------------------------------------------------------------+
*/
#ifdef ET_MIN
byte ET_RxFilter(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
800146a4:	20 1d       	sub	sp,4
    byte retval;

    if (    (FBLOCK_ET == rx_ptr->FBlock_ID)
800146a6:	30 f9       	mov	r9,15
| Returns     : see RxFilterResult                                             |
+------------------------------------------------------------------------------+
*/
#ifdef ET_MIN
byte ET_RxFilter(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
800146a8:	18 97       	mov	r7,r12
    byte retval;

    if (    (FBLOCK_ET == rx_ptr->FBlock_ID)
800146aa:	f7 38 00 0a 	ld.ub	r8,r11[10]
800146ae:	f2 08 18 00 	cp.b	r8,r9
800146b2:	c2 40       	breq	800146fa <ET_RxFilter+0x5a>
    }

    retval = RXFILTERRESULT_TRANSPARENT;

    #ifdef FUNCID_ET_SHUTDOWNSUSPENDMODE
    if (FBLOCK_NETBLOCK == rx_ptr->FBlock_ID)
800146b4:	30 19       	mov	r9,1
800146b6:	f2 08 18 00 	cp.b	r8,r9
800146ba:	c0 50       	breq	800146c4 <ET_RxFilter+0x24>
        tx_ptr->FBlock_ID  = rx_ptr->FBlock_ID;
        tx_ptr->Inst_ID    = rx_ptr->Inst_ID;
        tx_ptr->Func_ID    = rx_ptr->Func_ID;
        tx_ptr->Operation  = OP_RESULT;
        tx_ptr->Data[0x00] = NBSHUTDOWN_SUSPEND;
        tx_ptr->Length     = (word)0x01;
800146bc:	30 0c       	mov	r12,0
    #else
        (void) tx_ptr;
    #endif

    return(retval);
}
800146be:	2f fd       	sub	sp,-4
800146c0:	e3 cd 80 80 	ldm	sp++,r7,pc
    #ifdef FUNCID_ET_SHUTDOWNSUSPENDMODE
    if (FBLOCK_NETBLOCK == rx_ptr->FBlock_ID)
    {
        /* if ShutdownSuspendMode is not Default this FBlock has to intercept     */
        /* NetBlock.Shutdown.Start(Query) messages and handle them specially.     */
        if((ET_SHUTDOWNSUSPENDMODE_DEFAULT != ET_SuspMode)          &&
800146c4:	4a 08       	lddpc	r8,80014744 <ET_RxFilter+0xa4>
800146c6:	30 2a       	mov	r10,2
800146c8:	11 88       	ld.ub	r8,r8[0x0]
800146ca:	f4 08 18 00 	cp.b	r8,r10
800146ce:	cf 70       	breq	800146bc <ET_RxFilter+0x1c>
           (FUNC_SHUTDOWN                  == rx_ptr->Func_ID)      &&
800146d0:	96 4c       	ld.sh	r12,r11[0x8]
800146d2:	30 6a       	mov	r10,6
800146d4:	f4 0c 19 00 	cp.h	r12,r10
800146d8:	cf 21       	brne	800146bc <ET_RxFilter+0x1c>
           (OP_START                       == rx_ptr->Operation)    &&
800146da:	f7 3a 00 0c 	ld.ub	r10,r11[12]
800146de:	30 0c       	mov	r12,0
800146e0:	f8 0a 18 00 	cp.b	r10,r12
800146e4:	ce c1       	brne	800146bc <ET_RxFilter+0x1c>
           (NBSHUTDOWN_QUERY               == rx_ptr->Data[0x00]))
800146e6:	76 0c       	ld.w	r12,r11[0x0]
800146e8:	19 8c       	ld.ub	r12,r12[0x0]
800146ea:	f4 0c 18 00 	cp.b	r12,r10
800146ee:	ce 71       	brne	800146bc <ET_RxFilter+0x1c>

    /* this function is only called if a NetBlock.Shutdown.Start(Query) was re- */
    /* ceived and ShutdownSuspendMode is not Default ... see ET_RxFilter()      */

    result = RXFILTERRESULT_DISPATCHED_NOTX;                  /* send no result */
    if(ET_SHUTDOWNSUSPENDMODE_ON == ET_SuspMode)
800146f0:	f2 08 18 00 	cp.b	r8,r9
800146f4:	c1 30       	breq	8001471a <ET_RxFilter+0x7a>
800146f6:	30 1c       	mov	r12,1
800146f8:	ce 3b       	rjmp	800146be <ET_RxFilter+0x1e>
byte ET_RxFilter(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
    byte retval;

    if (    (FBLOCK_ET == rx_ptr->FBlock_ID)
         && (OP_REPORTS > rx_ptr->Operation))
800146fa:	f7 39 00 0c 	ld.ub	r9,r11[12]
800146fe:	30 88       	mov	r8,8
80014700:	f0 09 18 00 	cp.b	r9,r8
80014704:	fe 9b ff dc 	brhi	800146bc <ET_RxFilter+0x1c>
    {
        rx_ptr->Inst_ID = MOST_GET_NODE_POS();
80014708:	50 0b       	stdsp	sp[0x0],r11
8001470a:	fe b0 e8 f9 	rcall	800118fc <MostGetNodePos>
8001470e:	40 0b       	lddsp	r11,sp[0x0]
80014710:	f7 6c 00 0b 	st.b	r11[11],r12
80014714:	f7 38 00 0a 	ld.ub	r8,r11[10]
80014718:	cc eb       	rjmp	800146b4 <ET_RxFilter+0x14>
    /* ceived and ShutdownSuspendMode is not Default ... see ET_RxFilter()      */

    result = RXFILTERRESULT_DISPATCHED_NOTX;                  /* send no result */
    if(ET_SHUTDOWNSUSPENDMODE_ON == ET_SuspMode)
    {
        tx_ptr->Tgt_Adr    = rx_ptr->Src_Adr;
8001471a:	96 39       	ld.sh	r9,r11[0x6]
8001471c:	ae 39       	st.h	r7[0x6],r9
        tx_ptr->FBlock_ID  = rx_ptr->FBlock_ID;
8001471e:	f7 39 00 0a 	ld.ub	r9,r11[10]
80014722:	ef 69 00 0a 	st.b	r7[10],r9
        tx_ptr->Inst_ID    = rx_ptr->Inst_ID;
80014726:	f7 39 00 0b 	ld.ub	r9,r11[11]
        tx_ptr->Func_ID    = rx_ptr->Func_ID;
        tx_ptr->Operation  = OP_RESULT;
8001472a:	30 ca       	mov	r10,12
    result = RXFILTERRESULT_DISPATCHED_NOTX;                  /* send no result */
    if(ET_SHUTDOWNSUSPENDMODE_ON == ET_SuspMode)
    {
        tx_ptr->Tgt_Adr    = rx_ptr->Src_Adr;
        tx_ptr->FBlock_ID  = rx_ptr->FBlock_ID;
        tx_ptr->Inst_ID    = rx_ptr->Inst_ID;
8001472c:	ef 69 00 0b 	st.b	r7[11],r9
        tx_ptr->Func_ID    = rx_ptr->Func_ID;
80014730:	96 49       	ld.sh	r9,r11[0x8]
        tx_ptr->Operation  = OP_RESULT;
80014732:	ef 6a 00 0c 	st.b	r7[12],r10
    if(ET_SHUTDOWNSUSPENDMODE_ON == ET_SuspMode)
    {
        tx_ptr->Tgt_Adr    = rx_ptr->Src_Adr;
        tx_ptr->FBlock_ID  = rx_ptr->FBlock_ID;
        tx_ptr->Inst_ID    = rx_ptr->Inst_ID;
        tx_ptr->Func_ID    = rx_ptr->Func_ID;
80014736:	ae 49       	st.h	r7[0x8],r9
        tx_ptr->Operation  = OP_RESULT;
        tx_ptr->Data[0x00] = NBSHUTDOWN_SUSPEND;
80014738:	6e 09       	ld.w	r9,r7[0x0]
8001473a:	b2 88       	st.b	r9[0x0],r8
        tx_ptr->Length     = (word)0x01;
8001473c:	30 2c       	mov	r12,2
8001473e:	30 18       	mov	r8,1
80014740:	ae 28       	st.h	r7[0x4],r8
80014742:	cb eb       	rjmp	800146be <ET_RxFilter+0x1e>
80014744:	00 00       	add	r0,r0
80014746:	4a 31       	lddpc	r1,800147d0 <ET_SendMessage+0x24>

80014748 <ET_Go_Net_Off>:
80014748:	eb cd 40 80 	pushm	r7,lr
+------------------------------------------------------------------------------+
*/
void ET_Go_Net_Off(void)
{
    #ifdef FUNCID_ET_AUTOWAKEUP
    if (ET_AutoWakeup_Params.delay > (byte)0x00)
8001474c:	48 77       	lddpc	r7,80014768 <ET_Go_Net_Off+0x20>
8001474e:	0f 8c       	ld.ub	r12,r7[0x0]
80014750:	58 0c       	cp.w	r12,0
80014752:	c0 50       	breq	8001475c <ET_Go_Net_Off+0x14>
    {
        ET_AutoWakeup_Request( ET_AutoWakeup_Params.delay,
80014754:	0f aa       	ld.ub	r10,r7[0x2]
80014756:	0f 9b       	ld.ub	r11,r7[0x1]
80014758:	fe b0 9d 0e 	rcall	80008174 <ET_AutoWakeup_Request>
                               ET_AutoWakeup_Params.diag,
                               ET_AutoWakeup_Params.duration );
    }
    ET_AutoWakeup_Params.delay    = (byte)0x00;
8001475c:	30 08       	mov	r8,0
    ET_AutoWakeup_Params.diag     = MNS_FALSE;
    ET_AutoWakeup_Params.duration = ET_AWU_DURATION_INFINITE;
8001475e:	ae a8       	st.b	r7[0x2],r8
    {
        ET_AutoWakeup_Request( ET_AutoWakeup_Params.delay,
                               ET_AutoWakeup_Params.diag,
                               ET_AutoWakeup_Params.duration );
    }
    ET_AutoWakeup_Params.delay    = (byte)0x00;
80014760:	ae 88       	st.b	r7[0x0],r8
    ET_AutoWakeup_Params.diag     = MNS_FALSE;
80014762:	ae 98       	st.b	r7[0x1],r8
    ET_AutoWakeup_Params.duration = ET_AWU_DURATION_INFINITE;
    #endif
}
80014764:	e3 cd 80 80 	ldm	sp++,r7,pc
80014768:	00 00       	add	r0,r0
8001476a:	3b 34       	mov	r4,-77

8001476c <ET_Init>:
8001476c:	d4 01       	pushm	lr
8001476e:	48 c8       	lddpc	r8,8001479c <ET_Init+0x30>
{
    #ifdef FUNCID_ET_SHUTDOWNSUSPENDMODE
    ET_SuspMode                             = ET_SHUTDOWNSUSPENDMODE_DEFAULT;
    #endif
    #ifdef FUNCID_ET_AUTOWAKEUP
    ET_AutoWakeup_Params.delay              = (byte)0x00;
80014770:	30 09       	mov	r9,0
    ET_AutoWakeup_Params.diag               = MNS_FALSE;
    ET_AutoWakeup_Params.duration           = ET_AWU_DURATION_INFINITE;
80014772:	b0 a9       	st.b	r8[0x2],r9
{
    #ifdef FUNCID_ET_SHUTDOWNSUSPENDMODE
    ET_SuspMode                             = ET_SHUTDOWNSUSPENDMODE_DEFAULT;
    #endif
    #ifdef FUNCID_ET_AUTOWAKEUP
    ET_AutoWakeup_Params.delay              = (byte)0x00;
80014774:	b0 89       	st.b	r8[0x0],r9
    ET_AutoWakeup_Params.diag               = MNS_FALSE;
80014776:	b0 99       	st.b	r8[0x1],r9
    ET_AutoWakeup_Params.duration           = ET_AWU_DURATION_INFINITE;
    #endif

    #ifdef FUNCID_ET_CODINGERRORS
    ET_CodingErrors.tx_ptr      = NULL;
80014778:	48 a8       	lddpc	r8,800147a0 <ET_Init+0x34>
8001477a:	30 09       	mov	r9,0
    ET_CodingErrors.status      = MNS_FALSE;
    ET_CodingErrors.off_counter = (word)0;
8001477c:	b0 39       	st.h	r8[0x6],r9
    ET_AutoWakeup_Params.diag               = MNS_FALSE;
    ET_AutoWakeup_Params.duration           = ET_AWU_DURATION_INFINITE;
    #endif

    #ifdef FUNCID_ET_CODINGERRORS
    ET_CodingErrors.tx_ptr      = NULL;
8001477e:	91 09       	st.w	r8[0x0],r9
    ET_CodingErrors.status      = MNS_FALSE;
80014780:	b0 c9       	st.b	r8[0x4],r9
*/
#ifdef ET_MIN
void ET_Init(void)
{
    #ifdef FUNCID_ET_SHUTDOWNSUSPENDMODE
    ET_SuspMode                             = ET_SHUTDOWNSUSPENDMODE_DEFAULT;
80014782:	30 29       	mov	r9,2
80014784:	48 88       	lddpc	r8,800147a4 <ET_Init+0x38>
    ET_CodingErrors.status      = MNS_FALSE;
    ET_CodingErrors.off_counter = (word)0;
    #endif

    #ifdef FUNCID_ET_DIAGRESULT
    if (MNS_FALSE == MostIsSupported(NSF_RBD))
80014786:	e0 6c 02 00 	mov	r12,512
*/
#ifdef ET_MIN
void ET_Init(void)
{
    #ifdef FUNCID_ET_SHUTDOWNSUSPENDMODE
    ET_SuspMode                             = ET_SHUTDOWNSUSPENDMODE_DEFAULT;
8001478a:	b0 89       	st.b	r8[0x0],r9
    ET_CodingErrors.status      = MNS_FALSE;
    ET_CodingErrors.off_counter = (word)0;
    #endif

    #ifdef FUNCID_ET_DIAGRESULT
    if (MNS_FALSE == MostIsSupported(NSF_RBD))
8001478c:	fe b0 b3 94 	rcall	8000aeb4 <MostIsSupported>
80014790:	c0 41       	brne	80014798 <ET_Init+0x2c>
    {
         ET_DiagResult = DIAG_OK;
80014792:	3f f9       	mov	r9,-1
80014794:	48 58       	lddpc	r8,800147a8 <ET_Init+0x3c>
80014796:	b0 89       	st.b	r8[0x0],r9
80014798:	d8 02       	popm	pc
8001479a:	d7 03       	nop
8001479c:	00 00       	add	r0,r0
8001479e:	3b 34       	mov	r4,-77
800147a0:	00 00       	add	r0,r0
800147a2:	3b 38       	mov	r8,-77
800147a4:	00 00       	add	r0,r0
800147a6:	4a 31       	lddpc	r1,80014830 <ET_PhysicalLayer_Result+0x40>
800147a8:	00 00       	add	r0,r0
800147aa:	4a 30       	lddpc	r0,80014834 <ET_PhysicalLayer_Result+0x44>

800147ac <ET_SendMessage>:
800147ac:	eb cd 40 80 	pushm	r7,lr
| Returns     : OP_RESULT                                                      |
+------------------------------------------------------------------------------+
*/
#ifdef FUNCID_ET_SENDMESSAGE
byte ET_SendMessage(pTMsgTx tx_ptr)
{
800147b0:	18 97       	mov	r7,r12

    ET_CalcMsgBufSize_Tx(&dummy, &max_length);

    if (MBS_DYN_MEM_ALLOC == max_length)
    {
        if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
800147b2:	e0 6c 40 00 	mov	r12,16384
800147b6:	fe b0 b3 7f 	rcall	8000aeb4 <MostIsSupported>
800147ba:	c0 f0       	breq	800147d8 <ET_SendMessage+0x2c>
800147bc:	33 2a       	mov	r10,50
        {
            max_length = (MBS_LCMSMAX_50 - (word)1) << 2;
        }
        else
        {
            return(CmdErrorMsg(tx_ptr, ERR_PROCESSING));
800147be:	30 08       	mov	r8,0
        max_length = MAX_MSG_TX_DATA;
    }

    for(index = (word)0x00; index < max_length; index++)
    {
        tx_ptr->Data[index] = LB(index);
800147c0:	6e 09       	ld.w	r9,r7[0x0]
800147c2:	f2 08 0b 08 	st.b	r9[r8],r8
800147c6:	2f f8       	sub	r8,-1
    if (MAX_MSG_TX_DATA < max_length)                           /* avoid overflow of tx_ptr->Data[] */
    {
        max_length = MAX_MSG_TX_DATA;
    }

    for(index = (word)0x00; index < max_length; index++)
800147c8:	f0 0a 19 00 	cp.h	r10,r8
800147cc:	fe 9b ff fa 	brhi	800147c0 <ET_SendMessage+0x14>
    {
        tx_ptr->Data[index] = LB(index);
    }
    tx_ptr->Length = max_length;
800147d0:	ae 2a       	st.h	r7[0x4],r10
800147d2:	30 cc       	mov	r12,12

    return(OP_RESULT);
}
800147d4:	e3 cd 80 80 	ldm	sp++,r7,pc
    {
        if (MNS_FALSE != MostIsSupported(NSF_MOST_150))
        {
            max_length = (MBS_LCMSMAX_150 - (word)1) << 2;
        }
        else if (MNS_FALSE != MostIsSupported(NSF_MOST_50))     /* MOST_50 */
800147d8:	31 0c       	mov	r12,16
800147da:	fe b0 b3 6d 	rcall	8000aeb4 <MostIsSupported>
800147de:	c0 30       	breq	800147e4 <ET_SendMessage+0x38>
        {
            max_length = (MBS_LCMSMAX_50 - (word)1) << 2;
        }
        else
        {
            return(CmdErrorMsg(tx_ptr, ERR_PROCESSING));
800147e0:	32 ca       	mov	r10,44
800147e2:	ce eb       	rjmp	800147be <ET_SendMessage+0x12>
800147e4:	0e 9c       	mov	r12,r7
800147e6:	34 2b       	mov	r11,66
800147e8:	fe b0 f9 c6 	rcall	80013b74 <CmdErrorMsg>
800147ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800147f0 <ET_PhysicalLayer_Result>:
800147f0:	eb cd 40 c0 	pushm	r6-r7,lr
800147f4:	20 2d       	sub	sp,8
800147f6:	18 97       	mov	r7,r12
    bool  valid;


    retval     = OP_STATUS;

    if(MNS_FALSE != MostIsSupported(NSF_MOST_150))
800147f8:	e0 6c 40 00 	mov	r12,16384
800147fc:	fe b0 b3 5c 	rcall	8000aeb4 <MostIsSupported>
80014800:	c1 80       	breq	80014830 <ET_PhysicalLayer_Result+0x40>
    {
        num_errors = (dword)0;
80014802:	30 08       	mov	r8,0
        valid = VmsvPhysicalLayerTestResult(&lock_status, &num_errors);
80014804:	1a 96       	mov	r6,sp

    retval     = OP_STATUS;

    if(MNS_FALSE != MostIsSupported(NSF_MOST_150))
    {
        num_errors = (dword)0;
80014806:	50 08       	stdsp	sp[0x0],r8
        valid = VmsvPhysicalLayerTestResult(&lock_status, &num_errors);
80014808:	fa cc ff f9 	sub	r12,sp,-7
8001480c:	1a 9b       	mov	r11,sp
8001480e:	fe b0 d3 db 	rcall	8000efc4 <VmsvPhysicalLayerTestResult>

        if (MNS_FALSE == valid)
80014812:	c1 60       	breq	8001483e <ET_PhysicalLayer_Result+0x4e>
        {
            retval = CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
        }
        else
        {
            tx_ptr->Data[0] = (MNS_FALSE != lock_status) ? (byte)0x01 : (byte)0x00;
80014814:	6e 08       	ld.w	r8,r7[0x0]
80014816:	1b f9       	ld.ub	r9,sp[0x7]
            CmdEncodeLong(&tx_ptr->Data[1], &num_errors);
80014818:	1a 9b       	mov	r11,sp
        {
            retval = CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
        }
        else
        {
            tx_ptr->Data[0] = (MNS_FALSE != lock_status) ? (byte)0x01 : (byte)0x00;
8001481a:	b0 89       	st.b	r8[0x0],r9
            CmdEncodeLong(&tx_ptr->Data[1], &num_errors);
8001481c:	6e 0c       	ld.w	r12,r7[0x0]
8001481e:	2f fc       	sub	r12,-1
80014820:	fe b0 f9 7a 	rcall	80013b14 <CmdEncodeLong>
            tx_ptr->Length = (word)5;
80014824:	30 58       	mov	r8,5
80014826:	30 cc       	mov	r12,12
80014828:	ae 28       	st.h	r7[0x4],r8
    {
        retval = CmdErrorMsg(tx_ptr, ERR_FKTID);   /* FuncID not found */
    }

    return(retval);
}
8001482a:	2f ed       	sub	sp,-8
8001482c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
            tx_ptr->Length = (word)5;
        }
    }
    else
    {
        retval = CmdErrorMsg(tx_ptr, ERR_FKTID);   /* FuncID not found */
80014830:	0e 9c       	mov	r12,r7
80014832:	30 3b       	mov	r11,3
80014834:	fe b0 f9 a0 	rcall	80013b74 <CmdErrorMsg>
    }

    return(retval);
}
80014838:	2f ed       	sub	sp,-8
8001483a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        num_errors = (dword)0;
        valid = VmsvPhysicalLayerTestResult(&lock_status, &num_errors);

        if (MNS_FALSE == valid)
        {
            retval = CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
8001483e:	0e 9c       	mov	r12,r7
80014840:	34 1b       	mov	r11,65
80014842:	fe b0 f9 99 	rcall	80013b74 <CmdErrorMsg>
    {
        retval = CmdErrorMsg(tx_ptr, ERR_FKTID);   /* FuncID not found */
    }

    return(retval);
}
80014846:	2f ed       	sub	sp,-8
80014848:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8001484c <ET_PhysicalLayerTest_Finished>:
8001484c:	d4 01       	pushm	lr
8001484e:	30 0c       	mov	r12,0
80014850:	fe b0 9c 94 	rcall	80008178 <ET_PhysicalLayerTest_Status>
80014854:	d8 02       	popm	pc
80014856:	d7 03       	nop

80014858 <ET_PhysicalLayerTest_Start>:
80014858:	eb cd 40 e0 	pushm	r5-r7,lr
| Returns     : OP_RESULTACK or OP_ERROR_ACK                                   |
+------------------------------------------------------------------------------+
*/
#ifdef FUNCID_ET_PHYSICALLAYERTEST
byte ET_PhysicalLayerTest_Start(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
8001485c:	20 2d       	sub	sp,8
8001485e:	18 97       	mov	r7,r12
80014860:	16 96       	mov	r6,r11
    word  lead_out;
    dword duration;

    retval = OP_RESULT;

    if(MNS_FALSE != MostIsSupported(NSF_MOST_150))
80014862:	e0 6c 40 00 	mov	r12,16384
80014866:	fe b0 b3 27 	rcall	8000aeb4 <MostIsSupported>
8001486a:	c2 b0       	breq	800148c0 <ET_PhysicalLayerTest_Start+0x68>
            retval = CmdErrorMsg(tx_ptr, ERR_LENGTH);              /* return OP_ERROR */
        }
        else
        #endif
        {
            type  = rx_ptr->Data[ET_PLT_TYPE_IDX];
8001486c:	6c 08       	ld.w	r8,r6[0x0]
            CmdDecodeWord(&lead_in,  &rx_ptr->Data[ET_PLT_LEADIN_IDX]);
8001486e:	fa cc ff fa 	sub	r12,sp,-6
80014872:	f0 cb ff fd 	sub	r11,r8,-3
            retval = CmdErrorMsg(tx_ptr, ERR_LENGTH);              /* return OP_ERROR */
        }
        else
        #endif
        {
            type  = rx_ptr->Data[ET_PLT_TYPE_IDX];
80014876:	11 a5       	ld.ub	r5,r8[0x2]
            CmdDecodeWord(&lead_in,  &rx_ptr->Data[ET_PLT_LEADIN_IDX]);
80014878:	fe b0 f9 45 	rcall	80013b02 <CmdDecodeWord>
            CmdDecodeLong(&duration, &rx_ptr->Data[ET_PLT_DURATION_IDX]);
8001487c:	1a 9c       	mov	r12,sp
8001487e:	6c 0b       	ld.w	r11,r6[0x0]
80014880:	2f bb       	sub	r11,-5
80014882:	fe b0 f9 5e 	rcall	80013b3e <CmdDecodeLong>
            CmdDecodeWord(&lead_out, &rx_ptr->Data[ET_PLT_LEADOUT_IDX]);
80014886:	6c 0b       	ld.w	r11,r6[0x0]
80014888:	fa cc ff fc 	sub	r12,sp,-4
8001488c:	2f 7b       	sub	r11,-9
8001488e:	fe b0 f9 3a 	rcall	80013b02 <CmdDecodeWord>

            /* range check */
            if (0x02 < type)
80014892:	30 28       	mov	r8,2
80014894:	f0 05 18 00 	cp.b	r5,r8
80014898:	e0 8b 00 1b 	brhi	800148ce <ET_PhysicalLayerTest_Start+0x76>
            {
                retval = CmdErrorParamWrong( tx_ptr, (byte)0x01, &rx_ptr->Data[ET_PLT_TYPE_IDX], (byte)sizeof(type));
            }
            else if (ET_PLT_DURATION_MIN > duration)
8001489c:	40 09       	lddsp	r9,sp[0x0]
8001489e:	e0 49 00 31 	cp.w	r9,49
800148a2:	e0 88 00 23 	brls	800148e8 <ET_PhysicalLayerTest_Start+0x90>
            }

            if (OP_RESULT == retval)
            {
                /* start state machine in VMSV and send ResultAck message from VMSV */
                if (ERR_NO == VmsvPhysicalLayerTestStart(rx_ptr, type, lead_in, duration, lead_out))
800148a6:	0c 9c       	mov	r12,r6
800148a8:	0a 9b       	mov	r11,r5
800148aa:	9a a8       	ld.uh	r8,sp[0x4]
800148ac:	9a ba       	ld.uh	r10,sp[0x6]
800148ae:	fe b0 d7 31 	rcall	8000f710 <VmsvPhysicalLayerTestStart>
800148b2:	18 96       	mov	r6,r12
800148b4:	c2 21       	brne	800148f8 <ET_PhysicalLayerTest_Start+0xa0>
                {
                    ET_PhysicalLayerTest_Status(MNS_TRUE);  /* inform application about start of PhysicalLayerTest */
800148b6:	30 1c       	mov	r12,1
800148b8:	fe b0 9c 60 	rcall	80008178 <ET_PhysicalLayerTest_Status>
800148bc:	0c 9c       	mov	r12,r6
800148be:	c0 58       	rjmp	800148c8 <ET_PhysicalLayerTest_Start+0x70>
            }
        }
    }
    else
    {
        retval = CmdErrorMsg(tx_ptr, ERR_FKTID);   /* FuncID not found */
800148c0:	0e 9c       	mov	r12,r7
800148c2:	30 3b       	mov	r11,3
800148c4:	fe b0 f9 58 	rcall	80013b74 <CmdErrorMsg>
    }

    return(retval);
}
800148c8:	2f ed       	sub	sp,-8
800148ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            CmdDecodeWord(&lead_out, &rx_ptr->Data[ET_PLT_LEADOUT_IDX]);

            /* range check */
            if (0x02 < type)
            {
                retval = CmdErrorParamWrong( tx_ptr, (byte)0x01, &rx_ptr->Data[ET_PLT_TYPE_IDX], (byte)sizeof(type));
800148ce:	6c 0a       	ld.w	r10,r6[0x0]
800148d0:	30 19       	mov	r9,1
800148d2:	2f ea       	sub	r10,-2
800148d4:	0e 9c       	mov	r12,r7
800148d6:	12 9b       	mov	r11,r9
800148d8:	fe b0 f9 5c 	rcall	80013b90 <CmdErrorParamWrong>
            else if (ET_PLT_DURATION_MIN > duration)
            {
                retval = CmdErrorParamWrong( tx_ptr, (byte)0x03, &rx_ptr->Data[ET_PLT_DURATION_IDX], (byte)sizeof(duration));
            }

            if (OP_RESULT == retval)
800148dc:	30 c8       	mov	r8,12
800148de:	f0 0c 18 00 	cp.b	r12,r8
800148e2:	cf 31       	brne	800148c8 <ET_PhysicalLayerTest_Start+0x70>
800148e4:	40 09       	lddsp	r9,sp[0x0]
800148e6:	ce 0b       	rjmp	800148a6 <ET_PhysicalLayerTest_Start+0x4e>
            {
                retval = CmdErrorParamWrong( tx_ptr, (byte)0x01, &rx_ptr->Data[ET_PLT_TYPE_IDX], (byte)sizeof(type));
            }
            else if (ET_PLT_DURATION_MIN > duration)
            {
                retval = CmdErrorParamWrong( tx_ptr, (byte)0x03, &rx_ptr->Data[ET_PLT_DURATION_IDX], (byte)sizeof(duration));
800148e8:	6c 0a       	ld.w	r10,r6[0x0]
800148ea:	30 49       	mov	r9,4
800148ec:	2f ba       	sub	r10,-5
800148ee:	30 3b       	mov	r11,3
800148f0:	0e 9c       	mov	r12,r7
800148f2:	fe b0 f9 4f 	rcall	80013b90 <CmdErrorParamWrong>
800148f6:	cf 3b       	rjmp	800148dc <ET_PhysicalLayerTest_Start+0x84>
                    ET_PhysicalLayerTest_Status(MNS_TRUE);  /* inform application about start of PhysicalLayerTest */
                    retval = OP_NO_REPORT;
                }
                else
                {
                    retval = CmdErrorMsg(tx_ptr, ERR_PROCESSING);
800148f8:	0e 9c       	mov	r12,r7
800148fa:	34 2b       	mov	r11,66
800148fc:	fe b0 f9 3c 	rcall	80013b74 <CmdErrorMsg>
80014900:	ce 4b       	rjmp	800148c8 <ET_PhysicalLayerTest_Start+0x70>
80014902:	d7 03       	nop

80014904 <ET_RReset_Set>:
80014904:	eb cd 40 c0 	pushm	r6-r7,lr
80014908:	30 18       	mov	r8,1
8001490a:	76 0a       	ld.w	r10,r11[0x0]
8001490c:	18 96       	mov	r6,r12
8001490e:	15 87       	ld.ub	r7,r10[0x0]
80014910:	f0 07 18 00 	cp.b	r7,r8
80014914:	e0 88 00 08 	brls	80014924 <ET_RReset_Set+0x20>
80014918:	30 19       	mov	r9,1
8001491a:	12 9b       	mov	r11,r9
8001491c:	fe b0 f9 3a 	rcall	80013b90 <CmdErrorParamWrong>
            }
        }
    }

    return(retval);
}
80014920:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        switch (settings)
        {
            case ET_MRR_SETTING_FACTORY:
            case ET_MRR_SETTING_CURRENT:
            {
                ET_MOSTRemoteReset_Request(rx_ptr->Src_Adr, settings);
80014924:	96 bc       	ld.uh	r12,r11[0x6]
80014926:	0e 9b       	mov	r11,r7
80014928:	fe b0 9c 27 	rcall	80008176 <ET_MOSTRemoteReset_Request>
                tx_ptr->Data[0] = settings;
8001492c:	6c 08       	ld.w	r8,r6[0x0]
8001492e:	b0 87       	st.b	r8[0x0],r7
                tx_ptr->Length  = ET_MRR_TX_LENGTH;
80014930:	30 cc       	mov	r12,12
80014932:	30 18       	mov	r8,1
80014934:	ac 28       	st.h	r6[0x4],r8
                retval = OP_STATUS;
                break;
80014936:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001493a:	d7 03       	nop

8001493c <ET_SystemState_Get>:
8001493c:	eb cd 40 e0 	pushm	r5-r7,lr
80014940:	20 1d       	sub	sp,4
80014942:	18 96       	mov	r6,r12
    if (INIC_SHADOW_INVALID_WORD == nwm_address)
    {
        nwm_address = (word)0x0000;               /* same behaviour as NmGetNWMAddr */
    }
    #else
    nwm_address = NmGetNWMAddr();           /* determined by module NETWM_S.C */
80014944:	e0 a0 05 be 	rcall	800154c0 <NmGetNWMAddr>
80014948:	fa c7 ff fc 	sub	r7,sp,-4
8001494c:	0e ec       	st.h	--r7,r12
    #endif

    tx_ptr->Data[0] = (NCS_OK == MostGetNCState()) ? ET_NCS_OK : ET_NCS_NOTOK;
8001494e:	6c 05       	ld.w	r5,r6[0x0]
80014950:	fe b0 d3 6e 	rcall	8000f02c <MostGetNCState>
80014954:	30 18       	mov	r8,1
80014956:	f0 0c 18 00 	cp.b	r12,r8
8001495a:	5f 18       	srne	r8
    CmdEncodeWord(&(tx_ptr->Data[1]), &nwm_address);
8001495c:	0e 9b       	mov	r11,r7
    }
    #else
    nwm_address = NmGetNWMAddr();           /* determined by module NETWM_S.C */
    #endif

    tx_ptr->Data[0] = (NCS_OK == MostGetNCState()) ? ET_NCS_OK : ET_NCS_NOTOK;
8001495e:	aa 88       	st.b	r5[0x0],r8
    CmdEncodeWord(&(tx_ptr->Data[1]), &nwm_address);
80014960:	6c 0c       	ld.w	r12,r6[0x0]
80014962:	2f fc       	sub	r12,-1
80014964:	fe b0 f8 ca 	rcall	80013af8 <CmdEncodeWord>
    tx_ptr->Length = (word)3;
80014968:	30 38       	mov	r8,3
    #else
    ET_SystemState_Request(tx_ptr->Tgt_Adr);
    return(OP_NO_REPORT);
    #endif

}
8001496a:	30 cc       	mov	r12,12
    nwm_address = NmGetNWMAddr();           /* determined by module NETWM_S.C */
    #endif

    tx_ptr->Data[0] = (NCS_OK == MostGetNCState()) ? ET_NCS_OK : ET_NCS_NOTOK;
    CmdEncodeWord(&(tx_ptr->Data[1]), &nwm_address);
    tx_ptr->Length = (word)3;
8001496c:	ac 28       	st.h	r6[0x4],r8
    #else
    ET_SystemState_Request(tx_ptr->Tgt_Adr);
    return(OP_NO_REPORT);
    #endif

}
8001496e:	2f fd       	sub	sp,-4
80014970:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80014974 <ET_Reset_Start>:
80014974:	d4 01       	pushm	lr
80014976:	fe b0 9c 8b 	rcall	8000828c <ET_Reset_Request>
8001497a:	d8 0a       	popm	pc,r12=0

8001497c <ET_CodingErrors_Get>:
8001497c:	eb cd 40 e0 	pushm	r5-r7,lr
| Parameter(s): ptr at message to send                                         |
| Returns     : OpType                                                         |
+------------------------------------------------------------------------------+
*/
byte ET_CodingErrors_Get(pTMsgTx tx_ptr)
{
80014980:	20 1d       	sub	sp,4
    byte retval = CMD_TX_RETAIN;

    if(MNS_FALSE != ET_CodingErrors.status)
80014982:	49 85       	lddpc	r5,800149e0 <ET_CodingErrors_Get+0x64>
| Parameter(s): ptr at message to send                                         |
| Returns     : OpType                                                         |
+------------------------------------------------------------------------------+
*/
byte ET_CodingErrors_Get(pTMsgTx tx_ptr)
{
80014984:	18 96       	mov	r6,r12
    byte retval = CMD_TX_RETAIN;

    if(MNS_FALSE != ET_CodingErrors.status)
80014986:	0b c9       	ld.ub	r9,r5[0x4]
80014988:	30 08       	mov	r8,0
8001498a:	f0 09 18 00 	cp.b	r9,r8
8001498e:	c0 a0       	breq	800149a2 <ET_CodingErrors_Get+0x26>
    {
        /* ON */

        /* check for busy */
        if(ET_CodingErrors.tx_ptr)
80014990:	6a 07       	ld.w	r7,r5[0x0]
80014992:	58 07       	cp.w	r7,0
80014994:	c1 a0       	breq	800149c8 <ET_CodingErrors_Get+0x4c>
        {
            retval = CmdErrorMsg(tx_ptr, ERR_BUSY);
80014996:	34 0b       	mov	r11,64
80014998:	fe b0 f8 ee 	rcall	80013b74 <CmdErrorMsg>

        retval = OP_STATUS;
    }

    return(retval);
}
8001499c:	2f fd       	sub	sp,-4
8001499e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    else
    {
        /* OFF */

        /* send the stored value of off_counter and reset it */
        dword val = (dword) ET_CodingErrors.off_counter;
800149a2:	8a b8       	ld.uh	r8,r5[0x6]
800149a4:	fa cb ff fc 	sub	r11,sp,-4
800149a8:	16 d8       	st.w	--r11,r8
        ET_CodingErrors.off_counter = (word)0;
800149aa:	30 08       	mov	r8,0
800149ac:	aa 38       	st.h	r5[0x6],r8

        tx_ptr->Data[0] = (byte)0x00;                   /* OFF */
800149ae:	78 09       	ld.w	r9,r12[0x0]
        CmdEncodeLong(&(tx_ptr->Data[1]), &val);
800149b0:	1a 9b       	mov	r11,sp

        /* send the stored value of off_counter and reset it */
        dword val = (dword) ET_CodingErrors.off_counter;
        ET_CodingErrors.off_counter = (word)0;

        tx_ptr->Data[0] = (byte)0x00;                   /* OFF */
800149b2:	b2 88       	st.b	r9[0x0],r8
        CmdEncodeLong(&(tx_ptr->Data[1]), &val);
800149b4:	78 0c       	ld.w	r12,r12[0x0]
800149b6:	2f fc       	sub	r12,-1
800149b8:	fe b0 f8 ae 	rcall	80013b14 <CmdEncodeLong>
        tx_ptr->Length = (word)5;
800149bc:	30 58       	mov	r8,5
800149be:	30 cc       	mov	r12,12
800149c0:	ac 28       	st.h	r6[0x4],r8

        retval = OP_STATUS;
    }

    return(retval);
}
800149c2:	2f fd       	sub	sp,-4
800149c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        }
        else
        {
            /* set ET_CodingErrors.tx_ptr since CB is called synchonously in
               case of an extended measurement */
            ET_CodingErrors.tx_ptr = tx_ptr;
800149c8:	8b 0c       	st.w	r5[0x0],r12

            if(ERR_NO != MostGetCodingErrors(ET_CodingErrors_CB))
800149ca:	fe cc ff e6 	sub	r12,pc,-26
800149ce:	fe b0 e8 9d 	rcall	80011b08 <MostGetCodingErrors>
            {
                /* we have not used the tx_ptr */
                ET_CodingErrors.tx_ptr = NULL;
800149d2:	c0 50       	breq	800149dc <ET_CodingErrors_Get+0x60>
800149d4:	8b 07       	st.w	r5[0x0],r7
800149d6:	e0 6c 00 80 	mov	r12,128
        {
            /* set ET_CodingErrors.tx_ptr since CB is called synchonously in
               case of an extended measurement */
            ET_CodingErrors.tx_ptr = tx_ptr;

            if(ERR_NO != MostGetCodingErrors(ET_CodingErrors_CB))
800149da:	ce 1b       	rjmp	8001499c <ET_CodingErrors_Get+0x20>
800149dc:	34 0c       	mov	r12,64
800149de:	cd fb       	rjmp	8001499c <ET_CodingErrors_Get+0x20>
800149e0:	00 00       	add	r0,r0
800149e2:	3b 38       	mov	r8,-77

800149e4 <ET_CodingErrors_CB>:
800149e4:	eb cd 40 80 	pushm	r7,lr
800149e8:	20 1d       	sub	sp,4
800149ea:	49 a8       	lddpc	r8,80014a50 <ET_CodingErrors_CB+0x6c>
800149ec:	11 c9       	ld.ub	r9,r8[0x4]
800149ee:	58 09       	cp.w	r9,0
800149f0:	c2 c0       	breq	80014a48 <ET_CodingErrors_CB+0x64>
800149f2:	70 07       	ld.w	r7,r8[0x0]
{
    if(MNS_FALSE != ET_CodingErrors.status)
    {
        /* ON */

        if((ET_CodingErrors.tx_ptr) && (NSR_E_BUSY != result))
800149f4:	58 07       	cp.w	r7,0
800149f6:	5f 1a       	srne	r10
800149f8:	fe 7e 81 00 	mov	lr,-32512
800149fc:	fc 0c 19 00 	cp.h	r12,lr
80014a00:	5f 1e       	srne	lr
80014a02:	14 6e       	and	lr,r10
80014a04:	30 0a       	mov	r10,0
80014a06:	f4 0e 18 00 	cp.b	lr,r10
80014a0a:	c1 c0       	breq	80014a42 <ET_CodingErrors_CB+0x5e>
        {
            /* recover tx_ptr and send status message */
            dword   val    = (dword) coding_errors;
80014a0c:	5c 7b       	castu.h	r11
            TMsgTx *tx_ptr = ET_CodingErrors.tx_ptr;
            ET_CodingErrors.tx_ptr = NULL;
80014a0e:	30 0a       	mov	r10,0
        /* ON */

        if((ET_CodingErrors.tx_ptr) && (NSR_E_BUSY != result))
        {
            /* recover tx_ptr and send status message */
            dword   val    = (dword) coding_errors;
80014a10:	50 0b       	stdsp	sp[0x0],r11
            TMsgTx *tx_ptr = ET_CodingErrors.tx_ptr;
            ET_CodingErrors.tx_ptr = NULL;
80014a12:	91 0a       	st.w	r8[0x0],r10

            if(NSR_S_CE_EXT_RESULT == result)
80014a14:	e0 6b 01 03 	mov	r11,259
            {
                ET_CodingErrors.status = MNS_FALSE; /* auto switch OFF */
80014a18:	f6 0c 19 00 	cp.h	r12,r11
80014a1c:	f1 fa 0e 04 	st.beq	r8[0x4],r10
80014a20:	f4 09 17 00 	moveq	r9,r10
            }

            tx_ptr->Data[0] = (MNS_FALSE != ET_CodingErrors.status) ? (byte)0x01 : (byte)0x00;
80014a24:	6e 08       	ld.w	r8,r7[0x0]
            CmdEncodeLong(&(tx_ptr->Data[1]), &val);
80014a26:	1a 9b       	mov	r11,sp
            if(NSR_S_CE_EXT_RESULT == result)
            {
                ET_CodingErrors.status = MNS_FALSE; /* auto switch OFF */
            }

            tx_ptr->Data[0] = (MNS_FALSE != ET_CodingErrors.status) ? (byte)0x01 : (byte)0x00;
80014a28:	b0 89       	st.b	r8[0x0],r9
            CmdEncodeLong(&(tx_ptr->Data[1]), &val);
80014a2a:	6e 0c       	ld.w	r12,r7[0x0]
80014a2c:	2f fc       	sub	r12,-1
80014a2e:	fe b0 f8 73 	rcall	80013b14 <CmdEncodeLong>
            tx_ptr->Length = (word)5;
80014a32:	30 58       	mov	r8,5
80014a34:	ae 28       	st.h	r7[0x4],r8
            tx_ptr->Operation = OP_STATUS;
80014a36:	30 c8       	mov	r8,12

            AmsMsgSend(tx_ptr);
80014a38:	0e 9c       	mov	r12,r7
            }

            tx_ptr->Data[0] = (MNS_FALSE != ET_CodingErrors.status) ? (byte)0x01 : (byte)0x00;
            CmdEncodeLong(&(tx_ptr->Data[1]), &val);
            tx_ptr->Length = (word)5;
            tx_ptr->Operation = OP_STATUS;
80014a3a:	ef 68 00 0c 	st.b	r7[12],r8

            AmsMsgSend(tx_ptr);
80014a3e:	fe b0 a7 9b 	rcall	80009974 <MsgSend>
        /* OFF */

        /* just store the off_counter for use in .Get */
        ET_CodingErrors.off_counter = coding_errors;
    }
}
80014a42:	2f fd       	sub	sp,-4
80014a44:	e3 cd 80 80 	ldm	sp++,r7,pc
    else
    {
        /* OFF */

        /* just store the off_counter for use in .Get */
        ET_CodingErrors.off_counter = coding_errors;
80014a48:	b0 3b       	st.h	r8[0x6],r11
    }
}
80014a4a:	2f fd       	sub	sp,-4
80014a4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80014a50:	00 00       	add	r0,r0
80014a52:	3b 38       	mov	r8,-77

80014a54 <ET_CodingErrors_Set>:
80014a54:	eb cd 40 c0 	pushm	r6-r7,lr
80014a58:	20 1d       	sub	sp,4
80014a5a:	30 58       	mov	r8,5
| Returns     : OP_NO_REPORT or OP_ERROR                                       |
+------------------------------------------------------------------------------+
*/
#ifdef FUNCID_ET_CODINGERRORS
byte ET_CodingErrors_Set(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
80014a5c:	16 97       	mov	r7,r11
80014a5e:	18 96       	mov	r6,r12
    byte length;
    word timeout;

    retval = OP_NO_REPORT;                                /* default: no status */

    length = (byte) rx_ptr->Length;
80014a60:	96 29       	ld.sh	r9,r11[0x4]
80014a62:	f0 09 18 00 	cp.b	r9,r8
80014a66:	c1 01       	brne	80014a86 <ET_CodingErrors_Set+0x32>
    if (length != (byte)5)
    {
        return(CmdErrorMsg(tx_ptr, ERR_LENGTH));              /* return OP_ERROR */
    }

    ce_mode = rx_ptr->Data[0];
80014a68:	76 0a       	ld.w	r10,r11[0x0]
    switch(ce_mode)
80014a6a:	15 88       	ld.ub	r8,r10[0x0]
80014a6c:	58 08       	cp.w	r8,0
80014a6e:	c1 20       	breq	80014a92 <ET_CodingErrors_Set+0x3e>
80014a70:	30 1b       	mov	r11,1
80014a72:	f6 08 18 00 	cp.b	r8,r11
80014a76:	c1 a0       	breq	80014aaa <ET_CodingErrors_Set+0x56>
            retval = OP_NO_REPORT;
            break;
        }
        default:
        {
            retval = CmdErrorParamWrong(tx_ptr, (byte)0x01, &(rx_ptr->Data[0]), (byte)0x01);
80014a78:	30 19       	mov	r9,1
80014a7a:	12 9b       	mov	r11,r9
80014a7c:	fe b0 f8 8a 	rcall	80013b90 <CmdErrorParamWrong>
            break;
        }
    }
    return(retval);
}
80014a80:	2f fd       	sub	sp,-4
80014a82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    length = (byte) rx_ptr->Length;

    if (length != (byte)5)
    {
        return(CmdErrorMsg(tx_ptr, ERR_LENGTH));              /* return OP_ERROR */
80014a86:	30 5b       	mov	r11,5
80014a88:	fe b0 f8 76 	rcall	80013b74 <CmdErrorMsg>
            retval = CmdErrorParamWrong(tx_ptr, (byte)0x01, &(rx_ptr->Data[0]), (byte)0x01);
            break;
        }
    }
    return(retval);
}
80014a8c:	2f fd       	sub	sp,-4
80014a8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    switch(ce_mode)
    {
        case ET_CE_OFF:                          /* Turning Off Coding Error Counting*/
        {
            /* set mode to OFF, that means status MNS_FALSE */
            ET_CodingErrors.status = MNS_FALSE;
80014a92:	49 99       	lddpc	r9,80014af4 <ET_CodingErrors_Set+0xa0>
            /* request current counter from INIC ... will be stored in off_counter */
            retval = (ERR_NO == MostGetCodingErrors(ET_CodingErrors_CB)) ? OP_NO_REPORT : CMD_RX_REPEAT;
80014a94:	fe cc 00 b0 	sub	r12,pc,176
80014a98:	b2 c8       	st.b	r9[0x4],r8
80014a9a:	fe b0 e8 37 	rcall	80011b08 <MostGetCodingErrors>
            retval = OP_NO_REPORT;
            break;
        }
        default:
        {
            retval = CmdErrorParamWrong(tx_ptr, (byte)0x01, &(rx_ptr->Data[0]), (byte)0x01);
80014a9e:	cf 10       	breq	80014a80 <ET_CodingErrors_Set+0x2c>
80014aa0:	e0 6c 00 80 	mov	r12,128
            break;
        }
    }
    return(retval);
}
80014aa4:	2f fd       	sub	sp,-4
80014aa6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        }
        case ET_CE_ON:                           /* Turning On Coding Error Counting*/
        {
            byte l1_result = ERR_NO;

            ET_CodingErrors.status      = MNS_TRUE;   /* mode "on" */
80014aaa:	49 39       	lddpc	r9,80014af4 <ET_CodingErrors_Set+0xa0>
            ET_CodingErrors.off_counter = (word)0;
80014aac:	b2 c8       	st.b	r9[0x4],r8
            (void)MostCountCodingErrors((word)0);  /* stop extended mode if running,
80014aae:	30 08       	mov	r8,0
        case ET_CE_ON:                           /* Turning On Coding Error Counting*/
        {
            byte l1_result = ERR_NO;

            ET_CodingErrors.status      = MNS_TRUE;   /* mode "on" */
            ET_CodingErrors.off_counter = (word)0;
80014ab0:	30 0c       	mov	r12,0
            (void)MostCountCodingErrors((word)0);  /* stop extended mode if running,
80014ab2:	b2 38       	st.h	r9[0x6],r8
80014ab4:	fe b0 e8 94 	rcall	80011bdc <MostCountCodingErrors>
                                             return value does not need to be checked
                                             since "stop" always works. */

            CmdDecodeWord(&timeout, &(rx_ptr->Data[3]));
80014ab8:	fa cc ff fe 	sub	r12,sp,-2
80014abc:	6e 0b       	ld.w	r11,r7[0x0]
80014abe:	2f db       	sub	r11,-3
80014ac0:	fe b0 f8 21 	rcall	80013b02 <CmdDecodeWord>

            if (  (timeout < WMCS_CE_TIMEOUT_MIN))
80014ac4:	9a 1c       	ld.sh	r12,sp[0x2]
80014ac6:	31 88       	mov	r8,24
80014ac8:	f0 0c 19 00 	cp.h	r12,r8
80014acc:	e0 88 00 0c 	brls	80014ae4 <ET_CodingErrors_Set+0x90>
            {
                return(CmdErrorParamWrong(tx_ptr, (byte)3, &(rx_ptr->Data[2]), (byte)2));
            }


            l1_result = MostCountCodingErrors(timeout);
80014ad0:	5c 7c       	castu.h	r12
80014ad2:	fe b0 e8 85 	rcall	80011bdc <MostCountCodingErrors>
            if(ERR_BUFOV == l1_result)
80014ad6:	30 48       	mov	r8,4
80014ad8:	f0 0c 18 00 	cp.b	r12,r8
80014adc:	ce 20       	breq	80014aa0 <ET_CodingErrors_Set+0x4c>
80014ade:	2f fd       	sub	sp,-4
80014ae0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

            CmdDecodeWord(&timeout, &(rx_ptr->Data[3]));

            if (  (timeout < WMCS_CE_TIMEOUT_MIN))
            {
                return(CmdErrorParamWrong(tx_ptr, (byte)3, &(rx_ptr->Data[2]), (byte)2));
80014ae4:	6e 0a       	ld.w	r10,r7[0x0]
80014ae6:	0c 9c       	mov	r12,r6
80014ae8:	2f ea       	sub	r10,-2
80014aea:	30 29       	mov	r9,2
80014aec:	30 3b       	mov	r11,3
80014aee:	fe b0 f8 51 	rcall	80013b90 <CmdErrorParamWrong>
80014af2:	cc 7b       	rjmp	80014a80 <ET_CodingErrors_Set+0x2c>
80014af4:	00 00       	add	r0,r0
80014af6:	3b 38       	mov	r8,-77

80014af8 <ET_CalcMsgBufSize_Rx>:
80014af8:	eb cd 40 c0 	pushm	r6-r7,lr
80014afc:	30 07       	mov	r7,0
80014afe:	16 96       	mov	r6,r11
80014b00:	b8 07       	st.h	r12[0x0],r7
80014b02:	fe b0 a1 49 	rcall	80008d94 <MsgGetSegMode>
80014b06:	30 28       	mov	r8,2
80014b08:	f0 0c 18 00 	cp.b	r12,r8
80014b0c:	c0 d0       	breq	80014b26 <ET_CalcMsgBufSize_Rx+0x2e>
80014b0e:	3e e8       	mov	r8,-18

    if (MSG_SEG_INIC_ONLY == seg_mode)
    {
        *length = MBS_CTRL_MAX_PAYLOAD;
    }
    else if (INIC_SHADOW_INVALID_BYTE != seg_mode)
80014b10:	f0 0c 18 00 	cp.b	r12,r8
80014b14:	c0 60       	breq	80014b20 <ET_CalcMsgBufSize_Rx+0x28>
    {
        #if PMS_RX_SEG_PREALLOC_SIZE
        *length = PMS_RX_SEG_PREALLOC_SIZE;
80014b16:	e0 68 00 f0 	mov	r8,240
80014b1a:	ac 08       	st.h	r6[0x0],r8
80014b1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        *length = MBS_DYN_MEM_ALLOC;
        #endif
    }
    else
    {
        *length = MBS_DYN_MEM_ALLOC;
80014b20:	ac 07       	st.h	r6[0x0],r7
80014b22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    /* and  use of preallocated buffers                 */
    seg_mode = MsgGetSegMode();

    if (MSG_SEG_INIC_ONLY == seg_mode)
    {
        *length = MBS_CTRL_MAX_PAYLOAD;
80014b26:	32 d8       	mov	r8,45
80014b28:	ac 08       	st.h	r6[0x0],r8
80014b2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80014b2e:	d7 03       	nop

80014b30 <ET_MsgBufSize_Get>:
80014b30:	d4 21       	pushm	r4-r7,lr
80014b32:	20 2d       	sub	sp,8
| Returns     : OpType                                                         |
+------------------------------------------------------------------------------+
*/
#ifdef FUNCID_ET_MESSAGEBUFSIZE
byte ET_MsgBufSize_Get(pTMsgTx tx_ptr)
{
80014b34:	18 97       	mov	r7,r12
    word length_tx;
    byte shared;
    byte retval;


    ET_CalcMsgBufSize_Rx(&count_rx, &length_rx);
80014b36:	fa c5 ff fc 	sub	r5,sp,-4
80014b3a:	fa c4 ff fa 	sub	r4,sp,-6
80014b3e:	0a 9b       	mov	r11,r5
80014b40:	08 9c       	mov	r12,r4
80014b42:	cd bf       	rcall	80014af8 <ET_CalcMsgBufSize_Rx>
80014b44:	30 08       	mov	r8,0
+------------------------------------------------------------------------------+
*/
#if (defined FUNCID_ET_MESSAGEBUFSIZE) || (defined FUNCID_ET_SENDMESSAGE)
void ET_CalcMsgBufSize_Tx(word *num, word *length)
{
    *num = MBS_DYN_MEM_ALLOC;
80014b46:	ba 08       	st.h	sp[0x0],r8

    #ifdef AMS_TX_NOSEG
    *length = MBS_CTRL_MAX_PAYLOAD;
    #else
    *length = MBS_DYN_MEM_ALLOC;
80014b48:	ba 18       	st.h	sp[0x2],r8
+------------------------------------------------------------------------------+
*/
#if (defined FUNCID_ET_MESSAGEBUFSIZE) || (defined FUNCID_ET_SENDMESSAGE)
void ET_CalcMsgBufSize_Tx(word *num, word *length)
{
    *num = MBS_DYN_MEM_ALLOC;
80014b4a:	fe b0 9b 14 	rcall	80008172 <ET_SharedRxTxMsgBuf_Query>


    ET_CalcMsgBufSize_Rx(&count_rx, &length_rx);
    ET_CalcMsgBufSize_Tx(&count_tx, &length_tx);

    shared = ET_SharedRxTxMsgBuf_Query();    /* callback ... shared buffer use? */
80014b4e:	30 18       	mov	r8,1

    switch (shared)
80014b50:	18 96       	mov	r6,r12


    ET_CalcMsgBufSize_Rx(&count_rx, &length_rx);
    ET_CalcMsgBufSize_Tx(&count_tx, &length_tx);

    shared = ET_SharedRxTxMsgBuf_Query();    /* callback ... shared buffer use? */
80014b52:	f0 0c 18 00 	cp.b	r12,r8

    switch (shared)
80014b56:	e0 88 00 08 	brls	80014b66 <ET_MsgBufSize_Get+0x36>
80014b5a:	0e 9c       	mov	r12,r7
            break;
        }

        default:
        {
            retval = CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC);
80014b5c:	30 bb       	mov	r11,11
80014b5e:	fe b0 f8 0b 	rcall	80013b74 <CmdErrorMsg>
80014b62:	2f ed       	sub	sp,-8
            break;
        }
    }

    return(retval);
}
80014b64:	d8 22       	popm	r4-r7,pc
80014b66:	08 9b       	mov	r11,r4
    {
        case MBS_SHARED:
        case MBS_NOT_SHARED:
        {
            /* prepare tx msg in exact order as described in the FB proposal */
            CmdEncodeWord(&(tx_ptr->Data[MBS_PARAM_COUNT_RX]),  &count_rx);
80014b68:	6e 0c       	ld.w	r12,r7[0x0]
80014b6a:	fe b0 f7 c7 	rcall	80013af8 <CmdEncodeWord>
80014b6e:	0a 9b       	mov	r11,r5
            CmdEncodeWord(&(tx_ptr->Data[MBS_PARAM_LENGTH_RX]), &length_rx);
80014b70:	6e 0c       	ld.w	r12,r7[0x0]
80014b72:	2f ec       	sub	r12,-2
80014b74:	fe b0 f7 c2 	rcall	80013af8 <CmdEncodeWord>
80014b78:	fa cb ff fe 	sub	r11,sp,-2
            CmdEncodeWord(&(tx_ptr->Data[MBS_PARAM_COUNT_TX]),  &count_tx);
80014b7c:	6e 0c       	ld.w	r12,r7[0x0]
80014b7e:	2f cc       	sub	r12,-4
80014b80:	fe b0 f7 bc 	rcall	80013af8 <CmdEncodeWord>
80014b84:	6e 0c       	ld.w	r12,r7[0x0]
            CmdEncodeWord(&(tx_ptr->Data[MBS_PARAM_LENGTH_TX]), &length_tx);
80014b86:	1a 9b       	mov	r11,sp
80014b88:	2f ac       	sub	r12,-6
80014b8a:	fe b0 f7 b7 	rcall	80013af8 <CmdEncodeWord>
80014b8e:	6e 08       	ld.w	r8,r7[0x0]
            tx_ptr->Data[MBS_PARAM_SHARED] = shared;
80014b90:	f1 66 00 08 	st.b	r8[8],r6
80014b94:	30 cc       	mov	r12,12
            tx_ptr->Length = MBS_LENGTH;
80014b96:	30 98       	mov	r8,9
80014b98:	ae 28       	st.h	r7[0x4],r8
80014b9a:	2f ed       	sub	sp,-8
            break;
        }
    }

    return(retval);
}
80014b9c:	d8 22       	popm	r4-r7,pc
80014b9e:	d7 03       	nop

80014ba0 <ET_Shutdown>:
80014ba0:	eb cd 40 e0 	pushm	r5-r7,lr
80014ba4:	20 1d       	sub	sp,4
80014ba6:	30 25       	mov	r5,2
80014ba8:	76 0a       	ld.w	r10,r11[0x0]
80014baa:	18 97       	mov	r7,r12
80014bac:	15 86       	ld.ub	r6,r10[0x0]
80014bae:	ea 06 18 00 	cp.b	r6,r5
    }
    #endif

    type = rx_ptr->Data[ET_SDN_TYPE];

    switch (type)                                              /* range check */
80014bb2:	e0 8b 00 16 	brhi	80014bde <ET_Shutdown+0x3e>
    {
        case ET_SHUTDOWN_IF_POWERMASTER:
        case ET_SHUTDOWN_SIM_DEAD_TEMPERATURE:
        case ET_SHUTDOWN_SIM_SHUTDOWN_TEMPERATURE:
        {
            result = ET_Shutdown_Request(type);
80014bb6:	50 0b       	stdsp	sp[0x0],r11
80014bb8:	0c 9c       	mov	r12,r6
80014bba:	fe b0 9b 8d 	rcall	800082d4 <ET_Shutdown_Request>
        }
    }

    if (OP_NO_REPORT == retval)
    {
        switch (result)
80014bbe:	30 18       	mov	r8,1
80014bc0:	40 0b       	lddsp	r11,sp[0x0]
80014bc2:	f0 0c 18 00 	cp.b	r12,r8
80014bc6:	c1 10       	breq	80014be8 <ET_Shutdown+0x48>
80014bc8:	c1 73       	brcs	80014bf6 <ET_Shutdown+0x56>
80014bca:	ea 0c 18 00 	cp.b	r12,r5
80014bce:	c1 70       	breq	80014bfc <ET_Shutdown+0x5c>
                }
                /*lint --e(616) the missing break statement is by design; ERR_DEVICE_MALFUNC ... */
            }
            default:                                   /* unexpected return value */
            {
                retval = CmdErrorMsg(tx_ptr, ERR_DEVICE_MALFUNC);
80014bd0:	0e 9c       	mov	r12,r7
80014bd2:	30 bb       	mov	r11,11
80014bd4:	fe b0 f7 d0 	rcall	80013b74 <CmdErrorMsg>
            }
        }   /* switch  (result) */
    } /* if (OP_NO_REPORT == retval) */

    return(retval);
}
80014bd8:	2f fd       	sub	sp,-4
80014bda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            result = ET_Shutdown_Request(type);
            break;
        }
        default:
        {
            retval = CmdErrorParamWrong(tx_ptr,                     /* Ptr at message to send */
80014bde:	30 19       	mov	r9,1
80014be0:	12 9b       	mov	r11,r9
80014be2:	fe b0 f7 d7 	rcall	80013b90 <CmdErrorParamWrong>

            break;
        }
    }

    if (OP_NO_REPORT == retval)
80014be6:	cf 91       	brne	80014bd8 <ET_Shutdown+0x38>
            {
                break;
            }
            case ET_SDN_UNABLE_TO_PROCESS:                         /* cannot process */
            {
                retval = CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
80014be8:	0e 9c       	mov	r12,r7
80014bea:	34 1b       	mov	r11,65
80014bec:	fe b0 f7 c4 	rcall	80013b74 <CmdErrorMsg>
            }
        }   /* switch  (result) */
    } /* if (OP_NO_REPORT == retval) */

    return(retval);
}
80014bf0:	2f fd       	sub	sp,-4
80014bf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        }
    }

    if (OP_NO_REPORT == retval)
    {
        switch (result)
80014bf6:	2f fd       	sub	sp,-4
80014bf8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
                retval = CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
                break;
            }
            case ET_SDN_NOT_POWERMASTER:                 /* cannot handle type==0x00 */
            {
                if (ET_SHUTDOWN_IF_POWERMASTER == type)
80014bfc:	58 06       	cp.w	r6,0
80014bfe:	ce 91       	brne	80014bd0 <ET_Shutdown+0x30>
                {
                    retval = CmdErrorParamNotAvailable(tx_ptr, (byte)0x01,
80014c00:	76 0a       	ld.w	r10,r11[0x0]
80014c02:	30 19       	mov	r9,1
80014c04:	0e 9c       	mov	r12,r7
80014c06:	12 9b       	mov	r11,r9
80014c08:	fe b0 f7 e1 	rcall	80013bca <CmdErrorParamNotAvailable>
                                                       &rx_ptr->Data[ET_SDN_TYPE], (byte)0x01);
                    break;
80014c0c:	ce 6b       	rjmp	80014bd8 <ET_Shutdown+0x38>
80014c0e:	d7 03       	nop

80014c10 <ET_AutoWakeup_Set>:
80014c10:	d4 01       	pushm	lr
80014c12:	76 09       	ld.w	r9,r11[0x0]
80014c14:	13 88       	ld.ub	r8,r9[0x0]
80014c16:	58 08       	cp.w	r8,0
80014c18:	c1 00       	breq	80014c38 <ET_AutoWakeup_Set+0x28>
80014c1a:	f2 ca ff ff 	sub	r10,r9,-1
80014c1e:	30 0b       	mov	r11,0
        ET_AutoWakeup_Params.delay    = (byte)0x00;
        ET_AutoWakeup_Params.diag     = MNS_FALSE;
        ET_AutoWakeup_Params.duration = ET_AWU_DURATION_INFINITE;
    }
    #ifndef CAPABILITY_TO_WAKE
    else if ((byte)0 == (rx_ptr->Data[ET_AWU_PARAM_DIAGNOSIS]) )                    /* no diagnosis         */
80014c20:	15 8e       	ld.ub	lr,r10[0x0]
80014c22:	f6 0e 18 00 	cp.b	lr,r11
80014c26:	c0 f0       	breq	80014c44 <ET_AutoWakeup_Set+0x34>
                                           0x01);                                   /* Number of bytes of failed parameter data type */
    }
    #endif
    else
    {
        ET_AutoWakeup_Params.delay    = rx_ptr->Data[ET_AWU_PARAM_DELAY];
80014c28:	48 aa       	lddpc	r10,80014c50 <ET_AutoWakeup_Set+0x40>
80014c2a:	b4 88       	st.b	r10[0x0],r8
        ET_AutoWakeup_Params.diag     = ((byte)0 != rx_ptr->Data[ET_AWU_PARAM_DIAGNOSIS]) ? MNS_TRUE : MNS_FALSE;
80014c2c:	30 18       	mov	r8,1
        ET_AutoWakeup_Params.duration = rx_ptr->Data[ET_AWU_PARAM_DURATION];
80014c2e:	30 0c       	mov	r12,0
    }
    #endif
    else
    {
        ET_AutoWakeup_Params.delay    = rx_ptr->Data[ET_AWU_PARAM_DELAY];
        ET_AutoWakeup_Params.diag     = ((byte)0 != rx_ptr->Data[ET_AWU_PARAM_DIAGNOSIS]) ? MNS_TRUE : MNS_FALSE;
80014c30:	b4 98       	st.b	r10[0x1],r8
        ET_AutoWakeup_Params.duration = rx_ptr->Data[ET_AWU_PARAM_DURATION];
80014c32:	13 b8       	ld.ub	r8,r9[0x3]
80014c34:	b4 a8       	st.b	r10[0x2],r8
    }

    return(retval);
}
80014c36:	d8 02       	popm	pc

    retval = OP_NO_REPORT;

    if ((byte)0 == rx_ptr->Data[ET_AWU_PARAM_DELAY])                                /* AutoWakeup is disabld */
    {
        ET_AutoWakeup_Params.delay    = (byte)0x00;
80014c38:	48 69       	lddpc	r9,80014c50 <ET_AutoWakeup_Set+0x40>
        ET_AutoWakeup_Params.diag     = MNS_FALSE;
        ET_AutoWakeup_Params.duration = ET_AWU_DURATION_INFINITE;
80014c3a:	10 9c       	mov	r12,r8
80014c3c:	b2 a8       	st.b	r9[0x2],r8

    retval = OP_NO_REPORT;

    if ((byte)0 == rx_ptr->Data[ET_AWU_PARAM_DELAY])                                /* AutoWakeup is disabld */
    {
        ET_AutoWakeup_Params.delay    = (byte)0x00;
80014c3e:	b2 88       	st.b	r9[0x0],r8
        ET_AutoWakeup_Params.diag     = MNS_FALSE;
80014c40:	b2 98       	st.b	r9[0x1],r8
80014c42:	d8 02       	popm	pc
        ET_AutoWakeup_Params.duration = ET_AWU_DURATION_INFINITE;
    }
    #ifndef CAPABILITY_TO_WAKE
    else if ((byte)0 == (rx_ptr->Data[ET_AWU_PARAM_DIAGNOSIS]) )                    /* no diagnosis         */
    {
        retval = CmdErrorParamNotAvailable(tx_ptr,                                  /* Ptr at message to send */
80014c44:	30 19       	mov	r9,1
80014c46:	30 2b       	mov	r11,2
80014c48:	fe b0 f7 c1 	rcall	80013bca <CmdErrorParamNotAvailable>
80014c4c:	d8 02       	popm	pc
80014c4e:	d7 03       	nop
80014c50:	00 00       	add	r0,r0
80014c52:	3b 34       	mov	r4,-77

80014c54 <MnsPending2Set>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef MNS2_10
void MnsPending2Set(word flags)
{
    MnsPending2 |= flags;
80014c54:	48 38       	lddpc	r8,80014c60 <MnsPending2Set+0xc>
80014c56:	90 09       	ld.sh	r9,r8[0x0]
80014c58:	f9 e9 10 09 	or	r9,r12,r9
80014c5c:	b0 09       	st.h	r8[0x0],r9
}
80014c5e:	5e fc       	retal	r12
80014c60:	00 00       	add	r0,r0
80014c62:	4a 32       	lddpc	r2,80014cec <InitNetServicesLayer2+0x10>

80014c64 <MnsPending2SetAndCall>:
/* Returns     : Nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef MNS2_11
void MnsPending2SetAndCall(word flags)
{
80014c64:	d4 01       	pushm	lr
    MnsPending2 |= flags;
80014c66:	48 58       	lddpc	r8,80014c78 <MnsPending2SetAndCall+0x14>
80014c68:	90 09       	ld.sh	r9,r8[0x0]
80014c6a:	12 4c       	or	r12,r9
80014c6c:	b0 0c       	st.h	r8[0x0],r12
    flags = MnsPending2;
    MnsRequestLayer2(flags);
80014c6e:	5c 7c       	castu.h	r12
80014c70:	fe b0 b3 c2 	rcall	8000b3f4 <MnsRequestLayer2>
}
80014c74:	d8 02       	popm	pc
80014c76:	d7 03       	nop
80014c78:	00 00       	add	r0,r0
80014c7a:	4a 32       	lddpc	r2,80014d04 <InitNetServicesLayer2+0x28>

80014c7c <MostServiceLayer2>:
80014c7c:	eb cd 40 c0 	pushm	r6-r7,lr
    #ifdef MNS2_OPT_1
    word ret;
    #endif

    #ifdef MNS2_OPT_1
    MnsPending2 |= (events & (MNS2_E_MASK));    /* capture relevant events */
80014c80:	49 67       	lddpc	r7,80014cd8 <MostServiceLayer2+0x5c>
80014c82:	e2 1b 00 0a 	andl	r11,0xa,COH
80014c86:	8e 08       	ld.sh	r8,r7[0x0]
80014c88:	10 4b       	or	r11,r8
/*               - 0xFFFF, if MNS2_OPT_1 is not defined in adjust2.h        */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef MNS2_1
word MostServiceLayer2(word opt, word events)
{
80014c8a:	18 96       	mov	r6,r12
    #ifdef MNS2_OPT_1
    word ret;
    #endif

    #ifdef MNS2_OPT_1
    MnsPending2 |= (events & (MNS2_E_MASK));    /* capture relevant events */
80014c8c:	ae 0b       	st.h	r7[0x0],r11
    #endif

    if (MNS_NET_ON == MostGetState())       /* Check state of MOST Supervisor */
80014c8e:	fe b0 d8 97 	rcall	8000fdbc <MostGetState>
80014c92:	30 48       	mov	r8,4
80014c94:	f0 0c 18 00 	cp.b	r12,r8
80014c98:	c0 60       	breq	80014ca4 <MostServiceLayer2+0x28>

    }
    #ifdef MNS2_OPT_1
    else
    {
        MnsPending2 = (word)0;                          /* Clear request flags, since not in MNS_NET_ON state */
80014c9a:	30 08       	mov	r8,0
80014c9c:	30 0c       	mov	r12,0
80014c9e:	ae 08       	st.h	r7[0x0],r8
    ret = MnsPending2;                                  /* Return Pending Flags */
    return(ret);
    #else
    return (0xFFFF);
    #endif
}
80014ca0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    if (MNS_NET_ON == MostGetState())       /* Check state of MOST Supervisor */
    {
        #ifdef MSV2_MIN
        #ifdef MNS2_OPT_1
        MnsPending2 &= MNS2_P_MASK;     /* mask used flags */
        MnsPending2 &= ~(word)(MNS2_P_MSV2_STATE | MNS2_P_MSV2_TIMEOUT);
80014ca4:	8e 08       	ld.sh	r8,r7[0x0]
80014ca6:	e2 18 00 10 	andl	r8,0x10,COH
        #ifdef NB_MIN
        NbService();
        #endif

        #ifdef MNS2_OPT_2
        if (!(opt&MNS2_O_NO_AH))
80014caa:	5c 76       	castu.h	r6
    if (MNS_NET_ON == MostGetState())       /* Check state of MOST Supervisor */
    {
        #ifdef MSV2_MIN
        #ifdef MNS2_OPT_1
        MnsPending2 &= MNS2_P_MASK;     /* mask used flags */
        MnsPending2 &= ~(word)(MNS2_P_MSV2_STATE | MNS2_P_MSV2_TIMEOUT);
80014cac:	ae 08       	st.h	r7[0x0],r8
        }
        #endif
        #endif

        #ifdef NB_MIN
        NbService();
80014cae:	cb fc       	rcall	80014e2c <NbService>
80014cb0:	ed b6 00 00 	bld	r6,0x0
        #endif

        #ifdef MNS2_OPT_2
        if (!(opt&MNS2_O_NO_AH))
80014cb4:	c0 81       	brne	80014cc4 <MostServiceLayer2+0x48>
80014cb6:	8e 08       	ld.sh	r8,r7[0x0]
80014cb8:	e2 16 00 02 	andl	r6,0x2,COH
            AddrHService();                             /* Address Search Handler */
            #endif
        }

        #ifdef MNS2_OPT_2
        if (!(opt&MNS2_O_NO_NTFS))
80014cbc:	c0 90       	breq	80014cce <MostServiceLayer2+0x52>
80014cbe:	8e 0c       	ld.sh	r12,r7[0x0]
            #ifdef MNS2_OPT_1
            MnsPending2 &= ~MNS2_P_NTFS;
            #endif

            #ifdef NTF_1
            NtfService();                               /* Notification Service */
80014cc0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80014cc4:	8e 08       	ld.sh	r8,r7[0x0]
        #ifdef MNS2_OPT_2
        if (!(opt&MNS2_O_NO_AH))
        #endif
        {
            #ifdef MNS2_OPT_1
            MnsPending2 &= ~(word)(MNS2_P_AH_STATE | MNS2_P_AH_TIMEOUT);
80014cc6:	e0 18 ff f3 	andl	r8,0xfff3
80014cca:	ae 08       	st.h	r7[0x0],r8
80014ccc:	cf 6b       	rjmp	80014cb8 <MostServiceLayer2+0x3c>
80014cce:	a5 c8       	cbr	r8,0x4
        #ifdef MNS2_OPT_2
        if (!(opt&MNS2_O_NO_NTFS))
        #endif
        {
            #ifdef MNS2_OPT_1
            MnsPending2 &= ~MNS2_P_NTFS;
80014cd0:	ae 08       	st.h	r7[0x0],r8
80014cd2:	e0 a0 09 73 	rcall	80015fb8 <NtfService>
            #endif

            #ifdef NTF_1
            NtfService();                               /* Notification Service */
80014cd6:	cf 4b       	rjmp	80014cbe <MostServiceLayer2+0x42>
80014cd8:	00 00       	add	r0,r0
80014cda:	4a 32       	lddpc	r2,80014d64 <ConfigStateFilterV2+0x4c>

80014cdc <InitNetServicesLayer2>:
80014cdc:	eb cd 40 80 	pushm	r7,lr
80014ce0:	48 88       	lddpc	r8,80014d00 <InitNetServicesLayer2+0x24>
80014ce2:	30 07       	mov	r7,0
80014ce4:	b0 07       	st.h	r8[0x0],r7
80014ce6:	c4 9d       	rcall	80014f78 <NbInit>
80014ce8:	fe b0 f6 f8 	rcall	80013ad8 <CmdInit>
    #ifdef AH_MIN
    AddrHInit();                                            /* Init Address Search Handler */
    #endif

    #ifdef CMD_MIN
    CmdInit();                                              /* Init MOST Command Interpreter */
80014cec:	c8 0c       	rcall	80014dec <MostSupervisor2Init>
    #endif

    #ifdef MSV2_MIN
    MostSupervisor2Init();                                  /* Init MOST Supervisor Layer II */
80014cee:	e0 a0 04 d1 	rcall	80015690 <NtfInit>
    #endif

    #ifdef NTF_0
    NtfInit();                                              /* Init Notification Service */
80014cf2:	fe b0 fd 3d 	rcall	8001476c <ET_Init>
    #endif

    #ifdef ET_MIN
    ET_Init();
80014cf6:	48 48       	lddpc	r8,80014d04 <InitNetServicesLayer2+0x28>
80014cf8:	b0 07       	st.h	r8[0x0],r7
    #endif

    #ifdef NETWORKMASTER_SHADOW                             /* Only if NetworkMaster Shadow available */
    NetworkMaster_Addr = (word)0x0000;                      /* Init NetworkMaster Address */
80014cfa:	e3 cd 80 80 	ldm	sp++,r7,pc
    #endif
}
80014cfe:	d7 03       	nop
80014d00:	00 00       	add	r0,r0
80014d02:	4a 32       	lddpc	r2,80014d8c <ConfigStatusChanged>
80014d04:	00 00       	add	r0,r0
80014d06:	4a 4a       	lddpc	r10,80014d94 <ConfigStatusChanged+0x8>

80014d08 <CheckConfigState>:
    else
    {
        return(MNS_TRUE);
    }
    #endif
}
80014d08:	5e ff       	retal	1
80014d0a:	d7 03       	nop

80014d0c <SetNWMAddressShadow>:
#endif

#ifdef MSV2_9
static void SetNWMAddressShadow(word address)
{
    NetworkMaster_Addr = address;
80014d0c:	48 28       	lddpc	r8,80014d14 <SetNWMAddressShadow+0x8>
80014d0e:	b0 0c       	st.h	r8[0x0],r12
}
80014d10:	5e fc       	retal	r12
80014d12:	d7 03       	nop
80014d14:	00 00       	add	r0,r0
80014d16:	4a 4a       	lddpc	r10,80014da4 <ConfigStatusChanged+0x18>

80014d18 <ConfigStateFilterV2>:
    byte fblock;

    result = MSG_TX_FILTER_CANCEL;


    if (MNS_FALSE != GetConfigStateFilterStatus())
80014d18:	49 58       	lddpc	r8,80014d6c <ConfigStateFilterV2+0x54>
80014d1a:	30 09       	mov	r9,0
80014d1c:	11 88       	ld.ub	r8,r8[0x0]
80014d1e:	f2 08 18 00 	cp.b	r8,r9
80014d22:	c2 40       	breq	80014d6a <ConfigStateFilterV2+0x52>
    {
        fblock = msg_ptr->FBlock_ID;
        if (   (FBLOCK_NETBLOCK      == fblock)
80014d24:	30 fa       	mov	r10,15
    result = MSG_TX_FILTER_CANCEL;


    if (MNS_FALSE != GetConfigStateFilterStatus())
    {
        fblock = msg_ptr->FBlock_ID;
80014d26:	f9 38 00 0a 	ld.ub	r8,r12[10]
        if (   (FBLOCK_NETBLOCK      == fblock)
80014d2a:	f4 08 18 00 	cp.b	r8,r10
80014d2e:	5f 0b       	sreq	r11
80014d30:	30 2a       	mov	r10,2
80014d32:	f0 0a 18 00 	cp.b	r10,r8
80014d36:	f9 ba 02 01 	movhs	r10,1
80014d3a:	f2 0a 17 30 	movlo	r10,r9
80014d3e:	f7 ea 10 0a 	or	r10,r11,r10
80014d42:	f2 0a 18 00 	cp.b	r10,r9
80014d46:	c1 21       	brne	80014d6a <ConfigStateFilterV2+0x52>
80014d48:	30 99       	mov	r9,9
80014d4a:	f2 08 18 00 	cp.b	r8,r9
80014d4e:	c0 e0       	breq	80014d6a <ConfigStateFilterV2+0x52>
            byte i;         /* list will not exceed byte range */
            byte list[] = {CFG_STATE_FILTER_EXCEPTION_LIST};

            for (i=(byte)0; i<(byte)sizeof(list); ++i)
            {
                if (list[i] == fblock)
80014d50:	32 49       	mov	r9,36
80014d52:	f2 08 18 00 	cp.b	r8,r9
80014d56:	c0 a0       	breq	80014d6a <ConfigStateFilterV2+0x52>
80014d58:	30 e9       	mov	r9,14
80014d5a:	f2 08 18 00 	cp.b	r8,r9
80014d5e:	c0 60       	breq	80014d6a <ConfigStateFilterV2+0x52>
80014d60:	32 29       	mov	r9,34
80014d62:	f2 08 18 00 	cp.b	r8,r9
80014d66:	5f 1c       	srne	r12
80014d68:	5e fc       	retal	r12
80014d6a:	5e fd       	retal	0
80014d6c:	00 00       	add	r0,r0
80014d6e:	4a 34       	lddpc	r4,80014df8 <MostSupervisor2Init+0xc>

80014d70 <SetConfigStateFilterStatus>:
/* Parameter(s): on  new status                                             */
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void SetConfigStateFilterStatus(bool on)
{
80014d70:	d4 01       	pushm	lr
    if (MNS_OFF != on)
80014d72:	58 0c       	cp.w	r12,0
80014d74:	c0 41       	brne	80014d7c <SetConfigStateFilterStatus+0xc>
        #endif
        #endif
    }
    else
    {
        MsgConfigStateFilterOn = MNS_FALSE;
80014d76:	48 58       	lddpc	r8,80014d88 <SetConfigStateFilterStatus+0x18>
80014d78:	b0 8c       	st.b	r8[0x0],r12
80014d7a:	d8 02       	popm	pc
/*--------------------------------------------------------------------------*/
void SetConfigStateFilterStatus(bool on)
{
    if (MNS_OFF != on)
    {
        MsgConfigStateFilterOn = MNS_TRUE;
80014d7c:	30 19       	mov	r9,1
80014d7e:	48 38       	lddpc	r8,80014d88 <SetConfigStateFilterStatus+0x18>
80014d80:	b0 89       	st.b	r8[0x0],r9

        PmsFlushMsgTxBuffer();
80014d82:	fe b0 c1 d5 	rcall	8000d12c <PmsFlushMsgTxBuffer>
80014d86:	d8 02       	popm	pc
80014d88:	00 00       	add	r0,r0
80014d8a:	4a 34       	lddpc	r4,80014e14 <MostSupervisor2Init+0x28>

80014d8c <ConfigStatusChanged>:
80014d8c:	eb cd 40 c0 	pushm	r6-r7,lr
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef MSV2_3
void ConfigStatusChanged(pTMsgRx Rx_Ptr)
{
    ConfigStatusOk = Rx_Ptr->Data[0];                       /* 0: NotOk, 1: Ok, 2: Invalid, 3: New */
80014d90:	49 67       	lddpc	r7,80014de8 <ConfigStatusChanged+0x5c>
80014d92:	78 08       	ld.w	r8,r12[0x0]
80014d94:	11 88       	ld.ub	r8,r8[0x0]
80014d96:	ae 88       	st.b	r7[0x0],r8
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef MSV2_3
void ConfigStatusChanged(pTMsgRx Rx_Ptr)
{
80014d98:	18 96       	mov	r6,r12
    ConfigStatusOk = Rx_Ptr->Data[0];                       /* 0: NotOk, 1: Ok, 2: Invalid, 3: New */

    if (NWM_CFG_STATUS_NOTOK == ConfigStatusOk)
80014d9a:	58 08       	cp.w	r8,0
80014d9c:	c1 11       	brne	80014dbe <ConfigStatusChanged+0x32>
        #ifdef AH_14
        AddrHClearTasks();                                  /* stop Address Handler    */
        #endif

        #ifdef ENABLE_CFG_MSG_FILTER
        SetConfigStateFilterStatus(MNS_ON);
80014d9e:	30 1c       	mov	r12,1
80014da0:	ce 8f       	rcall	80014d70 <SetConfigStateFilterStatus>
80014da2:	0f 8c       	ld.ub	r12,r7[0x0]
        SetConfigStateFilterStatus(MNS_OFF);
        #endif
    }

    #ifdef MSV2_CB5
    if (    (NWM_CFG_STATUS_INVALID == ConfigStatusOk )
80014da4:	30 28       	mov	r8,2
80014da6:	f8 c9 00 02 	sub	r9,r12,2
80014daa:	f0 09 18 00 	cp.b	r9,r8
80014dae:	e0 88 00 12 	brls	80014dd2 <ConfigStatusChanged+0x46>
80014db2:	58 0c       	cp.w	r12,0
    {
        AddrHDevTabDel(Rx_Ptr);
    }
    #endif

    if (NWM_CFG_STATUS_NOTOK == ConfigStatusOk)         /* NetworkMaster.Configuration.Status.(NotOk) */
80014db4:	c0 80       	breq	80014dc4 <ConfigStatusChanged+0x38>
80014db6:	fe b0 99 a9 	rcall	80008108 <SystemCommunicationInit>
        }
    }

    /*  Start System Communication Init */
    /*--------------------------------- */
    SystemCommunicationInit(ConfigStatusOk);            /* Callback Application: */
80014dba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
                                                        /* Start SystemCommunicationInit Process (Init Notification,...) */
}
80014dbe:	30 0c       	mov	r12,0
        #endif
    }
    else
    {
        #ifdef ENABLE_CFG_MSG_FILTER
        SetConfigStateFilterStatus(MNS_OFF);
80014dc0:	cd 8f       	rcall	80014d70 <SetConfigStateFilterStatus>
80014dc2:	cf 0b       	rjmp	80014da2 <ConfigStatusChanged+0x16>
80014dc4:	c9 8c       	rcall	80014ef4 <NbCheckPosValid>
80014dc6:	c0 c0       	breq	80014dde <ConfigStatusChanged+0x52>
    }
    #endif

    if (NWM_CFG_STATUS_NOTOK == ConfigStatusOk)         /* NetworkMaster.Configuration.Status.(NotOk) */
    {
        if ((byte)0 == NbCheckPosValid(NULL))                 /* node adress can be changed only if node position is valid */
80014dc8:	0f 8c       	ld.ub	r12,r7[0x0]
80014dca:	fe b0 99 9f 	rcall	80008108 <SystemCommunicationInit>


            /*  Initialize Notification Service */
            /*---------------------------------- */
            #ifdef NTF_0                                /* due to a "NWM.Configuration.NotOk" message           */
            NtfInit();
80014dce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        }
    }

    /*  Start System Communication Init */
    /*--------------------------------- */
    SystemCommunicationInit(ConfigStatusOk);            /* Callback Application: */
80014dd2:	0c 9c       	mov	r12,r6
                                                        /* Start SystemCommunicationInit Process (Init Notification,...) */
}
80014dd4:	fe b0 99 9c 	rcall	8000810c <FBlockIDsChanged>
    #ifdef MSV2_CB5
    if (    (NWM_CFG_STATUS_INVALID == ConfigStatusOk )
         || (NWM_CFG_STATUS_NEW     == ConfigStatusOk )
         || (NWM_CFG_STATUS_NEWEXT  == ConfigStatusOk ) )
    {
        FBlockIDsChanged(Rx_Ptr);
80014dd8:	48 48       	lddpc	r8,80014de8 <ConfigStatusChanged+0x5c>
80014dda:	11 8c       	ld.ub	r12,r8[0x0]
80014ddc:	ce bb       	rjmp	80014db2 <ConfigStatusChanged+0x26>
80014dde:	e0 a0 04 59 	rcall	80015690 <NtfInit>
80014de2:	0f 8c       	ld.ub	r12,r7[0x0]


            /*  Initialize Notification Service */
            /*---------------------------------- */
            #ifdef NTF_0                                /* due to a "NWM.Configuration.NotOk" message           */
            NtfInit();
80014de4:	cf 3b       	rjmp	80014dca <ConfigStatusChanged+0x3e>
80014de6:	d7 03       	nop
80014de8:	00 00       	add	r0,r0
80014dea:	4a 35       	lddpc	r5,80014e74 <NB_FBlockIDs_Set+0x44>

80014dec <MostSupervisor2Init>:
80014dec:	d4 01       	pushm	lr
80014dee:	20 2d       	sub	sp,8
80014df0:	fe c8 00 e4 	sub	r8,pc,228
80014df4:	50 08       	stdsp	sp[0x0],r8
80014df6:	48 b8       	lddpc	r8,80014e20 <MostSupervisor2Init+0x34>
80014df8:	1a 9c       	mov	r12,sp
80014dfa:	50 18       	stdsp	sp[0x4],r8
80014dfc:	fe b0 d3 d6 	rcall	8000f5a8 <VmsvRegisterInternalHooks>
80014e00:	fe b0 d1 16 	rcall	8000f02c <MostGetNCState>
    #ifdef NETWORKMASTER_LOCAL
    ConfigState = (byte)0x01;                                     /* Starting the State Machine controlling the */
                                                            /* the Configuration Process */
    ConfigStatusOk = NWM_CFG_STATUS_NOTOK;                  /* Init Flag */
    #else
    ConfigStatusOk = MostGetNCState();
80014e04:	48 89       	lddpc	r9,80014e24 <MostSupervisor2Init+0x38>
    AddrHDevTabInit(MNS_TRUE);
    #endif

    /*  Start System Communication Init */
    /*--------------------------------- */
    if (NWM_CFG_STATUS_OK != ConfigStatusOk)
80014e06:	b2 8c       	st.b	r9[0x0],r12
80014e08:	30 19       	mov	r9,1
80014e0a:	f2 0c 18 00 	cp.b	r12,r9
    {
        SystemCommunicationInit(ConfigStatusOk);                /* Callback Application: */
80014e0e:	c0 30       	breq	80014e14 <MostSupervisor2Init+0x28>
80014e10:	fe b0 99 7c 	rcall	80008108 <SystemCommunicationInit>
    MNS2_REQUEST_CALL(MNS2_P_MSV2_STATE)                    /* Set Request Flag and call application */
    #endif


    #ifdef ENABLE_CFG_MSG_FILTER
    MsgConfigStateFilterOn = MNS_TRUE;
80014e14:	30 19       	mov	r9,1
80014e16:	48 58       	lddpc	r8,80014e28 <MostSupervisor2Init+0x3c>
    #endif

}
80014e18:	b0 89       	st.b	r8[0x0],r9
80014e1a:	2f ed       	sub	sp,-8
80014e1c:	d8 02       	popm	pc
80014e1e:	d7 03       	nop
80014e20:	80 00       	ld.sh	r0,r0[0x0]
80014e22:	81 0a       	st.w	r0[0x0],r10
80014e24:	00 00       	add	r0,r0
80014e26:	4a 35       	lddpc	r5,80014eb0 <NbGetFBlockIndex+0xc>
80014e28:	00 00       	add	r0,r0
80014e2a:	4a 34       	lddpc	r4,80014eb4 <NbGetFBlockIndex+0x10>

80014e2c <NbService>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_12
void NbService(void)
{
}
80014e2c:	5e fc       	retal	r12
80014e2e:	d7 03       	nop

80014e30 <NB_FBlockIDs_Set>:
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I20
byte NB_FBlockIDs_Set(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80014e30:	eb cd 40 f8 	pushm	r3-r7,lr
    }
    #endif

    #ifndef NB_CB16
    #if (NUM_FBLOCKS>0)
    FBlock_Rx  = Rx_Ptr->Data[0];
80014e34:	76 08       	ld.w	r8,r11[0x0]
80014e36:	49 4c       	lddpc	r12,80014e84 <NB_FBlockIDs_Set+0x54>
    InstOld_Rx = Rx_Ptr->Data[1];
    InstNew_Rx = Rx_Ptr->Data[2];
80014e38:	11 a5       	ld.ub	r5,r8[0x2]
    }
    #endif

    #ifndef NB_CB16
    #if (NUM_FBLOCKS>0)
    FBlock_Rx  = Rx_Ptr->Data[0];
80014e3a:	11 8e       	ld.ub	lr,r8[0x0]
    InstOld_Rx = Rx_Ptr->Data[1];
80014e3c:	11 94       	ld.ub	r4,r8[0x1]
                                                                        /*    0x00 := FBlock.Inst found not yet */
                                                                        /*    0x01 := FBlock found */
                                                                        /*    0x02 := FBlock.Inst found */
    do
    {
        if (NetBlock.pFBlockIDs.FBlockID[i] == FBlock_Rx)               /* Check FBlockID */
80014e3e:	18 96       	mov	r6,r12

    #ifndef NB_CB16
    #if (NUM_FBLOCKS>0)
    FBlock_Rx  = Rx_Ptr->Data[0];
    InstOld_Rx = Rx_Ptr->Data[1];
    InstNew_Rx = Rx_Ptr->Data[2];
80014e40:	30 18       	mov	r8,1
        else
        {
            i++;
        }

    }while( i<NUM_FBLOCKS && SearchStatus<2 );
80014e42:	30 37       	mov	r7,3
80014e44:	c0 c8       	rjmp	80014e5c <NB_FBlockIDs_Set+0x2c>
80014e46:	f0 07 18 00 	cp.b	r7,r8
80014e4a:	f9 b9 02 01 	movhs	r9,1
80014e4e:	f9 b9 03 00 	movlo	r9,0
80014e52:	f1 db c0 08 	bfextu	r8,r11,0x0,0x8
80014e56:	ed b9 00 00 	bld	r9,0x0
80014e5a:	c1 31       	brne	80014e80 <NB_FBlockIDs_Set+0x50>
                                                                        /*    0x00 := FBlock.Inst found not yet */
                                                                        /*    0x01 := FBlock found */
                                                                        /*    0x02 := FBlock.Inst found */
    do
    {
        if (NetBlock.pFBlockIDs.FBlockID[i] == FBlock_Rx)               /* Check FBlockID */
80014e5c:	f0 c9 00 01 	sub	r9,r8,1
        else
        {
            i++;
        }

    }while( i<NUM_FBLOCKS && SearchStatus<2 );
80014e60:	f0 cb ff ff 	sub	r11,r8,-1
                                                                        /*    0x00 := FBlock.Inst found not yet */
                                                                        /*    0x01 := FBlock found */
                                                                        /*    0x02 := FBlock.Inst found */
    do
    {
        if (NetBlock.pFBlockIDs.FBlockID[i] == FBlock_Rx)               /* Check FBlockID */
80014e64:	5c 59       	castu.b	r9
80014e66:	f8 09 07 0a 	ld.ub	r10,r12[r9]
80014e6a:	fc 0a 18 00 	cp.b	r10,lr
80014e6e:	ce c1       	brne	80014e46 <NB_FBlockIDs_Set+0x16>
        {
            SearchStatus = (byte)0x01;

            if (NetBlock.pFBlockIDs.InstID[i] == InstOld_Rx)            /* Check old InstID */
80014e70:	ec 09 00 09 	add	r9,r6,r9
80014e74:	08 93       	mov	r3,r4
80014e76:	13 ca       	ld.ub	r10,r9[0x4]
80014e78:	e8 0a 18 00 	cp.b	r10,r4
80014e7c:	ce 51       	brne	80014e46 <NB_FBlockIDs_Set+0x16>
            {
                NetBlock.pFBlockIDs.InstID[i] = InstNew_Rx;             /* Set new InstID */
80014e7e:	b2 c5       	st.b	r9[0x4],r5
    #endif

    #else
    return(NBFBlockIDsSet(Tx_Ptr, Rx_Ptr));           /* call application to change InstID */
    #endif
}
80014e80:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80014e84:	00 00       	add	r0,r0
80014e86:	4a 41       	lddpc	r1,80014f14 <NbCheckPosValid+0x20>

80014e88 <NB_Version_Get>:
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I151
byte NB_Version_Get(pTMsgTx tx_ptr)
{
  tx_ptr->Data[0] = NB_VERSION_MAJOR;
80014e88:	78 08       	ld.w	r8,r12[0x0]
80014e8a:	30 39       	mov	r9,3
80014e8c:	b0 89       	st.b	r8[0x0],r9
  tx_ptr->Data[1] = NB_VERSION_MINOR;
80014e8e:	30 09       	mov	r9,0
80014e90:	78 08       	ld.w	r8,r12[0x0]
80014e92:	b0 99       	st.b	r8[0x1],r9
  tx_ptr->Data[2] = NB_VERSION_BUILD;
80014e94:	30 19       	mov	r9,1
80014e96:	78 08       	ld.w	r8,r12[0x0]
80014e98:	b0 a9       	st.b	r8[0x2],r9
  tx_ptr->Length  = (word)3;
80014e9a:	30 38       	mov	r8,3
80014e9c:	b8 28       	st.h	r12[0x4],r8
  return(OP_STATUS);
}
80014e9e:	30 cc       	mov	r12,12
80014ea0:	5e fc       	retal	r12
80014ea2:	d7 03       	nop

80014ea4 <NbGetFBlockIndex>:
/*                  0xFF means: FBlockID.InstID not found                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_4
byte NbGetFBlockIndex(byte fblock_id, byte inst_id)
{
80014ea4:	eb cd 40 e0 	pushm	r5-r7,lr
80014ea8:	49 19       	lddpc	r9,80014eec <NbGetFBlockIndex+0x48>
80014eaa:	18 98       	mov	r8,r12
        }

        index++;

    }
    while ( index < (byte)NUM_FBLOCKS );
80014eac:	30 47       	mov	r7,4
/*                  0xFF means: FBlockID.InstID not found                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_4
byte NbGetFBlockIndex(byte fblock_id, byte inst_id)
{
80014eae:	30 0c       	mov	r12,0

    do
    {
        if (NetBlock.pFBlockIDs.FBlockID[index] == fblock_id)
        {
            if ( (NetBlock.pFBlockIDs.InstID[index] == inst_id) || ((byte)0 == inst_id) )
80014eb0:	18 96       	mov	r6,r12
            {
                return(index);
            }
        }

        index++;
80014eb2:	f8 ce ff ff 	sub	lr,r12,-1

    index = (byte)0;

    do
    {
        if (NetBlock.pFBlockIDs.FBlockID[index] == fblock_id)
80014eb6:	13 8a       	ld.ub	r10,r9[0x0]
80014eb8:	f0 0a 18 00 	cp.b	r10,r8
80014ebc:	c0 b0       	breq	80014ed2 <NbGetFBlockIndex+0x2e>
            {
                return(index);
            }
        }

        index++;
80014ebe:	f9 de c0 08 	bfextu	r12,lr,0x0,0x8
80014ec2:	2f f9       	sub	r9,-1

    }
    while ( index < (byte)NUM_FBLOCKS );
80014ec4:	ee 0c 18 00 	cp.b	r12,r7
80014ec8:	cf 51       	brne	80014eb2 <NbGetFBlockIndex+0xe>
80014eca:	e0 6c 00 ff 	mov	r12,255
  #endif

    return ((byte)0xFF);              /* FBlockID.InstID not found */
}
80014ece:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    do
    {
        if (NetBlock.pFBlockIDs.FBlockID[index] == fblock_id)
        {
            if ( (NetBlock.pFBlockIDs.InstID[index] == inst_id) || ((byte)0 == inst_id) )
80014ed2:	ec 0b 18 00 	cp.b	r11,r6
80014ed6:	5f 05       	sreq	r5
80014ed8:	13 ca       	ld.ub	r10,r9[0x4]
80014eda:	f6 0a 18 00 	cp.b	r10,r11
80014ede:	5f 0a       	sreq	r10
80014ee0:	eb ea 10 0a 	or	r10,r5,r10
80014ee4:	ec 0a 18 00 	cp.b	r10,r6
80014ee8:	ce b0       	breq	80014ebe <NbGetFBlockIndex+0x1a>
80014eea:	cf 2b       	rjmp	80014ece <NbGetFBlockIndex+0x2a>
80014eec:	00 00       	add	r0,r0
80014eee:	4a 41       	lddpc	r1,80014f7c <NbInit+0x4>

80014ef0 <NbGoNetOff>:
void NbGoNetOff(void)
{
    #ifdef AH_14
    AddrHClearTasks();
    #endif
}
80014ef0:	5e fc       	retal	r12
80014ef2:	d7 03       	nop

80014ef4 <NbCheckPosValid>:
#ifdef NB_10
byte NbCheckPosValid(pTMsgRx rx_ptr)
{
    byte fblock;

    if (NULL == rx_ptr)
80014ef4:	58 0c       	cp.w	r12,0
80014ef6:	c1 a0       	breq	80014f2a <NbCheckPosValid+0x36>
            return((byte)2);                                /* delay  */
        }
    }
    else
    {
        if (MNS_FALSE != NodePositionValid)
80014ef8:	49 68       	lddpc	r8,80014f50 <NbCheckPosValid+0x5c>
80014efa:	11 89       	ld.ub	r9,r8[0x0]
80014efc:	30 08       	mov	r8,0
80014efe:	f0 09 18 00 	cp.b	r9,r8
80014f02:	c1 91       	brne	80014f34 <NbCheckPosValid+0x40>
        {
            return((byte)0);                                /* ok */
        }
        else
        {
            fblock = rx_ptr->FBlock_ID;
80014f04:	f9 38 00 0a 	ld.ub	r8,r12[10]

            if (   (FBLOCK_NETBLOCK == fblock)              /* NetBlock message ? */
80014f08:	30 19       	mov	r9,1
80014f0a:	f2 08 18 00 	cp.b	r8,r9
80014f0e:	c1 40       	breq	80014f36 <NbCheckPosValid+0x42>
                if (FUNC_FBLOCKIDS == rx_ptr->Func_ID)      /* FBlockIDs command? */
                    return((byte)1);                        /* discard message */
                else
                    return((byte)2);                        /* delay answer */
            }
            else if (  (FBLOCK_ET  == fblock)               /* FBlock ET ? */
80014f10:	30 f9       	mov	r9,15
80014f12:	f2 08 18 00 	cp.b	r8,r9
80014f16:	c0 f1       	brne	80014f34 <NbCheckPosValid+0x40>
                   && (rx_ptr->Operation < OP_REPORTS))     /* command or report message ? */
80014f18:	f9 39 00 0c 	ld.ub	r9,r12[12]
80014f1c:	30 88       	mov	r8,8
80014f1e:	f0 09 18 00 	cp.b	r9,r8
80014f22:	e0 8b 00 09 	brhi	80014f34 <NbCheckPosValid+0x40>
80014f26:	30 2c       	mov	r12,2
            {
                return ((byte)0);                           /* ok */
            }
        }
    }
}
80014f28:	5e fc       	retal	r12
{
    byte fblock;

    if (NULL == rx_ptr)
    {
        if (MNS_FALSE != NodePositionValid)
80014f2a:	48 a8       	lddpc	r8,80014f50 <NbCheckPosValid+0x5c>
80014f2c:	11 88       	ld.ub	r8,r8[0x0]
80014f2e:	f8 08 18 00 	cp.b	r8,r12
80014f32:	cf a0       	breq	80014f26 <NbCheckPosValid+0x32>
                    return((byte)1);                        /* discard message */
                else
                    return((byte)2);                        /* delay answer */
            }
            else if (  (FBLOCK_ET  == fblock)               /* FBlock ET ? */
                   && (rx_ptr->Operation < OP_REPORTS))     /* command or report message ? */
80014f34:	5e fd       	retal	0
        else
        {
            fblock = rx_ptr->FBlock_ID;

            if (   (FBLOCK_NETBLOCK == fblock)              /* NetBlock message ? */
               &&  (rx_ptr->Operation < OP_REPORTS) )       /* command or report message ? */
80014f36:	f9 39 00 0c 	ld.ub	r9,r12[12]
80014f3a:	30 88       	mov	r8,8
80014f3c:	f0 09 18 00 	cp.b	r9,r8
80014f40:	fe 9b ff fa 	brhi	80014f34 <NbCheckPosValid+0x40>
            {
                if (FUNC_FBLOCKIDS == rx_ptr->Func_ID)      /* FBlockIDs command? */
80014f44:	98 49       	ld.sh	r9,r12[0x8]
80014f46:	30 08       	mov	r8,0
80014f48:	f0 09 19 00 	cp.h	r9,r8
80014f4c:	ce d1       	brne	80014f26 <NbCheckPosValid+0x32>
80014f4e:	5e ff       	retal	1
80014f50:	00 00       	add	r0,r0
80014f52:	4a 40       	lddpc	r0,80014fe0 <NB_ShutDownReason_Get+0xc>

80014f54 <NbRefreshNodePos>:
/*                  0xFF means: FBlockID.InstID not found                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_5
void NbRefreshNodePos(void)
{
80014f54:	d4 01       	pushm	lr
    if ( (byte)0xFF == MostGetNodePos() )
80014f56:	fe b0 e4 d3 	rcall	800118fc <MostGetNodePos>
80014f5a:	3f f8       	mov	r8,-1
80014f5c:	f0 0c 18 00 	cp.b	r12,r8
80014f60:	c0 50       	breq	80014f6a <NbRefreshNodePos+0x16>
    {
        NodePositionValid = MNS_FALSE;
    }
    else
    {
        NodePositionValid = MNS_TRUE;
80014f62:	30 19       	mov	r9,1
80014f64:	48 48       	lddpc	r8,80014f74 <NbRefreshNodePos+0x20>
80014f66:	b0 89       	st.b	r8[0x0],r9
80014f68:	d8 02       	popm	pc
#ifdef NB_5
void NbRefreshNodePos(void)
{
    if ( (byte)0xFF == MostGetNodePos() )
    {
        NodePositionValid = MNS_FALSE;
80014f6a:	30 09       	mov	r9,0
80014f6c:	48 28       	lddpc	r8,80014f74 <NbRefreshNodePos+0x20>
80014f6e:	b0 89       	st.b	r8[0x0],r9
80014f70:	d8 02       	popm	pc
80014f72:	d7 03       	nop
80014f74:	00 00       	add	r0,r0
80014f76:	4a 40       	lddpc	r0,80015004 <NB_ShutDownReason_Set+0x1c>

80014f78 <NbInit>:
80014f78:	eb cd 40 80 	pushm	r7,lr
        #if (CMD_NUM_WILDCARDS > 0)
        if (   ((byte*)0  != FBlocks[i].Inst_Tab_Ptr)       /* Forget about wildcard "INST ID don't care" in FBLOCK table of Command Interpreter */
            || (FBLOCK_ET == FBlocks[i].FBlock      ) )     /* But accept FBlock ET */
        #endif
        {
            NetBlock.pFBlockIDs.FBlockID[fblock_index]  = FBlocks[i].FBlock;                /* Get FBlockIDs from table */
80014f7c:	48 f9       	lddpc	r9,80014fb8 <NbInit+0x40>
80014f7e:	f3 38 00 30 	ld.ub	r8,r9[48]
80014f82:	48 f7       	lddpc	r7,80014fbc <NbInit+0x44>
80014f84:	ae b8       	st.b	r7[0x3],r8
            NetBlock.pFBlockIDs.InstID[fblock_index]    = InstIDsDefault[fblock_index];     /* Get InstIDs default values (Rom Read) */
80014f86:	48 f8       	lddpc	r8,80014fc0 <NbInit+0x48>
80014f88:	11 ba       	ld.ub	r10,r8[0x3]
80014f8a:	ae fa       	st.b	r7[0x7],r10
        #if (CMD_NUM_WILDCARDS > 0)
        if (   ((byte*)0  != FBlocks[i].Inst_Tab_Ptr)       /* Forget about wildcard "INST ID don't care" in FBLOCK table of Command Interpreter */
            || (FBLOCK_ET == FBlocks[i].FBlock      ) )     /* But accept FBlock ET */
        #endif
        {
            NetBlock.pFBlockIDs.FBlockID[fblock_index]  = FBlocks[i].FBlock;                /* Get FBlockIDs from table */
80014f8c:	f3 3a 00 0c 	ld.ub	r10,r9[12]
80014f90:	ae 8a       	st.b	r7[0x0],r10
            NetBlock.pFBlockIDs.InstID[fblock_index]    = InstIDsDefault[fblock_index];     /* Get InstIDs default values (Rom Read) */
80014f92:	11 8a       	ld.ub	r10,r8[0x0]
80014f94:	ae ca       	st.b	r7[0x4],r10
        #if (CMD_NUM_WILDCARDS > 0)
        if (   ((byte*)0  != FBlocks[i].Inst_Tab_Ptr)       /* Forget about wildcard "INST ID don't care" in FBLOCK table of Command Interpreter */
            || (FBLOCK_ET == FBlocks[i].FBlock      ) )     /* But accept FBlock ET */
        #endif
        {
            NetBlock.pFBlockIDs.FBlockID[fblock_index]  = FBlocks[i].FBlock;                /* Get FBlockIDs from table */
80014f96:	f3 3a 00 18 	ld.ub	r10,r9[24]
80014f9a:	f3 39 00 24 	ld.ub	r9,r9[36]
80014f9e:	ae 9a       	st.b	r7[0x1],r10
            NetBlock.pFBlockIDs.InstID[fblock_index]    = InstIDsDefault[fblock_index];     /* Get InstIDs default values (Rom Read) */
80014fa0:	11 9a       	ld.ub	r10,r8[0x1]
80014fa2:	11 a8       	ld.ub	r8,r8[0x2]
80014fa4:	ae da       	st.b	r7[0x5],r10
80014fa6:	ae e8       	st.b	r7[0x6],r8
        #if (CMD_NUM_WILDCARDS > 0)
        if (   ((byte*)0  != FBlocks[i].Inst_Tab_Ptr)       /* Forget about wildcard "INST ID don't care" in FBLOCK table of Command Interpreter */
            || (FBLOCK_ET == FBlocks[i].FBlock      ) )     /* But accept FBlock ET */
        #endif
        {
            NetBlock.pFBlockIDs.FBlockID[fblock_index]  = FBlocks[i].FBlock;                /* Get FBlockIDs from table */
80014fa8:	ae a9       	st.b	r7[0x2],r9
    #endif


    /* Init pNodePosition */
    /*------------------------------------------ */
    NbRefreshNodePos();
80014faa:	cd 5f       	rcall	80014f54 <NbRefreshNodePos>
80014fac:	30 08       	mov	r8,0

    /* Init mShutDown */
    /*------------------------------------------ */
    NetBlock.mShutDown.Suspend = MNS_FALSE;
80014fae:	ef 68 00 08 	st.b	r7[8],r8
80014fb2:	e3 cd 80 80 	ldm	sp++,r7,pc

    #ifdef NB_ADD7
    BoundaryGet_Pending = MNS_FALSE;
    #endif

}
80014fb6:	d7 03       	nop
80014fb8:	80 06       	ld.sh	r6,r0[0x0]
80014fba:	ff 94       	*unknown*
80014fbc:	00 00       	add	r0,r0
80014fbe:	4a 41       	lddpc	r1,8001504c <NB_Boundary_Error+0x44>
80014fc0:	80 06       	ld.sh	r6,r0[0x0]
80014fc2:	ff dc       	*unknown*

80014fc4 <NB_ShutDownReason_Error>:
80014fc4:	d4 01       	pushm	lr
80014fc6:	fe b0 98 bd 	rcall	80008140 <NbShutDownReasonError>
{
    #ifdef NB_CBE16
    NbShutDownReasonError(Rx_Ptr);                        /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
80014fca:	d8 0a       	popm	pc,r12=0

80014fcc <NB_ShutDownReason_Status>:
80014fcc:	d4 01       	pushm	lr
80014fce:	fe b0 99 7b 	rcall	800082c4 <NbShutDownReasonStatus>
{
    #ifdef NB_CBS16
    NbShutDownReasonStatus(Rx_Ptr);                       /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
80014fd2:	d8 0a       	popm	pc,r12=0

80014fd4 <NB_ShutDownReason_Get>:
80014fd4:	eb cd 40 80 	pushm	r7,lr
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I161
byte NB_ShutDownReason_Get(pTMsgTx Tx_Ptr)
{
80014fd8:	18 97       	mov	r7,r12
    Tx_Ptr->Length = VmsvGetSSOResult(Tx_Ptr);
80014fda:	fe b0 d3 f9 	rcall	8000f7cc <VmsvGetSSOResult>
80014fde:	ae 2c       	st.h	r7[0x4],r12

    return(OP_STATUS);
}
80014fe0:	30 cc       	mov	r12,12
80014fe2:	e3 cd 80 80 	ldm	sp++,r7,pc
80014fe6:	d7 03       	nop

80014fe8 <NB_ShutDownReason_Set>:
80014fe8:	d4 01       	pushm	lr
80014fea:	30 08       	mov	r8,0
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );
    }
    #endif

    if (Rx_Ptr->Data[0] != (byte)0x00)
80014fec:	76 0a       	ld.w	r10,r11[0x0]
80014fee:	15 89       	ld.ub	r9,r10[0x0]
80014ff0:	f0 09 18 00 	cp.b	r9,r8
80014ff4:	c0 41       	brne	80014ffc <NB_ShutDownReason_Set+0x14>
    {
        return(CmdErrorParamWrong(Tx_Ptr, (byte)0x01, &Rx_Ptr->Data[0], (byte)0x01));
    }

    /* reset shutdown reason */
    VmsvResetSSOResult();
80014ff6:	fe b0 d0 81 	rcall	8000f0f8 <VmsvResetSSOResult>
80014ffa:	d8 0a       	popm	pc,r12=0
    }
    #endif

    if (Rx_Ptr->Data[0] != (byte)0x00)
    {
        return(CmdErrorParamWrong(Tx_Ptr, (byte)0x01, &Rx_Ptr->Data[0], (byte)0x01));
80014ffc:	30 19       	mov	r9,1
80014ffe:	12 9b       	mov	r11,r9
80015000:	fe b0 f5 c8 	rcall	80013b90 <CmdErrorParamWrong>
80015004:	d8 02       	popm	pc
80015006:	d7 03       	nop

80015008 <NB_Boundary_Error>:
80015008:	d4 01       	pushm	lr
8001500a:	30 19       	mov	r9,1
8001500c:	18 98       	mov	r8,r12
8001500e:	98 3a       	ld.sh	r10,r12[0x6]
#ifdef NB_I14F
byte NB_Boundary_Error(pTMsgRx Rx_Ptr)
{
    byte i;

    if (MSG_SRC_INIC == Rx_Ptr->Src_Adr)                    /* message from INIC ? */
80015010:	f2 0a 19 00 	cp.h	r10,r9
80015014:	c0 40       	breq	8001501c <NB_Boundary_Error+0x14>
        }
    }
    else
    {
        #ifdef NB_CBE14
        NbBoundaryError(Rx_Ptr);
80015016:	fe b0 98 92 	rcall	8000813a <NbBoundaryError>
        #endif
    }
    return(OP_NO_REPORT);
}
8001501a:	d8 0a       	popm	pc,r12=0
{
    byte i;

    if (MSG_SRC_INIC == Rx_Ptr->Src_Adr)                    /* message from INIC ? */
    {
        if (MNS_FALSE != BoundaryGet_Pending)               /* boundary value could not be changed or Deallocation All failed */
8001501c:	49 49       	lddpc	r9,8001506c <NB_Boundary_Error+0x64>
8001501e:	30 0a       	mov	r10,0
80015020:	13 8b       	ld.ub	r11,r9[0x0]
80015022:	f4 0b 18 00 	cp.b	r11,r10
80015026:	cf a0       	breq	8001501a <NB_Boundary_Error+0x12>
        {
            BoundaryGet_Pending     = MNS_FALSE;
80015028:	b2 8a       	st.b	r9[0x0],r10

            BoundaryPtr->Operation  = OP_ERROR;             /* send error message using retained msg pointer */
8001502a:	49 2e       	lddpc	lr,80015070 <NB_Boundary_Error+0x68>
8001502c:	30 fa       	mov	r10,15
8001502e:	7c 09       	ld.w	r9,lr[0x0]
80015030:	f3 6a 00 0c 	st.b	r9[12],r10
            BoundaryPtr->Length     = Rx_Ptr->Length;       /* copy error info received from INIC */
80015034:	98 2a       	ld.sh	r10,r12[0x4]
80015036:	7c 09       	ld.w	r9,lr[0x0]
80015038:	b2 2a       	st.h	r9[0x4],r10

            for (i = (byte)0; i < BoundaryPtr->Length; ++i)
8001503a:	30 09       	mov	r9,0
8001503c:	7c 0c       	ld.w	r12,lr[0x0]
8001503e:	98 2a       	ld.sh	r10,r12[0x4]
80015040:	f2 0a 19 00 	cp.h	r10,r9
80015044:	c1 00       	breq	80015064 <NB_Boundary_Error+0x5c>
80015046:	30 09       	mov	r9,0
            {
                BoundaryPtr->Data[i] = Rx_Ptr->Data[i];
80015048:	78 0a       	ld.w	r10,r12[0x0]
8001504a:	70 0b       	ld.w	r11,r8[0x0]
8001504c:	f6 09 07 0b 	ld.ub	r11,r11[r9]
80015050:	f4 09 0b 0b 	st.b	r10[r9],r11
            BoundaryGet_Pending     = MNS_FALSE;

            BoundaryPtr->Operation  = OP_ERROR;             /* send error message using retained msg pointer */
            BoundaryPtr->Length     = Rx_Ptr->Length;       /* copy error info received from INIC */

            for (i = (byte)0; i < BoundaryPtr->Length; ++i)
80015054:	2f f9       	sub	r9,-1
80015056:	7c 0c       	ld.w	r12,lr[0x0]
80015058:	5c 59       	castu.b	r9
8001505a:	98 2a       	ld.sh	r10,r12[0x4]
8001505c:	f2 0a 19 00 	cp.h	r10,r9
80015060:	fe 9b ff f4 	brhi	80015048 <NB_Boundary_Error+0x40>
            {
                BoundaryPtr->Data[i] = Rx_Ptr->Data[i];
            }
            AmsMsgSend(BoundaryPtr);
80015064:	fe b0 a4 88 	rcall	80009974 <MsgSend>
        #ifdef NB_CBE14
        NbBoundaryError(Rx_Ptr);
        #endif
    }
    return(OP_NO_REPORT);
}
80015068:	d8 0a       	popm	pc,r12=0
8001506a:	d7 03       	nop
8001506c:	00 00       	add	r0,r0
8001506e:	4a 38       	lddpc	r8,800150f8 <NB_EUI48_Status>
80015070:	00 00       	add	r0,r0
80015072:	4a 3c       	lddpc	r12,800150fc <NB_EUI48_Status+0x4>

80015074 <NB_Boundary_Status>:
80015074:	d4 01       	pushm	lr
80015076:	30 1a       	mov	r10,1
80015078:	18 98       	mov	r8,r12
8001507a:	98 39       	ld.sh	r9,r12[0x6]
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I14C
byte NB_Boundary_Status(pTMsgRx Rx_Ptr)
{
    if (MSG_SRC_INIC == Rx_Ptr->Src_Adr)                            /* message from INIC ? */
8001507c:	f4 09 19 00 	cp.h	r9,r10
80015080:	c0 40       	breq	80015088 <NB_Boundary_Status+0x14>
        }
    }
    else
    {
        #ifdef NB_CBS14
        NbBoundaryStatus(Rx_Ptr);
80015082:	fe b0 98 5b 	rcall	80008138 <NbBoundaryStatus>
        #endif
    }
    return(OP_NO_REPORT);
}
80015086:	d8 0a       	popm	pc,r12=0
#ifdef NB_I14C
byte NB_Boundary_Status(pTMsgRx Rx_Ptr)
{
    if (MSG_SRC_INIC == Rx_Ptr->Src_Adr)                            /* message from INIC ? */
    {
        if (MNS_FALSE != BoundaryGet_Pending)
80015088:	48 ca       	lddpc	r10,800150b8 <NB_Boundary_Status+0x44>
8001508a:	30 0b       	mov	r11,0
8001508c:	15 8c       	ld.ub	r12,r10[0x0]
8001508e:	f6 0c 18 00 	cp.b	r12,r11
80015092:	cf a0       	breq	80015086 <NB_Boundary_Status+0x12>
        {
            BoundaryGet_Pending    = MNS_FALSE;
80015094:	b4 8b       	st.b	r10[0x0],r11

            BoundaryPtr->Operation = OP_STATUS;                     /* send status message using retained msg pointer */
80015096:	48 aa       	lddpc	r10,800150bc <NB_Boundary_Status+0x48>
80015098:	74 0b       	ld.w	r11,r10[0x0]
8001509a:	30 cc       	mov	r12,12
8001509c:	f7 6c 00 0c 	st.b	r11[12],r12
            BoundaryPtr->Length    = (word)1;
800150a0:	74 0b       	ld.w	r11,r10[0x0]
800150a2:	b6 29       	st.h	r11[0x4],r9
            BoundaryPtr->Data[0]   = Rx_Ptr->Data[0];               /* new boundary value */
800150a4:	70 08       	ld.w	r8,r8[0x0]
800150a6:	11 89       	ld.ub	r9,r8[0x0]
800150a8:	74 08       	ld.w	r8,r10[0x0]
800150aa:	70 08       	ld.w	r8,r8[0x0]
800150ac:	b0 89       	st.b	r8[0x0],r9
            AmsMsgSend(BoundaryPtr);
800150ae:	74 0c       	ld.w	r12,r10[0x0]
800150b0:	fe b0 a4 62 	rcall	80009974 <MsgSend>
        #ifdef NB_CBS14
        NbBoundaryStatus(Rx_Ptr);
        #endif
    }
    return(OP_NO_REPORT);
}
800150b4:	d8 0a       	popm	pc,r12=0
800150b6:	d7 03       	nop
800150b8:	00 00       	add	r0,r0
800150ba:	4a 38       	lddpc	r8,80015144 <NB_FBlockInfo_Get+0x24>
800150bc:	00 00       	add	r0,r0
800150be:	4a 3c       	lddpc	r12,80015148 <NB_FBlockInfo_Get+0x28>

800150c0 <NB_SamplingFrequency_Error>:
800150c0:	d4 01       	pushm	lr
800150c2:	fe b0 98 3a 	rcall	80008136 <NbSamplingFrequencyError>
800150c6:	d8 0a       	popm	pc,r12=0

800150c8 <NB_SamplingFrequency_Status>:
{
    #ifdef NB_CBE11
    NbSamplingFrequencyError(Rx_Ptr);                       /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150c8:	d4 01       	pushm	lr
800150ca:	fe b0 98 35 	rcall	80008134 <NbSamplingFrequencyStatus>
{
    #ifdef NB_CBS11
    NbSamplingFrequencyStatus(Rx_Ptr);                      /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150ce:	d8 0a       	popm	pc,r12=0

800150d0 <NB_RetryParameters_Error>:
800150d0:	d4 01       	pushm	lr
800150d2:	fe b0 98 30 	rcall	80008132 <NbRetryParametersError>
{
    #ifdef NB_CBE10
    NbRetryParametersError(Rx_Ptr);                     /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150d6:	d8 0a       	popm	pc,r12=0

800150d8 <NB_RetryParameters_Status>:
800150d8:	d4 01       	pushm	lr
800150da:	fe b0 98 2b 	rcall	80008130 <NbRetryParametersStatus>
{
    #ifdef NB_CBS10
    NbRetryParametersStatus(Rx_Ptr);                        /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150de:	d8 0a       	popm	pc,r12=0

800150e0 <NB_NodePosition_Error>:
800150e0:	d4 01       	pushm	lr
800150e2:	fe b0 98 26 	rcall	8000812e <NbNodePositionError>
{
    #ifdef NB_CBE9
    NbNodePositionError(Rx_Ptr);                        /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150e6:	d8 0a       	popm	pc,r12=0

800150e8 <NB_NodePosition_Status>:
800150e8:	d4 01       	pushm	lr
800150ea:	fe b0 98 21 	rcall	8000812c <NbNodePositionStatus>
{
    #ifdef NB_CBS9
    NbNodePositionStatus(Rx_Ptr);                       /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150ee:	d8 0a       	popm	pc,r12=0

800150f0 <NB_EUI48_Error>:
800150f0:	d4 01       	pushm	lr
800150f2:	fe b0 98 2d 	rcall	8000814c <NbEUI48Error>
{
    #ifdef NB_CBE19
    NbEUI48Error(Rx_Ptr);                      /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150f6:	d8 0a       	popm	pc,r12=0

800150f8 <NB_EUI48_Status>:
800150f8:	d4 01       	pushm	lr
800150fa:	fe b0 98 28 	rcall	8000814a <NbEUI48Status>
{
    #ifdef NB_CBS19
    NbEUI48Status(Rx_Ptr);                     /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800150fe:	d8 0a       	popm	pc,r12=0

80015100 <NB_ImplFBlocks_Error>:
80015100:	d4 01       	pushm	lr
80015102:	fe b0 98 23 	rcall	80008148 <NbImplFBlocksError>
{
    #ifdef NB_CBE18
    NbImplFBlocksError(Rx_Ptr);                      /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
80015106:	d8 0a       	popm	pc,r12=0

80015108 <NB_ImplFBlocks_Status>:
80015108:	d4 01       	pushm	lr
8001510a:	fe b0 98 1e 	rcall	80008146 <NbImplFBlocksStatus>
{
    #ifdef NB_CBS18
    NbImplFBlocksStatus(Rx_Ptr);                     /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
8001510e:	d8 0a       	popm	pc,r12=0

80015110 <NB_FBlockInfo_Error>:
80015110:	d4 01       	pushm	lr
80015112:	fe b0 98 19 	rcall	80008144 <NbFBlockInfoError>
{
    #ifdef NB_CBE17
    NbFBlockInfoError(Rx_Ptr);                      /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
80015116:	d8 0a       	popm	pc,r12=0

80015118 <NB_FBlockInfo_Status>:
80015118:	d4 01       	pushm	lr
8001511a:	fe b0 98 14 	rcall	80008142 <NbFBlockInfoStatus>
{
    #ifdef NB_CBS17
    NbFBlockInfoStatus(Rx_Ptr);                     /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
8001511e:	d8 0a       	popm	pc,r12=0

80015120 <NB_FBlockInfo_Get>:
80015120:	eb cd 40 e0 	pushm	r5-r7,lr
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I171
byte NB_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80015124:	20 4d       	sub	sp,16
    word rx_id;
    byte name[] = "NetBlock";
80015126:	4e a8       	lddpc	r8,800152cc <NB_FBlockInfo_Get+0x1ac>
80015128:	f0 e6 00 00 	ld.d	r6,r8[0]
8001512c:	f1 39 00 08 	ld.ub	r9,r8[8]
80015130:	fa e7 00 00 	st.d	sp[0],r6
80015134:	fb 69 00 08 	st.b	sp[8],r9
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I171
byte NB_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80015138:	16 96       	mov	r6,r11
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
8001513a:	6c 0a       	ld.w	r10,r6[0x0]
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */

    Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
8001513c:	78 0b       	ld.w	r11,r12[0x0]
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */
8001513e:	15 95       	ld.ub	r5,r10[0x1]
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
80015140:	15 89       	ld.ub	r9,r10[0x0]
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */

    Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
80015142:	b6 89       	st.b	r11[0x0],r9
    Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
80015144:	6c 0a       	ld.w	r10,r6[0x0]
80015146:	15 9b       	ld.ub	r11,r10[0x1]
80015148:	78 0a       	ld.w	r10,r12[0x0]
8001514a:	b4 9b       	st.b	r10[0x1],r11
    {
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
8001514c:	a9 69       	lsl	r9,0x8
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */

    Tx_Ptr->Data[0] = Rx_Ptr->Data[0];              /* prepare TX message */
    Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
    Tx_Ptr->Length  = (word)2;
8001514e:	30 2a       	mov	r10,2
80015150:	b8 2a       	st.h	r12[0x4],r10
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */
80015152:	12 05       	add	r5,r9
/*--------------------------------------------------------------------------*/
#ifdef NB_I171
byte NB_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
    word rx_id;
    byte name[] = "NetBlock";
80015154:	1a 98       	mov	r8,sp
/* Returns     : OpType                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I171
byte NB_FBlockInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80015156:	18 97       	mov	r7,r12
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );  /* return(OP_ERROR) */
    }
    #endif

    rx_id = (word)((word)Rx_Ptr->Data[0] << 8);     /* Data[0] contains HB of ID */
    rx_id += Rx_Ptr->Data[1];                       /* Data[1] contains LB of ID */
80015158:	5c 85       	casts.h	r5
    Tx_Ptr->Data[1] = Rx_Ptr->Data[1];
    Tx_Ptr->Length  = (word)2;

    answer_prepared = MNS_TRUE;

    if (rx_id < (word)0x1000)                             /* FktID ?*/
8001515a:	e0 69 0f ff 	mov	r9,4095
8001515e:	f2 05 19 00 	cp.h	r5,r9
80015162:	e0 8b 00 1c 	brhi	8001519a <NB_FBlockInfo_Get+0x7a>
    {
        Tx_Ptr->Length  = (word)3;
80015166:	30 38       	mov	r8,3
80015168:	b8 28       	st.h	r12[0x4],r8

        switch (rx_id)
8001516a:	30 98       	mov	r8,9
8001516c:	f0 05 19 00 	cp.h	r5,r8
80015170:	e0 88 00 28 	brls	800151c0 <NB_FBlockInfo_Get+0xa0>
80015174:	31 28       	mov	r8,18
80015176:	f0 05 19 00 	cp.h	r5,r8
8001517a:	c2 70       	breq	800151c8 <NB_FBlockInfo_Get+0xa8>
8001517c:	e0 8b 00 92 	brhi	800152a0 <NB_FBlockInfo_Get+0x180>
80015180:	31 08       	mov	r8,16
80015182:	f0 05 19 00 	cp.h	r5,r8
80015186:	c2 10       	breq	800151c8 <NB_FBlockInfo_Get+0xa8>
80015188:	31 18       	mov	r8,17
8001518a:	f0 05 19 00 	cp.h	r5,r8
8001518e:	c6 e0       	breq	8001526a <NB_FBlockInfo_Get+0x14a>
            case FUNC_NB_BOUNDARY:
                Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
                break;

            default:
                Tx_Ptr->Data[2] = MAT_UNKNOWN;
80015190:	6e 08       	ld.w	r8,r7[0x0]
80015192:	30 09       	mov	r9,0
80015194:	30 0b       	mov	r11,0
80015196:	b0 a9       	st.b	r8[0x2],r9
80015198:	c1 c8       	rjmp	800151d0 <NB_FBlockInfo_Get+0xb0>
                break;
        }
    }
    else
    {
        switch (rx_id)
8001519a:	fe 79 f0 03 	mov	r9,-4093
8001519e:	f2 05 19 00 	cp.h	r5,r9
800151a2:	c3 f0       	breq	80015220 <NB_FBlockInfo_Get+0x100>
800151a4:	e0 88 00 29 	brls	800151f6 <NB_FBlockInfo_Get+0xd6>
800151a8:	fe 78 f0 04 	mov	r8,-4092
800151ac:	f0 05 19 00 	cp.h	r5,r8
800151b0:	c6 c0       	breq	80015288 <NB_FBlockInfo_Get+0x168>
800151b2:	fe 78 f0 06 	mov	r8,-4090
800151b6:	f0 05 19 00 	cp.h	r5,r8
800151ba:	c5 d0       	breq	80015274 <NB_FBlockInfo_Get+0x154>
800151bc:	30 0b       	mov	r11,0
800151be:	c0 98       	rjmp	800151d0 <NB_FBlockInfo_Get+0xb0>

    if (rx_id < (word)0x1000)                             /* FktID ?*/
    {
        Tx_Ptr->Length  = (word)3;

        switch (rx_id)
800151c0:	30 78       	mov	r8,7
800151c2:	f0 05 19 00 	cp.h	r5,r8
800151c6:	c4 23       	brcs	8001524a <NB_FBlockInfo_Get+0x12a>
            case FUNC_SHUTDOWNREASON:
            case FUNC_VERSION:
            case FUNC_EUI48:
            case FUNC_NB_RBDRESULT:
            case FUNC_NB_BOUNDARY:
                Tx_Ptr->Data[2] = MAT_FULLY_IMPLEMENTED_VERIFIED;
800151c8:	6e 08       	ld.w	r8,r7[0x0]
800151ca:	31 29       	mov	r9,18
800151cc:	30 1b       	mov	r11,1
800151ce:	b0 a9       	st.b	r8[0x2],r9

        }
    }

    /* Call Application, because request cannot be answered by NetServices completely      */
    if (MNS_FALSE == NbFBlockInfoGet(rx_id, answer_prepared, Tx_Ptr))           /* unknown ID ? */
800151d0:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
800151d4:	0e 9a       	mov	r10,r7
800151d6:	fe b0 98 17 	rcall	80008204 <NbFBlockInfoGet>
800151da:	c0 50       	breq	800151e4 <NB_FBlockInfo_Get+0xc4>
800151dc:	30 cc       	mov	r12,12
    {
        return_value = OP_STATUS;
    }

    return(return_value);
}
800151de:	2f cd       	sub	sp,-16
800151e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    }

    /* Call Application, because request cannot be answered by NetServices completely      */
    if (MNS_FALSE == NbFBlockInfoGet(rx_id, answer_prepared, Tx_Ptr))           /* unknown ID ? */
    {
        return_value = CmdErrorParamWrong( Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)2);  /* prepare error message   */
800151e4:	6c 0a       	ld.w	r10,r6[0x0]
800151e6:	0e 9c       	mov	r12,r7
800151e8:	30 29       	mov	r9,2
800151ea:	30 1b       	mov	r11,1
800151ec:	fe b0 f4 d2 	rcall	80013b90 <CmdErrorParamWrong>
    {
        return_value = OP_STATUS;
    }

    return(return_value);
}
800151f0:	2f cd       	sub	sp,-16
800151f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
                break;
        }
    }
    else
    {
        switch (rx_id)
800151f6:	fe 79 f0 01 	mov	r9,-4095
800151fa:	f2 05 19 00 	cp.h	r5,r9
800151fe:	cd f1       	brne	800151bc <NB_FBlockInfo_Get+0x9c>
        {
            case FBI_FBLOCK_NAME:
                Tx_Ptr->Data[2] = FRMT_ISO8859;
80015200:	78 09       	ld.w	r9,r12[0x0]
80015202:	30 1a       	mov	r10,1
80015204:	b2 aa       	st.b	r9[0x2],r10
80015206:	30 09       	mov	r9,0
                for(i=(byte)0; i<(byte)(sizeof(name)/sizeof(name[0])); ++i)
                {
                    Tx_Ptr->Data[i+3] = (byte)name[i];
80015208:	6e 0a       	ld.w	r10,r7[0x0]
8001520a:	f0 09 07 0b 	ld.ub	r11,r8[r9]
8001520e:	12 0a       	add	r10,r9
80015210:	b4 bb       	st.b	r10[0x3],r11
80015212:	2f f9       	sub	r9,-1
    {
        switch (rx_id)
        {
            case FBI_FBLOCK_NAME:
                Tx_Ptr->Data[2] = FRMT_ISO8859;
                for(i=(byte)0; i<(byte)(sizeof(name)/sizeof(name[0])); ++i)
80015214:	58 99       	cp.w	r9,9
80015216:	cf 91       	brne	80015208 <NB_FBlockInfo_Get+0xe8>
                {
                    Tx_Ptr->Data[i+3] = (byte)name[i];
                }
                Tx_Ptr->Length = (word)i + (word)3;
80015218:	30 c8       	mov	r8,12
8001521a:	30 1b       	mov	r11,1
8001521c:	ae 28       	st.h	r7[0x4],r8
                break;
8001521e:	cd 9b       	rjmp	800151d0 <NB_FBlockInfo_Get+0xb0>
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_13
void NbGetVersion(byte *version)
{
    *version++ = NB_VERSION_MAJOR;
80015220:	30 39       	mov	r9,3
    *version++ = NB_VERSION_MINOR;
    *version   = NB_VERSION_BUILD;
80015222:	30 18       	mov	r8,1
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_13
void NbGetVersion(byte *version)
{
    *version++ = NB_VERSION_MAJOR;
80015224:	fb 69 00 0c 	st.b	sp[12],r9
    *version++ = NB_VERSION_MINOR;
    *version   = NB_VERSION_BUILD;
80015228:	fb 68 00 0e 	st.b	sp[14],r8
/*--------------------------------------------------------------------------*/
#ifdef NB_13
void NbGetVersion(byte *version)
{
    *version++ = NB_VERSION_MAJOR;
    *version++ = NB_VERSION_MINOR;
8001522c:	30 09       	mov	r9,0
8001522e:	fb 69 00 0d 	st.b	sp[13],r9
                break;

            case FBI_FBLOCK_VERSION:
                NbGetVersion(&version[0]);

                Tx_Ptr->Data[2] = FRMT_ISO8859;
80015232:	78 09       	ld.w	r9,r12[0x0]
80015234:	b2 a8       	st.b	r9[0x2],r8
            case FBI_MOST_VERSION:
                NbGetMOSTVersion(&version[0]);

                Tx_Ptr->Data[2] = FRMT_ISO8859;

                i = MsgVersionToISO8859(&version[0], &Tx_Ptr->Data[3]);
80015236:	6e 0b       	ld.w	r11,r7[0x0]
80015238:	fa cc ff f4 	sub	r12,sp,-12
8001523c:	2f db       	sub	r11,-3
8001523e:	fe b0 9d 11 	rcall	80008c60 <MsgVersionToISO8859>

                Tx_Ptr->Length  = (word)i + (word)3;
80015242:	30 1b       	mov	r11,1
80015244:	2f dc       	sub	r12,-3
80015246:	ae 2c       	st.h	r7[0x4],r12
                break;
80015248:	cc 4b       	rjmp	800151d0 <NB_FBlockInfo_Get+0xb0>

    if (rx_id < (word)0x1000)                             /* FktID ?*/
    {
        Tx_Ptr->Length  = (word)3;

        switch (rx_id)
8001524a:	30 48       	mov	r8,4
8001524c:	f0 05 19 00 	cp.h	r5,r8
80015250:	e0 8b 00 38 	brhi	800152c0 <NB_FBlockInfo_Get+0x1a0>
80015254:	f4 05 19 00 	cp.h	r5,r10
80015258:	cb 82       	brcc	800151c8 <NB_FBlockInfo_Get+0xa8>
8001525a:	30 08       	mov	r8,0
8001525c:	f0 05 19 00 	cp.h	r5,r8
80015260:	cb 40       	breq	800151c8 <NB_FBlockInfo_Get+0xa8>
80015262:	30 18       	mov	r8,1
80015264:	f0 05 19 00 	cp.h	r5,r8
80015268:	c9 41       	brne	80015190 <NB_FBlockInfo_Get+0x70>
                break;

            case FUNC_DEVICEINFO:
            case FUNC_SHUTDOWN:
            case FUNC_FBLOCKINFO:
                Tx_Ptr->Data[2] = MAT_PARTLY_IMPLEMENTED_VERIFIED;
8001526a:	6e 08       	ld.w	r8,r7[0x0]
8001526c:	31 19       	mov	r9,17
8001526e:	30 1b       	mov	r11,1
80015270:	b0 a9       	st.b	r8[0x2],r9
                break;
80015272:	ca fb       	rjmp	800151d0 <NB_FBlockInfo_Get+0xb0>

                Tx_Ptr->Length  = (word)i + (word)3;
                break;

            case FBI_FBLOCK_TYPE:
                Tx_Ptr->Data[2] = FRMT_ISO8859;
80015274:	78 08       	ld.w	r8,r12[0x0]
80015276:	30 19       	mov	r9,1
80015278:	b0 a9       	st.b	r8[0x2],r9
                Tx_Ptr->Data[3] = (byte)'\0';
8001527a:	30 09       	mov	r9,0
8001527c:	78 08       	ld.w	r8,r12[0x0]
8001527e:	b0 b9       	st.b	r8[0x3],r9
                Tx_Ptr->Length  = (word)4;
80015280:	30 1b       	mov	r11,1
80015282:	30 48       	mov	r8,4
80015284:	b8 28       	st.h	r12[0x4],r8
                break;
80015286:	ca 5b       	rjmp	800151d0 <NB_FBlockInfo_Get+0xb0>
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_14
void NbGetMOSTVersion(byte *version)
{
    *version++ = GFB_VERSION_MAJOR;
80015288:	30 38       	mov	r8,3
    *version++ = GFB_VERSION_MINOR;
    *version   = GFB_VERSION_BUILD;
8001528a:	fb 6a 00 0e 	st.b	sp[14],r10
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_14
void NbGetMOSTVersion(byte *version)
{
    *version++ = GFB_VERSION_MAJOR;
8001528e:	fb 68 00 0c 	st.b	sp[12],r8
    *version++ = GFB_VERSION_MINOR;
80015292:	30 08       	mov	r8,0
80015294:	fb 68 00 0d 	st.b	sp[13],r8
                break;

            case FBI_MOST_VERSION:
                NbGetMOSTVersion(&version[0]);

                Tx_Ptr->Data[2] = FRMT_ISO8859;
80015298:	30 19       	mov	r9,1
8001529a:	78 08       	ld.w	r8,r12[0x0]
8001529c:	b0 a9       	st.b	r8[0x2],r9
8001529e:	cc cb       	rjmp	80015236 <NB_FBlockInfo_Get+0x116>

    if (rx_id < (word)0x1000)                             /* FktID ?*/
    {
        Tx_Ptr->Length  = (word)3;

        switch (rx_id)
800152a0:	e0 68 04 05 	mov	r8,1029
800152a4:	f0 05 19 00 	cp.h	r5,r8
800152a8:	c9 00       	breq	800151c8 <NB_FBlockInfo_Get+0xa8>
800152aa:	e0 68 0a 03 	mov	r8,2563
800152ae:	f0 05 19 00 	cp.h	r5,r8
800152b2:	c8 b0       	breq	800151c8 <NB_FBlockInfo_Get+0xa8>
800152b4:	31 38       	mov	r8,19
800152b6:	f0 05 19 00 	cp.h	r5,r8
800152ba:	fe 91 ff 6b 	brne	80015190 <NB_FBlockInfo_Get+0x70>
800152be:	c8 5b       	rjmp	800151c8 <NB_FBlockInfo_Get+0xa8>
800152c0:	30 68       	mov	r8,6
800152c2:	f0 05 19 00 	cp.h	r5,r8
800152c6:	fe 91 ff 65 	brne	80015190 <NB_FBlockInfo_Get+0x70>
800152ca:	cd 0b       	rjmp	8001526a <NB_FBlockInfo_Get+0x14a>
800152cc:	80 06       	ld.sh	r6,r0[0x0]
800152ce:	e1 c0 d4 01 	ldm	r0,r0,r10,r12,lr-pc

800152d0 <NB_Version_Error>:
800152d0:	d4 01       	pushm	lr
800152d2:	fe b0 97 36 	rcall	8000813e <NbVersionError>
800152d6:	d8 0a       	popm	pc,r12=0

800152d8 <NB_Version_Status>:
800152d8:	d4 01       	pushm	lr
800152da:	fe b0 97 31 	rcall	8000813c <NbVersionStatus>
{
    #ifdef NB_CBS15
    NbVersionStatus(Rx_Ptr);                      /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800152de:	d8 0a       	popm	pc,r12=0

800152e0 <NB_GroupAddr_Error>:
800152e0:	d4 01       	pushm	lr
800152e2:	fe b0 97 22 	rcall	80008126 <NbGroupAddrError>
{
    #ifdef NB_CBE4
    NbGroupAddrError(Rx_Ptr);                       /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800152e6:	d8 0a       	popm	pc,r12=0

800152e8 <NB_GroupAddr_Status>:
800152e8:	d4 01       	pushm	lr
800152ea:	fe b0 97 1d 	rcall	80008124 <NbGroupAddrStatus>
{
    #ifdef NB_CBS4
    NbGroupAddrStatus(Rx_Ptr);                      /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800152ee:	d8 0a       	popm	pc,r12=0

800152f0 <NB_NodeAddr_Error>:
800152f0:	d4 01       	pushm	lr
800152f2:	fe b0 97 14 	rcall	8000811a <NbNodeAddrError>
{
    #ifdef NB_CBE1
    NbNodeAddrError(Rx_Ptr);                        /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800152f6:	d8 0a       	popm	pc,r12=0

800152f8 <NB_NodeAddr_Status>:
800152f8:	d4 01       	pushm	lr
800152fa:	fe b0 97 0f 	rcall	80008118 <NbNodeAddrStatus>

    #ifdef NB_CBS1
    NbNodeAddrStatus(Rx_Ptr);                       /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
800152fe:	d8 0a       	popm	pc,r12=0

80015300 <NB_ShutDown_Error>:
80015300:	d4 01       	pushm	lr
80015302:	fe b0 97 14 	rcall	8000812a <NbShutDownError>
{
    #ifdef NB_CBE7
    NbShutDownError(Rx_Ptr);                            /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
80015306:	d8 0a       	popm	pc,r12=0

80015308 <NB_ShutDown_Result>:
80015308:	d4 01       	pushm	lr
8001530a:	fe b0 97 0f 	rcall	80008128 <NbShutDownResult>
{
    #ifdef NB_CBS7
    NbShutDownResult(Rx_Ptr);                           /* Transport to Application */
    #endif
    return(OP_NO_REPORT);
}
8001530e:	d8 0a       	popm	pc,r12=0

80015310 <NB_ShutDown_Start>:
80015310:	eb cd 40 80 	pushm	r7,lr
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I70
byte NB_ShutDown_Start(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
80015314:	20 1d       	sub	sp,4
    }
    #endif

    ret = OP_NO_REPORT;                                         /* default: No Result required */

    switch (Rx_Ptr->Data[0])
80015316:	30 29       	mov	r9,2
80015318:	76 0a       	ld.w	r10,r11[0x0]
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I70
byte NB_ShutDown_Start(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
8001531a:	18 97       	mov	r7,r12
    }
    #endif

    ret = OP_NO_REPORT;                                         /* default: No Result required */

    switch (Rx_Ptr->Data[0])
8001531c:	15 88       	ld.ub	r8,r10[0x0]
8001531e:	f2 08 18 00 	cp.b	r8,r9
80015322:	c2 80       	breq	80015372 <NB_ShutDown_Start+0x62>
80015324:	30 49       	mov	r9,4
80015326:	f2 08 18 00 	cp.b	r8,r9
8001532a:	c1 c0       	breq	80015362 <NB_ShutDown_Start+0x52>
8001532c:	30 09       	mov	r9,0
8001532e:	f2 08 18 00 	cp.b	r8,r9
80015332:	c0 80       	breq	80015342 <NB_ShutDown_Start+0x32>

        /*---------------------------------- */
        /*  wrong parameter */
        /*---------------------------------- */
        default:
            ret = CmdErrorParamWrong(Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)1);           /* Prepare Error Message */
80015334:	30 19       	mov	r9,1
80015336:	12 9b       	mov	r11,r9
80015338:	fe b0 f4 2c 	rcall	80013b90 <CmdErrorParamWrong>
            break;
    }
    return(ret);
}
8001533c:	2f fd       	sub	sp,-4
8001533e:	e3 cd 80 80 	ldm	sp++,r7,pc
    {
        /*---------------------------------- */
        /*  NetBlock.ShutDown.Start(Query) */
        /*---------------------------------- */
        case NB_SHUTDOWN_QUERY:
            NetBlock.mShutDown.Suspend = NbShutDown();                  /* Call Application and get new status  */
80015342:	fe b0 96 e8 	rcall	80008112 <NbShutDown>
80015346:	49 48       	lddpc	r8,80015394 <NB_ShutDown_Start+0x84>
80015348:	f1 6c 00 08 	st.b	r8[8],r12

            if (MNS_FALSE != NetBlock.mShutDown.Suspend)                     /* Application not ready for shut down process ? */
8001534c:	58 0c       	cp.w	r12,0
8001534e:	c0 f0       	breq	8001536c <NB_ShutDown_Start+0x5c>
            {
                Tx_Ptr->Data[0] = NB_SHUTDOWN_SUSPEND;                  /* Answer: Suspend */
80015350:	6e 08       	ld.w	r8,r7[0x0]
80015352:	30 19       	mov	r9,1
80015354:	b0 89       	st.b	r8[0x0],r9
                Tx_Ptr->Length  = (word)1;
80015356:	30 cc       	mov	r12,12
80015358:	30 18       	mov	r8,1
8001535a:	ae 28       	st.h	r7[0x4],r8
        default:
            ret = CmdErrorParamWrong(Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)1);           /* Prepare Error Message */
            break;
    }
    return(ret);
}
8001535c:	2f fd       	sub	sp,-4
8001535e:	e3 cd 80 80 	ldm	sp++,r7,pc
            SetConfigStateFilterStatus(MNS_ON);
            #endif
            break;

        case NB_SHUTDOWN_DEVICE:
            if (MNS_FALSE == NbShutDownDevice())
80015362:	50 0b       	stdsp	sp[0x0],r11
80015364:	fe b0 96 d9 	rcall	80008116 <NbShutDownDevice>
80015368:	40 0b       	lddsp	r11,sp[0x0]
8001536a:	c0 d0       	breq	80015384 <NB_ShutDown_Start+0x74>

        /*---------------------------------- */
        /*  wrong parameter */
        /*---------------------------------- */
        default:
            ret = CmdErrorParamWrong(Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)1);           /* Prepare Error Message */
8001536c:	2f fd       	sub	sp,-4
8001536e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

        /*---------------------------------- */
        /*  NetBlock.ShutDown.Start(Execute) */
        /*---------------------------------- */
        case NB_SHUTDOWN_EXECUTE:
            NbShutDownExecute();                                        /* Call Application */
80015372:	fe b0 96 d1 	rcall	80008114 <NbShutDownExecute>
            #ifdef AH_11                    /*     but only when the telegram "NetBlock.ShutDown.Start(Execute)" has been received. */
            AddrHStoreDevTabAH();                                       /* Store decentral registry in non-volatile menory area. */
            #endif                                                      /* But check first, if table has been initialized */

            #ifdef NTF_0
            NtfInit();                                                  /* initialize Notification Service */
80015376:	c8 dd       	rcall	80015690 <NtfInit>
80015378:	30 1c       	mov	r12,1
            #endif

            #ifdef ENABLE_CFG_MSG_FILTER
            SetConfigStateFilterStatus(MNS_ON);
8001537a:	fe b0 fc fb 	rcall	80014d70 <SetConfigStateFilterStatus>
8001537e:	2f fd       	sub	sp,-4
80015380:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80015384:	76 0a       	ld.w	r10,r11[0x0]
            break;

        case NB_SHUTDOWN_DEVICE:
            if (MNS_FALSE == NbShutDownDevice())
            {
                ret = CmdErrorParamWrong(Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)1);           /* Prepare Error Message */
80015386:	30 19       	mov	r9,1
80015388:	0e 9c       	mov	r12,r7
8001538a:	12 9b       	mov	r11,r9
8001538c:	fe b0 f4 02 	rcall	80013b90 <CmdErrorParamWrong>
80015390:	cd 6b       	rjmp	8001533c <NB_ShutDown_Start+0x2c>
80015392:	d7 03       	nop
80015394:	00 00       	add	r0,r0
80015396:	4a 41       	lddpc	r1,80015424 <NB_DeviceInfo_Get+0x7c>

80015398 <NB_DeviceInfo_Error>:
80015398:	d4 01       	pushm	lr
8001539a:	fe b0 96 c4 	rcall	80008122 <NbDeviceInfoError>
8001539e:	d8 0a       	popm	pc,r12=0

800153a0 <NB_DeviceInfo_Status>:
800153a0:	d4 01       	pushm	lr
800153a2:	fe b0 96 bf 	rcall	80008120 <NbDeviceInfoStatus>
800153a6:	d8 0a       	popm	pc,r12=0

800153a8 <NB_DeviceInfo_Get>:
800153a8:	d4 21       	pushm	r4-r7,lr
800153aa:	78 08       	ld.w	r8,r12[0x0]
800153ac:	76 09       	ld.w	r9,r11[0x0]
800153ae:	18 96       	mov	r6,r12
    #ifndef CMD_ADD8
    if (Rx_Ptr->Length != (word)1)
        return( CmdErrorMsg(Tx_Ptr, ERR_LENGTH) );              /* return(OP_ERROR) */
    #endif

    rx_id           = Rx_Ptr->Data[0];
800153b0:	13 8c       	ld.ub	r12,r9[0x0]
    Tx_Ptr->Data[0] = rx_id;                                    /* Data[0] contains ID !! */
800153b2:	b0 8c       	st.b	r8[0x0],r12
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I31
byte NB_DeviceInfo_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
{
800153b4:	16 95       	mov	r5,r11

    rx_id           = Rx_Ptr->Data[0];
    Tx_Ptr->Data[0] = rx_id;                                    /* Data[0] contains ID !! */
    returnvalue     = OP_STATUS;

    switch (rx_id)
800153b6:	3a 08       	mov	r8,-96
800153b8:	f0 0c 18 00 	cp.b	r12,r8
800153bc:	c0 d0       	breq	800153d6 <NB_DeviceInfo_Get+0x2e>

        /*--------------------------- */
        /* Handled by application */
        /*--------------------------- */
        default:
            Tx_Ptr->Length = (word)0;                           /* gives the possibility to recognize if the application has created an own error message */ 
800153be:	30 04       	mov	r4,0
            returnvalue = NbGetDeviceInfo(rx_id, Tx_Ptr);       /* Call Application, whenever request cannot  */
800153c0:	0c 9b       	mov	r11,r6

        /*--------------------------- */
        /* Handled by application */
        /*--------------------------- */
        default:
            Tx_Ptr->Length = (word)0;                           /* gives the possibility to recognize if the application has created an own error message */ 
800153c2:	ac 24       	st.h	r6[0x4],r4
            returnvalue = NbGetDeviceInfo(rx_id, Tx_Ptr);       /* Call Application, whenever request cannot  */
800153c4:	fe b0 97 d6 	rcall	80008370 <NbGetDeviceInfo>
                                                                /* be answered by NetServices directly */

            if (   (OP_ERROR == returnvalue)                    /* unknown ID ? */
800153c8:	30 f8       	mov	r8,15
        /*--------------------------- */
        /* Handled by application */
        /*--------------------------- */
        default:
            Tx_Ptr->Length = (word)0;                           /* gives the possibility to recognize if the application has created an own error message */ 
            returnvalue = NbGetDeviceInfo(rx_id, Tx_Ptr);       /* Call Application, whenever request cannot  */
800153ca:	18 97       	mov	r7,r12
                                                                /* be answered by NetServices directly */

            if (   (OP_ERROR == returnvalue)                    /* unknown ID ? */
800153cc:	f0 0c 18 00 	cp.b	r12,r8
800153d0:	c2 00       	breq	80015410 <NB_DeviceInfo_Get+0x68>
            }
            break;
    }

    return(returnvalue);
}
800153d2:	0e 9c       	mov	r12,r7
800153d4:	d8 22       	popm	r4-r7,pc
        /* NetServices Version */
        /* NetServices Revision */
        /*--------------------------- */
        case 0xA0:

            MostGetRevision(&Tx_Ptr->Data[1]);                  /* Data[1]: Day of Transceiver Revision Date */
800153d6:	6c 0c       	ld.w	r12,r6[0x0]
800153d8:	2f fc       	sub	r12,-1
800153da:	fe b0 ad 31 	rcall	8000ae3c <MostGetRevision>
                                                                /* Data[2]: Month of Transceiver Revision Date */
                                                                /* Data[3]: Year of Transceiver Revision Date */
            tgt_ptr = &Tx_Ptr->Data[4];
800153de:	6c 08       	ld.w	r8,r6[0x0]
            *tgt_ptr++ = ((byte)0x03);                           /* Data[4]..[6]:  NetServices Version */
800153e0:	30 39       	mov	r9,3
800153e2:	b0 c9       	st.b	r8[0x4],r9
800153e4:	f0 ca ff fb 	sub	r10,r8,-5
            *tgt_ptr++ = ((byte)0x00);
800153e8:	30 09       	mov	r9,0
800153ea:	b4 89       	st.b	r10[0x0],r9
            *tgt_ptr++ = ((byte)0x04);
800153ec:	30 4a       	mov	r10,4
800153ee:	b0 ea       	st.b	r8[0x6],r10
800153f0:	f0 ca ff f9 	sub	r10,r8,-7
            *tgt_ptr++ = ((byte)0x00);                           /* Data[7]..[10]: NetServices Revision           */
800153f4:	b4 89       	st.b	r10[0x0],r9
            *tgt_ptr++ = ((byte)0x18);                           /*           */
800153f6:	31 89       	mov	r9,24
800153f8:	f1 69 00 08 	st.b	r8[8],r9
            *tgt_ptr++ = ((byte)0xFF);                           /*                       */
800153fc:	3f f9       	mov	r9,-1
            tgt_ptr = &Tx_Ptr->Data[4];
            *tgt_ptr++ = ((byte)0x03);                           /* Data[4]..[6]:  NetServices Version */
            *tgt_ptr++ = ((byte)0x00);
            *tgt_ptr++ = ((byte)0x04);
            *tgt_ptr++ = ((byte)0x00);                           /* Data[7]..[10]: NetServices Revision           */
            *tgt_ptr++ = ((byte)0x18);                           /*           */
800153fe:	2f 78       	sub	r8,-9
            *tgt_ptr++ = ((byte)0xFF);                           /*                       */
80015400:	b0 89       	st.b	r8[0x0],r9
            *tgt_ptr   = ((byte)0x2A);                           /*                       */
80015402:	32 a9       	mov	r9,42
80015404:	b0 99       	st.b	r8[0x1],r9

            Tx_Ptr->Length = (word)11;
80015406:	30 c7       	mov	r7,12
80015408:	30 b8       	mov	r8,11
            }
            break;
    }

    return(returnvalue);
}
8001540a:	0e 9c       	mov	r12,r7
            *tgt_ptr++ = ((byte)0x00);                           /* Data[7]..[10]: NetServices Revision           */
            *tgt_ptr++ = ((byte)0x18);                           /*           */
            *tgt_ptr++ = ((byte)0xFF);                           /*                       */
            *tgt_ptr   = ((byte)0x2A);                           /*                       */

            Tx_Ptr->Length = (word)11;
8001540c:	ac 28       	st.h	r6[0x4],r8
            }
            break;
    }

    return(returnvalue);
}
8001540e:	d8 22       	popm	r4-r7,pc
            Tx_Ptr->Length = (word)0;                           /* gives the possibility to recognize if the application has created an own error message */ 
            returnvalue = NbGetDeviceInfo(rx_id, Tx_Ptr);       /* Call Application, whenever request cannot  */
                                                                /* be answered by NetServices directly */

            if (   (OP_ERROR == returnvalue)                    /* unknown ID ? */
                && ((word)0  == Tx_Ptr->Length))                /* did application create an error message ? */
80015410:	8c 28       	ld.sh	r8,r6[0x4]
80015412:	e8 08 19 00 	cp.h	r8,r4
80015416:	cd e1       	brne	800153d2 <NB_DeviceInfo_Get+0x2a>
            {
                (void)CmdErrorParamWrong( Tx_Ptr, (byte)1, &Rx_Ptr->Data[0], (byte)1);    /* prepare error message   */
80015418:	30 19       	mov	r9,1
8001541a:	6a 0a       	ld.w	r10,r5[0x0]
8001541c:	0c 9c       	mov	r12,r6
8001541e:	12 9b       	mov	r11,r9
80015420:	fe b0 f3 b8 	rcall	80013b90 <CmdErrorParamWrong>
80015424:	cd 7b       	rjmp	800153d2 <NB_DeviceInfo_Get+0x2a>
80015426:	d7 03       	nop

80015428 <NB_FBlockIDs_Error>:
80015428:	d4 01       	pushm	lr
8001542a:	fe b0 96 7a 	rcall	8000811e <NbFBlockIDsError>
8001542e:	d8 0a       	popm	pc,r12=0

80015430 <NB_FBlockIDs_Status>:
80015430:	d4 01       	pushm	lr
80015432:	fe b0 96 75 	rcall	8000811c <NbFBlockIDsStatus>
    #if !(defined AH_5) && !(defined NB_CBS2)
    (void) Rx_Ptr;
    #endif

    return(OP_NO_REPORT);
}
80015436:	d8 0a       	popm	pc,r12=0

80015438 <NB_FBlockIDs_Get>:
80015438:	eb cd 40 fc 	pushm	r2-r7,lr
            }
        }
    }
    #endif

    if (NULL != Rx_Ptr)
8001543c:	58 0b       	cp.w	r11,0
8001543e:	c0 a0       	breq	80015452 <NB_FBlockIDs_Get+0x1a>
    {
        if ((byte)0xFF == Rx_Ptr->Inst_ID)                          /* injected message? */
80015440:	f7 39 00 0b 	ld.ub	r9,r11[11]
80015444:	3f f8       	mov	r8,-1
        {
            Tx_Ptr->MidLevelRetries = DEF_MID_LEVEL_RETRIES_FBLOCKIDS;
80015446:	f0 09 18 00 	cp.b	r9,r8
8001544a:	f9 b8 00 3f 	moveq	r8,63
8001544e:	f9 f8 0e 0d 	st.beq	r12[0xd],r8
        }
    }

    #ifndef NB_CB9  /* Response message is prepared by NetServices */
    ptr_data  = &Tx_Ptr->Data[0];
80015452:	49 b8       	lddpc	r8,800154bc <NB_FBlockIDs_Get+0x84>
/*               Rx_Ptr = NULL, if function is called by NTFS module.       */
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I21
byte NB_FBlockIDs_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
80015454:	30 0e       	mov	lr,0
            Tx_Ptr->MidLevelRetries = DEF_MID_LEVEL_RETRIES_FBLOCKIDS;
        }
    }

    #ifndef NB_CB9  /* Response message is prepared by NetServices */
    ptr_data  = &Tx_Ptr->Data[0];
80015456:	78 03       	ld.w	r3,r12[0x0]
/*               Rx_Ptr = NULL, if function is called by NTFS module.       */
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NB_I21
byte NB_FBlockIDs_Get(pTMsgTx Tx_Ptr, pTMsgRx Rx_Ptr)
80015458:	f0 c4 ff fd 	sub	r4,r8,-3
    overflow  = MNS_FALSE;

    #if (NUM_FBLOCKS>0)
    for (i=(byte)0;(i<NUM_FBLOCKS) && (MNS_FALSE == overflow);i++)
    {
        if (   ((byte)0xF0 >  NetBlock.pFBlockIDs.FBlockID[i])      /* Filter supplier specific FBlocks */
8001545c:	30 f5       	mov	r5,15
8001545e:	3e f6       	mov	r6,-17
80015460:	1c 97       	mov	r7,lr
            && (FBLOCK_ET  != NetBlock.pFBlockIDs.FBlockID[i]) )    /* and FBlock ET */
        {
            if (counter < (word)(MAX_MSG_TX_DATA - 1))
80015462:	33 02       	mov	r2,48
    overflow  = MNS_FALSE;

    #if (NUM_FBLOCKS>0)
    for (i=(byte)0;(i<NUM_FBLOCKS) && (MNS_FALSE == overflow);i++)
    {
        if (   ((byte)0xF0 >  NetBlock.pFBlockIDs.FBlockID[i])      /* Filter supplier specific FBlocks */
80015464:	11 89       	ld.ub	r9,r8[0x0]
80015466:	ea 09 18 00 	cp.b	r9,r5
8001546a:	5f 1b       	srne	r11
8001546c:	f2 06 18 00 	cp.b	r6,r9
80015470:	f9 ba 02 01 	movhs	r10,1
80015474:	f9 ba 03 00 	movlo	r10,0
80015478:	f7 ea 00 0a 	and	r10,r11,r10
8001547c:	ee 0a 18 00 	cp.b	r10,r7
80015480:	c1 50       	breq	800154aa <NB_FBlockIDs_Get+0x72>
            && (FBLOCK_ET  != NetBlock.pFBlockIDs.FBlockID[i]) )    /* and FBlock ET */
        {
            if (counter < (word)(MAX_MSG_TX_DATA - 1))
80015482:	e4 0e 19 00 	cp.h	lr,r2
80015486:	e0 88 00 0d 	brls	800154a0 <NB_FBlockIDs_Get+0x68>
8001548a:	30 19       	mov	r9,1
    ptr_data  = &Tx_Ptr->Data[0];
    counter   = (byte)0;
    overflow  = MNS_FALSE;

    #if (NUM_FBLOCKS>0)
    for (i=(byte)0;(i<NUM_FBLOCKS) && (MNS_FALSE == overflow);i++)
8001548c:	08 38       	cp.w	r8,r4
8001548e:	c1 10       	breq	800154b0 <NB_FBlockIDs_Get+0x78>
80015490:	2f f8       	sub	r8,-1
80015492:	58 09       	cp.w	r9,0
80015494:	ce 80       	breq	80015464 <NB_FBlockIDs_Get+0x2c>
        }
    }
    #endif
    if (MNS_FALSE != overflow)
    {
        return(CmdErrorMsg(Tx_Ptr, ERR_PROCESSING)); /* Processing Error */
80015496:	34 2b       	mov	r11,66
80015498:	fe b0 f3 6e 	rcall	80013b74 <CmdErrorMsg>
8001549c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
        if (   ((byte)0xF0 >  NetBlock.pFBlockIDs.FBlockID[i])      /* Filter supplier specific FBlocks */
            && (FBLOCK_ET  != NetBlock.pFBlockIDs.FBlockID[i]) )    /* and FBlock ET */
        {
            if (counter < (word)(MAX_MSG_TX_DATA - 1))
            {
                *ptr_data++ =  NetBlock.pFBlockIDs.FBlockID[i];
800154a0:	06 c9       	st.b	r3++,r9
                *ptr_data++ =  NetBlock.pFBlockIDs.InstID[i];
                counter     += (byte)2;
800154a2:	2f ee       	sub	lr,-2
            && (FBLOCK_ET  != NetBlock.pFBlockIDs.FBlockID[i]) )    /* and FBlock ET */
        {
            if (counter < (word)(MAX_MSG_TX_DATA - 1))
            {
                *ptr_data++ =  NetBlock.pFBlockIDs.FBlockID[i];
                *ptr_data++ =  NetBlock.pFBlockIDs.InstID[i];
800154a4:	11 c9       	ld.ub	r9,r8[0x4]
                counter     += (byte)2;
800154a6:	5c 8e       	casts.h	lr
            && (FBLOCK_ET  != NetBlock.pFBlockIDs.FBlockID[i]) )    /* and FBlock ET */
        {
            if (counter < (word)(MAX_MSG_TX_DATA - 1))
            {
                *ptr_data++ =  NetBlock.pFBlockIDs.FBlockID[i];
                *ptr_data++ =  NetBlock.pFBlockIDs.InstID[i];
800154a8:	06 c9       	st.b	r3++,r9
                counter     += (byte)2;
800154aa:	30 09       	mov	r9,0
    ptr_data  = &Tx_Ptr->Data[0];
    counter   = (byte)0;
    overflow  = MNS_FALSE;

    #if (NUM_FBLOCKS>0)
    for (i=(byte)0;(i<NUM_FBLOCKS) && (MNS_FALSE == overflow);i++)
800154ac:	08 38       	cp.w	r8,r4
800154ae:	cf 11       	brne	80015490 <NB_FBlockIDs_Get+0x58>
                overflow = MNS_TRUE;
            }
        }
    }
    #endif
    if (MNS_FALSE != overflow)
800154b0:	58 09       	cp.w	r9,0
800154b2:	cf 21       	brne	80015496 <NB_FBlockIDs_Get+0x5e>
    {
        return(CmdErrorMsg(Tx_Ptr, ERR_PROCESSING)); /* Processing Error */
    }
    else
    {
        Tx_Ptr->Length = (word)counter;
800154b4:	b8 2e       	st.h	r12[0x4],lr
800154b6:	30 cc       	mov	r12,12
    Tx_Ptr->Operation = OP_STATUS;      /* default, can be overwritten, by using OP_NO_REPORT */
    Tx_Ptr->Length    = (word)0;        /* length and data must be set by application */
    NBFBlockIDsGet(Tx_Ptr);             /* call application to prepare the response */
    return(Tx_Ptr->Operation);
    #endif
}
800154b8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800154bc:	00 00       	add	r0,r0
800154be:	4a 41       	lddpc	r1,8001554c <NM_Configuration_Error>

800154c0 <NmGetNWMAddr>:
/* Returns     : NetworkMaster Address                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NM_1
word NmGetNWMAddr(void)
{
800154c0:	48 28       	lddpc	r8,800154c8 <NmGetNWMAddr+0x8>
    return(NetworkMaster_Addr);
}
800154c2:	90 0c       	ld.sh	r12,r8[0x0]
800154c4:	5e fc       	retal	r12
800154c6:	d7 03       	nop
800154c8:	00 00       	add	r0,r0
800154ca:	4a 4a       	lddpc	r10,80015558 <NM_Configuration_Status+0x4>

800154cc <NM_OwnConfigInvalid_ErrorAck>:
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NM_I9FA
byte NM_OwnConfigInvalid_ErrorAck(pTMsgRx Rx_Ptr)
{
800154cc:	d4 01       	pushm	lr
    #ifdef NM_CBEA9
    NmOwnConfigInvalidErrorAck(Rx_Ptr);
800154ce:	fe b0 96 51 	rcall	80008170 <NmOwnConfigInvalidErrorAck>
    #endif
    return(OP_NO_REPORT);
}
800154d2:	d8 0a       	popm	pc,r12=0

800154d4 <NM_OwnConfigInvalid_ResultAck>:
800154d4:	d4 01       	pushm	lr
800154d6:	fe b0 96 4c 	rcall	8000816e <NmOwnConfigInvalidResultAck>
{
    #ifdef NM_CBRA9
    NmOwnConfigInvalidResultAck(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
800154da:	d8 0a       	popm	pc,r12=0

800154dc <NM_Version_Error>:
800154dc:	d4 01       	pushm	lr
800154de:	fe b0 96 47 	rcall	8000816c <NmVersionError>
{
    #ifdef NM_CBE8
    NmVersionError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
800154e2:	d8 0a       	popm	pc,r12=0

800154e4 <NM_Version_Status>:
800154e4:	d4 01       	pushm	lr
800154e6:	fe b0 96 42 	rcall	8000816a <NmVersionStatus>
{
    #ifdef NM_CBS8
    NmVersionStatus(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
800154ea:	d8 0a       	popm	pc,r12=0

800154ec <NM_FBlockInfo_Error>:
800154ec:	d4 01       	pushm	lr
800154ee:	fe b0 96 3d 	rcall	80008168 <NmFBlockInfoError>
{
    #ifdef NM_CBE7
    NmFBlockInfoError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
800154f2:	d8 0a       	popm	pc,r12=0

800154f4 <NM_FBlockInfo_Status>:
800154f4:	d4 01       	pushm	lr
800154f6:	fe b0 96 38 	rcall	80008166 <NmFBlockInfoStatus>
{
    #ifdef NM_CBS7
    NmFBlockInfoStatus(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
800154fa:	d8 0a       	popm	pc,r12=0

800154fc <NM_SystemAvail_Error>:
800154fc:	d4 01       	pushm	lr
800154fe:	fe b0 96 33 	rcall	80008164 <NmSystemAvailError>
{
    #ifdef NM_CBE6
    NmSystemAvailError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
80015502:	d8 0a       	popm	pc,r12=0

80015504 <NM_SystemAvail_Status>:
80015504:	d4 01       	pushm	lr
80015506:	fe b0 96 2e 	rcall	80008162 <NmSystemAvailStatus>
{
    #ifdef NM_CBS6
    NmSystemAvailStatus(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
8001550a:	d8 0a       	popm	pc,r12=0

8001550c <NM_FktIDs_Error>:
8001550c:	d4 01       	pushm	lr
8001550e:	fe b0 96 29 	rcall	80008160 <NmFktIDsError>
{
    #ifdef NM_CBE5
    NmFktIDsError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
80015512:	d8 0a       	popm	pc,r12=0

80015514 <NM_FktIDs_Status>:
80015514:	d4 01       	pushm	lr
80015516:	fe b0 96 24 	rcall	8000815e <NmFktIDsStatus>
{
    #ifdef NM_CBS5
    NmFktIDsStatus(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
8001551a:	d8 0a       	popm	pc,r12=0

8001551c <NM_SaveConfig_ErrorAck>:
8001551c:	d4 01       	pushm	lr
8001551e:	fe b0 96 1f 	rcall	8000815c <NmSaveConfigErrorAck>
{
    #ifdef NM_CBEA4
    NmSaveConfigErrorAck(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
80015522:	d8 0a       	popm	pc,r12=0

80015524 <NM_SaveConfig_Error>:
80015524:	d4 01       	pushm	lr
80015526:	fe b0 96 19 	rcall	80008158 <NmSaveConfigError>
{
    #ifdef NM_CBE4
    NmSaveConfigError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
8001552a:	d8 0a       	popm	pc,r12=0

8001552c <NM_SaveConfig_ResultAck>:
8001552c:	d4 01       	pushm	lr
8001552e:	fe b0 96 16 	rcall	8000815a <NmSaveConfigResultAck>
{
    #ifdef NM_CBRA4
    NmSaveConfigResultAck(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
80015532:	d8 0a       	popm	pc,r12=0

80015534 <NM_SaveConfig_Result>:
80015534:	d4 01       	pushm	lr
80015536:	fe b0 96 10 	rcall	80008156 <NmSaveConfigResult>
{
    #ifdef NM_CBR4
    NmSaveConfigResult(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
8001553a:	d8 0a       	popm	pc,r12=0

8001553c <NM_CentralReg_Error>:
8001553c:	d4 01       	pushm	lr
8001553e:	fe b0 96 0b 	rcall	80008154 <NmCentralRegError>

    #ifdef NM_CBE2
    NmCentralRegError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
80015542:	d8 0a       	popm	pc,r12=0

80015544 <NM_CentralReg_Status>:
80015544:	d4 01       	pushm	lr
80015546:	fe b0 96 06 	rcall	80008152 <NmCentralRegStatus>

    #ifdef NM_CBS2
    NmCentralRegStatus(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
8001554a:	d8 0a       	popm	pc,r12=0

8001554c <NM_Configuration_Error>:
8001554c:	d4 01       	pushm	lr
8001554e:	fe b0 96 01 	rcall	80008150 <NmConfigurationError>
{
    #ifdef NM_CBE1
    NmConfigurationError(Rx_Ptr);
    #endif
    return(OP_NO_REPORT);
}
80015552:	d8 0a       	popm	pc,r12=0

80015554 <NM_Configuration_Status>:
80015554:	eb cd 40 80 	pushm	r7,lr
/* Returns     : OP_Type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NM_I1C
byte NM_Configuration_Status(pTMsgRx Rx_Ptr)
{
80015558:	18 97       	mov	r7,r12
    }
    #endif


    #ifdef NM_CBS1
    NmConfigurationStatus(Rx_Ptr);
8001555a:	fe b0 95 fa 	rcall	8000814e <NmConfigurationStatus>
    #endif

    #ifdef MSV2_3
    ConfigStatusChanged(Rx_Ptr);
8001555e:	0e 9c       	mov	r12,r7
80015560:	fe b0 fc 16 	rcall	80014d8c <ConfigStatusChanged>
    #endif

    return(OP_NO_REPORT);
}
80015564:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80015568 <NtfCalcNum>:
/* Returns     : Number of Matrix Elements                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_6
word NtfCalcNum(void)
{
80015568:	eb cd 40 f8 	pushm	r3-r7,lr
    word num_elements;
    byte i;

    num_elements = (word)0;

    NtfFBlockPtr = NtfFBlockTab;
8001556c:	49 28       	lddpc	r8,800155b4 <NtfCalcNum+0x4c>
8001556e:	49 36       	lddpc	r6,800155b8 <NtfCalcNum+0x50>
/* Parameter(s): none                                                       */
/* Returns     : Number of Matrix Elements                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_6
word NtfCalcNum(void)
80015570:	10 97       	mov	r7,r8
    word num_elements;
    byte i;

    num_elements = (word)0;

    NtfFBlockPtr = NtfFBlockTab;
80015572:	8d 08       	st.w	r6[0x0],r8
/* Parameter(s): none                                                       */
/* Returns     : Number of Matrix Elements                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_6
word NtfCalcNum(void)
80015574:	f0 c3 ff f0 	sub	r3,r8,-16
80015578:	30 0c       	mov	r12,0
8001557a:	49 14       	lddpc	r4,800155bc <NtfCalcNum+0x54>
8001557c:	49 15       	lddpc	r5,800155c0 <NtfCalcNum+0x58>
8001557e:	49 2e       	lddpc	lr,800155c4 <NtfCalcNum+0x5c>

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        NtfLoadFBlockDescription();

        while(NtfPropTabPtr->Type_FuncID != NTF_TERMINATION)
80015580:	3f fb       	mov	r11,-1
#ifdef NTF_2
void NtfLoadFBlockDescription(void)
{
    NtfFBlockIndex = NtfFBlockPtr->FBlockIndex;     /* read local fblock index */
    NtfNumDev      = NtfFBlockPtr->NumDev;          /* read number of devices of this device table (column of notif.matrix) */
    NtfPropTabPtr  = NtfFBlockPtr->PtrPropTab;      /* Load base address of property table */
80015582:	6e 18       	ld.w	r8,r7[0x4]
80015584:	9d 08       	st.w	lr[0x0],r8
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_2
void NtfLoadFBlockDescription(void)
{
    NtfFBlockIndex = NtfFBlockPtr->FBlockIndex;     /* read local fblock index */
80015586:	0f 89       	ld.ub	r9,r7[0x0]
80015588:	a8 89       	st.b	r4[0x0],r9
    NtfNumDev      = NtfFBlockPtr->NumDev;          /* read number of devices of this device table (column of notif.matrix) */
8001558a:	0f 9a       	ld.ub	r10,r7[0x1]
8001558c:	aa 8a       	st.b	r5[0x0],r10

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        NtfLoadFBlockDescription();

        while(NtfPropTabPtr->Type_FuncID != NTF_TERMINATION)
8001558e:	90 09       	ld.sh	r9,r8[0x0]
80015590:	f6 09 19 00 	cp.h	r9,r11
80015594:	c0 a0       	breq	800155a8 <NtfCalcNum+0x40>
80015596:	2f 08       	sub	r8,-16
        {
            num_elements += (word)NtfNumDev;
            NtfPropTabPtr++;
80015598:	9d 08       	st.w	lr[0x0],r8
    {
        NtfLoadFBlockDescription();

        while(NtfPropTabPtr->Type_FuncID != NTF_TERMINATION)
        {
            num_elements += (word)NtfNumDev;
8001559a:	14 0c       	add	r12,r10

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        NtfLoadFBlockDescription();

        while(NtfPropTabPtr->Type_FuncID != NTF_TERMINATION)
8001559c:	90 09       	ld.sh	r9,r8[0x0]
        {
            num_elements += (word)NtfNumDev;
8001559e:	5c 8c       	casts.h	r12

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        NtfLoadFBlockDescription();

        while(NtfPropTabPtr->Type_FuncID != NTF_TERMINATION)
800155a0:	2f 08       	sub	r8,-16
800155a2:	f6 09 19 00 	cp.h	r9,r11
800155a6:	cf 91       	brne	80015598 <NtfCalcNum+0x30>
        {
            num_elements += (word)NtfNumDev;
            NtfPropTabPtr++;
        }

        NtfFBlockPtr++;
800155a8:	2f 87       	sub	r7,-8
800155aa:	8d 07       	st.w	r6[0x0],r7

    num_elements = (word)0;

    NtfFBlockPtr = NtfFBlockTab;

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
800155ac:	06 37       	cp.w	r7,r3
800155ae:	ce a1       	brne	80015582 <NtfCalcNum+0x1a>

        NtfFBlockPtr++;
    }

    return(num_elements);
}
800155b0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800155b4:	80 07       	ld.sh	r7,r0[0x0]
800155b6:	08 5c       	eor	r12,r4
800155b8:	00 00       	add	r0,r0
800155ba:	4a 6c       	lddpc	r12,80015650 <NtfInitOneMatrix+0x88>
800155bc:	00 00       	add	r0,r0
800155be:	4a 74       	lddpc	r4,80015658 <NtfInitOneMatrix+0x90>
800155c0:	00 00       	add	r0,r0
800155c2:	4a 78       	lddpc	r8,8001565c <NtfInitOneMatrix+0x94>
800155c4:	00 00       	add	r0,r0
800155c6:	4a 4c       	lddpc	r12,80015654 <NtfInitOneMatrix+0x8c>

800155c8 <NtfInitOneMatrix>:
/*               0x02: init_mode not supported                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_9
byte NtfInitOneMatrix(byte ntf_fblock_index, bool init_mode)
{
800155c8:	eb cd 40 f8 	pushm	r3-r7,lr
    pTNtfMatrix ptrMatrix;      /* pointer at notification matrix (contains flags and device index)          */
    TNtfMatrix flags_device_index;
    byte device_index;


    if (ntf_fblock_index < NTF_MAX_FBLOCKS)      /* valid index ?  (0 = first entry in the table) */
800155cc:	30 14       	mov	r4,1
800155ce:	e8 0c 18 00 	cp.b	r12,r4
800155d2:	e0 88 00 04 	brls	800155da <NtfInitOneMatrix+0x12>
800155d6:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
    {
        ptrFBlockTab = &NtfFBlockTab[ntf_fblock_index];     /* load ptr at FBlock table */
800155da:	4a 88       	lddpc	r8,80015678 <NtfInitOneMatrix+0xb0>
800155dc:	f0 0c 00 3c 	add	r12,r8,r12<<0x3
        num_lines   = (byte)(ptrFBlockTab->NumDev + 1);             /* +1 due to the flag field */
        ptrPropTab  = ptrFBlockTab->PtrPropTab;             /* load pointer at property table */
800155e0:	78 16       	ld.w	r6,r12[0x4]


    if (ntf_fblock_index < NTF_MAX_FBLOCKS)      /* valid index ?  (0 = first entry in the table) */
    {
        ptrFBlockTab = &NtfFBlockTab[ntf_fblock_index];     /* load ptr at FBlock table */
        num_lines   = (byte)(ptrFBlockTab->NumDev + 1);             /* +1 due to the flag field */
800155e2:	19 98       	ld.ub	r8,r12[0x1]
800155e4:	f0 cc ff ff 	sub	r12,r8,-1
800155e8:	5c 5c       	castu.b	r12
        ptrPropTab  = ptrFBlockTab->PtrPropTab;             /* load pointer at property table */


        if (MNS_FALSE != init_mode)  /* as part of first or complete initialization : */
800155ea:	58 0b       	cp.w	r11,0
800155ec:	c2 d1       	brne	80015646 <NtfInitOneMatrix+0x7e>
        {
            #if 0
            return(0x02);   /*  re-initialization not supported */
            #endif

            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
800155ee:	8c 09       	ld.sh	r9,r6[0x0]
800155f0:	3f f5       	mov	r5,-1
800155f2:	ea 09 19 00 	cp.h	r9,r5
800155f6:	c2 60       	breq	80015642 <NtfInitOneMatrix+0x7a>
/*               0x01: matrix not initialized, due to wrong index           */
/*               0x02: init_mode not supported                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_9
byte NtfInitOneMatrix(byte ntf_fblock_index, bool init_mode)
800155f8:	20 18       	sub	r8,1

            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */

                *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;          /* clear flagfield (first line) in the matrix */
800155fa:	31 fa       	mov	r10,31
/*               0x01: matrix not initialized, due to wrong index           */
/*               0x02: init_mode not supported                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_9
byte NtfInitOneMatrix(byte ntf_fblock_index, bool init_mode)
800155fc:	e7 d8 c0 08 	bfextu	r3,r8,0x0,0x8
                    {
                        device_index = (byte)(flags_device_index & MASK_DEV_INDEX);

                        *ptrMatrix = NTF_DEV_INDEX_FREE;        /* clear entry */

                        if ((word)0 < NtfDeviceTabCnt[device_index])
80015600:	49 f7       	lddpc	r7,8001567c <NtfInitOneMatrix+0xb4>
            return(0x02);   /*  re-initialization not supported */
            #endif

            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */
80015602:	6c 18       	ld.w	r8,r6[0x4]

                *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;          /* clear flagfield (first line) in the matrix */
80015604:	b0 8a       	st.b	r8[0x0],r10

                for (i=(byte)1; i<num_lines; i++)                             /* number of lines per property */
80015606:	e8 0c 18 00 	cp.b	r12,r4
8001560a:	e0 88 00 17 	brls	80015638 <NtfInitOneMatrix+0x70>

            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */

                *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;          /* clear flagfield (first line) in the matrix */
8001560e:	2f f8       	sub	r8,-1
/*               0x01: matrix not initialized, due to wrong index           */
/*               0x02: init_mode not supported                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_9
byte NtfInitOneMatrix(byte ntf_fblock_index, bool init_mode)
80015610:	f0 03 00 0e 	add	lr,r8,r3
80015614:	c0 28       	rjmp	80015618 <NtfInitOneMatrix+0x50>
                        {
                            NtfDeviceTabCnt[device_index]--;                /* decrement respective counter of Device Index Table */
                        }

                    }
                    ptrMatrix++;
80015616:	2f f8       	sub	r8,-1

                *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;          /* clear flagfield (first line) in the matrix */

                for (i=(byte)1; i<num_lines; i++)                             /* number of lines per property */
                {
                    flags_device_index = *ptrMatrix;
80015618:	11 89       	ld.ub	r9,r8[0x0]
                    if (flags_device_index != NTF_DEV_INDEX_FREE)       /* entry already in use */
8001561a:	f4 09 18 00 	cp.b	r9,r10
8001561e:	c0 b0       	breq	80015634 <NtfInitOneMatrix+0x6c>
                    {
                        device_index = (byte)(flags_device_index & MASK_DEV_INDEX);

                        *ptrMatrix = NTF_DEV_INDEX_FREE;        /* clear entry */
80015620:	b0 8a       	st.b	r8[0x0],r10

                        if ((word)0 < NtfDeviceTabCnt[device_index])
80015622:	f3 d9 c0 05 	bfextu	r9,r9,0x0,0x5
80015626:	ee 09 04 1b 	ld.sh	r11,r7[r9<<0x1]
8001562a:	58 0b       	cp.w	r11,0
8001562c:	c0 40       	breq	80015634 <NtfInitOneMatrix+0x6c>
                        {
                            NtfDeviceTabCnt[device_index]--;                /* decrement respective counter of Device Index Table */
8001562e:	20 1b       	sub	r11,1
80015630:	ee 09 0a 1b 	st.h	r7[r9<<0x1],r11
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */

                *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;          /* clear flagfield (first line) in the matrix */

                for (i=(byte)1; i<num_lines; i++)                             /* number of lines per property */
80015634:	1c 38       	cp.w	r8,lr
80015636:	cf 01       	brne	80015616 <NtfInitOneMatrix+0x4e>

                    }
                    ptrMatrix++;
                }

                ptrPropTab++;                                           /* next property */
80015638:	2f 06       	sub	r6,-16
        {
            #if 0
            return(0x02);   /*  re-initialization not supported */
            #endif

            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
8001563a:	8c 08       	ld.sh	r8,r6[0x0]
8001563c:	ea 08 19 00 	cp.h	r8,r5
80015640:	ce 11       	brne	80015602 <NtfInitOneMatrix+0x3a>
80015642:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
        ptrPropTab  = ptrFBlockTab->PtrPropTab;             /* load pointer at property table */


        if (MNS_FALSE != init_mode)  /* as part of first or complete initialization : */
        {
            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
80015646:	8c 08       	ld.sh	r8,r6[0x0]
80015648:	3f fb       	mov	r11,-1
8001564a:	f6 08 19 00 	cp.h	r8,r11
8001564e:	cf a0       	breq	80015642 <NtfInitOneMatrix+0x7a>
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */

                for (i=(byte)0; i<num_lines; i++)                             /* number of lines per property */
                {
                    *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;      /* clear entry in matrix */
80015650:	31 fa       	mov	r10,31

        if (MNS_FALSE != init_mode)  /* as part of first or complete initialization : */
        {
            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */
80015652:	6c 19       	ld.w	r9,r6[0x4]

                for (i=(byte)0; i<num_lines; i++)                             /* number of lines per property */
80015654:	58 0c       	cp.w	r12,0
80015656:	c0 90       	breq	80015668 <NtfInitOneMatrix+0xa0>
80015658:	30 08       	mov	r8,0
                {
                    *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;      /* clear entry in matrix */
8001565a:	f2 08 0b 0a 	st.b	r9[r8],r10
8001565e:	2f f8       	sub	r8,-1
        {
            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
            {
                ptrMatrix = ptrPropTab->PtrNtfMatrixCol;                /* load base ptr at column (one property) */

                for (i=(byte)0; i<num_lines; i++)                             /* number of lines per property */
80015660:	f0 0c 18 00 	cp.b	r12,r8
80015664:	fe 9b ff fb 	brhi	8001565a <NtfInitOneMatrix+0x92>
                {
                    *ptrMatrix++ = (TNtfMatrix)NTF_DEV_INDEX_FREE;      /* clear entry in matrix */
                }

                ptrPropTab++;                                           /* next property */
80015668:	2f 06       	sub	r6,-16
        ptrPropTab  = ptrFBlockTab->PtrPropTab;             /* load pointer at property table */


        if (MNS_FALSE != init_mode)  /* as part of first or complete initialization : */
        {
            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
8001566a:	8c 08       	ld.sh	r8,r6[0x0]
8001566c:	f6 08 19 00 	cp.h	r8,r11
80015670:	cf 11       	brne	80015652 <NtfInitOneMatrix+0x8a>
        {
            #if 0
            return(0x02);   /*  re-initialization not supported */
            #endif

            while(ptrPropTab->Type_FuncID != NTF_TERMINATION)   /* loop for all properties of this FBlock */
80015672:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80015676:	d7 03       	nop
80015678:	80 07       	ld.sh	r7,r0[0x0]
8001567a:	08 5c       	eor	r12,r4
8001567c:	00 00       	add	r0,r0
8001567e:	4a 58       	lddpc	r8,80015710 <NtfInit+0x80>

80015680 <NtfInitAllMatrices>:
/* Parameter(s): none                                                       */
/* Returns     : nothing                                                    */
/*--------------------------------------------------------------------------*/
#ifdef NTF_8
void NtfInitAllMatrices(void)
{
80015680:	d4 01       	pushm	lr
    byte i;

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)      /* Init NtfMatrix of all FBlocks */
    {
        (void)NtfInitOneMatrix(i, MNS_TRUE);                /* first or complete initialization          */
80015682:	30 1b       	mov	r11,1
80015684:	30 0c       	mov	r12,0
80015686:	ca 1f       	rcall	800155c8 <NtfInitOneMatrix>
80015688:	30 1b       	mov	r11,1
8001568a:	16 9c       	mov	r12,r11
8001568c:	c9 ef       	rcall	800155c8 <NtfInitOneMatrix>
8001568e:	d8 02       	popm	pc

80015690 <NtfInit>:
80015690:	eb cd 40 c0 	pushm	r6-r7,lr
    }
}
80015694:	49 d8       	lddpc	r8,80015708 <NtfInit+0x78>
80015696:	30 07       	mov	r7,0
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        NtfDeviceTab[i]    = (word)0x0000;  /* Init Device Table */
80015698:	b0 47       	st.h	r8[0x8],r7
8001569a:	b0 07       	st.h	r8[0x0],r7
8001569c:	b0 17       	st.h	r8[0x2],r7
8001569e:	b0 27       	st.h	r8[0x4],r7
800156a0:	b0 37       	st.h	r8[0x6],r7
        NtfDeviceTabCnt[i] = (word)0x0000;  /* Init Counter Array */
800156a2:	49 b8       	lddpc	r8,8001570c <NtfInit+0x7c>
800156a4:	b0 47       	st.h	r8[0x8],r7
800156a6:	b0 07       	st.h	r8[0x0],r7
800156a8:	b0 17       	st.h	r8[0x2],r7
800156aa:	b0 27       	st.h	r8[0x4],r7
800156ac:	b0 37       	st.h	r8[0x6],r7
    }
    NtfDeviceTabWriteIndex = (byte)0;
800156ae:	49 98       	lddpc	r8,80015710 <NtfInit+0x80>
800156b0:	b0 87       	st.b	r8[0x0],r7

    NtfInitAllMatrices();                   /* Complete initialisation of all matrices */
800156b2:	ce 7f       	rcall	80015680 <NtfInitAllMatrices>
800156b4:	c5 af       	rcall	80015568 <NtfCalcNum>

    #ifdef NTF_6
    NtfNumElements = NtfCalcNum();          /* Calculate number of all matrix elements */
800156b6:	49 86       	lddpc	r6,80015714 <NtfInit+0x84>
800156b8:	ac 0c       	st.h	r6[0x0],r12
800156ba:	49 8c       	lddpc	r12,80015718 <NtfInit+0x88>
800156bc:	b8 07       	st.h	r12[0x0],r7
                                            /* This is neccessary only, if service will not be polled  */
    NtfLoopCounter = (word)0;
800156be:	49 8c       	lddpc	r12,8001571c <NtfInit+0x8c>
800156c0:	49 86       	lddpc	r6,80015720 <NtfInit+0x90>
    #endif

    NtfFBlockPtr = NtfFBlockTab;            /* Init pointer at table containing all FBlocks to service */
800156c2:	99 06       	st.w	r12[0x0],r6
800156c4:	49 8c       	lddpc	r12,80015724 <NtfInit+0x94>
800156c6:	b8 87       	st.b	r12[0x0],r7
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_2
void NtfLoadFBlockDescription(void)
{
    NtfFBlockIndex = NtfFBlockPtr->FBlockIndex;     /* read local fblock index */
800156c8:	49 8c       	lddpc	r12,80015728 <NtfInit+0x98>
800156ca:	49 98       	lddpc	r8,8001572c <NtfInit+0x9c>
    NtfNumDev      = NtfFBlockPtr->NumDev;          /* read number of devices of this device table (column of notif.matrix) */
800156cc:	30 57       	mov	r7,5
    NtfPropTabPtr  = NtfFBlockPtr->PtrPropTab;      /* Load base address of property table */
800156ce:	90 0a       	ld.sh	r10,r8[0x0]
/*--------------------------------------------------------------------------*/
#ifdef NTF_2
void NtfLoadFBlockDescription(void)
{
    NtfFBlockIndex = NtfFBlockPtr->FBlockIndex;     /* read local fblock index */
    NtfNumDev      = NtfFBlockPtr->NumDev;          /* read number of devices of this device table (column of notif.matrix) */
800156d0:	b8 87       	st.b	r12[0x0],r7
#ifdef NTF_3
void NtfLoadPropDescription(void)
{
    word type_funcid;

    type_funcid = NtfPropTabPtr->Type_FuncID;           /* read Type and FuncID of current property */
800156d2:	fd da c0 0c 	bfextu	lr,r10,0x0,0xc
    NtfType = (byte)(type_funcid >> 12);                /* prepare Type */
    NtfFuncID = (word)(type_funcid & 0x0FFF);           /* prepare FuncID */
800156d6:	49 7c       	lddpc	r12,80015730 <NtfInit+0xa0>
800156d8:	f5 da c1 84 	bfextu	r10,r10,0xc,0x4
void NtfLoadPropDescription(void)
{
    word type_funcid;

    type_funcid = NtfPropTabPtr->Type_FuncID;           /* read Type and FuncID of current property */
    NtfType = (byte)(type_funcid >> 12);                /* prepare Type */
800156dc:	99 08       	st.w	r12[0x0],r8
800156de:	49 6c       	lddpc	r12,80015734 <NtfInit+0xa4>
#ifdef NTF_2
void NtfLoadFBlockDescription(void)
{
    NtfFBlockIndex = NtfFBlockPtr->FBlockIndex;     /* read local fblock index */
    NtfNumDev      = NtfFBlockPtr->NumDev;          /* read number of devices of this device table (column of notif.matrix) */
    NtfPropTabPtr  = NtfFBlockPtr->PtrPropTab;      /* Load base address of property table */
800156e0:	b8 8a       	st.b	r12[0x0],r10
void NtfLoadPropDescription(void)
{
    word type_funcid;

    type_funcid = NtfPropTabPtr->Type_FuncID;           /* read Type and FuncID of current property */
    NtfType = (byte)(type_funcid >> 12);                /* prepare Type */
800156e2:	49 6a       	lddpc	r10,80015738 <NtfInit+0xa8>
800156e4:	b4 0e       	st.h	r10[0x0],lr
    NtfFuncID = (word)(type_funcid & 0x0FFF);           /* prepare FuncID */
800156e6:	49 6a       	lddpc	r10,8001573c <NtfInit+0xac>
800156e8:	70 19       	ld.w	r9,r8[0x4]

    NtfMatrixColPtr =  NtfPropTabPtr->PtrNtfMatrixCol;  /* read base pointer on notification matrix column */
800156ea:	70 3b       	ld.w	r11,r8[0xc]
800156ec:	95 09       	st.w	r10[0x0],r9

    #ifdef NTF_EXT
    #ifdef PTR_UNION_VOID
    NtfPropertyExt1Ptr = NtfPropTabPtr->PropExt1.DPtr;  /* read data ptr for extended use                                        */
    #else
    NtfPropertyExt1Ptr = NtfPropTabPtr->PtrPropertyExt1;/* read ptr for extended use (function ptr or data ptr)                  */
800156ee:	70 2a       	ld.w	r10,r8[0x8]

    type_funcid = NtfPropTabPtr->Type_FuncID;           /* read Type and FuncID of current property */
    NtfType = (byte)(type_funcid >> 12);                /* prepare Type */
    NtfFuncID = (word)(type_funcid & 0x0FFF);           /* prepare FuncID */

    NtfMatrixColPtr =  NtfPropTabPtr->PtrNtfMatrixCol;  /* read base pointer on notification matrix column */
800156f0:	49 48       	lddpc	r8,80015740 <NtfInit+0xb0>

    #ifdef PTR_UNION_VOID
    NtfPropertyPtr    = NtfPropTabPtr->Prop.DPtr;       /* read data ptr at property             */
    #else
    NtfPropertyPtr    = NtfPropTabPtr->PtrProperty;     /* read ptr (function ptr or data ptr)           */
800156f2:	91 0a       	st.w	r8[0x0],r10
800156f4:	49 48       	lddpc	r8,80015744 <NtfInit+0xb4>
800156f6:	91 0b       	st.w	r8[0x0],r11

    #ifdef NTF_EXT
    #ifdef PTR_UNION_VOID
    NtfPropertyExt1Ptr = NtfPropTabPtr->PropExt1.DPtr;  /* read data ptr for extended use                                        */
    #else
    NtfPropertyExt1Ptr = NtfPropTabPtr->PtrPropertyExt1;/* read ptr for extended use (function ptr or data ptr)                  */
800156f8:	49 48       	lddpc	r8,80015748 <NtfInit+0xb8>
800156fa:	30 1a       	mov	r10,1
    #endif
    #endif

    NtfIndexNext = (byte)1;                             /* Init index for device index table (column of notification matrix) */
800156fc:	b0 8a       	st.b	r8[0x0],r10
800156fe:	49 48       	lddpc	r8,8001574c <NtfInit+0xbc>
80015700:	13 89       	ld.ub	r9,r9[0x0]
                                                        /* But forget about Flag field (first entry, index=0)                    */

    NtfPropFlags = *NtfMatrixColPtr;                    /* read property flags (ColumnFlags, first entry in Column)              */
80015702:	b0 89       	st.b	r8[0x0],r9
80015704:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    NtfFBlockPtr = NtfFBlockTab;            /* Init pointer at table containing all FBlocks to service */

    NtfLoadFBlockDescription();             /* load first FBlock description */
    NtfLoadPropDescription();               /* load first Property description of first FBlock */
}
80015708:	00 00       	add	r0,r0
8001570a:	4a 7a       	lddpc	r10,800157a4 <NtfIncPropTabPtr+0x54>
8001570c:	00 00       	add	r0,r0
8001570e:	4a 58       	lddpc	r8,800157a0 <NtfIncPropTabPtr+0x50>
80015710:	00 00       	add	r0,r0
80015712:	4a 70       	lddpc	r0,800157ac <NtfIncPropTabPtr+0x5c>
80015714:	00 00       	add	r0,r0
80015716:	4a 76       	lddpc	r6,800157b0 <NtfIncPropTabPtr+0x60>
80015718:	00 00       	add	r0,r0
8001571a:	4a 72       	lddpc	r2,800157b4 <NtfIncPropTabPtr+0x64>
8001571c:	00 00       	add	r0,r0
8001571e:	4a 6c       	lddpc	r12,800157b4 <NtfIncPropTabPtr+0x64>
80015720:	80 07       	ld.sh	r7,r0[0x0]
80015722:	08 5c       	eor	r12,r4
80015724:	00 00       	add	r0,r0
80015726:	4a 74       	lddpc	r4,800157c0 <NtfIncPropTabPtr+0x70>
80015728:	00 00       	add	r0,r0
8001572a:	4a 78       	lddpc	r8,800157c4 <NtfIncPropTabPtr+0x74>
8001572c:	80 06       	ld.sh	r6,r0[0x0]
8001572e:	96 74       	ld.sh	r4,r11[0xe]
80015730:	00 00       	add	r0,r0
80015732:	4a 4c       	lddpc	r12,800157c0 <NtfIncPropTabPtr+0x70>
80015734:	00 00       	add	r0,r0
80015736:	4a 68       	lddpc	r8,800157cc <NtfIncPropTabPtr+0x7c>
80015738:	00 00       	add	r0,r0
8001573a:	4a 62       	lddpc	r2,800157d0 <NtfIncPropTabPtr+0x80>
8001573c:	00 00       	add	r0,r0
8001573e:	4a 64       	lddpc	r4,800157d4 <NtfIncPropTabPtr+0x84>
80015740:	00 00       	add	r0,r0
80015742:	4a 54       	lddpc	r4,800157d4 <NtfIncPropTabPtr+0x84>
80015744:	00 00       	add	r0,r0
80015746:	4a 50       	lddpc	r0,800157d8 <NtfIncPropTabPtr+0x88>
80015748:	00 00       	add	r0,r0
8001574a:	4a 79       	lddpc	r9,800157e4 <NtfIncPropTabPtr+0x94>
8001574c:	00 00       	add	r0,r0
8001574e:	4a 84       	lddpc	r4,800157ec <NtfClearDeviceIndex>

80015750 <NtfIncPropTabPtr>:
80015750:	49 ba       	lddpc	r10,800157bc <NtfIncPropTabPtr+0x6c>
80015752:	74 08       	ld.w	r8,r10[0x0]
80015754:	2f 08       	sub	r8,-16
80015756:	95 08       	st.w	r10[0x0],r8
80015758:	3f fb       	mov	r11,-1
8001575a:	90 09       	ld.sh	r9,r8[0x0]
#ifdef NTF_5
void NtfIncPropTabPtr(void)
{
    NtfPropTabPtr++;                                            /* increment pointer at property table */

    if (NTF_TERMINATION == NtfPropTabPtr->Type_FuncID)          /* termination of property table reached ? */
8001575c:	f6 09 19 00 	cp.h	r9,r11
80015760:	c1 90       	breq	80015792 <NtfIncPropTabPtr+0x42>
{
    word type_funcid;

    type_funcid = NtfPropTabPtr->Type_FuncID;           /* read Type and FuncID of current property */
    NtfType = (byte)(type_funcid >> 12);                /* prepare Type */
    NtfFuncID = (word)(type_funcid & 0x0FFF);           /* prepare FuncID */
80015762:	f5 d9 c0 0c 	bfextu	r10,r9,0x0,0xc
void NtfLoadPropDescription(void)
{
    word type_funcid;

    type_funcid = NtfPropTabPtr->Type_FuncID;           /* read Type and FuncID of current property */
    NtfType = (byte)(type_funcid >> 12);                /* prepare Type */
80015766:	f3 d9 c1 84 	bfextu	r9,r9,0xc,0x4
8001576a:	49 6b       	lddpc	r11,800157c0 <NtfIncPropTabPtr+0x70>
8001576c:	b6 89       	st.b	r11[0x0],r9
    NtfFuncID = (word)(type_funcid & 0x0FFF);           /* prepare FuncID */
8001576e:	49 69       	lddpc	r9,800157c4 <NtfIncPropTabPtr+0x74>
80015770:	b2 0a       	st.h	r9[0x0],r10

    NtfMatrixColPtr =  NtfPropTabPtr->PtrNtfMatrixCol;  /* read base pointer on notification matrix column */
80015772:	49 6a       	lddpc	r10,800157c8 <NtfIncPropTabPtr+0x78>
80015774:	70 19       	ld.w	r9,r8[0x4]
80015776:	95 09       	st.w	r10[0x0],r9

    #ifdef PTR_UNION_VOID
    NtfPropertyPtr    = NtfPropTabPtr->Prop.DPtr;       /* read data ptr at property             */
    #else
    NtfPropertyPtr    = NtfPropTabPtr->PtrProperty;     /* read ptr (function ptr or data ptr)           */
80015778:	49 5a       	lddpc	r10,800157cc <NtfIncPropTabPtr+0x7c>
8001577a:	70 2b       	ld.w	r11,r8[0x8]
8001577c:	95 0b       	st.w	r10[0x0],r11

    #ifdef NTF_EXT
    #ifdef PTR_UNION_VOID
    NtfPropertyExt1Ptr = NtfPropTabPtr->PropExt1.DPtr;  /* read data ptr for extended use                                        */
    #else
    NtfPropertyExt1Ptr = NtfPropTabPtr->PtrPropertyExt1;/* read ptr for extended use (function ptr or data ptr)                  */
8001577e:	70 3a       	ld.w	r10,r8[0xc]
80015780:	49 48       	lddpc	r8,800157d0 <NtfIncPropTabPtr+0x80>
80015782:	91 0a       	st.w	r8[0x0],r10
    #endif
    #endif

    NtfIndexNext = (byte)1;                             /* Init index for device index table (column of notification matrix) */
80015784:	49 48       	lddpc	r8,800157d4 <NtfIncPropTabPtr+0x84>
80015786:	30 1a       	mov	r10,1
80015788:	b0 8a       	st.b	r8[0x0],r10
                                                        /* But forget about Flag field (first entry, index=0)                    */

    NtfPropFlags = *NtfMatrixColPtr;                    /* read property flags (ColumnFlags, first entry in Column)              */
8001578a:	49 48       	lddpc	r8,800157d8 <NtfIncPropTabPtr+0x88>
8001578c:	13 89       	ld.ub	r9,r9[0x0]
8001578e:	b0 89       	st.b	r8[0x0],r9

    if (NTF_TERMINATION == NtfPropTabPtr->Type_FuncID)          /* termination of property table reached ? */
        NtfIncFBlockPtr();                                      /* next FBlock */

    NtfLoadPropDescription();                                   /* load description of next property */
}
80015790:	5e fc       	retal	r12
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_4
void NtfIncFBlockPtr(void)
{
    if (NtfFBlockPtr == &NtfFBlockTab[NTF_MAX_FBLOCKS-1] )     /* inc pointer modulo table size */
80015792:	49 39       	lddpc	r9,800157dc <NtfIncPropTabPtr+0x8c>
80015794:	49 38       	lddpc	r8,800157e0 <NtfIncPropTabPtr+0x90>
80015796:	72 0b       	ld.w	r11,r9[0x0]
80015798:	f0 cc ff f8 	sub	r12,r8,-8
8001579c:	18 3b       	cp.w	r11,r12
8001579e:	c0 30       	breq	800157a4 <NtfIncPropTabPtr+0x54>
        NtfFBlockPtr =  &NtfFBlockTab[0];
    else
        NtfFBlockPtr++;
800157a0:	f6 c8 ff f8 	sub	r8,r11,-8
800157a4:	93 08       	st.w	r9[0x0],r8
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_2
void NtfLoadFBlockDescription(void)
{
    NtfFBlockIndex = NtfFBlockPtr->FBlockIndex;     /* read local fblock index */
800157a6:	49 09       	lddpc	r9,800157e4 <NtfIncPropTabPtr+0x94>
800157a8:	11 8b       	ld.ub	r11,r8[0x0]
800157aa:	b2 8b       	st.b	r9[0x0],r11
    NtfNumDev      = NtfFBlockPtr->NumDev;          /* read number of devices of this device table (column of notif.matrix) */
800157ac:	48 f9       	lddpc	r9,800157e8 <NtfIncPropTabPtr+0x98>
800157ae:	11 9b       	ld.ub	r11,r8[0x1]
800157b0:	b2 8b       	st.b	r9[0x0],r11
    NtfPropTabPtr  = NtfFBlockPtr->PtrPropTab;      /* Load base address of property table */
800157b2:	70 18       	ld.w	r8,r8[0x4]
800157b4:	95 08       	st.w	r10[0x0],r8
800157b6:	90 09       	ld.sh	r9,r8[0x0]
800157b8:	cd 5b       	rjmp	80015762 <NtfIncPropTabPtr+0x12>
800157ba:	d7 03       	nop
800157bc:	00 00       	add	r0,r0
800157be:	4a 4c       	lddpc	r12,8001584c <NtfWriteDeviceTab+0xc>
800157c0:	00 00       	add	r0,r0
800157c2:	4a 68       	lddpc	r8,80015858 <NtfWriteDeviceTab+0x18>
800157c4:	00 00       	add	r0,r0
800157c6:	4a 62       	lddpc	r2,8001585c <NtfWriteDeviceTab+0x1c>
800157c8:	00 00       	add	r0,r0
800157ca:	4a 64       	lddpc	r4,80015860 <NtfWriteDeviceTab+0x20>
800157cc:	00 00       	add	r0,r0
800157ce:	4a 54       	lddpc	r4,80015860 <NtfWriteDeviceTab+0x20>
800157d0:	00 00       	add	r0,r0
800157d2:	4a 50       	lddpc	r0,80015864 <NtfWriteDeviceTab+0x24>
800157d4:	00 00       	add	r0,r0
800157d6:	4a 79       	lddpc	r9,80015870 <NtfWriteDeviceTab+0x30>
800157d8:	00 00       	add	r0,r0
800157da:	4a 84       	lddpc	r4,80015878 <NtfWriteDeviceTab+0x38>
800157dc:	00 00       	add	r0,r0
800157de:	4a 6c       	lddpc	r12,80015874 <NtfWriteDeviceTab+0x34>
800157e0:	80 07       	ld.sh	r7,r0[0x0]
800157e2:	08 5c       	eor	r12,r4
800157e4:	00 00       	add	r0,r0
800157e6:	4a 74       	lddpc	r4,80015880 <NtfWriteDeviceTab+0x40>
800157e8:	00 00       	add	r0,r0
800157ea:	4a 78       	lddpc	r8,80015884 <NtfWriteDeviceTab+0x44>

800157ec <NtfClearDeviceIndex>:
/*                          1: device_index not available                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_21
byte NtfClearDeviceIndex(pTNtfMatrix device_index_tab_ptr, byte num_entries, byte device_index)
{
800157ec:	d4 01       	pushm	lr
    TNtfMatrix device_index_flags;          /* device index and flags */

    device_index_tab_ptr = *device_index_tab_ptrptr;


    for (i=(byte)0;i<num_entries;i++)
800157ee:	58 0b       	cp.w	r11,0
800157f0:	c1 40       	breq	80015818 <NtfClearDeviceIndex+0x2c>
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */
800157f2:	19 89       	ld.ub	r9,r12[0x0]

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
800157f4:	f1 d9 c0 05 	bfextu	r8,r9,0x0,0x5
800157f8:	10 3a       	cp.w	r10,r8
800157fa:	c1 00       	breq	8001581a <NtfClearDeviceIndex+0x2e>
        #endif
        {
            *device_index_tab_ptrptr = device_index_tab_ptr;

            #ifdef NTF_SINGLE_PREV
            if (device_index_flags & MASK_FLAG_SINGLE)
800157fc:	30 08       	mov	r8,0
800157fe:	c0 78       	rjmp	8001580c <NtfClearDeviceIndex+0x20>
            #endif

            return((byte)1);
        }

        device_index_tab_ptr++;
80015800:	2f fc       	sub	r12,-1
    device_index_tab_ptr = *device_index_tab_ptrptr;


    for (i=(byte)0;i<num_entries;i++)
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */
80015802:	19 89       	ld.ub	r9,r12[0x0]

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
80015804:	fd d9 c0 05 	bfextu	lr,r9,0x0,0x5
80015808:	1c 3a       	cp.w	r10,lr
8001580a:	c0 80       	breq	8001581a <NtfClearDeviceIndex+0x2e>
    TNtfMatrix device_index_flags;          /* device index and flags */

    device_index_tab_ptr = *device_index_tab_ptrptr;


    for (i=(byte)0;i<num_entries;i++)
8001580c:	2f f8       	sub	r8,-1
8001580e:	5c 58       	castu.b	r8
80015810:	f0 0b 18 00 	cp.b	r11,r8
80015814:	fe 9b ff f6 	brhi	80015800 <NtfClearDeviceIndex+0x14>
    {
        *device_index_tab_ptr = NTF_DEV_INDEX_FREE;     /* clear entry */

        if ((word)0 < NtfDeviceTabCnt[device_index])
        {
            NtfDeviceTabCnt[device_index]--;                /* decrement respective counter of Device Index Table */
80015818:	da 0a       	popm	pc,r12=1
        #endif
        {
            *device_index_tab_ptrptr = device_index_tab_ptr;

            #ifdef NTF_SINGLE_PREV
            if (device_index_flags & MASK_FLAG_SINGLE)
8001581a:	30 08       	mov	r8,0
8001581c:	f0 09 18 00 	cp.b	r9,r8
80015820:	cf c5       	brlt	80015818 <NtfClearDeviceIndex+0x2c>
    if ((byte)1 == scan_status)               /* device index available ? (ignore 'Single Notification' !) */
    #else
    if (scan_status)                    /* device index available ? */
    #endif
    {
        *device_index_tab_ptr = NTF_DEV_INDEX_FREE;     /* clear entry */
80015822:	31 f8       	mov	r8,31
80015824:	b8 88       	st.b	r12[0x0],r8

        if ((word)0 < NtfDeviceTabCnt[device_index])
80015826:	48 68       	lddpc	r8,8001583c <NtfClearDeviceIndex+0x50>
80015828:	f0 0a 04 1c 	ld.sh	r12,r8[r10<<0x1]
8001582c:	58 0c       	cp.w	r12,0
8001582e:	c0 50       	breq	80015838 <NtfClearDeviceIndex+0x4c>
        {
            NtfDeviceTabCnt[device_index]--;                /* decrement respective counter of Device Index Table */
80015830:	20 1c       	sub	r12,1
80015832:	f0 0a 0a 1c 	st.h	r8[r10<<0x1],r12
80015836:	d8 0a       	popm	pc,r12=0
80015838:	d8 02       	popm	pc
8001583a:	d7 03       	nop
8001583c:	00 00       	add	r0,r0
8001583e:	4a 58       	lddpc	r8,800158d0 <NtfWriteDeviceTab+0x90>

80015840 <NtfWriteDeviceTab>:
/* Returns     : device_index (0xFF: no entry free)                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_30
byte NtfWriteDeviceTab(word device_addr)
{
80015840:	eb cd 40 f8 	pushm	r3-r7,lr
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015844:	4a 6a       	lddpc	r10,800158dc <NtfWriteDeviceTab+0x9c>
80015846:	94 08       	ld.sh	r8,r10[0x0]
80015848:	f8 08 19 00 	cp.h	r8,r12
8001584c:	c3 b0       	breq	800158c2 <NtfWriteDeviceTab+0x82>
8001584e:	94 18       	ld.sh	r8,r10[0x2]
80015850:	f8 08 19 00 	cp.h	r8,r12
80015854:	c3 90       	breq	800158c6 <NtfWriteDeviceTab+0x86>
80015856:	94 28       	ld.sh	r8,r10[0x4]
80015858:	f8 08 19 00 	cp.h	r8,r12
8001585c:	c3 70       	breq	800158ca <NtfWriteDeviceTab+0x8a>
8001585e:	94 38       	ld.sh	r8,r10[0x6]
80015860:	f8 08 19 00 	cp.h	r8,r12
80015864:	c3 60       	breq	800158d0 <NtfWriteDeviceTab+0x90>
80015866:	94 48       	ld.sh	r8,r10[0x8]
80015868:	f8 08 19 00 	cp.h	r8,r12
8001586c:	c3 50       	breq	800158d6 <NtfWriteDeviceTab+0x96>
8001586e:	49 d3       	lddpc	r3,800158e0 <NtfWriteDeviceTab+0xa0>
80015870:	30 59       	mov	r9,5
80015872:	07 88       	ld.ub	r8,r3[0x0]
80015874:	e0 64 00 ff 	mov	r4,255
80015878:	49 b5       	lddpc	r5,800158e4 <NtfWriteDeviceTab+0xa4>
    search_cnt  = NTF_SIZE_DEVICE_TAB;
    return_value = (byte)0xFF;                          /* will be changed if free entry found */

    do
    {
        if  ((word)0 == NtfDeviceTabCnt[NtfDeviceTabWriteIndex])       /* free entry ? */
8001587a:	30 06       	mov	r6,0
        }
        else
            search_cnt--;                                        /* decrement loop counter */

        NtfDeviceTabWriteIndex++;                           /* increment index modulo array size */
        if (NTF_SIZE_DEVICE_TAB == NtfDeviceTabWriteIndex)
8001587c:	12 97       	mov	r7,r9
8001587e:	c0 f8       	rjmp	8001589c <NtfWriteDeviceTab+0x5c>
    do
    {
        if  ((word)0 == NtfDeviceTabCnt[NtfDeviceTabWriteIndex])       /* free entry ? */
        {
            search_flag = MNS_TRUE;
            NtfDeviceTab[NtfDeviceTabWriteIndex] = device_addr;  /* set entry in Device Table */
80015880:	f4 08 0a 1c 	st.h	r10[r8<<0x1],r12
80015884:	10 94       	mov	r4,r8
80015886:	30 1b       	mov	r11,1
            return_value = NtfDeviceTabWriteIndex;               /* save index as return value */
        }
        else
            search_cnt--;                                        /* decrement loop counter */

        NtfDeviceTabWriteIndex++;                           /* increment index modulo array size */
80015888:	2f f8       	sub	r8,-1
8001588a:	5c 58       	castu.b	r8
        if (NTF_SIZE_DEVICE_TAB == NtfDeviceTabWriteIndex)
8001588c:	f0 07 18 00 	cp.b	r7,r8
80015890:	f9 b8 00 00 	moveq	r8,0
            NtfDeviceTabWriteIndex = (byte)0x00;

    }while (search_cnt && (MNS_FALSE == search_flag));
80015894:	58 09       	cp.w	r9,0
80015896:	c1 20       	breq	800158ba <NtfWriteDeviceTab+0x7a>
80015898:	58 0b       	cp.w	r11,0
8001589a:	c0 c1       	brne	800158b2 <NtfWriteDeviceTab+0x72>
            search_flag = MNS_TRUE;
            NtfDeviceTab[NtfDeviceTabWriteIndex] = device_addr;  /* set entry in Device Table */
            return_value = NtfDeviceTabWriteIndex;               /* save index as return value */
        }
        else
            search_cnt--;                                        /* decrement loop counter */
8001589c:	f2 ce 00 01 	sub	lr,r9,1
    search_cnt  = NTF_SIZE_DEVICE_TAB;
    return_value = (byte)0xFF;                          /* will be changed if free entry found */

    do
    {
        if  ((word)0 == NtfDeviceTabCnt[NtfDeviceTabWriteIndex])       /* free entry ? */
800158a0:	ea 08 04 1b 	ld.sh	r11,r5[r8<<0x1]
800158a4:	ec 0b 19 00 	cp.h	r11,r6
800158a8:	ce c0       	breq	80015880 <NtfWriteDeviceTab+0x40>
            search_flag = MNS_TRUE;
            NtfDeviceTab[NtfDeviceTabWriteIndex] = device_addr;  /* set entry in Device Table */
            return_value = NtfDeviceTabWriteIndex;               /* save index as return value */
        }
        else
            search_cnt--;                                        /* decrement loop counter */
800158aa:	f3 de c0 08 	bfextu	r9,lr,0x0,0x8
800158ae:	30 0b       	mov	r11,0
800158b0:	ce cb       	rjmp	80015888 <NtfWriteDeviceTab+0x48>

        NtfDeviceTabWriteIndex++;                           /* increment index modulo array size */
        if (NTF_SIZE_DEVICE_TAB == NtfDeviceTabWriteIndex)
            NtfDeviceTabWriteIndex = (byte)0x00;

    }while (search_cnt && (MNS_FALSE == search_flag));
800158b2:	a6 88       	st.b	r3[0x0],r8
800158b4:	08 9c       	mov	r12,r4

    return(return_value);               /* 0xFF: no free entry */
                                        /* other value: respective index of Device Table */
}
800158b6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

        NtfDeviceTabWriteIndex++;                           /* increment index modulo array size */
        if (NTF_SIZE_DEVICE_TAB == NtfDeviceTabWriteIndex)
            NtfDeviceTabWriteIndex = (byte)0x00;

    }while (search_cnt && (MNS_FALSE == search_flag));
800158ba:	a6 88       	st.b	r3[0x0],r8
800158bc:	08 9c       	mov	r12,r4
800158be:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
800158c2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800158c6:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
800158ca:	30 2c       	mov	r12,2
800158cc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800158d0:	30 3c       	mov	r12,3
800158d2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800158d6:	30 4c       	mov	r12,4
800158d8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800158dc:	00 00       	add	r0,r0
800158de:	4a 7a       	lddpc	r10,80015978 <NtfCheck+0x48>
800158e0:	00 00       	add	r0,r0
800158e2:	4a 70       	lddpc	r0,8001597c <NtfCheck+0x4c>
800158e4:	00 00       	add	r0,r0
800158e6:	4a 58       	lddpc	r8,80015978 <NtfCheck+0x48>

800158e8 <NtfLoadFBlockDescriptionRx>:
/*                    Service                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_50
byte NtfLoadFBlockDescriptionRx(pTMsgRx rx_ptr, byte* num_dev_ptr, pTNtfPropL* prop_tab_baseptrptr)
{
800158e8:	eb cd 40 c0 	pushm	r6-r7,lr
800158ec:	18 98       	mov	r8,r12
800158ee:	16 97       	mov	r7,r11
800158f0:	14 96       	mov	r6,r10
    byte fblock_index;
    pTNtfFBlockL fblock_tab_ptr;

    fblock_index = NbGetFBlockIndex( rx_ptr->FBlock_ID, rx_ptr->Inst_ID);
800158f2:	f1 3b 00 0b 	ld.ub	r11,r8[11]
800158f6:	f9 3c 00 0a 	ld.ub	r12,r12[10]
800158fa:	fe b0 fa d5 	rcall	80014ea4 <NbGetFBlockIndex>
                                                    /* get local FBlock index of FBlockID.InstID */
    if ((byte)0xFF == fblock_index)
800158fe:	3f f8       	mov	r8,-1
80015900:	f0 0c 18 00 	cp.b	r12,r8
80015904:	c0 70       	breq	80015912 <NtfLoadFBlockDescriptionRx+0x2a>

    fblock_tab_ptr = NtfFBlockTab;      /* set pointer at first entry in the Notification FBlock Table */

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        if (fblock_tab_ptr->FBlockIndex == fblock_index)
80015906:	58 0c       	cp.w	r12,0
80015908:	c0 70       	breq	80015916 <NtfLoadFBlockDescriptionRx+0x2e>
8001590a:	30 18       	mov	r8,1
8001590c:	f0 0c 18 00 	cp.b	r12,r8
80015910:	c0 b0       	breq	80015926 <NtfLoadFBlockDescriptionRx+0x3e>

    if (fblock_tab_ptr != NULL)                          /* fblock index found ? */
    {
        *num_dev_ptr = fblock_tab_ptr->NumDev;              /* read maximum count of devices to service          */
        *prop_tab_baseptrptr = fblock_tab_ptr->PtrPropTab;  /* read base (!) pointer at property table */
        return((byte)0x00);
80015912:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1

    fblock_tab_ptr = NtfFBlockTab;      /* set pointer at first entry in the Notification FBlock Table */

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        if (fblock_tab_ptr->FBlockIndex == fblock_index)
80015916:	48 68       	lddpc	r8,8001592c <NtfLoadFBlockDescriptionRx+0x44>

    fblock_tab_ptr = NtfGetFBlockTabPtr(fblock_index);

    if (fblock_tab_ptr != NULL)                          /* fblock index found ? */
    {
        *num_dev_ptr = fblock_tab_ptr->NumDev;              /* read maximum count of devices to service          */
80015918:	11 99       	ld.ub	r9,r8[0x1]
8001591a:	ae 89       	st.b	r7[0x0],r9
        *prop_tab_baseptrptr = fblock_tab_ptr->PtrPropTab;  /* read base (!) pointer at property table */
8001591c:	30 0c       	mov	r12,0
8001591e:	70 18       	ld.w	r8,r8[0x4]
80015920:	8d 08       	st.w	r6[0x0],r8
        return((byte)0x00);
80015922:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    fblock_tab_ptr = NtfFBlockTab;      /* set pointer at first entry in the Notification FBlock Table */

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        if (fblock_tab_ptr->FBlockIndex == fblock_index)
80015926:	48 28       	lddpc	r8,8001592c <NtfLoadFBlockDescriptionRx+0x44>
80015928:	2f 88       	sub	r8,-8
8001592a:	cf 7b       	rjmp	80015918 <NtfLoadFBlockDescriptionRx+0x30>
8001592c:	80 07       	ld.sh	r7,r0[0x0]
8001592e:	08 5c       	eor	r12,r4

80015930 <NtfCheck>:
80015930:	d4 31       	pushm	r0-r7,lr
80015932:	20 3d       	sub	sp,12
/* Returns     : op_type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_61
byte NtfCheck(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
80015934:	18 97       	mov	r7,r12
80015936:	16 94       	mov	r4,r11
    #ifndef CMD_ADD8
    if (rx_ptr->Length != (word)0x02)                         /* invalid length */
        return( CmdErrorMsg(tx_ptr, ERR_LENGTH) );       /* return(OP_ERROR) */
    #endif

    CmdDecodeWord(&device_id,&rx_ptr->Data[0]);
80015938:	fa c5 ff f8 	sub	r5,sp,-8
8001593c:	76 0b       	ld.w	r11,r11[0x0]
8001593e:	0a 9c       	mov	r12,r5
80015940:	fe b0 f0 e1 	rcall	80013b02 <CmdDecodeWord>
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015944:	4c 69       	lddpc	r9,80015a5c <NtfCheck+0x12c>
    if (rx_ptr->Length != (word)0x02)                         /* invalid length */
        return( CmdErrorMsg(tx_ptr, ERR_LENGTH) );       /* return(OP_ERROR) */
    #endif

    CmdDecodeWord(&device_id,&rx_ptr->Data[0]);
    device_index = NtfScanDeviceTab(device_id);
80015946:	9a 48       	ld.sh	r8,sp[0x8]
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015948:	92 0a       	ld.sh	r10,r9[0x0]
8001594a:	f0 0a 19 00 	cp.h	r10,r8
8001594e:	c1 80       	breq	8001597e <NtfCheck+0x4e>
80015950:	92 1a       	ld.sh	r10,r9[0x2]
80015952:	f0 0a 19 00 	cp.h	r10,r8
80015956:	c7 b0       	breq	80015a4c <NtfCheck+0x11c>
80015958:	92 2a       	ld.sh	r10,r9[0x4]
8001595a:	f0 0a 19 00 	cp.h	r10,r8
8001595e:	c7 90       	breq	80015a50 <NtfCheck+0x120>
80015960:	92 3a       	ld.sh	r10,r9[0x6]
80015962:	f0 0a 19 00 	cp.h	r10,r8
80015966:	c7 70       	breq	80015a54 <NtfCheck+0x124>
80015968:	92 49       	ld.sh	r9,r9[0x8]
8001596a:	f0 09 19 00 	cp.h	r9,r8
8001596e:	c7 50       	breq	80015a58 <NtfCheck+0x128>

    CmdDecodeWord(&device_id,&rx_ptr->Data[0]);
    device_index = NtfScanDeviceTab(device_id);
    if ((byte)0xFF == device_index)
    {
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_DEVICEID_NOTAVAIL) );    /* Error: DeviceID not entered in DeviceTab */
80015970:	0e 9c       	mov	r12,r7
80015972:	30 8a       	mov	r10,8
80015974:	32 0b       	mov	r11,32
80015976:	fe b0 f1 05 	rcall	80013b80 <CmdErrorByte>

        ++prop_tab_ptr;                                         /* next property */
    }

    return(OP_STATUS);
}
8001597a:	2f dd       	sub	sp,-12
8001597c:	d8 32       	popm	r0-r7,pc
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
8001597e:	30 06       	mov	r6,0
    device_index = NtfScanDeviceTab(device_id);
    if ((byte)0xFF == device_index)
    {
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_DEVICEID_NOTAVAIL) );    /* Error: DeviceID not entered in DeviceTab */
    }
    else if ((word)0 == NtfDeviceTabCnt[device_index])
80015980:	4b 88       	lddpc	r8,80015a60 <NtfCheck+0x130>
80015982:	30 00       	mov	r0,0
80015984:	f0 06 04 18 	ld.sh	r8,r8[r6<<0x1]
80015988:	e0 08 19 00 	cp.h	r8,r0
8001598c:	cf 20       	breq	80015970 <NtfCheck+0x40>
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_DEVICEID_NOTAVAIL) );    /* Error: DeviceID not entered in DeviceTab */
    }

    /*-------------- Load FBlock Description ------------------- */

    fblock_error = NtfLoadFBlockDescriptionRx(rx_ptr,&num_dev,&prop_tab_baseptr);       /* load max. number of device_index entries */
8001598e:	08 9c       	mov	r12,r4
80015990:	1a 9a       	mov	r10,sp
80015992:	fa cb ff f5 	sub	r11,sp,-11
80015996:	ca 9f       	rcall	800158e8 <NtfLoadFBlockDescriptionRx>
80015998:	18 93       	mov	r3,r12
8001599a:	c5 21       	brne	80015a3e <NtfCheck+0x10e>
                                                                                        /* and base pointer at property table */

    if (fblock_error)
8001599c:	0a 9b       	mov	r11,r5
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_FBLOCK_NOTAVAIL) );
                                                                /* Error: FBlockID.InstID not registered */
                                                                /*        in Notification Service ! */
                                                                /*        --> return(OP_ERROR) */

    CmdEncodeWord(&tx_ptr->Data[0],&device_id);                 /* prepare Tx message */
8001599e:	6e 0c       	ld.w	r12,r7[0x0]
800159a0:	fe b0 f0 ac 	rcall	80013af8 <CmdEncodeWord>
800159a4:	30 28       	mov	r8,2
    tx_ptr->Length = (word)2;
800159a6:	ef 60 00 0d 	st.b	r7[13],r0

    #ifdef AMS_TX_ADD9
    tx_ptr->MidLevelRetries = (byte)0;                          /* internally generated messages don't use MLR */
800159aa:	ae 28       	st.h	r7[0x4],r8
                                                                /* Error: FBlockID.InstID not registered */
                                                                /*        in Notification Service ! */
                                                                /*        --> return(OP_ERROR) */

    CmdEncodeWord(&tx_ptr->Data[0],&device_id);                 /* prepare Tx message */
    tx_ptr->Length = (word)2;
800159ac:	3f f8       	mov	r8,-1
    tx_ptr->MidLevelRetries = (byte)0;                          /* internally generated messages don't use MLR */
    #endif

    prop_tab_ptr = prop_tab_baseptr;

    while (prop_tab_ptr->Type_FuncID != NTF_TERMINATION)
800159ae:	40 02       	lddsp	r2,sp[0x0]

    #ifdef AMS_TX_ADD9
    tx_ptr->MidLevelRetries = (byte)0;                          /* internally generated messages don't use MLR */
    #endif

    prop_tab_ptr = prop_tab_baseptr;
800159b0:	84 09       	ld.sh	r9,r2[0x0]

    while (prop_tab_ptr->Type_FuncID != NTF_TERMINATION)
800159b2:	f0 09 19 00 	cp.h	r9,r8
800159b6:	c3 b0       	breq	80015a2c <NtfCheck+0xfc>
800159b8:	fb 39 00 0b 	ld.ub	r9,sp[11]
800159bc:	fa c1 ff fa 	sub	r1,sp,-6
                else
                {
                    num++;                                          /* entry found */
                    success = MNS_TRUE;
                    func_id = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
                    CmdEncodeWord(&tx_ptr->Data[2*num], &func_id);
800159c0:	64 15       	ld.w	r5,r2[0x4]

    prop_tab_ptr = prop_tab_baseptr;

    while (prop_tab_ptr->Type_FuncID != NTF_TERMINATION)
    {
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table */
800159c2:	e0 09 18 00 	cp.b	r9,r0
                                                                /* (column of notification matrix) */
        success = MNS_FALSE;                                    /* used to stop search if entry is found */
        for (i=(byte)0; (i < num_dev) && (MNS_FALSE == success); i++, device_index_tab_ptr++)
800159c6:	c2 d0       	breq	80015a20 <NtfCheck+0xf0>
800159c8:	2f f5       	sub	r5,-1

    prop_tab_ptr = prop_tab_baseptr;

    while (prop_tab_ptr->Type_FuncID != NTF_TERMINATION)
    {
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table */
800159ca:	30 04       	mov	r4,0
800159cc:	c0 b8       	rjmp	800159e2 <NtfCheck+0xb2>
800159ce:	30 0a       	mov	r10,0
                                                                /* (column of notification matrix) */
        success = MNS_FALSE;                                    /* used to stop search if entry is found */
        for (i=(byte)0; (i < num_dev) && (MNS_FALSE == success); i++, device_index_tab_ptr++)
        {
            if (device_index == (*device_index_tab_ptr & MASK_DEV_INDEX))
800159d0:	2f f4       	sub	r4,-1
    while (prop_tab_ptr->Type_FuncID != NTF_TERMINATION)
    {
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table */
                                                                /* (column of notification matrix) */
        success = MNS_FALSE;                                    /* used to stop search if entry is found */
        for (i=(byte)0; (i < num_dev) && (MNS_FALSE == success); i++, device_index_tab_ptr++)
800159d2:	2f f5       	sub	r5,-1
800159d4:	5c 54       	castu.b	r4
800159d6:	e8 09 18 00 	cp.b	r9,r4
800159da:	e0 88 00 23 	brls	80015a20 <NtfCheck+0xf0>
800159de:	58 0a       	cp.w	r10,0
800159e0:	c2 01       	brne	80015a20 <NtfCheck+0xf0>
800159e2:	0b 88       	ld.ub	r8,r5[0x0]
        {
            if (device_index == (*device_index_tab_ptr & MASK_DEV_INDEX))
800159e4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800159e8:	0c 38       	cp.w	r8,r6
800159ea:	cf 21       	brne	800159ce <NtfCheck+0x9e>
800159ec:	2f f3       	sub	r3,-1
                {
                    return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_MSG_BUF_OVERFLOW) );
                }
                else
                {
                    num++;                                          /* entry found */
800159ee:	8e a8       	ld.uh	r8,r7[0x4]
        success = MNS_FALSE;                                    /* used to stop search if entry is found */
        for (i=(byte)0; (i < num_dev) && (MNS_FALSE == success); i++, device_index_tab_ptr++)
        {
            if (device_index == (*device_index_tab_ptr & MASK_DEV_INDEX))
            {
                if (MAX_MSG_TX_DATA < tx_ptr->Length + (word)2)     /* message length exceeds buffer size (MAX_MSG_TX_DATA) */
800159f0:	5c 83       	casts.h	r3
                {
                    return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_MSG_BUF_OVERFLOW) );
                }
                else
                {
                    num++;                                          /* entry found */
800159f2:	e0 48 00 30 	cp.w	r8,48
        success = MNS_FALSE;                                    /* used to stop search if entry is found */
        for (i=(byte)0; (i < num_dev) && (MNS_FALSE == success); i++, device_index_tab_ptr++)
        {
            if (device_index == (*device_index_tab_ptr & MASK_DEV_INDEX))
            {
                if (MAX_MSG_TX_DATA < tx_ptr->Length + (word)2)     /* message length exceeds buffer size (MAX_MSG_TX_DATA) */
800159f6:	e0 89 00 1d 	brgt	80015a30 <NtfCheck+0x100>
800159fa:	84 08       	ld.sh	r8,r2[0x0]
                }
                else
                {
                    num++;                                          /* entry found */
                    success = MNS_TRUE;
                    func_id = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
800159fc:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
80015a00:	ba 38       	st.h	sp[0x6],r8
80015a02:	6e 08       	ld.w	r8,r7[0x0]
                    CmdEncodeWord(&tx_ptr->Data[2*num], &func_id);
80015a04:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
80015a08:	02 9b       	mov	r11,r1
80015a0a:	f0 0c 00 1c 	add	r12,r8,r12<<0x1
80015a0e:	fe b0 f0 75 	rcall	80013af8 <CmdEncodeWord>
80015a12:	8e 28       	ld.sh	r8,r7[0x4]
                    tx_ptr->Length += (word)2;
80015a14:	30 1a       	mov	r10,1
80015a16:	2f e8       	sub	r8,-2
80015a18:	ae 28       	st.h	r7[0x4],r8
80015a1a:	fb 39 00 0b 	ld.ub	r9,sp[11]
80015a1e:	cd 9b       	rjmp	800159d0 <NtfCheck+0xa0>
80015a20:	2f 02       	sub	r2,-16
                }
            }
        }

        ++prop_tab_ptr;                                         /* next property */
80015a22:	3f fa       	mov	r10,-1
    tx_ptr->MidLevelRetries = (byte)0;                          /* internally generated messages don't use MLR */
    #endif

    prop_tab_ptr = prop_tab_baseptr;

    while (prop_tab_ptr->Type_FuncID != NTF_TERMINATION)
80015a24:	84 08       	ld.sh	r8,r2[0x0]
80015a26:	f4 08 19 00 	cp.h	r8,r10
80015a2a:	cc b1       	brne	800159c0 <NtfCheck+0x90>
80015a2c:	30 cc       	mov	r12,12
80015a2e:	ca 6b       	rjmp	8001597a <NtfCheck+0x4a>
80015a30:	0e 9c       	mov	r12,r7
        {
            if (device_index == (*device_index_tab_ptr & MASK_DEV_INDEX))
            {
                if (MAX_MSG_TX_DATA < tx_ptr->Length + (word)2)     /* message length exceeds buffer size (MAX_MSG_TX_DATA) */
                {
                    return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_MSG_BUF_OVERFLOW) );
80015a32:	30 1a       	mov	r10,1
80015a34:	32 0b       	mov	r11,32
80015a36:	fe b0 f0 a5 	rcall	80013b80 <CmdErrorByte>
80015a3a:	2f dd       	sub	sp,-12

        ++prop_tab_ptr;                                         /* next property */
    }

    return(OP_STATUS);
}
80015a3c:	d8 32       	popm	r0-r7,pc
80015a3e:	32 0a       	mov	r10,32

    fblock_error = NtfLoadFBlockDescriptionRx(rx_ptr,&num_dev,&prop_tab_baseptr);       /* load max. number of device_index entries */
                                                                                        /* and base pointer at property table */

    if (fblock_error)
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_FBLOCK_NOTAVAIL) );
80015a40:	0e 9c       	mov	r12,r7
80015a42:	14 9b       	mov	r11,r10
80015a44:	fe b0 f0 9e 	rcall	80013b80 <CmdErrorByte>
80015a48:	2f dd       	sub	sp,-12

        ++prop_tab_ptr;                                         /* next property */
    }

    return(OP_STATUS);
}
80015a4a:	d8 32       	popm	r0-r7,pc
80015a4c:	30 16       	mov	r6,1
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015a4e:	c9 9b       	rjmp	80015980 <NtfCheck+0x50>
80015a50:	30 26       	mov	r6,2
80015a52:	c9 7b       	rjmp	80015980 <NtfCheck+0x50>
80015a54:	30 36       	mov	r6,3
80015a56:	c9 5b       	rjmp	80015980 <NtfCheck+0x50>
80015a58:	30 46       	mov	r6,4
80015a5a:	c9 3b       	rjmp	80015980 <NtfCheck+0x50>
80015a5c:	00 00       	add	r0,r0
80015a5e:	4a 7a       	lddpc	r10,80015af8 <NtfPropertyChangedIdx+0x4c>
80015a60:	00 00       	add	r0,r0
80015a62:	4a 58       	lddpc	r8,80015af4 <NtfPropertyChangedIdx+0x48>

80015a64 <NtfChangeAllFlags>:
80015a64:	d4 01       	pushm	lr
80015a66:	58 0b       	cp.w	r11,0
80015a68:	c0 e0       	breq	80015a84 <NtfChangeAllFlags+0x20>
80015a6a:	f8 c8 ff fe 	sub	r8,r12,-2
80015a6e:	20 1b       	sub	r11,1
80015a70:	2f fc       	sub	r12,-1
80015a72:	5c 5b       	castu.b	r11
80015a74:	f0 0b 00 0b 	add	r11,r8,r11
    device_index_tab_ptr++;                                         /* forget about column flag field */

    for (i=(byte)0;i<num_entries;i++)
    {
        flags_device_index = *device_index_tab_ptr;                 /* read flags and device index */
        *device_index_tab_ptr++ = flags_device_index | flags_set;   /* set flag(s) */
80015a78:	19 88       	ld.ub	r8,r12[0x0]
80015a7a:	f5 e8 10 08 	or	r8,r10,r8
80015a7e:	18 c8       	st.b	r12++,r8
    byte i;
    TNtfMatrix flags_device_index;

    device_index_tab_ptr++;                                         /* forget about column flag field */

    for (i=(byte)0;i<num_entries;i++)
80015a80:	16 3c       	cp.w	r12,r11
80015a82:	cf b1       	brne	80015a78 <NtfChangeAllFlags+0x14>
        flags_device_index = *device_index_tab_ptr;                 /* read flags and device index */
        *device_index_tab_ptr++ = flags_device_index | flags_set;   /* set flag(s) */
    }

    #ifdef MNS2_OPT_1
    NtfLoopCounter = NtfNumElements;                                /* Load counter to indicate demand for re-trigger */
80015a84:	48 48       	lddpc	r8,80015a94 <NtfChangeAllFlags+0x30>
80015a86:	90 09       	ld.sh	r9,r8[0x0]
80015a88:	48 48       	lddpc	r8,80015a98 <NtfChangeAllFlags+0x34>
    #endif

    #ifdef MNS2_OPT_1
    MNS2_REQUEST_CALL(MNS2_P_NTFS)                                  /* Set Request Flag and call application */
80015a8a:	31 0c       	mov	r12,16
        flags_device_index = *device_index_tab_ptr;                 /* read flags and device index */
        *device_index_tab_ptr++ = flags_device_index | flags_set;   /* set flag(s) */
    }

    #ifdef MNS2_OPT_1
    NtfLoopCounter = NtfNumElements;                                /* Load counter to indicate demand for re-trigger */
80015a8c:	b0 09       	st.h	r8[0x0],r9
    #endif

    #ifdef MNS2_OPT_1
    MNS2_REQUEST_CALL(MNS2_P_NTFS)                                  /* Set Request Flag and call application */
80015a8e:	fe b0 f8 eb 	rcall	80014c64 <MnsPending2SetAndCall>
    #endif
}
80015a92:	d8 02       	popm	pc
80015a94:	00 00       	add	r0,r0
80015a96:	4a 76       	lddpc	r6,80015b30 <NtfWriteDeviceIndex+0x14>
80015a98:	00 00       	add	r0,r0
80015a9a:	4a 72       	lddpc	r2,80015b34 <NtfWriteDeviceIndex+0x18>

80015a9c <NtfPropertyChanged>:
80015a9c:	d4 01       	pushm	lr
80015a9e:	19 88       	ld.ub	r8,r12[0x0]
{
    #ifdef NTF_EXT
    TNtfMatrix property_flags;

    property_flags = *device_index_tab_ptr;
    *device_index_tab_ptr   = property_flags | MASK_FLAG_ERROR;                         /* clear flag ERROR (inverted!)          */
80015aa0:	a1 a8       	sbr	r8,0x0
    #endif

    NtfChangeAllFlags(device_index_tab_ptr, num_entries, MASK_FLAG_NTF);
80015aa2:	34 0a       	mov	r10,64
{
    #ifdef NTF_EXT
    TNtfMatrix property_flags;

    property_flags = *device_index_tab_ptr;
    *device_index_tab_ptr   = property_flags | MASK_FLAG_ERROR;                         /* clear flag ERROR (inverted!)          */
80015aa4:	b8 88       	st.b	r12[0x0],r8
    #endif

    NtfChangeAllFlags(device_index_tab_ptr, num_entries, MASK_FLAG_NTF);
80015aa6:	cd ff       	rcall	80015a64 <NtfChangeAllFlags>
80015aa8:	d8 02       	popm	pc
}
80015aaa:	d7 03       	nop

80015aac <NtfPropertyChangedIdx>:
80015aac:	d4 01       	pushm	lr
80015aae:	58 0c       	cp.w	r12,0

    fblock_tab_ptr = NtfFBlockTab;      /* set pointer at first entry in the Notification FBlock Table */

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        if (fblock_tab_ptr->FBlockIndex == fblock_index)
80015ab0:	c0 60       	breq	80015abc <NtfPropertyChangedIdx+0x10>
80015ab2:	30 18       	mov	r8,1
80015ab4:	f0 0c 18 00 	cp.b	r12,r8
80015ab8:	c1 e0       	breq	80015af4 <NtfPropertyChangedIdx+0x48>
80015aba:	d8 02       	popm	pc
80015abc:	49 09       	lddpc	r9,80015afc <NtfPropertyChangedIdx+0x50>
    fblock_tab_ptr = NtfGetFBlockTabPtr(fblock_index);

    if (fblock_tab_ptr != NULL)                          /* fblock index found ? */
    {
        num_dev = fblock_tab_ptr->NumDev;               /* read maximum count of devices to service          */
        prop_tab_baseptr = fblock_tab_ptr->PtrPropTab;  /* read base (!) pointer at property table */
80015abe:	72 18       	ld.w	r8,r9[0x4]

    fblock_tab_ptr = NtfGetFBlockTabPtr(fblock_index);

    if (fblock_tab_ptr != NULL)                          /* fblock index found ? */
    {
        num_dev = fblock_tab_ptr->NumDev;               /* read maximum count of devices to service          */
80015ac0:	13 9c       	ld.ub	r12,r9[0x1]
#ifdef NTF_52
pTNtfPropL NtfGetPropTabPtr(pTNtfPropL prop_tab_ptr, word func_id)
{
    word func_id_tab;

    if (func_id < 0x0FFF)
80015ac2:	e0 69 0f fe 	mov	r9,4094
80015ac6:	f2 0b 19 00 	cp.h	r11,r9
80015aca:	fe 9b ff f8 	brhi	80015aba <NtfPropertyChangedIdx+0xe>
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015ace:	e0 6a 0f ff 	mov	r10,4095
80015ad2:	c0 58       	rjmp	80015adc <NtfPropertyChangedIdx+0x30>
80015ad4:	f4 09 19 00 	cp.h	r9,r10
80015ad8:	cf 10       	breq	80015aba <NtfPropertyChangedIdx+0xe>
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;
80015ada:	2f 08       	sub	r8,-16
    word func_id_tab;

    if (func_id < 0x0FFF)
        do
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
80015adc:	90 09       	ld.sh	r9,r8[0x0]
80015ade:	f3 d9 c0 0c 	bfextu	r9,r9,0x0,0xc
            if (func_id_tab == func_id)
80015ae2:	f2 0b 19 00 	cp.h	r11,r9
80015ae6:	cf 71       	brne	80015ad4 <NtfPropertyChangedIdx+0x28>
        num_dev = fblock_tab_ptr->NumDev;               /* read maximum count of devices to service          */
        prop_tab_baseptr = fblock_tab_ptr->PtrPropTab;  /* read base (!) pointer at property table */

        prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, fkt_id);       /* prepare pointer at corresponding property line */

        if (prop_tab_ptr != NULL)                                        /* property available ? */
80015ae8:	58 08       	cp.w	r8,0
80015aea:	ce 80       	breq	80015aba <NtfPropertyChangedIdx+0xe>
        {
            device_index_tab_baseptr = prop_tab_ptr->PtrNtfMatrixCol;

            NtfPropertyChanged(device_index_tab_baseptr, num_dev);       /* call first level function */
80015aec:	18 9b       	mov	r11,r12
80015aee:	70 1c       	ld.w	r12,r8[0x4]
80015af0:	cd 6f       	rcall	80015a9c <NtfPropertyChanged>
80015af2:	d8 02       	popm	pc
80015af4:	48 29       	lddpc	r9,80015afc <NtfPropertyChangedIdx+0x50>

    fblock_tab_ptr = NtfFBlockTab;      /* set pointer at first entry in the Notification FBlock Table */

    for (i=(byte)0;i<NTF_MAX_FBLOCKS;i++)
    {
        if (fblock_tab_ptr->FBlockIndex == fblock_index)
80015af6:	2f 89       	sub	r9,-8
80015af8:	ce 3b       	rjmp	80015abe <NtfPropertyChangedIdx+0x12>
80015afa:	d7 03       	nop
80015afc:	80 07       	ld.sh	r7,r0[0x0]
80015afe:	08 5c       	eor	r12,r4

80015b00 <NtfPropertyChangedFkt>:
80015b00:	eb cd 40 80 	pushm	r7,lr
/* Returns     : nothing                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_44
void NtfPropertyChangedFkt(byte fblock_id, byte inst_id, word fkt_id)
{
80015b04:	14 97       	mov	r7,r10
    byte         fblock_index;

    fblock_index = NbGetFBlockIndex( fblock_id, inst_id);
80015b06:	fe b0 f9 cf 	rcall	80014ea4 <NbGetFBlockIndex>
    if ((byte)0xFF == fblock_index)
80015b0a:	3f f8       	mov	r8,-1
80015b0c:	f0 0c 18 00 	cp.b	r12,r8
80015b10:	c0 40       	breq	80015b18 <NtfPropertyChangedFkt+0x18>
        return;

    NtfPropertyChangedIdx(fblock_index, fkt_id);
80015b12:	0e 9b       	mov	r11,r7
80015b14:	5c 7b       	castu.h	r11
80015b16:	cc bf       	rcall	80015aac <NtfPropertyChangedIdx>
80015b18:	e3 cd 80 80 	ldm	sp++,r7,pc

80015b1c <NtfWriteDeviceIndex>:
80015b1c:	eb cd 40 c0 	pushm	r6-r7,lr
80015b20:	58 0b       	cp.w	r11,0
80015b22:	c2 50       	breq	80015b6c <NtfWriteDeviceIndex+0x50>
80015b24:	19 8e       	ld.ub	lr,r12[0x0]
80015b26:	ed de c0 05 	bfextu	r6,lr,0x0,0x5
    for (i=(byte)0;i<num_entries;i++)
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
80015b2a:	0c 3a       	cp.w	r10,r6
80015b2c:	c2 40       	breq	80015b74 <NtfWriteDeviceIndex+0x58>

        #ifdef MNS2_OPT_1
        MNS2_REQUEST_CALL(MNS2_P_NTFS)                          /* Set Request Flag and call application */
        #endif

        return((byte)1);
80015b2e:	18 99       	mov	r9,r12
80015b30:	30 08       	mov	r8,0
80015b32:	c0 78       	rjmp	80015b40 <NtfWriteDeviceIndex+0x24>
            #endif

            return((byte)1);
        }

        device_index_tab_ptr++;
80015b34:	2f f9       	sub	r9,-1
    device_index_tab_ptr = *device_index_tab_ptrptr;


    for (i=(byte)0;i<num_entries;i++)
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */
80015b36:	13 8e       	ld.ub	lr,r9[0x0]

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
80015b38:	ef de c0 05 	bfextu	r7,lr,0x0,0x5
80015b3c:	0e 3a       	cp.w	r10,r7
80015b3e:	c1 a0       	breq	80015b72 <NtfWriteDeviceIndex+0x56>
    TNtfMatrix device_index_flags;          /* device index and flags */

    device_index_tab_ptr = *device_index_tab_ptrptr;


    for (i=(byte)0;i<num_entries;i++)
80015b40:	2f f8       	sub	r8,-1
80015b42:	5c 58       	castu.b	r8
80015b44:	f0 0b 18 00 	cp.b	r11,r8
80015b48:	fe 9b ff f6 	brhi	80015b34 <NtfWriteDeviceIndex+0x18>
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
80015b4c:	59 f6       	cp.w	r6,31
80015b4e:	c2 00       	breq	80015b8e <NtfWriteDeviceIndex+0x72>

    #ifdef MNS2_OPT_1
    MNS2_REQUEST_CALL(MNS2_P_NTFS)                              /* Set Request Flag and call application */
    #endif

    return((byte)0);                                                  /* report success */
80015b50:	30 08       	mov	r8,0
80015b52:	c0 78       	rjmp	80015b60 <NtfWriteDeviceIndex+0x44>
            #endif

            return((byte)1);
        }

        device_index_tab_ptr++;
80015b54:	2f fc       	sub	r12,-1
    for (i=(byte)0;i<num_entries;i++)
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
80015b56:	19 89       	ld.ub	r9,r12[0x0]
80015b58:	f3 d9 c0 05 	bfextu	r9,r9,0x0,0x5
80015b5c:	59 f9       	cp.w	r9,31
80015b5e:	c1 80       	breq	80015b8e <NtfWriteDeviceIndex+0x72>
    TNtfMatrix device_index_flags;          /* device index and flags */

    device_index_tab_ptr = *device_index_tab_ptrptr;


    for (i=(byte)0;i<num_entries;i++)
80015b60:	2f f8       	sub	r8,-1
80015b62:	5c 58       	castu.b	r8
80015b64:	f0 0b 18 00 	cp.b	r11,r8
80015b68:	fe 9b ff f6 	brhi	80015b54 <NtfWriteDeviceIndex+0x38>
80015b6c:	30 2c       	mov	r12,2
    #ifdef MNS2_OPT_1
    MNS2_REQUEST_CALL(MNS2_P_NTFS)                              /* Set Request Flag and call application */
    #endif

    return((byte)0);                                                  /* report success */
}
80015b6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    for (i=(byte)0;i<num_entries;i++)
    {
        device_index_flags = *device_index_tab_ptr;         /* read device index and flags out of table */

        #ifdef NTF_SINGLE_PREV
        if ( ((device_index_flags & MASK_DEV_INDEX) == (TNtfMatrix)device_index) ) /* valid device index ? */
80015b72:	12 9c       	mov	r12,r9
        #endif

        *device_index_tab_ptr = flags_device_index | MASK_FLAG_NTF; /* set flag NTF at existing entry */

        #ifdef MNS2_OPT_1
        NtfLoopCounter = NtfNumElements;                        /* Load counter to indicate demand for re-trigger */
80015b74:	49 08       	lddpc	r8,80015bb4 <NtfWriteDeviceIndex+0x98>

        #ifdef NTF_SINGLE_PREV
        flags_device_index &= (TNtfMatrix)~MASK_FLAG_SINGLE;        /* clear flag of 'Single Notification' */
        #endif

        *device_index_tab_ptr = flags_device_index | MASK_FLAG_NTF; /* set flag NTF at existing entry */
80015b76:	fd de c0 07 	bfextu	lr,lr,0x0,0x7
80015b7a:	a7 ae       	sbr	lr,0x6
80015b7c:	b8 8e       	st.b	r12[0x0],lr

        #ifdef MNS2_OPT_1
        NtfLoopCounter = NtfNumElements;                        /* Load counter to indicate demand for re-trigger */
80015b7e:	90 09       	ld.sh	r9,r8[0x0]
80015b80:	48 e8       	lddpc	r8,80015bb8 <NtfWriteDeviceIndex+0x9c>
        #endif



        #ifdef MNS2_OPT_1
        MNS2_REQUEST_CALL(MNS2_P_NTFS)                          /* Set Request Flag and call application */
80015b82:	31 0c       	mov	r12,16
        #endif

        *device_index_tab_ptr = flags_device_index | MASK_FLAG_NTF; /* set flag NTF at existing entry */

        #ifdef MNS2_OPT_1
        NtfLoopCounter = NtfNumElements;                        /* Load counter to indicate demand for re-trigger */
80015b84:	b0 09       	st.h	r8[0x0],r9
        #endif



        #ifdef MNS2_OPT_1
        MNS2_REQUEST_CALL(MNS2_P_NTFS)                          /* Set Request Flag and call application */
80015b86:	fe b0 f8 6f 	rcall	80014c64 <MnsPending2SetAndCall>
80015b8a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
    if ((byte)0 == scan_status)                                           /* no free table entry ? */
    {
        return((byte)2);
    }

    *device_index_tab_ptr = (TNtfMatrix)(device_index | MASK_FLAG_NTF);     /* write device_index into first free table entry, since  */
80015b8e:	14 98       	mov	r8,r10
80015b90:	a7 a8       	sbr	r8,0x6
80015b92:	b8 88       	st.b	r12[0x0],r8
    NtfLoopCounter = NtfNumElements;                            /* Load counter to indicate demand for re-trigger */
    #endif



    NtfDeviceTabCnt[device_index]++;                            /* increment respective counter of Device Index Table */
80015b94:	48 a8       	lddpc	r8,80015bbc <NtfWriteDeviceIndex+0xa0>
80015b96:	f0 0a 04 19 	ld.sh	r9,r8[r10<<0x1]
80015b9a:	2f f9       	sub	r9,-1
80015b9c:	f0 0a 0a 19 	st.h	r8[r10<<0x1],r9
    *device_index_tab_ptr = (TNtfMatrix)(device_index | MASK_FLAG_NTF);     /* write device_index into first free table entry, since  */
                                                                            /* device_index not already existing */
                                                                            /* and set flag NTF */

    #ifdef MNS2_OPT_1
    NtfLoopCounter = NtfNumElements;                            /* Load counter to indicate demand for re-trigger */
80015ba0:	48 58       	lddpc	r8,80015bb4 <NtfWriteDeviceIndex+0x98>
80015ba2:	90 09       	ld.sh	r9,r8[0x0]
80015ba4:	48 58       	lddpc	r8,80015bb8 <NtfWriteDeviceIndex+0x9c>


    NtfDeviceTabCnt[device_index]++;                            /* increment respective counter of Device Index Table */

    #ifdef MNS2_OPT_1
    MNS2_REQUEST_CALL(MNS2_P_NTFS)                              /* Set Request Flag and call application */
80015ba6:	31 0c       	mov	r12,16
    *device_index_tab_ptr = (TNtfMatrix)(device_index | MASK_FLAG_NTF);     /* write device_index into first free table entry, since  */
                                                                            /* device_index not already existing */
                                                                            /* and set flag NTF */

    #ifdef MNS2_OPT_1
    NtfLoopCounter = NtfNumElements;                            /* Load counter to indicate demand for re-trigger */
80015ba8:	b0 09       	st.h	r8[0x0],r9


    NtfDeviceTabCnt[device_index]++;                            /* increment respective counter of Device Index Table */

    #ifdef MNS2_OPT_1
    MNS2_REQUEST_CALL(MNS2_P_NTFS)                              /* Set Request Flag and call application */
80015baa:	fe b0 f8 5d 	rcall	80014c64 <MnsPending2SetAndCall>
80015bae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80015bb2:	d7 03       	nop
80015bb4:	00 00       	add	r0,r0
80015bb6:	4a 76       	lddpc	r6,80015c50 <NtfGetNotificationMatrix+0x90>
80015bb8:	00 00       	add	r0,r0
80015bba:	4a 72       	lddpc	r2,80015c54 <NtfGetNotificationMatrix+0x94>
80015bbc:	00 00       	add	r0,r0
80015bbe:	4a 58       	lddpc	r8,80015c50 <NtfGetNotificationMatrix+0x90>

80015bc0 <NtfGetNotificationMatrix>:
80015bc0:	d4 31       	pushm	r0-r7,lr
80015bc2:	20 3d       	sub	sp,12
/* Returns     : op_type                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_11
byte NtfGetNotificationMatrix(pTMsgTx tx_ptr, pTMsgRx rx_ptr)
{
80015bc4:	16 96       	mov	r6,r11
80015bc6:	18 97       	mov	r7,r12
    #endif


    /*-------------- Load FBlock Description ------------------- */

    fblock_error = NtfLoadFBlockDescriptionRx(rx_ptr,&num_dev,&prop_tab_baseptr);
80015bc8:	1a 9a       	mov	r10,sp
80015bca:	fa cb ff f5 	sub	r11,sp,-11
80015bce:	0c 9c       	mov	r12,r6
80015bd0:	c8 ce       	rcall	800158e8 <NtfLoadFBlockDescriptionRx>
80015bd2:	c2 31       	brne	80015c18 <NtfGetNotificationMatrix+0x58>

    if (fblock_error)
80015bd4:	fa c4 ff f8 	sub	r4,sp,-8
                                                               /*        --> return(OP_ERROR) */


    /*-------------- Get Parameter (FuncID) -------------------- */

    CmdDecodeWord(&func_id,&rx_ptr->Data[0]);                   /* read parameter (Function ID) */
80015bd8:	6c 0b       	ld.w	r11,r6[0x0]
80015bda:	08 9c       	mov	r12,r4
80015bdc:	fe b0 ef 93 	rcall	80013b02 <CmdDecodeWord>
80015be0:	9a 4a       	ld.sh	r10,sp[0x8]


    /*---------------------------------------------------------- */


    prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id); /* get pointer at corresponding line of the property table */
80015be2:	40 08       	lddsp	r8,sp[0x0]
80015be4:	e0 69 0f fe 	mov	r9,4094
#ifdef NTF_52
pTNtfPropL NtfGetPropTabPtr(pTNtfPropL prop_tab_ptr, word func_id)
{
    word func_id_tab;

    if (func_id < 0x0FFF)
80015be8:	f2 0a 19 00 	cp.h	r10,r9
80015bec:	e0 8b 00 0f 	brhi	80015c0a <NtfGetNotificationMatrix+0x4a>
80015bf0:	e0 6b 0f ff 	mov	r11,4095
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015bf4:	c0 28       	rjmp	80015bf8 <NtfGetNotificationMatrix+0x38>
80015bf6:	2f 08       	sub	r8,-16
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;
80015bf8:	90 09       	ld.sh	r9,r8[0x0]
    word func_id_tab;

    if (func_id < 0x0FFF)
        do
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
80015bfa:	f3 d9 c0 0c 	bfextu	r9,r9,0x0,0xc
80015bfe:	f2 0a 19 00 	cp.h	r10,r9
            if (func_id_tab == func_id)
80015c02:	c1 20       	breq	80015c26 <NtfGetNotificationMatrix+0x66>
80015c04:	f6 09 19 00 	cp.h	r9,r11
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015c08:	cf 71       	brne	80015bf6 <NtfGetNotificationMatrix+0x36>
80015c0a:	6c 0a       	ld.w	r10,r6[0x0]
        tx_ptr->Length = tx_length;                             /* set length of data to transmit */
    }
    else
    {
     /* return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, 0x04) );   */
        return( CmdErrorParamNotAvailable( tx_ptr, (byte)1, &rx_ptr->Data[0], (byte)2) );
80015c0c:	0e 9c       	mov	r12,r7
80015c0e:	30 29       	mov	r9,2
80015c10:	30 1b       	mov	r11,1
80015c12:	fe b0 ef dc 	rcall	80013bca <CmdErrorParamNotAvailable>
80015c16:	c0 68       	rjmp	80015c22 <NtfGetNotificationMatrix+0x62>
80015c18:	32 0a       	mov	r10,32
    /*-------------- Load FBlock Description ------------------- */

    fblock_error = NtfLoadFBlockDescriptionRx(rx_ptr,&num_dev,&prop_tab_baseptr);

    if (fblock_error)
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_FBLOCK_NOTAVAIL) );
80015c1a:	0e 9c       	mov	r12,r7
80015c1c:	14 9b       	mov	r11,r10
80015c1e:	fe b0 ef b1 	rcall	80013b80 <CmdErrorByte>
80015c22:	2f dd       	sub	sp,-12
                                                                /*        in Notification Service ! */
                                                                /*        --> return(OP_ERROR) */
    }

    return (OP_STATUS);
}
80015c24:	d8 32       	popm	r0-r7,pc
80015c26:	58 08       	cp.w	r8,0
    /*---------------------------------------------------------- */


    prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id); /* get pointer at corresponding line of the property table */

    if (prop_tab_ptr != NULL)
80015c28:	cf 10       	breq	80015c0a <NtfGetNotificationMatrix+0x4a>
80015c2a:	70 15       	ld.w	r5,r8[0x4]
    {
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table              */
80015c2c:	08 9b       	mov	r11,r4
                                                                /* (column of notification matrix) */

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
80015c2e:	6e 0c       	ld.w	r12,r7[0x0]
80015c30:	fe b0 ef 64 	rcall	80013af8 <CmdEncodeWord>
80015c34:	fb 3a 00 0b 	ld.ub	r10,sp[11]
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */

        for (i=(byte)0;i<num_dev;i++)                           /* scan whole column */
80015c38:	6e 01       	ld.w	r1,r7[0x0]
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table              */
                                                                /* (column of notification matrix) */

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */
80015c3a:	58 0a       	cp.w	r10,0

        for (i=(byte)0;i<num_dev;i++)                           /* scan whole column */
80015c3c:	c3 20       	breq	80015ca0 <NtfGetNotificationMatrix+0xe0>
80015c3e:	30 06       	mov	r6,0
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table              */
                                                                /* (column of notification matrix) */

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */
80015c40:	2f f5       	sub	r5,-1

    prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id); /* get pointer at corresponding line of the property table */

    if (prop_tab_ptr != NULL)
    {
        device_index_tab_ptr = prop_tab_ptr->PtrNtfMatrixCol+1; /* set pointer at first entry in device index table              */
80015c42:	2f e1       	sub	r1,-2
                                                                /* (column of notification matrix) */

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */
80015c44:	30 20       	mov	r0,2
80015c46:	49 82       	lddpc	r2,80015ca4 <NtfGetNotificationMatrix+0xe4>
80015c48:	31 f3       	mov	r3,31
            device_index_flags = *device_index_tab_ptr++;       /* get device index and flags from table and increment  */
                                                                /* pointer at index table */
            device_index = (byte)(device_index_flags & MASK_DEV_INDEX);
            device_addr  = NtfDeviceTab[device_index];

            if ( (device_index != (byte)NTF_DEV_INDEX_FREE) && !(device_index_flags & MASK_FLAG_SINGLE) )
80015c4a:	0c 94       	mov	r4,r6
80015c4c:	c0 78       	rjmp	80015c5a <NtfGetNotificationMatrix+0x9a>
80015c4e:	2f f6       	sub	r6,-1

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */

        for (i=(byte)0;i<num_dev;i++)                           /* scan whole column */
80015c50:	5c 56       	castu.b	r6
80015c52:	ec 0a 18 00 	cp.b	r10,r6
80015c56:	e0 88 00 21 	brls	80015c98 <NtfGetNotificationMatrix+0xd8>
80015c5a:	0b 38       	ld.ub	r8,r5++
        {
            device_index_flags = *device_index_tab_ptr++;       /* get device index and flags from table and increment  */
80015c5c:	f3 d8 c0 05 	bfextu	r9,r8,0x0,0x5
                                                                /* pointer at index table */
            device_index = (byte)(device_index_flags & MASK_DEV_INDEX);
80015c60:	e4 09 04 1b 	ld.sh	r11,r2[r9<<0x1]
            device_addr  = NtfDeviceTab[device_index];
80015c64:	ba 3b       	st.h	sp[0x6],r11
80015c66:	e6 09 18 00 	cp.b	r9,r3

            if ( (device_index != (byte)NTF_DEV_INDEX_FREE) && !(device_index_flags & MASK_FLAG_SINGLE) )
80015c6a:	5f 19       	srne	r9
80015c6c:	5c d8       	com	r8
80015c6e:	f3 e8 02 78 	and	r8,r9,r8>>0x7
80015c72:	e8 08 18 00 	cp.b	r8,r4
80015c76:	ce c0       	breq	80015c4e <NtfGetNotificationMatrix+0x8e>
80015c78:	02 9c       	mov	r12,r1
            {                                                   /* valid device index ? But forget about single notification */
                                                                /* entries */
                CmdEncodeWord(tx_data_ptr,&device_addr);        /* copy device id to tx message */
80015c7a:	fa cb ff fa 	sub	r11,sp,-6
80015c7e:	fe b0 ef 3d 	rcall	80013af8 <CmdEncodeWord>
80015c82:	2f e0       	sub	r0,-2
                tx_data_ptr += 2;                               /* set pointer to next parameter (device id) */
                tx_length   = (word)(tx_length+(word)2);        /* increment length of data to transmit */
80015c84:	2f f6       	sub	r6,-1

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */

        for (i=(byte)0;i<num_dev;i++)                           /* scan whole column */
80015c86:	2f e1       	sub	r1,-2

            if ( (device_index != (byte)NTF_DEV_INDEX_FREE) && !(device_index_flags & MASK_FLAG_SINGLE) )
            {                                                   /* valid device index ? But forget about single notification */
                                                                /* entries */
                CmdEncodeWord(tx_data_ptr,&device_addr);        /* copy device id to tx message */
                tx_data_ptr += 2;                               /* set pointer to next parameter (device id) */
80015c88:	5c 80       	casts.h	r0
                tx_length   = (word)(tx_length+(word)2);        /* increment length of data to transmit */
80015c8a:	fb 3a 00 0b 	ld.ub	r10,sp[11]
80015c8e:	5c 56       	castu.b	r6

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */

        for (i=(byte)0;i<num_dev;i++)                           /* scan whole column */
80015c90:	ec 0a 18 00 	cp.b	r10,r6
80015c94:	fe 9b ff e3 	brhi	80015c5a <NtfGetNotificationMatrix+0x9a>
80015c98:	ae 20       	st.h	r7[0x4],r0
                tx_data_ptr += 2;                               /* set pointer to next parameter (device id) */
                tx_length   = (word)(tx_length+(word)2);        /* increment length of data to transmit */
            }
        }

        tx_ptr->Length = tx_length;                             /* set length of data to transmit */
80015c9a:	30 cc       	mov	r12,12
80015c9c:	2f dd       	sub	sp,-12
                                                                /*        in Notification Service ! */
                                                                /*        --> return(OP_ERROR) */
    }

    return (OP_STATUS);
}
80015c9e:	d8 32       	popm	r0-r7,pc
80015ca0:	30 20       	mov	r0,2

        CmdEncodeWord(&tx_ptr->Data[0],&func_id);               /* first parameter: Function ID  */
        tx_length   = (word)2;                                  /* init length of tx message */
        tx_data_ptr = &tx_ptr->Data[2];                         /* init pointer at parameter field containing device ids */

        for (i=(byte)0;i<num_dev;i++)                           /* scan whole column */
80015ca2:	cf bb       	rjmp	80015c98 <NtfGetNotificationMatrix+0xd8>
80015ca4:	00 00       	add	r0,r0
80015ca6:	4a 7a       	lddpc	r10,80015d40 <NtfSetNotificationMatrix+0x98>

80015ca8 <NtfSetNotificationMatrix>:
80015ca8:	d4 31       	pushm	r0-r7,lr
80015caa:	20 5d       	sub	sp,20
80015cac:	16 97       	mov	r7,r11
80015cae:	96 20       	ld.sh	r0,r11[0x4]
80015cb0:	18 93       	mov	r3,r12
80015cb2:	fa ca ff f8 	sub	r10,sp,-8
80015cb6:	fa cb ff ed 	sub	r11,sp,-19
80015cba:	0e 9c       	mov	r12,r7
80015cbc:	c1 6e       	rcall	800158e8 <NtfLoadFBlockDescriptionRx>
80015cbe:	18 92       	mov	r2,r12
    #endif


    /*-------------- Load FBlock Description ------------------- */

    fblock_error = NtfLoadFBlockDescriptionRx(rx_ptr,&num_dev,&prop_tab_baseptr);       /* load max. number of device_index entries */
80015cc0:	c6 81       	brne	80015d90 <NtfSetNotificationMatrix+0xe8>
                                                                                        /* and base pointer at property table */

    if (fblock_error)
80015cc2:	6e 0b       	ld.w	r11,r7[0x0]
                                                                /*        --> return(OP_ERROR) */


    /*-------------- Read Parameters --------------------------- */

    control = rx_ptr->Data[0];                              /* get param: Control */
80015cc4:	fa cc ff f0 	sub	r12,sp,-16
    CmdDecodeWord(&device_id,&rx_ptr->Data[1]);             /* get param: DeviceID */
80015cc8:	17 36       	ld.ub	r6,r11++
                                                                /*        --> return(OP_ERROR) */


    /*-------------- Read Parameters --------------------------- */

    control = rx_ptr->Data[0];                              /* get param: Control */
80015cca:	fe b0 ef 1c 	rcall	80013b02 <CmdDecodeWord>
    CmdDecodeWord(&device_id,&rx_ptr->Data[1]);             /* get param: DeviceID */
80015cce:	30 18       	mov	r8,1



    /*-------------- Get Device Index -------------------------- */

    if (control <= NTF_SET_FUNC )                           /* set all or set func */
80015cd0:	f0 06 18 00 	cp.b	r6,r8
80015cd4:	e0 88 00 27 	brls	80015d22 <NtfSetNotificationMatrix+0x7a>
80015cd8:	30 38       	mov	r8,3

        if ((byte)0xFF == device_index)                           /* device table overflow ? */
            return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_DEVTABLE_OVERFLOW) ); /* Error: Device Table Overflow */
                                                                                        /*        --> return(OP_ERROR) */
    }
    else if (control <= NTF_CLR_FUNC)                        /* clr all or clr func */
80015cda:	f0 06 18 00 	cp.b	r6,r8
80015cde:	e0 8b 00 2c 	brhi	80015d36 <NtfSetNotificationMatrix+0x8e>
80015ce2:	fe f9 02 ce 	ld.w	r9,pc[718]
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015ce6:	fb 08 00 10 	ld.sh	r8,sp[16]
            return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_DEVTABLE_OVERFLOW) ); /* Error: Device Table Overflow */
                                                                                        /*        --> return(OP_ERROR) */
    }
    else if (control <= NTF_CLR_FUNC)                        /* clr all or clr func */
    {
        device_index = NtfScanDeviceTab(device_id);
80015cea:	92 0a       	ld.sh	r10,r9[0x0]
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015cec:	f0 0a 19 00 	cp.h	r10,r8
80015cf0:	e0 80 01 55 	breq	80015f9a <NtfSetNotificationMatrix+0x2f2>
80015cf4:	92 1a       	ld.sh	r10,r9[0x2]
80015cf6:	f0 0a 19 00 	cp.h	r10,r8
80015cfa:	e0 80 01 52 	breq	80015f9e <NtfSetNotificationMatrix+0x2f6>
80015cfe:	92 2a       	ld.sh	r10,r9[0x4]
80015d00:	f0 0a 19 00 	cp.h	r10,r8
80015d04:	e0 80 01 50 	breq	80015fa4 <NtfSetNotificationMatrix+0x2fc>
80015d08:	92 3a       	ld.sh	r10,r9[0x6]
80015d0a:	f0 0a 19 00 	cp.h	r10,r8
80015d0e:	e0 80 01 4e 	breq	80015faa <NtfSetNotificationMatrix+0x302>
80015d12:	92 49       	ld.sh	r9,r9[0x8]
80015d14:	f0 09 19 00 	cp.h	r9,r8
80015d18:	e0 80 01 30 	breq	80015f78 <NtfSetNotificationMatrix+0x2d0>
80015d1c:	30 0c       	mov	r12,0

        /*----------------------------------------- */
        default:
        /*----------------------------------------- */

            return( CmdErrorParamWrong(tx_ptr, (byte)1, &rx_ptr->Data[0], (byte)1) );    /* Error: wrong parameter control */
80015d1e:	2f bd       	sub	sp,-20
    }                                                                        /*        --> return(OP_ERROR) */

    return(OP_NO_REPORT);                               /* no error occurred */
}
80015d20:	d8 32       	popm	r0-r7,pc
80015d22:	fb 1c 00 10 	ld.uh	r12,sp[16]

    /*-------------- Get Device Index -------------------------- */

    if (control <= NTF_SET_FUNC )                           /* set all or set func */
    {
        device_index = NtfWriteDeviceTab(device_id);        /* check if already existing and write new entry if necessary */
80015d26:	fe b0 fd 8d 	rcall	80015840 <NtfWriteDeviceTab>
80015d2a:	3f f8       	mov	r8,-1

        if ((byte)0xFF == device_index)                           /* device table overflow ? */
80015d2c:	18 92       	mov	r2,r12

    /*-------------- Get Device Index -------------------------- */

    if (control <= NTF_SET_FUNC )                           /* set all or set func */
    {
        device_index = NtfWriteDeviceTab(device_id);        /* check if already existing and write new entry if necessary */
80015d2e:	f0 0c 18 00 	cp.b	r12,r8

        if ((byte)0xFF == device_index)                           /* device table overflow ? */
80015d32:	e0 80 01 2e 	breq	80015f8e <NtfSetNotificationMatrix+0x2e6>
80015d36:	66 08       	ld.w	r8,r3[0x0]
    }

    /*---------------------------------------------------------- */


    error_msg_ptr   = &tx_ptr->Data[2];                         /* init pointer to data field storing failed func ids    */
80015d38:	2f e8       	sub	r8,-2
80015d3a:	50 08       	stdsp	sp[0x0],r8
80015d3c:	30 18       	mov	r8,1
    num_func_failed = (byte)0;                                  /* number of failed func ids */


    switch (control)
80015d3e:	f0 06 18 00 	cp.b	r6,r8
80015d42:	c5 50       	breq	80015dec <NtfSetNotificationMatrix+0x144>
80015d44:	c2 d2       	brcc	80015d9e <NtfSetNotificationMatrix+0xf6>
80015d46:	40 27       	lddsp	r7,sp[0x8]
    {
        /*----------------------------------------- */
        case NTF_SET_ALL:
        /*----------------------------------------- */

            prop_tab_ptr = prop_tab_baseptr;                            /* set pointer at first Property Table entry */
80015d48:	e0 65 0f ff 	mov	r5,4095

            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);/* read FunctionID in Property Table */
                if (func_id_tab != (word)PROP_TERMINATION)
80015d4c:	8e 06       	ld.sh	r6,r7[0x0]

            prop_tab_ptr = prop_tab_baseptr;                            /* set pointer at first Property Table entry */

            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);/* read FunctionID in Property Table */
80015d4e:	ed d6 c0 0c 	bfextu	r6,r6,0x0,0xc
80015d52:	ea 06 19 00 	cp.h	r6,r5
                if (func_id_tab != (word)PROP_TERMINATION)
80015d56:	ce 30       	breq	80015d1c <NtfSetNotificationMatrix+0x74>
80015d58:	30 01       	mov	r1,0
80015d5a:	e0 64 0e ff 	mov	r4,3839
                {
                    if (func_id_tab < 0xF00)  /* ignore supplier specific functions */
80015d5e:	30 20       	mov	r0,2
                    {
                        device_index_tab_baseptr = prop_tab_ptr->PtrNtfMatrixCol;       /* read base pointer at device index table */
                        /*lint -e644 the variable is initialized! Otherwise the switch selects default case! */
                        if ( (byte)2 == NtfWriteDeviceIndex(device_index_tab_baseptr+1, num_dev, device_index) )
80015d60:	e8 06 19 00 	cp.h	r6,r4
            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);/* read FunctionID in Property Table */
                if (func_id_tab != (word)PROP_TERMINATION)
                {
                    if (func_id_tab < 0xF00)  /* ignore supplier specific functions */
80015d64:	e0 88 00 2d 	brls	80015dbe <NtfSetNotificationMatrix+0x116>
80015d68:	2f 07       	sub	r7,-16
                            NtfErrorAppendFuncID(&num_func_failed, &error_msg_ptr, func_id_tab);/* Error: Device Index Table of */
                                                                                                /* respective property overflow */
                        }
                    }

                    prop_tab_ptr++;                                     /* next property */
80015d6a:	8e 06       	ld.sh	r6,r7[0x0]

            prop_tab_ptr = prop_tab_baseptr;                            /* set pointer at first Property Table entry */

            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);/* read FunctionID in Property Table */
80015d6c:	ed d6 c0 0c 	bfextu	r6,r6,0x0,0xc
80015d70:	ea 06 19 00 	cp.h	r6,r5
                if (func_id_tab != (word)PROP_TERMINATION)
80015d74:	cf 61       	brne	80015d60 <NtfSetNotificationMatrix+0xb8>
80015d76:	58 01       	cp.w	r1,0
                }

            }while (func_id_tab != (word)PROP_TERMINATION);


            if (num_func_failed)                                            /* at least one entry failed */
80015d78:	cd 20       	breq	80015d1c <NtfSetNotificationMatrix+0x74>
80015d7a:	66 08       	ld.w	r8,r3[0x0]
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_55
byte NtfErrorComplFuncID(byte num, pTMsgTx tx_ptr)
{
    tx_ptr->Data[0] = ERR_FUNC_SPECIFIC;    /* Prepare Data[0]..Data[1] in the error msg  */
80015d7c:	32 09       	mov	r9,32
80015d7e:	b0 89       	st.b	r8[0x0],r9
80015d80:	31 09       	mov	r9,16
    tx_ptr->Data[1] = NTF_ERR_MATRIX;
80015d82:	66 08       	ld.w	r8,r3[0x0]
80015d84:	b0 99       	st.b	r8[0x1],r9
80015d86:	a1 71       	lsl	r1,0x1
    tx_ptr->Length  = (word)((num << 1) + 2);
80015d88:	30 fc       	mov	r12,15
80015d8a:	2f e1       	sub	r1,-2
80015d8c:	a6 21       	st.h	r3[0x4],r1
80015d8e:	cc 8b       	rjmp	80015d1e <NtfSetNotificationMatrix+0x76>


            if (num_func_failed)                                            /* at least one entry failed */
            {                                                               /* Error: Device Index Table of */
                                                                            /* respective property overflow */
                return ( NtfErrorComplFuncID(num_func_failed, tx_ptr) );    /* --> return(OP_ERROR) */
80015d90:	32 0a       	mov	r10,32

    fblock_error = NtfLoadFBlockDescriptionRx(rx_ptr,&num_dev,&prop_tab_baseptr);       /* load max. number of device_index entries */
                                                                                        /* and base pointer at property table */

    if (fblock_error)
        return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_FBLOCK_NOTAVAIL) );
80015d92:	06 9c       	mov	r12,r3
80015d94:	14 9b       	mov	r11,r10
80015d96:	fe b0 ee f5 	rcall	80013b80 <CmdErrorByte>
80015d9a:	2f bd       	sub	sp,-20

            return( CmdErrorParamWrong(tx_ptr, (byte)1, &rx_ptr->Data[0], (byte)1) );    /* Error: wrong parameter control */
    }                                                                        /*        --> return(OP_ERROR) */

    return(OP_NO_REPORT);                               /* no error occurred */
}
80015d9c:	d8 32       	popm	r0-r7,pc
80015d9e:	30 28       	mov	r8,2

    error_msg_ptr   = &tx_ptr->Data[2];                         /* init pointer to data field storing failed func ids    */
    num_func_failed = (byte)0;                                  /* number of failed func ids */


    switch (control)
80015da0:	f0 06 18 00 	cp.b	r6,r8
80015da4:	e0 80 00 c0 	breq	80015f24 <NtfSetNotificationMatrix+0x27c>
80015da8:	30 38       	mov	r8,3
80015daa:	f0 06 18 00 	cp.b	r6,r8
80015dae:	c7 d0       	breq	80015ea8 <NtfSetNotificationMatrix+0x200>
80015db0:	30 19       	mov	r9,1

        /*----------------------------------------- */
        default:
        /*----------------------------------------- */

            return( CmdErrorParamWrong(tx_ptr, (byte)1, &rx_ptr->Data[0], (byte)1) );    /* Error: wrong parameter control */
80015db2:	6e 0a       	ld.w	r10,r7[0x0]
80015db4:	06 9c       	mov	r12,r3
80015db6:	12 9b       	mov	r11,r9
80015db8:	fe b0 ee ec 	rcall	80013b90 <CmdErrorParamWrong>
80015dbc:	cb 1b       	rjmp	80015d1e <NtfSetNotificationMatrix+0x76>
80015dbe:	6e 1c       	ld.w	r12,r7[0x4]
                {
                    if (func_id_tab < 0xF00)  /* ignore supplier specific functions */
                    {
                        device_index_tab_baseptr = prop_tab_ptr->PtrNtfMatrixCol;       /* read base pointer at device index table */
                        /*lint -e644 the variable is initialized! Otherwise the switch selects default case! */
                        if ( (byte)2 == NtfWriteDeviceIndex(device_index_tab_baseptr+1, num_dev, device_index) )
80015dc0:	04 9a       	mov	r10,r2
80015dc2:	2f fc       	sub	r12,-1
80015dc4:	fb 3b 00 13 	ld.ub	r11,sp[19]
80015dc8:	ca ae       	rcall	80015b1c <NtfWriteDeviceIndex>
80015dca:	e0 0c 18 00 	cp.b	r12,r0
80015dce:	cc d1       	brne	80015d68 <NtfSetNotificationMatrix+0xc0>
80015dd0:	31 7a       	mov	r10,23
80015dd2:	f4 01 18 00 	cp.b	r1,r10
/*--------------------------------------------------------------------------*/
#ifdef NTF_54
void NtfErrorAppendFuncID(byte *ptr_num, byte **pptr_tgt, word func_id)
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
80015dd6:	fe 9b ff c9 	brhi	80015d68 <NtfSetNotificationMatrix+0xc0>
80015dda:	40 09       	lddsp	r9,sp[0x0]
80015ddc:	2f f1       	sub	r1,-1
        (*ptr_num)++;                               /* increment number of failed func ids                                           */

        #ifdef AMS_TX_ADD3
        MsgTxDataWord(pptr_tgt, &func_id);          /* Prepare parameter in the error msg */
        #else
        *((*pptr_tgt)++) = HB(func_id);
80015dde:	ec 08 16 08 	lsr	r8,r6,0x8
80015de2:	5c 51       	castu.b	r1
80015de4:	12 c8       	st.b	r9++,r8
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
    #endif
    {
        (*ptr_num)++;                               /* increment number of failed func ids                                           */
80015de6:	12 c6       	st.b	r9++,r6

        #ifdef AMS_TX_ADD3
        MsgTxDataWord(pptr_tgt, &func_id);          /* Prepare parameter in the error msg */
        #else
        *((*pptr_tgt)++) = HB(func_id);
80015de8:	50 09       	stdsp	sp[0x0],r9
        *((*pptr_tgt)++) = LB(func_id);
80015dea:	cb fb       	rjmp	80015d68 <NtfSetNotificationMatrix+0xc0>
80015dec:	5c 50       	castu.b	r0
80015dee:	30 38       	mov	r8,3

        /*----------------------------------------- */
        case NTF_SET_FUNC:
        /*----------------------------------------- */

            for ( i=(byte)3; i<(byte)rx_length; i+=(byte)2 )
80015df0:	f0 00 18 00 	cp.b	r0,r8
80015df4:	fe 98 ff 94 	brls	80015d1c <NtfSetNotificationMatrix+0x74>
80015df8:	30 06       	mov	r6,0
80015dfa:	50 13       	stdsp	sp[0x4],r3


            if (num_func_failed)                                            /* at least one entry failed */
            {                                                               /* Error: Device Index Table of */
                                                                            /* respective property overflow */
                return ( NtfErrorComplFuncID(num_func_failed, tx_ptr) );    /* --> return(OP_ERROR) */
80015dfc:	30 35       	mov	r5,3
/*--------------------------------------------------------------------------*/
#ifdef NTF_54
void NtfErrorAppendFuncID(byte *ptr_num, byte **pptr_tgt, word func_id)
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
80015dfe:	fa c1 ff f2 	sub	r1,sp,-14


            if (num_func_failed)                                            /* at least one entry failed */
            {                                                               /* Error: Device Index Table of */
                                                                            /* respective property overflow */
                return ( NtfErrorComplFuncID(num_func_failed, tx_ptr) );    /* --> return(OP_ERROR) */
80015e02:	e0 64 0f ff 	mov	r4,4095
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015e06:	0c 93       	mov	r3,r6
80015e08:	c1 58       	rjmp	80015e32 <NtfSetNotificationMatrix+0x18a>
/*--------------------------------------------------------------------------*/
#ifdef NTF_54
void NtfErrorAppendFuncID(byte *ptr_num, byte **pptr_tgt, word func_id)
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
80015e0a:	31 79       	mov	r9,23
80015e0c:	f2 03 18 00 	cp.b	r3,r9
80015e10:	e0 8b 00 0a 	brhi	80015e24 <NtfSetNotificationMatrix+0x17c>
80015e14:	40 09       	lddsp	r9,sp[0x0]
80015e16:	2f f3       	sub	r3,-1
        (*ptr_num)++;                               /* increment number of failed func ids                                           */

        #ifdef AMS_TX_ADD3
        MsgTxDataWord(pptr_tgt, &func_id);          /* Prepare parameter in the error msg */
        #else
        *((*pptr_tgt)++) = HB(func_id);
80015e18:	f1 da c1 08 	bfextu	r8,r10,0x8,0x8
80015e1c:	5c 53       	castu.b	r3
80015e1e:	12 c8       	st.b	r9++,r8
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
    #endif
    {
        (*ptr_num)++;                               /* increment number of failed func ids                                           */
80015e20:	12 ca       	st.b	r9++,r10

        #ifdef AMS_TX_ADD3
        MsgTxDataWord(pptr_tgt, &func_id);          /* Prepare parameter in the error msg */
        #else
        *((*pptr_tgt)++) = HB(func_id);
80015e22:	50 09       	stdsp	sp[0x0],r9
        *((*pptr_tgt)++) = LB(func_id);
80015e24:	2f e5       	sub	r5,-2
80015e26:	2f f6       	sub	r6,-1

        /*----------------------------------------- */
        case NTF_SET_FUNC:
        /*----------------------------------------- */

            for ( i=(byte)3; i<(byte)rx_length; i+=(byte)2 )
80015e28:	5c 55       	castu.b	r5
80015e2a:	e0 05 18 00 	cp.b	r5,r0
80015e2e:	e0 82 00 94 	brhs	80015f56 <NtfSetNotificationMatrix+0x2ae>
80015e32:	ec 08 15 01 	lsl	r8,r6,0x1
            {
                CmdDecodeWord(&func_id,&rx_ptr->Data[i]);                   /* Read Func ID of property to service */
80015e36:	2f d8       	sub	r8,-3
80015e38:	6e 0b       	ld.w	r11,r7[0x0]
80015e3a:	02 9c       	mov	r12,r1
80015e3c:	10 0b       	add	r11,r8
80015e3e:	fe b0 ee 62 	rcall	80013b02 <CmdDecodeWord>
80015e42:	9a 7a       	ld.sh	r10,sp[0xe]
80015e44:	40 28       	lddsp	r8,sp[0x8]
                prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id);  /* Get pointer at corresponding line of */
80015e46:	e0 69 0f fe 	mov	r9,4094
#ifdef NTF_52
pTNtfPropL NtfGetPropTabPtr(pTNtfPropL prop_tab_ptr, word func_id)
{
    word func_id_tab;

    if (func_id < 0x0FFF)
80015e4a:	f2 0a 19 00 	cp.h	r10,r9
80015e4e:	fe 9b ff de 	brhi	80015e0a <NtfSetNotificationMatrix+0x162>
80015e52:	90 09       	ld.sh	r9,r8[0x0]
80015e54:	f3 d9 c0 0c 	bfextu	r9,r9,0x0,0xc
        do
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
80015e58:	f2 0a 19 00 	cp.h	r10,r9
            if (func_id_tab == func_id)
80015e5c:	c0 b0       	breq	80015e72 <NtfSetNotificationMatrix+0x1ca>
80015e5e:	e8 09 19 00 	cp.h	r9,r4
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015e62:	cd 40       	breq	80015e0a <NtfSetNotificationMatrix+0x162>
80015e64:	2f 08       	sub	r8,-16
80015e66:	90 09       	ld.sh	r9,r8[0x0]
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;
80015e68:	f3 d9 c0 0c 	bfextu	r9,r9,0x0,0xc
    word func_id_tab;

    if (func_id < 0x0FFF)
        do
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
80015e6c:	f2 0a 19 00 	cp.h	r10,r9
            if (func_id_tab == func_id)
80015e70:	cf 71       	brne	80015e5e <NtfSetNotificationMatrix+0x1b6>
80015e72:	58 08       	cp.w	r8,0
80015e74:	cc b0       	breq	80015e0a <NtfSetNotificationMatrix+0x162>
            for ( i=(byte)3; i<(byte)rx_length; i+=(byte)2 )
            {
                CmdDecodeWord(&func_id,&rx_ptr->Data[i]);                   /* Read Func ID of property to service */
                prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id);  /* Get pointer at corresponding line of */
                                                                            /* the Property Table  */
                if (prop_tab_ptr != NULL)
80015e76:	70 1c       	ld.w	r12,r8[0x4]
80015e78:	04 9a       	mov	r10,r2
                {
                    device_index_tab_baseptr = prop_tab_ptr->PtrNtfMatrixCol;/* read base pointer at device index table */

                    if ( (byte)2 == NtfWriteDeviceIndex(device_index_tab_baseptr+1, num_dev, device_index) )
80015e7a:	2f fc       	sub	r12,-1
80015e7c:	fb 3b 00 13 	ld.ub	r11,sp[19]
80015e80:	c4 ee       	rcall	80015b1c <NtfWriteDeviceIndex>
80015e82:	30 28       	mov	r8,2
80015e84:	f0 0c 18 00 	cp.b	r12,r8
80015e88:	cc e1       	brne	80015e24 <NtfSetNotificationMatrix+0x17c>
80015e8a:	9a 78       	ld.sh	r8,sp[0xe]
80015e8c:	31 7a       	mov	r10,23
80015e8e:	f4 03 18 00 	cp.b	r3,r10
/*--------------------------------------------------------------------------*/
#ifdef NTF_54
void NtfErrorAppendFuncID(byte *ptr_num, byte **pptr_tgt, word func_id)
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
80015e92:	fe 9b ff c9 	brhi	80015e24 <NtfSetNotificationMatrix+0x17c>
80015e96:	40 0a       	lddsp	r10,sp[0x0]
80015e98:	2f f3       	sub	r3,-1
80015e9a:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
    #endif
    {
        (*ptr_num)++;                               /* increment number of failed func ids                                           */
80015e9e:	5c 53       	castu.b	r3

        #ifdef AMS_TX_ADD3
        MsgTxDataWord(pptr_tgt, &func_id);          /* Prepare parameter in the error msg */
        #else
        *((*pptr_tgt)++) = HB(func_id);
80015ea0:	14 c9       	st.b	r10++,r9
80015ea2:	14 c8       	st.b	r10++,r8
{
    #if (MAX_MSG_TX_DATA < 512)
    if ( *ptr_num < (byte)((MAX_MSG_TX_DATA-2)/2)  )        /* Do not overflow limit of AMS TX buffer  */
    #endif
    {
        (*ptr_num)++;                               /* increment number of failed func ids                                           */
80015ea4:	50 0a       	stdsp	sp[0x0],r10

        #ifdef AMS_TX_ADD3
        MsgTxDataWord(pptr_tgt, &func_id);          /* Prepare parameter in the error msg */
        #else
        *((*pptr_tgt)++) = HB(func_id);
80015ea6:	cb fb       	rjmp	80015e24 <NtfSetNotificationMatrix+0x17c>
        *((*pptr_tgt)++) = LB(func_id);
80015ea8:	e7 d0 c0 08 	bfextu	r3,r0,0x0,0x8
80015eac:	f0 03 18 00 	cp.b	r3,r8

        /*----------------------------------------- */
        case NTF_CLR_FUNC:
        /*----------------------------------------- */

            for ( i=(byte)3; i<(byte)rx_length; i+=(byte)2 )
80015eb0:	fe 98 ff 36 	brls	80015d1c <NtfSetNotificationMatrix+0x74>
80015eb4:	30 05       	mov	r5,0
80015eb6:	30 36       	mov	r6,3
80015eb8:	fa c1 ff f2 	sub	r1,sp,-14

            prop_tab_ptr = prop_tab_baseptr;
            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);       /* read FunctionID in Property Table */
                if (func_id_tab != (word)PROP_TERMINATION)
80015ebc:	e0 60 0f fe 	mov	r0,4094
80015ec0:	e0 64 0f ff 	mov	r4,4095
#ifdef NTF_52
pTNtfPropL NtfGetPropTabPtr(pTNtfPropL prop_tab_ptr, word func_id)
{
    word func_id_tab;

    if (func_id < 0x0FFF)
80015ec4:	c0 88       	rjmp	80015ed4 <NtfSetNotificationMatrix+0x22c>
            if (func_id_tab == func_id)
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015ec6:	2f e6       	sub	r6,-2
80015ec8:	2f f5       	sub	r5,-1
80015eca:	5c 56       	castu.b	r6

        /*----------------------------------------- */
        case NTF_CLR_FUNC:
        /*----------------------------------------- */

            for ( i=(byte)3; i<(byte)rx_length; i+=(byte)2 )
80015ecc:	e6 06 18 00 	cp.b	r6,r3
80015ed0:	fe 92 ff 26 	brhs	80015d1c <NtfSetNotificationMatrix+0x74>
80015ed4:	ea 08 15 01 	lsl	r8,r5,0x1
80015ed8:	2f d8       	sub	r8,-3
            {
                CmdDecodeWord(&func_id,&rx_ptr->Data[i]);                   /* Read Func ID of property to service */
80015eda:	6e 0b       	ld.w	r11,r7[0x0]
80015edc:	02 9c       	mov	r12,r1
80015ede:	10 0b       	add	r11,r8
80015ee0:	fe b0 ee 11 	rcall	80013b02 <CmdDecodeWord>
80015ee4:	9a 7a       	ld.sh	r10,sp[0xe]
80015ee6:	40 28       	lddsp	r8,sp[0x8]
80015ee8:	e0 0a 19 00 	cp.h	r10,r0
                prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id);  /* Get pointer at corresponding line of */
80015eec:	fe 9b ff ed 	brhi	80015ec6 <NtfSetNotificationMatrix+0x21e>
#ifdef NTF_52
pTNtfPropL NtfGetPropTabPtr(pTNtfPropL prop_tab_ptr, word func_id)
{
    word func_id_tab;

    if (func_id < 0x0FFF)
80015ef0:	90 09       	ld.sh	r9,r8[0x0]
80015ef2:	f3 d9 c0 0c 	bfextu	r9,r9,0x0,0xc
        do
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
80015ef6:	f2 0a 19 00 	cp.h	r10,r9
80015efa:	c0 b0       	breq	80015f10 <NtfSetNotificationMatrix+0x268>
            if (func_id_tab == func_id)
80015efc:	e8 09 19 00 	cp.h	r9,r4
80015f00:	ce 30       	breq	80015ec6 <NtfSetNotificationMatrix+0x21e>
                return(prop_tab_ptr);
            else
                prop_tab_ptr++;

        }while (func_id_tab != (word)PROP_TERMINATION);
80015f02:	2f 08       	sub	r8,-16
80015f04:	90 09       	ld.sh	r9,r8[0x0]
80015f06:	f3 d9 c0 0c 	bfextu	r9,r9,0x0,0xc
    word func_id_tab;

    if (func_id < 0x0FFF)
        do
        {
            func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);
80015f0a:	f2 0a 19 00 	cp.h	r10,r9
80015f0e:	cf 71       	brne	80015efc <NtfSetNotificationMatrix+0x254>
            if (func_id_tab == func_id)
80015f10:	58 08       	cp.w	r8,0
80015f12:	cd a0       	breq	80015ec6 <NtfSetNotificationMatrix+0x21e>
80015f14:	70 1c       	ld.w	r12,r8[0x4]
            {
                CmdDecodeWord(&func_id,&rx_ptr->Data[i]);                   /* Read Func ID of property to service */
                prop_tab_ptr = NtfGetPropTabPtr(prop_tab_baseptr, func_id);  /* Get pointer at corresponding line of */
                                                                            /* the Property Table  */

                if (prop_tab_ptr != NULL)                                    /* property registered in Notification Service ? */
80015f16:	04 9a       	mov	r10,r2
80015f18:	fb 3b 00 13 	ld.ub	r11,sp[19]
                {
                    device_index_tab_baseptr = prop_tab_ptr->PtrNtfMatrixCol;/* read base pointer at device index table */

                    (void)NtfClearDeviceIndex(device_index_tab_baseptr+1, num_dev, device_index);
80015f1c:	2f fc       	sub	r12,-1
80015f1e:	fe b0 fc 67 	rcall	800157ec <NtfClearDeviceIndex>
80015f22:	cd 2b       	rjmp	80015ec6 <NtfSetNotificationMatrix+0x21e>
80015f24:	40 27       	lddsp	r7,sp[0x8]
80015f26:	e0 66 0f ff 	mov	r6,4095

        /*----------------------------------------- */
        case NTF_CLR_ALL:
        /*----------------------------------------- */

            prop_tab_ptr = prop_tab_baseptr;
80015f2a:	8e 08       	ld.sh	r8,r7[0x0]
            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);       /* read FunctionID in Property Table */
80015f2c:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
80015f30:	ec 08 19 00 	cp.h	r8,r6
80015f34:	fe 90 fe f4 	breq	80015d1c <NtfSetNotificationMatrix+0x74>
80015f38:	6e 1c       	ld.w	r12,r7[0x4]
80015f3a:	04 9a       	mov	r10,r2
80015f3c:	2f 07       	sub	r7,-16
                if (func_id_tab != (word)PROP_TERMINATION)
                {
                    device_index_tab_baseptr = prop_tab_ptr->PtrNtfMatrixCol;   /* read base pointer at device index table */

                    (void)NtfClearDeviceIndex(device_index_tab_baseptr+1, num_dev, device_index);
80015f3e:	2f fc       	sub	r12,-1
80015f40:	fb 3b 00 13 	ld.ub	r11,sp[19]
80015f44:	fe b0 fc 54 	rcall	800157ec <NtfClearDeviceIndex>
80015f48:	8e 08       	ld.sh	r8,r7[0x0]
80015f4a:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc

            prop_tab_ptr = prop_tab_baseptr;
            do
            {
                func_id_tab = (word)(prop_tab_ptr->Type_FuncID & 0x0FFF);       /* read FunctionID in Property Table */
                if (func_id_tab != (word)PROP_TERMINATION)
80015f4e:	ec 08 19 00 	cp.h	r8,r6
80015f52:	cf 31       	brne	80015f38 <NtfSetNotificationMatrix+0x290>
80015f54:	ce 4a       	rjmp	80015d1c <NtfSetNotificationMatrix+0x74>
80015f56:	06 9a       	mov	r10,r3
80015f58:	40 13       	lddsp	r3,sp[0x4]
80015f5a:	58 0a       	cp.w	r10,0
80015f5c:	fe 90 fe e0 	breq	80015d1c <NtfSetNotificationMatrix+0x74>
                {
                        NtfErrorAppendFuncID(&num_func_failed, &error_msg_ptr, func_id);    /* Error: Property not registered */
                }                                                                           /* in Notification Service */
            }

            if (num_func_failed)                                            /* at least one entry failed */
80015f60:	66 08       	ld.w	r8,r3[0x0]
80015f62:	32 09       	mov	r9,32
80015f64:	b0 89       	st.b	r8[0x0],r9
/*                                                                          */
/*--------------------------------------------------------------------------*/
#ifdef NTF_55
byte NtfErrorComplFuncID(byte num, pTMsgTx tx_ptr)
{
    tx_ptr->Data[0] = ERR_FUNC_SPECIFIC;    /* Prepare Data[0]..Data[1] in the error msg  */
80015f66:	31 09       	mov	r9,16
80015f68:	66 08       	ld.w	r8,r3[0x0]
80015f6a:	b0 99       	st.b	r8[0x1],r9
    tx_ptr->Data[1] = NTF_ERR_MATRIX;
80015f6c:	30 fc       	mov	r12,15
80015f6e:	f4 08 15 01 	lsl	r8,r10,0x1
    tx_ptr->Length  = (word)((num << 1) + 2);
80015f72:	2f e8       	sub	r8,-2
80015f74:	a6 28       	st.h	r3[0x4],r8
80015f76:	cd 4a       	rjmp	80015d1e <NtfSetNotificationMatrix+0x76>
80015f78:	30 48       	mov	r8,4
80015f7a:	10 92       	mov	r2,r8
                }                                                                           /* in Notification Service */
            }

            if (num_func_failed)                                            /* at least one entry failed */
            {
                return ( NtfErrorComplFuncID(num_func_failed, tx_ptr) );    /* --> return(OP_ERROR) */
80015f7c:	48 e9       	lddpc	r9,80015fb4 <NtfSetNotificationMatrix+0x30c>
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015f7e:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
        device_index = NtfScanDeviceTab(device_id);
        if ((byte)0xFF == device_index)                      /* address not found ? */
        {
            return (OP_NO_REPORT);
        }
        else if ((word)0 == NtfDeviceTabCnt[device_index])        /* address found, but not used in any Notification Matrix */
80015f82:	30 08       	mov	r8,0
80015f84:	f0 09 19 00 	cp.h	r9,r8
80015f88:	fe 91 fe d7 	brne	80015d36 <NtfSetNotificationMatrix+0x8e>
80015f8c:	cc 8a       	rjmp	80015d1c <NtfSetNotificationMatrix+0x74>
80015f8e:	06 9c       	mov	r12,r3
80015f90:	32 1a       	mov	r10,33
80015f92:	32 0b       	mov	r11,32
    if (control <= NTF_SET_FUNC )                           /* set all or set func */
    {
        device_index = NtfWriteDeviceTab(device_id);        /* check if already existing and write new entry if necessary */

        if ((byte)0xFF == device_index)                           /* device table overflow ? */
            return( CmdErrorByte(tx_ptr, ERR_FUNC_SPECIFIC, NTF_ERR_DEVTABLE_OVERFLOW) ); /* Error: Device Table Overflow */
80015f94:	fe b0 ed f6 	rcall	80013b80 <CmdErrorByte>
80015f98:	cc 3a       	rjmp	80015d1e <NtfSetNotificationMatrix+0x76>
80015f9a:	04 98       	mov	r8,r2
80015f9c:	cf 0b       	rjmp	80015f7c <NtfSetNotificationMatrix+0x2d4>
80015f9e:	30 18       	mov	r8,1
{
    byte i;

    for (i=(byte)0;i<NTF_SIZE_DEVICE_TAB;i++)
    {
        if (NtfDeviceTab[i] == device_addr)
80015fa0:	10 92       	mov	r2,r8
80015fa2:	ce db       	rjmp	80015f7c <NtfSetNotificationMatrix+0x2d4>
80015fa4:	30 28       	mov	r8,2
80015fa6:	10 92       	mov	r2,r8
80015fa8:	ce ab       	rjmp	80015f7c <NtfSetNotificationMatrix+0x2d4>
80015faa:	30 38       	mov	r8,3
80015fac:	10 92       	mov	r2,r8
80015fae:	ce 7b       	rjmp	80015f7c <NtfSetNotificationMatrix+0x2d4>
80015fb0:	00 00       	add	r0,r0
80015fb2:	4a 7a       	lddpc	r10,8001604c <NtfService+0x94>
80015fb4:	00 00       	add	r0,r0
80015fb6:	4a 58       	lddpc	r8,80016048 <NtfService+0x90>

80015fb8 <NtfService>:
80015fb8:	eb cd 40 e0 	pushm	r5-r7,lr
80015fbc:	33 2c       	mov	r12,50
80015fbe:	fe b0 97 6f 	rcall	80008e9c <MsgGetTxPtrExt>
80015fc2:	18 97       	mov	r7,r12
80015fc4:	e0 80 00 bc 	breq	8001613c <NtfService+0x184>
80015fc8:	fe f8 02 1c 	ld.w	r8,pc[540]
80015fcc:	70 09       	ld.w	r9,r8[0x0]
80015fce:	30 2a       	mov	r10,2
80015fd0:	fe f6 02 18 	ld.w	r6,pc[536]
80015fd4:	0d 88       	ld.ub	r8,r6[0x0]
80015fd6:	f2 08 00 08 	add	r8,r9,r8
80015fda:	11 89       	ld.ub	r9,r8[0x0]

        device_index = (byte)(flags_device_index & MASK_DEV_INDEX);

        #ifndef NTF_ADD5
        #ifdef AMS_TX_ADD9
        tx_ptr->MidLevelRetries = DEF_MID_LEVEL_RETRIES_INT_PROC;       /* set number of mid level retries */
80015fdc:	f9 6a 00 0d 	st.b	r12[13],r10
        #endif
        #endif


        if ( device_index != (byte)NTF_DEV_INDEX_FREE)
80015fe0:	31 fb       	mov	r11,31

        device_index_ptr = NtfMatrixColPtr + (TNtfMatrix)NtfIndexNext;  /* prepare pointer at device index table */

        flags_device_index = *device_index_ptr;                         /* read flags and device index */

        device_index = (byte)(flags_device_index & MASK_DEV_INDEX);
80015fe2:	f5 d9 c0 05 	bfextu	r10,r9,0x0,0x5
        tx_ptr->MidLevelRetries = DEF_MID_LEVEL_RETRIES_INT_PROC;       /* set number of mid level retries */
        #endif
        #endif


        if ( device_index != (byte)NTF_DEV_INDEX_FREE)
80015fe6:	f6 0a 18 00 	cp.b	r10,r11
80015fea:	c6 70       	breq	800160b8 <NtfService+0x100>
        {                                                               /* Entry in Device Index Table available ? */

            #ifdef NTF_EXT
            if (NtfPropertyExt1Ptr && (flags_device_index & MASK_FLAG_EXT1))                /* Flag EXT1 set ?                       */
80015fec:	fe fe 02 00 	ld.w	lr,pc[512]
80015ff0:	7c 0b       	ld.w	r11,lr[0x0]
80015ff2:	58 0b       	cp.w	r11,0
80015ff4:	c7 d0       	breq	800160ee <NtfService+0x136>
80015ff6:	ed b9 00 05 	bld	r9,0x5
80015ffa:	c7 a1       	brne	800160ee <NtfService+0x136>
80015ffc:	30 3c       	mov	r12,3
80015ffe:	4f d9       	lddpc	r9,800161f0 <NtfService+0x238>
            #endif

                #ifdef NTF_DEBUG_1                                      /* if debug mode: */
                tx_ptr->Tgt_Adr = (word)0x0100;                         /* send all messages to same device */
                #else                                                   /* and put target address into data field */
                tx_ptr->Tgt_Adr = NtfDeviceTab[device_index];
80016000:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80016004:	ae 39       	st.h	r7[0x6],r9
80016006:	e2 19 ff 00 	andl	r9,0xff00,COH
                #endif

                #ifdef AMS_TX_ADD9
                if (0x0300 == (tx_ptr->Tgt_Adr & 0xFF00))               /* set number of mid level retries to 0 */
8001600a:	e0 49 03 00 	cp.w	r9,768
8001600e:	c0 41       	brne	80016016 <NtfService+0x5e>
80016010:	30 09       	mov	r9,0
                {                                                       /* in case of Group- or Broadcast message */
                    tx_ptr->MidLevelRetries = (byte)0;
80016012:	ef 69 00 0d 	st.b	r7[13],r9
80016016:	4f 89       	lddpc	r9,800161f4 <NtfService+0x23c>
                }
                #endif

                #if (NUM_FBLOCKS>0)
                tx_ptr->FBlock_ID   = NetBlock.pFBlockIDs.FBlockID[NtfFBlockIndex];
80016018:	4f 8b       	lddpc	r11,800161f8 <NtfService+0x240>
8001601a:	17 85       	ld.ub	r5,r11[0x0]
8001601c:	f2 05 07 05 	ld.ub	r5,r9[r5]
80016020:	ef 65 00 0a 	st.b	r7[10],r5
80016024:	17 8b       	ld.ub	r11,r11[0x0]
                tx_ptr->Inst_ID     = NetBlock.pFBlockIDs.InstID[NtfFBlockIndex];
80016026:	16 09       	add	r9,r11
80016028:	13 c9       	ld.ub	r9,r9[0x4]
8001602a:	ef 69 00 0b 	st.b	r7[11],r9
8001602e:	4f 49       	lddpc	r9,800161fc <NtfService+0x244>
                #endif

                tx_ptr->Func_ID     = NtfFuncID;
80016030:	92 09       	ld.sh	r9,r9[0x0]
80016032:	ae 49       	st.h	r7[0x8],r9
80016034:	30 29       	mov	r9,2

                switch (notify_required)
80016036:	f2 0c 18 00 	cp.b	r12,r9
8001603a:	c2 b0       	breq	80016090 <NtfService+0xd8>
8001603c:	30 39       	mov	r9,3
8001603e:	f2 0c 18 00 	cp.b	r12,r9
80016042:	c6 80       	breq	80016112 <NtfService+0x15a>
80016044:	11 89       	ld.ub	r9,r8[0x0]
                {
                    case 0x01:

                        new_flags_device_index = *device_index_ptr; /* read content of matrix field again, since flags could be modified by another process */
80016046:	30 0b       	mov	r11,0

                        if (new_flags_device_index & MASK_FLAG_SINGLE)
80016048:	f6 09 18 00 	cp.b	r9,r11
8001604c:	e0 85 00 93 	brlt	80016172 <NtfService+0x1ba>
80016050:	a7 c9       	cbr	r9,0x6
                                NtfDeviceTabCnt[device_index]--;                        /* decrement respective Device Table counter */
                            }
                        }
                        else
                        {
                            *device_index_ptr = (TNtfMatrix)(new_flags_device_index & ~MASK_FLAG_NTF);  /* clear flag NTF */
80016052:	b0 89       	st.b	r8[0x0],r9
80016054:	30 c8       	mov	r8,12
                        }

                        tx_ptr->Operation   = OP_STATUS;
80016056:	ef 68 00 0c 	st.b	r7[12],r8
8001605a:	4e a8       	lddpc	r8,80016200 <NtfService+0x248>

                        switch (NtfType & MASK_TYPE)
8001605c:	11 88       	ld.ub	r8,r8[0x0]
8001605e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80016062:	58 38       	cp.w	r8,3
80016064:	e0 80 00 b3 	breq	800161ca <NtfService+0x212>
80016068:	e0 89 00 72 	brgt	8001614c <NtfService+0x194>
8001606c:	58 18       	cp.w	r8,1
8001606e:	e0 80 00 95 	breq	80016198 <NtfService+0x1e0>
80016072:	58 28       	cp.w	r8,2
80016074:	c6 01       	brne	80016134 <NtfService+0x17c>
80016076:	30 08       	mov	r8,0
                                break;

                            case NTF_TYPE_BYTE:

                                #ifdef AMS_TX_ADD9
                                tx_ptr->MidLevelRetries = (byte)0;                  /* set number of mid level retries to 0 for messages completely generated by NTFS*/
80016078:	ef 68 00 0d 	st.b	r7[13],r8
8001607c:	4e 29       	lddpc	r9,80016204 <NtfService+0x24c>
                                #ifdef NTF_DEBUG_1
                                CmdEncodeWord(&tx_ptr->Data[0],&NtfDeviceTab[device_index]);
                                tx_ptr->Data[2] = *(byte*)NtfPropertyPtr;
                                tx_ptr->Length  = (word)3;
                                #else
                                tx_ptr->Data[0] = *(byte*)NtfPropertyPtr;
8001607e:	6e 08       	ld.w	r8,r7[0x0]
80016080:	72 09       	ld.w	r9,r9[0x0]
80016082:	13 89       	ld.ub	r9,r9[0x0]
80016084:	b0 89       	st.b	r8[0x0],r9
80016086:	30 18       	mov	r8,1
                                tx_ptr->Length  = (word)1;
80016088:	ef 3c 00 0c 	ld.ub	r12,r7[12]
8001608c:	ae 28       	st.h	r7[0x4],r8
8001608e:	c1 08       	rjmp	800160ae <NtfService+0xf6>
                                #endif
                                break;
80016090:	11 89       	ld.ub	r9,r8[0x0]

                    #ifdef NTF_EXT
                    case 0x02:

                        new_flags_device_index = *device_index_ptr; /* read content of matrix field again  */
                        *device_index_ptr = (TNtfMatrix)(new_flags_device_index & ~MASK_FLAG_NTF);        /* clear flag NTF */
80016092:	a7 c9       	cbr	r9,0x6
80016094:	b0 89       	st.b	r8[0x0],r9
80016096:	30 f8       	mov	r8,15

                        tx_ptr->Operation   = OP_ERROR;
80016098:	ef 68 00 0c 	st.b	r7[12],r8
8001609c:	30 08       	mov	r8,0

                        #ifdef AMS_TX_ADD9
                        tx_ptr->MidLevelRetries = (byte)0;                      /* set number of mid level retries to 0 for messages completely generated by NTFS*/
8001609e:	34 1b       	mov	r11,65
                        #ifdef NTF_DEBUG_1
                        CmdEncodeWord(&tx_ptr->Data[0],&NtfDeviceTab[device_index]);
                        tx_ptr->Data[2] = ERR_NOTAVAILABLE;
                        tx_ptr->Length  = (word)3;
                        #else
                        CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
800160a0:	ef 68 00 0d 	st.b	r7[13],r8
                        *device_index_ptr = (TNtfMatrix)(new_flags_device_index & ~MASK_FLAG_NTF);        /* clear flag NTF */

                        tx_ptr->Operation   = OP_ERROR;

                        #ifdef AMS_TX_ADD9
                        tx_ptr->MidLevelRetries = (byte)0;                      /* set number of mid level retries to 0 for messages completely generated by NTFS*/
800160a4:	0e 9c       	mov	r12,r7
                        #ifdef NTF_DEBUG_1
                        CmdEncodeWord(&tx_ptr->Data[0],&NtfDeviceTab[device_index]);
                        tx_ptr->Data[2] = ERR_NOTAVAILABLE;
                        tx_ptr->Length  = (word)3;
                        #else
                        CmdErrorMsg(tx_ptr, ERR_NOTAVAILABLE);
800160a6:	fe b0 ed 67 	rcall	80013b74 <CmdErrorMsg>
800160aa:	ef 3c 00 0c 	ld.ub	r12,r7[12]
800160ae:	30 88       	mov	r8,8
                        break;
                    #endif
                }


                if (tx_ptr->Operation >= OP_REPORTS)        /* valid notification ? */
800160b0:	f0 0c 18 00 	cp.b	r12,r8
800160b4:	e0 8b 00 40 	brhi	80016134 <NtfService+0x17c>
800160b8:	0e 9c       	mov	r12,r7
                    exit_loop = MNS_TRUE;
                    #endif
                }
                else
                {
                    MsgTxUnused(tx_ptr);
800160ba:	fe b0 97 3d 	rcall	80008f34 <MsgTxUnused>
800160be:	0d 88       	ld.ub	r8,r6[0x0]
        else
        {
        /* if no notify required then move on */
        #endif /*#ifndef NTF_ADD5*/

            NtfIndexNext++;
800160c0:	2f f8       	sub	r8,-1
800160c2:	ac 88       	st.b	r6[0x0],r8
800160c4:	4d 19       	lddpc	r9,80016208 <NtfService+0x250>
            if (NtfIndexNext > NtfNumDev)                 /* last entry of device index table ?  */
800160c6:	13 89       	ld.ub	r9,r9[0x0]
800160c8:	f0 09 18 00 	cp.b	r9,r8
800160cc:	c1 b3       	brcs	80016102 <NtfService+0x14a>
800160ce:	4d 08       	lddpc	r8,8001620c <NtfService+0x254>
            {
                NtfIncPropTabPtr();                         /*       next property, first device */
            }                                               /* else: same property, next device */

            #ifdef MNS2_OPT_1
            if (NtfLoopCounter)                             /* Decrement Loop Counter, since one element was serviced */
800160d0:	90 09       	ld.sh	r9,r8[0x0]
800160d2:	58 09       	cp.w	r9,0
800160d4:	c0 b0       	breq	800160ea <NtfService+0x132>
800160d6:	20 19       	sub	r9,1
            {
                NtfLoopCounter--;
800160d8:	5c 89       	casts.h	r9
800160da:	b0 09       	st.h	r8[0x0],r9
800160dc:	58 09       	cp.w	r9,0
        #endif

    } /* if (tx_ptr) */

    #ifdef MNS2_OPT_1
    if (NtfLoopCounter)
800160de:	c0 60       	breq	800160ea <NtfService+0x132>
800160e0:	31 0c       	mov	r12,16
    {
        MNS2_REQUEST_SET(MNS2_P_NTFS)                   /* Set Request Flag, if not all elements has been serviced */
800160e2:	fe b0 f5 b9 	rcall	80014c54 <MnsPending2Set>
800160e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800160ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800160ee:	4c 9b       	lddpc	r11,80016210 <NtfService+0x258>
            }
            else
            #endif

            #ifdef NTF_EXT
            if ( !(NtfPropFlags & MASK_FLAG_ERROR) )                                        /* Flag ERROR (inverted!) set ?          */
800160f0:	17 8b       	ld.ub	r11,r11[0x0]
800160f2:	ed bb 00 00 	bld	r11,0x0
800160f6:	c0 90       	breq	80016108 <NtfService+0x150>
800160f8:	ed b9 00 06 	bld	r9,0x6
            {
                if (flags_device_index & MASK_FLAG_NTF)                                     /* Flag NTF set ? */
800160fc:	cd e1       	brne	800160b8 <NtfService+0x100>
800160fe:	30 2c       	mov	r12,2
80016100:	c7 fb       	rjmp	80015ffe <NtfService+0x46>
80016102:	fe b0 fb 27 	rcall	80015750 <NtfIncPropTabPtr>
        #endif /*#ifndef NTF_ADD5*/

            NtfIndexNext++;
            if (NtfIndexNext > NtfNumDev)                 /* last entry of device index table ?  */
            {
                NtfIncPropTabPtr();                         /*       next property, first device */
80016106:	ce 4b       	rjmp	800160ce <NtfService+0x116>
80016108:	ed b9 00 06 	bld	r9,0x6
                    notify_required = (byte)0x02;
            }
            else
            #endif
            {
                if (flags_device_index & MASK_FLAG_NTF)             /* has NTF flag been set (announced event)  */
8001610c:	cd 61       	brne	800160b8 <NtfService+0x100>
8001610e:	30 1c       	mov	r12,1
    if (NtfLoopCounter)
    {
        MNS2_REQUEST_SET(MNS2_P_NTFS)                   /* Set Request Flag, if not all elements has been serviced */
    }
    #endif
}
80016110:	c7 7b       	rjmp	80015ffe <NtfService+0x46>
80016112:	11 89       	ld.ub	r9,r8[0x0]

                    #ifdef NTF_EXT
                    case 0x03:

                        new_flags_device_index = *device_index_ptr; /* read content of matrix field again, since flags could be modified by another process */
                        *device_index_ptr = (TNtfMatrix)(new_flags_device_index & ~MASK_FLAG_EXT1);
80016114:	a5 d9       	cbr	r9,0x5
80016116:	b0 89       	st.b	r8[0x0],r9
80016118:	4b a8       	lddpc	r8,80016200 <NtfService+0x248>

                        switch (NtfType & MASK_TYPE_EXT)
8001611a:	11 88       	ld.ub	r8,r8[0x0]
8001611c:	e2 18 00 08 	andl	r8,0x8,COH
80016120:	c1 11       	brne	80016142 <NtfService+0x18a>
80016122:	ef 68 00 0d 	st.b	r7[13],r8
                                #endif
                                break;

                            case NTF_TYPE_EXT_DATA:
                                #ifdef AMS_TX_ADD9
                                tx_ptr->MidLevelRetries = (byte)0;                      /* set number of mid level retries to 0 for messages completely generated by NTFS*/
80016126:	0e 9c       	mov	r12,r7
                                #endif

                                CmdEncodeStrRam(tx_ptr,(byte*)NtfPropertyExt1Ptr);
80016128:	7c 0b       	ld.w	r11,lr[0x0]
8001612a:	fe b0 ed 6d 	rcall	80013c04 <CmdEncodeStrRam>
8001612e:	30 e8       	mov	r8,14
                                tx_ptr->Operation   = NTF_EXT_OPTYPE;
80016130:	ef 68 00 0c 	st.b	r7[12],r8
80016134:	0e 9c       	mov	r12,r7
                }


                if (tx_ptr->Operation >= OP_REPORTS)        /* valid notification ? */
                {
                    AmsMsgSend(tx_ptr);
80016136:	fe b0 9c 1f 	rcall	80009974 <MsgSend>
8001613a:	cc 2b       	rjmp	800160be <NtfService+0x106>
8001613c:	4b 48       	lddpc	r8,8001620c <NtfService+0x254>
    /* loop until notification is found or complete table is looked through */
    while ((0 < NtfLoopCounter) && (MNS_FALSE == exit_loop))
    #else
    tx_ptr = MsgGetTxPtr();

    if (tx_ptr)                     /* tx message entry free ? */
8001613e:	90 09       	ld.sh	r9,r8[0x0]
80016140:	cc eb       	rjmp	800160dc <NtfService+0x124>
80016142:	58 88       	cp.w	r8,8
                    case 0x03:

                        new_flags_device_index = *device_index_ptr; /* read content of matrix field again, since flags could be modified by another process */
                        *device_index_ptr = (TNtfMatrix)(new_flags_device_index & ~MASK_FLAG_EXT1);

                        switch (NtfType & MASK_TYPE_EXT)
80016144:	c1 10       	breq	80016166 <NtfService+0x1ae>
80016146:	ef 3c 00 0c 	ld.ub	r12,r7[12]
8001614a:	cb 2b       	rjmp	800160ae <NtfService+0xf6>
8001614c:	58 58       	cp.w	r8,5
                            *device_index_ptr = (TNtfMatrix)(new_flags_device_index & ~MASK_FLAG_NTF);  /* clear flag NTF */
                        }

                        tx_ptr->Operation   = OP_STATUS;

                        switch (NtfType & MASK_TYPE)
8001614e:	c1 e0       	breq	8001618a <NtfService+0x1d2>
80016150:	c3 05       	brlt	800161b0 <NtfService+0x1f8>
80016152:	58 68       	cp.w	r8,6
80016154:	cf 01       	brne	80016134 <NtfService+0x17c>
80016156:	4a c8       	lddpc	r8,80016204 <NtfService+0x24c>
                            case NTF_TYPE_INDTXRX:                                 /* callback function with TX Ptr (<> NULL) and RX Ptr (=NULL) */

                                #ifdef PTR_UNION_VOID
                                tx_ptr->Operation = ( *(byte(*)(pTMsgTx, pTMsgRx)) NtfPropTabPtr->Prop.FPtr ) (tx_ptr, NULL);
                                #else
                                tx_ptr->Operation = ( *(byte(*)(pTMsgTx, pTMsgRx)) NtfPropertyPtr ) (tx_ptr, NULL);
80016158:	30 0b       	mov	r11,0
8001615a:	70 08       	ld.w	r8,r8[0x0]
8001615c:	0e 9c       	mov	r12,r7
8001615e:	5d 18       	icall	r8
80016160:	ef 6c 00 0c 	st.b	r7[12],r12
80016164:	ca 5b       	rjmp	800160ae <NtfService+0xf6>
80016166:	7c 08       	ld.w	r8,lr[0x0]
                        {
                            case NTF_TYPE_EXT_FUNC:
                                #ifdef PTR_UNION_VOID
                                tx_ptr->Operation = ( *(byte(*)(pTMsgTx )) NtfPropTabPtr->PropExt1.FPtr ) (tx_ptr);
                                #else
                                tx_ptr->Operation = ( *(byte(*)(pTMsgTx )) NtfPropertyExt1Ptr ) (tx_ptr);
80016168:	0e 9c       	mov	r12,r7
8001616a:	5d 18       	icall	r8
8001616c:	ef 6c 00 0c 	st.b	r7[12],r12
80016170:	c9 fb       	rjmp	800160ae <NtfService+0xf6>
                                #endif
                                break;
80016172:	31 f9       	mov	r9,31

                        new_flags_device_index = *device_index_ptr; /* read content of matrix field again, since flags could be modified by another process */

                        if (new_flags_device_index & MASK_FLAG_SINGLE)
                        {
                            *device_index_ptr = NTF_DEV_INDEX_FREE;                     /* clear entry in device index table */
80016174:	b0 89       	st.b	r8[0x0],r9
80016176:	4a 88       	lddpc	r8,80016214 <NtfService+0x25c>
                            if ((word)0 < NtfDeviceTabCnt[device_index])
80016178:	f0 0a 04 19 	ld.sh	r9,r8[r10<<0x1]
8001617c:	58 09       	cp.w	r9,0
8001617e:	fe 90 ff 6b 	breq	80016054 <NtfService+0x9c>
80016182:	20 19       	sub	r9,1
                            {
                                NtfDeviceTabCnt[device_index]--;                        /* decrement respective Device Table counter */
80016184:	f0 0a 0a 19 	st.h	r8[r10<<0x1],r9
80016188:	c6 6b       	rjmp	80016054 <NtfService+0x9c>
8001618a:	49 f8       	lddpc	r8,80016204 <NtfService+0x24c>
                            case NTF_TYPE_IND:                                      /* callback function with TX Ptr only */

                                #ifdef PTR_UNION_VOID
                                tx_ptr->Operation = ( *(byte(*)(pTMsgTx )) NtfPropTabPtr->Prop.FPtr ) (tx_ptr);
                                #else
                                tx_ptr->Operation = ( *(byte(*)(pTMsgTx )) NtfPropertyPtr ) (tx_ptr);
8001618c:	0e 9c       	mov	r12,r7
8001618e:	70 08       	ld.w	r8,r8[0x0]
80016190:	5d 18       	icall	r8
80016192:	ef 6c 00 0c 	st.b	r7[12],r12
80016196:	c8 cb       	rjmp	800160ae <NtfService+0xf6>
                                #endif
                                break;                                          /* function pointer is stored in NtfPropertyPtr */
80016198:	30 09       	mov	r9,0
                        switch (NtfType & MASK_TYPE)
                        {
                            case NTF_TYPE_BOOL:

                                #ifdef AMS_TX_ADD9
                                tx_ptr->MidLevelRetries = (byte)0;                  /* set number of mid level retries to 0 for messages completely generated by NTFS*/
8001619a:	ef 69 00 0d 	st.b	r7[13],r9
8001619e:	49 aa       	lddpc	r10,80016204 <NtfService+0x24c>
                                #ifdef NTF_DEBUG_1
                                CmdEncodeWord(&tx_ptr->Data[0],&NtfDeviceTab[device_index]);
                                tx_ptr->Data[2] = (byte)(*(bool*)NtfPropertyPtr);   /* prepare data field */
                                tx_ptr->Length = (word)3;                           /* prepare data length */
                                #else
                                tx_ptr->Data[0] = (byte)(*(bool*)NtfPropertyPtr);   /* prepare data field */
800161a0:	6e 09       	ld.w	r9,r7[0x0]
800161a2:	74 0a       	ld.w	r10,r10[0x0]
800161a4:	15 8a       	ld.ub	r10,r10[0x0]
800161a6:	b2 8a       	st.b	r9[0x0],r10
800161a8:	ae 28       	st.h	r7[0x4],r8
                                tx_ptr->Length = (word)1;                           /* prepare data length */
800161aa:	ef 3c 00 0c 	ld.ub	r12,r7[12]
800161ae:	c8 0b       	rjmp	800160ae <NtfService+0xf6>
                                #endif
                                break;
800161b0:	30 08       	mov	r8,0
                                break;

                            case NTF_TYPE_LONG:

                                #ifdef AMS_TX_ADD9
                                tx_ptr->MidLevelRetries = (byte)0;                      /* set number of mid level retries to 0 for messages completely generated by NTFS*/
800161b2:	ef 68 00 0d 	st.b	r7[13],r8
800161b6:	49 48       	lddpc	r8,80016204 <NtfService+0x24c>
                                #ifdef NTF_DEBUG_1
                                CmdEncodeWord(&tx_ptr->Data[0],&NtfDeviceTab[device_index]);
                                CmdEncodeLong(&tx_ptr->Data[2],(dword*)NtfPropertyPtr);
                                tx_ptr->Length = (word)6;
                                #else
                                CmdEncodeLong(&tx_ptr->Data[0],(dword*)NtfPropertyPtr);
800161b8:	6e 0c       	ld.w	r12,r7[0x0]
800161ba:	70 0b       	ld.w	r11,r8[0x0]
800161bc:	fe b0 ec ac 	rcall	80013b14 <CmdEncodeLong>
800161c0:	30 48       	mov	r8,4
                                tx_ptr->Length = (word)4;
800161c2:	ef 3c 00 0c 	ld.ub	r12,r7[12]
800161c6:	ae 28       	st.h	r7[0x4],r8
800161c8:	c7 3b       	rjmp	800160ae <NtfService+0xf6>
                                #endif
                                break;
800161ca:	30 08       	mov	r8,0
                                break;

                            case NTF_TYPE_WORD:

                                #ifdef AMS_TX_ADD9
                                tx_ptr->MidLevelRetries = (byte)0;                      /* set number of mid level retries to 0 for messages completely generated by NTFS*/
800161cc:	ef 68 00 0d 	st.b	r7[13],r8
800161d0:	48 d8       	lddpc	r8,80016204 <NtfService+0x24c>
                                #ifdef NTF_DEBUG_1
                                CmdEncodeWord(&tx_ptr->Data[0],&NtfDeviceTab[device_index]);
                                CmdEncodeWord(&tx_ptr->Data[2],(word*)NtfPropertyPtr);
                                tx_ptr->Length = (word)4;
                                #else
                                CmdEncodeWord(&tx_ptr->Data[0],(word*)NtfPropertyPtr);
800161d2:	6e 0c       	ld.w	r12,r7[0x0]
800161d4:	70 0b       	ld.w	r11,r8[0x0]
800161d6:	fe b0 ec 91 	rcall	80013af8 <CmdEncodeWord>
800161da:	30 28       	mov	r8,2
                                tx_ptr->Length = (word)2;
800161dc:	ef 3c 00 0c 	ld.ub	r12,r7[12]
800161e0:	ae 28       	st.h	r7[0x4],r8
800161e2:	c6 6b       	rjmp	800160ae <NtfService+0xf6>
                                #endif
                                break;
800161e4:	00 00       	add	r0,r0
800161e6:	4a 64       	lddpc	r4,8001627c <app_go_net_on>
800161e8:	00 00       	add	r0,r0
800161ea:	4a 79       	lddpc	r9,80016284 <app_go_net_on+0x8>
800161ec:	00 00       	add	r0,r0
800161ee:	4a 50       	lddpc	r0,80016280 <app_go_net_on+0x4>
800161f0:	00 00       	add	r0,r0
800161f2:	4a 7a       	lddpc	r10,8001628c <app_go_net_on+0x10>
800161f4:	00 00       	add	r0,r0
800161f6:	4a 41       	lddpc	r1,80016284 <app_go_net_on+0x8>
800161f8:	00 00       	add	r0,r0
800161fa:	4a 74       	lddpc	r4,80016294 <app_go_net_on+0x18>
800161fc:	00 00       	add	r0,r0
800161fe:	4a 62       	lddpc	r2,80016294 <app_go_net_on+0x18>
80016200:	00 00       	add	r0,r0
80016202:	4a 68       	lddpc	r8,80016298 <app_go_net_on+0x1c>
80016204:	00 00       	add	r0,r0
80016206:	4a 54       	lddpc	r4,80016298 <app_go_net_on+0x1c>
80016208:	00 00       	add	r0,r0
8001620a:	4a 78       	lddpc	r8,800162a4 <app_go_net_on+0x28>
8001620c:	00 00       	add	r0,r0
8001620e:	4a 72       	lddpc	r2,800162a8 <app_go_net_on+0x2c>
80016210:	00 00       	add	r0,r0
80016212:	4a 84       	lddpc	r4,800162b0 <app_go_net_on+0x34>
80016214:	00 00       	add	r0,r0
80016216:	4a 58       	lddpc	r8,800162a8 <app_go_net_on+0x2c>

80016218 <app_start_check_timer>:
*
*  RETURNS:        nothing
*
*/
void app_start_check_timer(uint16_t timeout)
{
80016218:	eb cd 40 c0 	pushm	r6-r7,lr
	uint16_t ticks_left;

	if (TIMER_IDLE == mostCheckTimer.flag)                  // see if timer is already running
8001621c:	48 f7       	lddpc	r7,80016258 <app_start_check_timer+0x40>
*
*  RETURNS:        nothing
*
*/
void app_start_check_timer(uint16_t timeout)
{
8001621e:	18 96       	mov	r6,r12
	uint16_t ticks_left;

	if (TIMER_IDLE == mostCheckTimer.flag)                  // see if timer is already running
80016220:	0f 99       	ld.ub	r9,r7[0x1]
80016222:	30 08       	mov	r8,0
80016224:	f0 09 18 00 	cp.b	r9,r8
80016228:	c1 00       	breq	80016248 <app_start_check_timer+0x30>
	{
		StartTimer(&mostCheckTimer, timeout, TIMER_ONE_SHOT);
	}
	else                                                    // timer is already running
	{
		ticks_left =  TmrTicksLeft(mostCheckTimer.handle);
8001622a:	0f 8c       	ld.ub	r12,r7[0x0]
8001622c:	fe b0 85 4c 	rcall	80006cc4 <TmrTicksLeft>
		if (timeout < ticks_left)                           // wants service sooner than previously asked for
80016230:	f8 06 19 00 	cp.h	r6,r12
80016234:	c0 33       	brcs	8001623a <app_start_check_timer+0x22>
80016236:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		{
			TmrNewTime(mostCheckTimer.handle, timeout);     // reset timer
8001623a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8001623e:	0f 8c       	ld.ub	r12,r7[0x0]
80016240:	fe b0 85 2e 	rcall	80006c9c <TmrNewTime>
80016244:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
{
	uint16_t ticks_left;

	if (TIMER_IDLE == mostCheckTimer.flag)                  // see if timer is already running
	{
		StartTimer(&mostCheckTimer, timeout, TIMER_ONE_SHOT);
80016248:	f7 dc c0 10 	bfextu	r11,r12,0x0,0x10
8001624c:	30 1a       	mov	r10,1
8001624e:	0e 9c       	mov	r12,r7
80016250:	fe b0 85 e2 	rcall	80006e14 <StartTimer>
80016254:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80016258:	00 00       	add	r0,r0
8001625a:	4d 6f       	lddpc	pc,800163b0 <T.76+0x58>

8001625c <app_go_net_off>:
8001625c:	d4 01       	pushm	lr
8001625e:	48 6c       	lddpc	r12,80016274 <app_go_net_off+0x18>
80016260:	e0 a0 0c d8 	rcall	80017c10 <puts>
80016264:	30 09       	mov	r9,0
80016266:	48 58       	lddpc	r8,80016278 <app_go_net_off+0x1c>
*
*/
void app_go_net_off(void)
{
	LOG_NOR("Got Net Off event, killing network connections \n");
	MyNode.Net_State = NISTATE_NET_OFF;                     // global flag that other routines check
80016268:	b0 99       	st.b	r8[0x1],r9
	kill_net_connections();                                 // reset all network side connections to "not connected" state
8001626a:	fe b0 71 11 	rcall	8000448c <kill_net_connections>
	ET_Go_Net_Off();                                        // Trigger ET's net off in case tester is running
8001626e:	fe b0 f2 6d 	rcall	80014748 <ET_Go_Net_Off>
	//    PwrStartPowerDownTimer();                                 // if we stay unlocked for 10 sec, power down
}
80016272:	d8 02       	popm	pc
80016274:	80 07       	ld.sh	r7,r0[0x0]
80016276:	08 84       	andn	r4,r4
80016278:	00 00       	add	r0,r0
8001627a:	40 06       	lddsp	r6,sp[0x0]

8001627c <app_go_net_on>:
8001627c:	eb cd 40 80 	pushm	r7,lr
80016280:	49 2c       	lddpc	r12,800162c8 <app_go_net_on+0x4c>
80016282:	e0 a0 0c c7 	rcall	80017c10 <puts>
80016286:	30 39       	mov	r9,3
void app_go_net_on(void)
{
	uint8_t NodePos;

	LOG_NOR("Network has reached state NetOn! \n");
	MyNode.Net_State = NISTATE_NET_ON;
80016288:	49 18       	lddpc	r8,800162cc <app_go_net_on+0x50>
	MostGetVersionInfo(&version_info);
8001628a:	49 27       	lddpc	r7,800162d0 <app_go_net_on+0x54>
void app_go_net_on(void)
{
	uint8_t NodePos;

	LOG_NOR("Network has reached state NetOn! \n");
	MyNode.Net_State = NISTATE_NET_ON;
8001628c:	b0 99       	st.b	r8[0x1],r9
	MostGetVersionInfo(&version_info);
8001628e:	0e 9c       	mov	r12,r7
80016290:	fe b0 a7 54 	rcall	8000b138 <MostGetVersionInfo>
	LOG_NOR("Hardware Version is %02X\n", version_info.hw);
80016294:	0f 88       	ld.ub	r8,r7[0x0]
80016296:	49 0c       	lddpc	r12,800162d4 <app_go_net_on+0x58>
80016298:	1a d8       	st.w	--sp,r8
8001629a:	e0 a0 0c 25 	rcall	80017ae4 <printf>
	LOG_NOR("Product Version is %d.%d.%d\n", version_info.fw[0], version_info.fw[1], version_info.fw[2]);
8001629e:	0f b9       	ld.ub	r9,r7[0x3]
800162a0:	0f 98       	ld.ub	r8,r7[0x1]
800162a2:	1a d9       	st.w	--sp,r9
800162a4:	0f a9       	ld.ub	r9,r7[0x2]
800162a6:	48 dc       	lddpc	r12,800162d8 <app_go_net_on+0x5c>
800162a8:	1a d9       	st.w	--sp,r9
800162aa:	1a d8       	st.w	--sp,r8
800162ac:	e0 a0 0c 1c 	rcall	80017ae4 <printf>
	
//	PwrStopPowerDownTimer();                                      // we're locked, stay powered up
	// Now set our InstID's to Node Position
	NodePos = MostGetNodePos();                                 // get our current node position
800162b0:	fe b0 db 26 	rcall	800118fc <MostGetNodePos>
	NetBlock.pFBlockIDs.InstID[AMP_INDEX]   = NodePos;
800162b4:	48 a8       	lddpc	r8,800162dc <app_go_net_on+0x60>
	NetBlock.pFBlockIDs.InstID[AUXIN_INDEX] = NodePos;
	masterStartFlag = 0;
800162b6:	30 09       	mov	r9,0
	
//	PwrStopPowerDownTimer();                                      // we're locked, stay powered up
	// Now set our InstID's to Node Position
	NodePos = MostGetNodePos();                                 // get our current node position
	NetBlock.pFBlockIDs.InstID[AMP_INDEX]   = NodePos;
	NetBlock.pFBlockIDs.InstID[AUXIN_INDEX] = NodePos;
800162b8:	b0 dc       	st.b	r8[0x5],r12
	LOG_NOR("Product Version is %d.%d.%d\n", version_info.fw[0], version_info.fw[1], version_info.fw[2]);
	
//	PwrStopPowerDownTimer();                                      // we're locked, stay powered up
	// Now set our InstID's to Node Position
	NodePos = MostGetNodePos();                                 // get our current node position
	NetBlock.pFBlockIDs.InstID[AMP_INDEX]   = NodePos;
800162ba:	b0 cc       	st.b	r8[0x4],r12
	NetBlock.pFBlockIDs.InstID[AUXIN_INDEX] = NodePos;
	masterStartFlag = 0;
800162bc:	2f cd       	sub	sp,-16
800162be:	48 98       	lddpc	r8,800162e0 <app_go_net_on+0x64>
800162c0:	b0 89       	st.b	r8[0x0],r9
	GREEN_LED_ON();
}
800162c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800162c6:	d7 03       	nop
800162c8:	80 07       	ld.sh	r7,r0[0x0]
800162ca:	08 b4       	st.h	r4++,r4
800162cc:	00 00       	add	r0,r0
800162ce:	40 06       	lddsp	r6,sp[0x0]
800162d0:	00 00       	add	r0,r0
800162d2:	4d 58       	lddpc	r8,80016424 <main+0x44>
800162d4:	80 07       	ld.sh	r7,r0[0x0]
800162d6:	08 d8       	st.w	--r4,r8
800162d8:	80 07       	ld.sh	r7,r0[0x0]
800162da:	08 f4       	st.b	--r4,r4
800162dc:	00 00       	add	r0,r0
800162de:	4a 41       	lddpc	r1,8001636c <T.76+0x14>
800162e0:	00 00       	add	r0,r0
800162e2:	3b 48       	mov	r8,-76

800162e4 <app_on_init_complete>:
800162e4:	d4 01       	pushm	lr
800162e6:	fe b0 84 ab 	rcall	80006c3c <TmrGetMasterTick_Long>
800162ea:	1a dc       	st.w	--sp,r12
800162ec:	48 7c       	lddpc	r12,80016308 <app_on_init_complete+0x24>
800162ee:	e0 a0 0b fb 	rcall	80017ae4 <printf>
800162f2:	30 3c       	mov	r12,3
*
*/
void app_on_init_complete(void)
{
	LOG_NOR("%u Most NetServices initialization complete \n", TmrGetMasterTick_Long());              // See how long NS took to start up
	MostSelectClockOutput(RMCK_256);                        // start clock for codec - needed before talking to codec
800162f4:	fe b0 dd 6c 	rcall	80011dcc <MostSelectClockOutput>
	InitPorts();                                            // sets up Streaming port - network not needed
800162f8:	fe b0 71 40 	rcall	80004578 <InitPorts>
	//masterStartFlag = 1;
	initFlag = 1;
800162fc:	30 19       	mov	r9,1
800162fe:	48 48       	lddpc	r8,8001630c <app_on_init_complete+0x28>
80016300:	2f fd       	sub	sp,-4
80016302:	b0 89       	st.b	r8[0x0],r9
}
80016304:	d8 02       	popm	pc
80016306:	d7 03       	nop
80016308:	80 07       	ld.sh	r7,r0[0x0]
8001630a:	09 14       	ld.sh	r4,r4++
8001630c:	00 00       	add	r0,r0
8001630e:	3b 50       	mov	r0,-75

80016310 <sysclk_enable_pba_module>:
80016310:	d4 01       	pushm	lr
80016312:	18 9b       	mov	r11,r12
80016314:	30 2c       	mov	r12,2
80016316:	fe b0 94 15 	rcall	80008b40 <sysclk_priv_enable_module>
8001631a:	d8 02       	popm	pc

8001631c <usart_serial_getchar>:
8001631c:	eb cd 40 80 	pushm	r7,lr
 * \param usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
{
80016320:	16 97       	mov	r7,r11
	*data = usart_getchar(usart);
80016322:	fe b0 93 45 	rcall	800089ac <usart_getchar>
80016326:	ae 8c       	st.b	r7[0x0],r12
}
80016328:	e3 cd 80 80 	ldm	sp++,r7,pc

8001632c <usart_serial_putchar>:
8001632c:	eb cd 40 c0 	pushm	r6-r7,lr
 *              ready to send.
 */
static inline int usart_serial_putchar(usart_if usart, uint8_t c)
{
	/* Mod by netbugger for printf */
	if(c == '\n') {
80016330:	30 a8       	mov	r8,10
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 *              ready to send.
 */
static inline int usart_serial_putchar(usart_if usart, uint8_t c)
{
80016332:	18 97       	mov	r7,r12
80016334:	16 96       	mov	r6,r11
	/* Mod by netbugger for printf */
	if(c == '\n') {
80016336:	f0 0b 18 00 	cp.b	r11,r8
8001633a:	c0 80       	breq	8001634a <usart_serial_putchar+0x1e>
		while (usart_write_char(usart, '\r')!=USART_SUCCESS);
	}
	while (usart_write_char(usart, c)!=USART_SUCCESS);
8001633c:	0c 9b       	mov	r11,r6
8001633e:	0e 9c       	mov	r12,r7
80016340:	fe b0 93 2c 	rcall	80008998 <usart_write_char>
80016344:	cf c1       	brne	8001633c <usart_serial_putchar+0x10>
	return 1;
}
80016346:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
 */
static inline int usart_serial_putchar(usart_if usart, uint8_t c)
{
	/* Mod by netbugger for printf */
	if(c == '\n') {
		while (usart_write_char(usart, '\r')!=USART_SUCCESS);
8001634a:	30 db       	mov	r11,13
8001634c:	0e 9c       	mov	r12,r7
8001634e:	fe b0 93 25 	rcall	80008998 <usart_write_char>
80016352:	cf c1       	brne	8001634a <usart_serial_putchar+0x1e>
80016354:	cf 4b       	rjmp	8001633c <usart_serial_putchar+0x10>
80016356:	d7 03       	nop

80016358 <T.76>:
80016358:	d4 01       	pushm	lr
8001635a:	49 d8       	lddpc	r8,800163cc <T.76+0x74>

/*! \brief Global State Machine:
 *        - Function Idle
 *        - Function Zoom
 */
static bool state_machine_global(int source_id, enum state_function *state)
8001635c:	18 99       	mov	r9,r12
{
	switch (*state) {
8001635e:	70 08       	ld.w	r8,r8[0x0]
80016360:	58 08       	cp.w	r8,0
80016362:	c1 11       	brne	80016384 <T.76+0x2c>
		case STATE_FCT_IDLE:
			
			if (version_flag == 2)	{	//after update
80016364:	49 ba       	lddpc	r10,800163d0 <T.76+0x78>
80016366:	15 8b       	ld.ub	r11,r10[0x0]
80016368:	30 2a       	mov	r10,2
8001636a:	f4 0b 18 00 	cp.b	r11,r10
8001636e:	c2 20       	breq	800163b2 <T.76+0x5a>
					}
				}
			}
			else
			{
				if (source_id == GUI_OUTPUT2_ID) {
80016370:	58 29       	cp.w	r9,2
80016372:	c0 30       	breq	80016378 <T.76+0x20>
					if (new_state_fct) {
						gui_set_selection(GUI_OUTPUT2_ID);
					}
				}
				else if (source_id == GUI_OUTPUT3_ID) {
80016374:	58 39       	cp.w	r9,3
80016376:	c0 61       	brne	80016382 <T.76+0x2a>
					if (new_state_fct) {
80016378:	49 79       	lddpc	r9,800163d4 <T.76+0x7c>
8001637a:	13 89       	ld.ub	r9,r9[0x0]
8001637c:	f0 09 18 00 	cp.b	r9,r8
80016380:	c2 01       	brne	800163c0 <T.76+0x68>
					zoom_view_id = GUI_OUTPUT3_ID;
			}
			break;
	}
	return true;
}
80016382:	da 0a       	popm	pc,r12=1
 *        - Function Idle
 *        - Function Zoom
 */
static bool state_machine_global(int source_id, enum state_function *state)
{
	switch (*state) {
80016384:	58 58       	cp.w	r8,5
80016386:	cf e1       	brne	80016382 <T.76+0x2a>
		// Not Implemented
		case STATE_FCT_FUNCTION4:
			break;
		// Zoom
		case STATE_FCT_ZOOM:
			if (new_state_fct) {
80016388:	49 38       	lddpc	r8,800163d4 <T.76+0x7c>
8001638a:	11 8a       	ld.ub	r10,r8[0x0]
8001638c:	30 08       	mov	r8,0
8001638e:	f0 0a 18 00 	cp.b	r10,r8
80016392:	cf 80       	breq	80016382 <T.76+0x2a>
				zoom_view = true;
80016394:	30 1a       	mov	r10,1
80016396:	49 18       	lddpc	r8,800163d8 <T.76+0x80>
80016398:	b0 8a       	st.b	r8[0x0],r10
//				printf("2");
				if (source_id == GUI_SOURCE1_ID)
8001639a:	58 0c       	cp.w	r12,0
8001639c:	c0 70       	breq	800163aa <T.76+0x52>
					zoom_view_id = GUI_SOURCE1_ID;
				else if (source_id == GUI_OUTPUT1_ID)
8001639e:	58 1c       	cp.w	r12,1
800163a0:	c0 50       	breq	800163aa <T.76+0x52>
					zoom_view_id = GUI_OUTPUT1_ID;
				else if (source_id == GUI_OUTPUT2_ID)
800163a2:	58 2c       	cp.w	r12,2
800163a4:	c0 30       	breq	800163aa <T.76+0x52>
					zoom_view_id = GUI_OUTPUT2_ID;
				else if (source_id == GUI_OUTPUT3_ID)
800163a6:	58 3c       	cp.w	r12,3
800163a8:	ce d1       	brne	80016382 <T.76+0x2a>
					zoom_view_id = GUI_OUTPUT3_ID;
800163aa:	48 d8       	lddpc	r8,800163dc <T.76+0x84>
			}
			break;
	}
	return true;
}
800163ac:	30 1c       	mov	r12,1
				else if (source_id == GUI_OUTPUT1_ID)
					zoom_view_id = GUI_OUTPUT1_ID;
				else if (source_id == GUI_OUTPUT2_ID)
					zoom_view_id = GUI_OUTPUT2_ID;
				else if (source_id == GUI_OUTPUT3_ID)
					zoom_view_id = GUI_OUTPUT3_ID;
800163ae:	91 09       	st.w	r8[0x0],r9
			}
			break;
	}
	return true;
}
800163b0:	d8 02       	popm	pc
{
	switch (*state) {
		case STATE_FCT_IDLE:
			
			if (version_flag == 2)	{	//after update
				if (source_id == GUI_SOURCE1_ID) {
800163b2:	58 0c       	cp.w	r12,0
800163b4:	c0 91       	brne	800163c6 <T.76+0x6e>
					if (new_state_fct) {
800163b6:	48 88       	lddpc	r8,800163d4 <T.76+0x7c>
800163b8:	11 88       	ld.ub	r8,r8[0x0]
800163ba:	f8 08 18 00 	cp.b	r8,r12
800163be:	ce 20       	breq	80016382 <T.76+0x2a>
						gui_set_selection(GUI_OUTPUT2_ID);
					}
				}
				else if (source_id == GUI_OUTPUT3_ID) {
					if (new_state_fct) {
						gui_set_selection(GUI_OUTPUT3_ID);
800163c0:	fe b0 7e 96 	rcall	800060ec <gui_set_selection>
800163c4:	cd fb       	rjmp	80016382 <T.76+0x2a>
				if (source_id == GUI_SOURCE1_ID) {
					if (new_state_fct) {
						gui_set_selection(GUI_SOURCE1_ID);
					}
				}
				else if (source_id == GUI_OUTPUT1_ID) {
800163c6:	58 1c       	cp.w	r12,1
800163c8:	cd 41       	brne	80016370 <T.76+0x18>
800163ca:	cd 7b       	rjmp	80016378 <T.76+0x20>
800163cc:	00 00       	add	r0,r0
800163ce:	3b 4c       	mov	r12,-76
800163d0:	00 00       	add	r0,r0
800163d2:	3c 90       	mov	r0,-55
800163d4:	00 00       	add	r0,r0
800163d6:	3b 51       	mov	r1,-75
800163d8:	00 00       	add	r0,r0
800163da:	3b 40       	mov	r0,-76
800163dc:	00 00       	add	r0,r0
800163de:	4a 8c       	lddpc	r12,8001647c <main+0x9c>

800163e0 <main>:
800163e0:	d4 31       	pushm	r0-r7,lr
800163e2:	20 1d       	sub	sp,4
TIMER_T mostCheckTimer;

int main (void)
{
	/* Clock Init */	
	sysclk_init();
800163e4:	fe b0 93 ca 	rcall	80008b78 <sysclk_init>
	
	/* Delay Init */
	delay_init(FOSC0);
	
	/* Debug UART Init */
	gpio_enable_module(USART_GPIO_MAP, sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));
800163e8:	30 2b       	mov	r11,2
800163ea:	fe fc 03 42 	ld.w	r12,pc[834]
800163ee:	fe b0 91 39 	rcall	80008660 <gpio_enable_module>
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
800163f2:	fe f8 03 3e 	ld.w	r8,pc[830]
800163f6:	fe 77 28 00 	mov	r7,-55296
800163fa:	91 07       	st.w	r8[0x0],r7
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
800163fc:	fe f8 03 38 	ld.w	r8,pc[824]
80016400:	fe c9 00 d4 	sub	r9,pc,212
80016404:	91 09       	st.w	r8[0x0],r9
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
80016406:	fe f8 03 32 	ld.w	r8,pc[818]
8001640a:	fe c9 00 ee 	sub	r9,pc,238
8001640e:	91 09       	st.w	r8[0x0],r9
 */
static inline bool usart_serial_init(volatile avr32_usart_t *usart,
		usart_serial_options_t *opt)
{
	// USART options.
	opt->channelmode = CONFIG_USART_SERIAL_MODE;
80016410:	30 08       	mov	r8,0
80016412:	fe f6 03 2a 	ld.w	r6,pc[810]
	case AVR32_GPIO_ADDRESS:
		sysclk_enable_pba_module(SYSCLK_GPIO);
		break;

	case AVR32_USART0_ADDRESS:
		sysclk_enable_pba_module(SYSCLK_USART0);
80016416:	30 8c       	mov	r12,8
80016418:	ed 68 00 08 	st.b	r6[8],r8
8001641c:	c7 af       	rcall	80016310 <sysclk_enable_pba_module>
8001641e:	e0 6a 24 00 	mov	r10,9216

	sysclk_enable_peripheral_clock(usart);

	if (usart_init_rs232(usart, opt, sysclk_get_peripheral_bus_hz(usart))) {
80016422:	ea 1a 00 f4 	orh	r10,0xf4
80016426:	0c 9b       	mov	r11,r6
80016428:	0e 9c       	mov	r12,r7
8001642a:	fe b0 92 e5 	rcall	800089f4 <usart_init_rs232>
8001642e:	fe f7 03 12 	ld.w	r7,pc[786]
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
80016432:	6e 08       	ld.w	r8,r7[0x0]
80016434:	30 0b       	mov	r11,0
80016436:	70 1c       	ld.w	r12,r8[0x4]
80016438:	e0 a0 0c 8e 	rcall	80017d54 <setbuf>
8001643c:	6e 08       	ld.w	r8,r7[0x0]
	setbuf(stdin, NULL);
8001643e:	30 0b       	mov	r11,0
80016440:	70 0c       	ld.w	r12,r8[0x0]
80016442:	e0 a0 0c 89 	rcall	80017d54 <setbuf>
80016446:	fe b0 6b 4d 	rcall	80003ae0 <init_board_gpio>
	stdio_serial_init(&AVR32_USART0, &USART_OPTIONS);
	
	
	//GPIO Init
	init_board_gpio();
8001644a:	fe fc 02 fa 	ld.w	r12,pc[762]
	
	// Insert application code here, after the board has been initialized.
	printf("AMG Player Started\n");
8001644e:	e0 a0 0b e1 	rcall	80017c10 <puts>
80016452:	e0 69 24 00 	mov	r9,9216
	
	// GUI, Controller and DSP process init
	gui_init(FCPU_HZ, FHSB_HZ, FPBB_HZ, FPBA_HZ);
80016456:	ea 19 00 f4 	orh	r9,0xf4
8001645a:	12 9a       	mov	r10,r9
8001645c:	12 9b       	mov	r11,r9
8001645e:	12 9c       	mov	r12,r9
80016460:	fe b0 81 f8 	rcall	80006850 <gui_init>
80016464:	fe fc 02 e4 	ld.w	r12,pc[740]
	printf ("GUI INIT\n");
80016468:	e0 a0 0b d4 	rcall	80017c10 <puts>
8001646c:	33 09       	mov	r9,48
		
	MyNode.NetworkFreq = 48;
8001646e:	fe f8 02 de 	ld.w	r8,pc[734]
80016472:	f1 69 00 11 	st.b	r8[17],r9
80016476:	fe b0 6b 77 	rcall	80003b64 <inic_HoldReset>
	
	/* INIC INIT */
	inic_HoldReset();
8001647a:	e1 b9 00 42 	mfsr	r9,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001647e:	e2 68 71 00 	mov	r8,160000
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80016482:	f2 08 00 0a 	add	r10,r9,r8
80016486:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001648a:	14 39       	cp.w	r9,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001648c:	e0 88 01 4b 	brls	80016722 <main+0x342>
80016490:	10 39       	cp.w	r9,r8
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80016492:	fe 98 ff fa 	brls	80016486 <main+0xa6>
80016496:	10 3a       	cp.w	r10,r8
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80016498:	cf 72       	brcc	80016486 <main+0xa6>
8001649a:	fe b0 6b 53 	rcall	80003b40 <inic_ReleaseReset>
	delay_ms(10);
	inic_ReleaseReset();
8001649e:	d3 03       	ssrf	0x10

	/* Interrupt related Functions  Init*/
	Disable_global_interrupt();
800164a0:	fe b0 91 b2 	rcall	80008804 <INTC_init_interrupts>
	INTC_init_interrupts();
800164a4:	fe b0 82 d0 	rcall	80006a44 <i2c_master_init>
	
	/* i2c Init */
	i2c_master_init();
800164a8:	fe b0 85 00 	rcall	80006ea8 <TmrInit>

	// Timer Init
	TmrInit();
800164ac:	fe fc 02 a4 	ld.w	r12,pc[676]
	printf("Timer Init\n");
800164b0:	e0 a0 0b b0 	rcall	80017c10 <puts>
800164b4:	e0 69 24 00 	mov	r9,9216

		
	//Controller Init
	controller_init(FCPU_HZ, FHSB_HZ, FPBA_HZ, FPBB_HZ);
800164b8:	ea 19 00 f4 	orh	r9,0xf4
800164bc:	12 9c       	mov	r12,r9
800164be:	12 9a       	mov	r10,r9
800164c0:	12 9b       	mov	r11,r9
800164c2:	fe b0 6e fd 	rcall	800042bc <controller_init>
800164c6:	fe fc 02 8e 	ld.w	r12,pc[654]
	printf ("Controller INIT\n");
800164ca:	e0 a0 0b a3 	rcall	80017c10 <puts>
800164ce:	fe b0 6d d3 	rcall	80004074 <can_task_init>
			
	// Initialize CAN Interface
	can_task_init();
800164d2:	fe fc 02 86 	ld.w	r12,pc[646]
	printf ("CAN INIT\n");
800164d6:	e0 a0 0b 9d 	rcall	80017c10 <puts>
800164da:	d5 03       	csrf	0x10
			
	// Enable global interrupts
	Enable_global_interrupt(); // time starts now
800164dc:	fe b0 6b 4a 	rcall	80003b70 <codec_HoldReset>
	/* Interrupt related Functions  Init End*/
	
	// give multichannel codec a reset after power up (release before initializing)
	codec_HoldReset();
800164e0:	fe b0 6b 3c 	rcall	80003b58 <codec_EnableI2c>
	codec_EnableI2c();    // enable codec's I2C mux - will run I2C at 100kHz always - so mux can stay enabled.
800164e4:	fe b0 6b 28 	rcall	80003b34 <codec_activeI2c>
	codec_activeI2c();
800164e8:	e1 b9 00 42 	mfsr	r9,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800164ec:	e0 78 38 80 	mov	r8,80000
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800164f0:	f2 08 00 0a 	add	r10,r9,r8
800164f4:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800164f8:	14 39       	cp.w	r9,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800164fa:	e0 88 00 0a 	brls	8001650e <main+0x12e>
800164fe:	10 39       	cp.w	r9,r8
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80016500:	e0 88 00 04 	brls	80016508 <main+0x128>
80016504:	10 3a       	cp.w	r10,r8
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80016506:	c0 73       	brcs	80016514 <main+0x134>
80016508:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001650c:	cf 6b       	rjmp	800164f8 <main+0x118>
8001650e:	10 39       	cp.w	r9,r8
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80016510:	fe 98 ff fa 	brls	80016504 <main+0x124>
80016514:	fe b0 70 5c 	rcall	800045cc <ConmgrInit>
	delay_ms(5);    // takes a few ms for mux to switch
	ConmgrInit();
80016518:	fe b0 85 1c 	rcall	80006f50 <MnsTraceInit>
	//DacInit();

	MnsTraceInit();
8001651c:	fe b0 83 90 	rcall	80006c3c <TmrGetMasterTick_Long>
	
	/* now start NetService */
	LOG_NOR("%u Starting NetServices...\n", TmrGetMasterTick_Long());
80016520:	1a dc       	st.w	--sp,r12
80016522:	fe fc 02 3a 	ld.w	r12,pc[570]
80016526:	e0 a0 0a df 	rcall	80017ae4 <printf>
8001652a:	fe b0 a4 33 	rcall	8000ad90 <GetNetServicesConfig>
	cfg_ptr = GetNetServicesConfig();
8001652e:	fe f8 02 32 	ld.w	r8,pc[562]
80016532:	91 0c       	st.w	r8[0x0],r12
80016534:	fe b0 8a 2a 	rcall	80007988 <prepare_mns_config>
	prepare_mns_config(cfg_ptr); // set up NetServices configuration
80016538:	fe b0 ad 28 	rcall	8000bf88 <InitNetServices>
	InitNetServices(); // NetServices get INIC to 'attached' state
8001653c:	fe b0 83 80 	rcall	80006c3c <TmrGetMasterTick_Long>
	LOG_NOR("%u InitNetServices has returned \n", TmrGetMasterTick_Long()); // See how long NS took to start up
80016540:	1a dc       	st.w	--sp,r12
80016542:	fe fc 02 22 	ld.w	r12,pc[546]
80016546:	e0 a0 0a cf 	rcall	80017ae4 <printf>
8001654a:	fe f1 02 1e 	ld.w	r1,pc[542]
	//PWROFF_UC_INACTIVE(); // now let INIC manage power
	

	InitializeTimer(&mostCheckTimer); // setup timer structure - nex_min_timeout call back runs this timer
8001654e:	fe f7 02 1e 	ld.w	r7,pc[542]
	
	gFwState.fVolCur = AVN_DEFAULT_VOLUME;
80016552:	02 9c       	mov	r12,r1
	InitNetServices(); // NetServices get INIC to 'attached' state
	LOG_NOR("%u InitNetServices has returned \n", TmrGetMasterTick_Long()); // See how long NS took to start up
	//PWROFF_UC_INACTIVE(); // now let INIC manage power
	

	InitializeTimer(&mostCheckTimer); // setup timer structure - nex_min_timeout call back runs this timer
80016554:	fe b0 84 0a 	rcall	80006d68 <InitializeTimer>
80016558:	31 e8       	mov	r8,30
	
	gFwState.fVolCur = AVN_DEFAULT_VOLUME;
8001655a:	30 15       	mov	r5,1
	gFwState.fVolSet = AVN_DEFAULT_VOLUME;
	gFwState.rVolCur = AVN_DEFAULT_VOLUME;
	gFwState.rVolSet = AVN_DEFAULT_VOLUME;
	gFwState.fwVerCur = 1;
8001655c:	2f ed       	sub	sp,-8
	gFwState.fwVerStored = 1;
8001655e:	ae c8       	st.b	r7[0x4],r8
	InitializeTimer(&mostCheckTimer); // setup timer structure - nex_min_timeout call back runs this timer
	
	gFwState.fVolCur = AVN_DEFAULT_VOLUME;
	gFwState.fVolSet = AVN_DEFAULT_VOLUME;
	gFwState.rVolCur = AVN_DEFAULT_VOLUME;
	gFwState.rVolSet = AVN_DEFAULT_VOLUME;
80016560:	ae b8       	st.b	r7[0x3],r8
	//PWROFF_UC_INACTIVE(); // now let INIC manage power
	

	InitializeTimer(&mostCheckTimer); // setup timer structure - nex_min_timeout call back runs this timer
	
	gFwState.fVolCur = AVN_DEFAULT_VOLUME;
80016562:	ae a8       	st.b	r7[0x2],r8
	gFwState.fVolSet = AVN_DEFAULT_VOLUME;
80016564:	ae d8       	st.b	r7[0x5],r8
	gFwState.rVolCur = AVN_DEFAULT_VOLUME;
80016566:	ae 95       	st.b	r7[0x1],r5
	gFwState.rVolSet = AVN_DEFAULT_VOLUME;
	gFwState.fwVerCur = 1;
80016568:	ae 85       	st.b	r7[0x0],r5
	gFwState.fwVerStored = 1;
8001656a:	fe f2 02 06 	ld.w	r2,pc[518]
8001656e:	fe f4 02 06 	ld.w	r4,pc[518]
80016572:	fe f3 02 06 	ld.w	r3,pc[518]
80016576:	fe f0 02 06 	ld.w	r0,pc[518]
8001657a:	c4 28       	rjmp	800165fe <main+0x21e>
8001657c:	58 18       	cp.w	r8,1
		gui_clear_view();
		new_state_fct = true;
		state_fct = STATE_FCT_IDLE;
	}

	switch (state) {
8001657e:	e0 80 00 91 	breq	800166a0 <main+0x2c0>
80016582:	30 08       	mov	r8,0
		case STATE_OUTPUT3:
			if (!state_machine_global(GUI_OUTPUT3_ID, &state_fct))
				return;
			break;
	}
	new_state_fct = false;
80016584:	a8 88       	st.b	r4[0x0],r8
80016586:	01 88       	ld.ub	r8,r0[0x0]
		state_machine_task();
		/* ---------------------- insert from here *////////////////////////////
		
				
		/* run NetServices - event driven */
		if (MnsServiceRequest == TRUE)
80016588:	ea 08 18 00 	cp.b	r8,r5
8001658c:	c5 b0       	breq	80016642 <main+0x262>
8001658e:	03 99       	ld.ub	r9,r1[0x1]
		{
			MnsServiceRequest = FALSE;
			MostService();
		}

		if (TIMER_EXPIRED == mostCheckTimer.flag) // see if time for a CheckTimers call
80016590:	30 28       	mov	r8,2
80016592:	f0 09 18 00 	cp.b	r9,r8
80016596:	c6 00       	breq	80016656 <main+0x276>
80016598:	fe b0 82 b0 	rcall	80006af8 <check_for_port_message>
		{
			mostCheckTimer.flag = TIMER_IDLE; // timer has expired - not running now
			MostCheckTimers(); // call the NetServices function
		}

		check_for_port_message(); // always checking for INIC traffic, handles it if ready
8001659c:	fe b0 6f 04 	rcall	800043a4 <connection_manager>
		connection_manager(); // run connection manager state machine
800165a0:	fe b0 83 a2 	rcall	80006ce4 <TmrTask>
		TmrTask(); // run all timers
800165a4:	4f 26       	lddpc	r6,8001676c <main+0x38c>
			NtfPropertyChangedFkt(FBLOCK_AMP, 0, AMP_EVENTS); // trigger notification
		}
		#endif
				
		/* Check FW Update */
		if(gFwState.fwVerCur != gFwState.fwVerStored) {
800165a6:	0f 98       	ld.ub	r8,r7[0x1]
800165a8:	0f 89       	ld.ub	r9,r7[0x0]
800165aa:	f2 08 18 00 	cp.b	r8,r9
800165ae:	c1 70       	breq	800165dc <main+0x1fc>
800165b0:	1a d9       	st.w	--sp,r9
800165b2:	4f 4c       	lddpc	r12,80016780 <main+0x3a0>
			LOG_NOR("FIRMWARE Changed(%d -> %d)\n", gFwState.fwVerCur, gFwState.fwVerStored);
800165b4:	1a d8       	st.w	--sp,r8
800165b6:	e0 a0 0a 97 	rcall	80017ae4 <printf>
800165ba:	0d 88       	ld.ub	r8,r6[0x0]
800165bc:	2f ed       	sub	sp,-8
800165be:	ea 08 18 00 	cp.b	r8,r5
			switch(gFwState.fwVerStored) {
800165c2:	e0 80 00 84 	breq	800166ca <main+0x2ea>
800165c6:	30 29       	mov	r9,2
800165c8:	f2 08 18 00 	cp.b	r8,r9
800165cc:	c6 f0       	breq	800166aa <main+0x2ca>
800165ce:	1a d8       	st.w	--sp,r8
800165d0:	4e dc       	lddpc	r12,80016784 <main+0x3a4>
800165d2:	e0 a0 0a 89 	rcall	80017ae4 <printf>
					CODEC_setVolume(0, gFwState.fVolSet);
					CODEC_setVolume(1, gFwState.rVolSet);
					gFwState.fwVerCur = gFwState.fwVerStored;
					break;
				default :
					LOG_ERR("Invalid Firmware, ver=%d\n", gFwState.fwVerStored);
800165d6:	0d 98       	ld.ub	r8,r6[0x1]
800165d8:	2f fd       	sub	sp,-4
800165da:	ac 88       	st.b	r6[0x0],r8
800165dc:	4e 46       	lddpc	r6,8001676c <main+0x38c>
					gFwState.fwVerStored = gFwState.fwVerCur;
800165de:	0f ab       	ld.ub	r11,r7[0x2]
800165e0:	0f b8       	ld.ub	r8,r7[0x3]
800165e2:	f6 08 18 00 	cp.b	r8,r11
					break;		
			}
		}
		
		if(gFwState.fVolCur != gFwState.fVolSet) {
800165e6:	c0 60       	breq	800165f2 <main+0x212>
800165e8:	30 0c       	mov	r12,0
800165ea:	fe b0 6d b7 	rcall	80004158 <CODEC_setVolume>
800165ee:	0d a8       	ld.ub	r8,r6[0x2]
800165f0:	ac b8       	st.b	r6[0x3],r8
			CODEC_setVolume(0, gFwState.fVolSet);
800165f2:	4d f6       	lddpc	r6,8001676c <main+0x38c>
800165f4:	0f cb       	ld.ub	r11,r7[0x4]
800165f6:	0f d8       	ld.ub	r8,r7[0x5]
			gFwState.fVolCur = gFwState.fVolSet;	
800165f8:	f6 08 18 00 	cp.b	r8,r11
		}
		if(gFwState.rVolCur != gFwState.rVolSet) {
800165fc:	c6 d1       	brne	800166d6 <main+0x2f6>
800165fe:	fe b0 6c e7 	rcall	80003fcc <can_task>
80016602:	fe b0 80 73 	rcall	800066e8 <gui_task>
80016606:	fe b0 6e 83 	rcall	8000430c <controller_task>

	while (1) {
		
		/* ---------------------- insert from here *////////////////////////////
		// Call CAN Task for communication management
		can_task();
8001660a:	fe b0 6e 51 	rcall	800042ac <controller_key_fct5>
		// Call Gui Task for display update
		gui_task();
8001660e:	18 96       	mov	r6,r12
		// Call Controller Task for control Update
		controller_task();
80016610:	c3 b0       	breq	80016686 <main+0x2a6>
80016612:	30 59       	mov	r9,5
 */
static void state_machine_task(void)
{
	//printf (".");
	// Set function state
	if (controller_key_fct5()) {
80016614:	a8 85       	st.b	r4[0x0],r5
80016616:	85 09       	st.w	r2[0x0],r9
80016618:	4d c9       	lddpc	r9,80016788 <main+0x3a8>
8001661a:	13 88       	ld.ub	r8,r9[0x0]
		
		state_fct = STATE_FCT_ZOOM;
8001661c:	58 08       	cp.w	r8,0
		new_state_fct = true;
8001661e:	c2 21       	brne	80016662 <main+0x282>
{
	//printf (".");
	// Set function state
	if (controller_key_fct5()) {
		
		state_fct = STATE_FCT_ZOOM;
80016620:	66 08       	ld.w	r8,r3[0x0]
		state_fct = STATE_FCT_IDLE;
		state = STATE_OUTPUT3;
		new_state_fct = true;
	}
	// Clear Zoom state if on and a key is pressed
	if (zoom_view && !controller_key_fct5()) {
80016622:	58 28       	cp.w	r8,2
80016624:	c2 d0       	breq	8001667e <main+0x29e>
80016626:	58 28       	cp.w	r8,2
80016628:	fe 98 ff aa 	brls	8001657c <main+0x19c>
		gui_clear_view();
		new_state_fct = true;
		state_fct = STATE_FCT_IDLE;
	}

	switch (state) {
8001662c:	58 38       	cp.w	r8,3
8001662e:	c3 40       	breq	80016696 <main+0x2b6>
80016630:	58 48       	cp.w	r8,4
80016632:	ca 81       	brne	80016582 <main+0x1a2>
80016634:	30 3c       	mov	r12,3
80016636:	c9 1e       	rcall	80016358 <T.76>
80016638:	ca 51       	brne	80016582 <main+0x1a2>
8001663a:	01 88       	ld.ub	r8,r0[0x0]
8001663c:	ea 08 18 00 	cp.b	r8,r5
		case STATE_OUTPUT2:
			if (!state_machine_global(GUI_OUTPUT2_ID, &state_fct))
				return;
			break;
		case STATE_OUTPUT3:
			if (!state_machine_global(GUI_OUTPUT3_ID, &state_fct))
80016640:	ca 71       	brne	8001658e <main+0x1ae>
80016642:	30 09       	mov	r9,0
80016644:	4c e8       	lddpc	r8,8001677c <main+0x39c>
80016646:	b0 89       	st.b	r8[0x0],r9
		state_machine_task();
		/* ---------------------- insert from here *////////////////////////////
		
				
		/* run NetServices - event driven */
		if (MnsServiceRequest == TRUE)
80016648:	fe b0 ad e4 	rcall	8000c210 <MostService>
8001664c:	03 99       	ld.ub	r9,r1[0x1]
8001664e:	30 28       	mov	r8,2
		{
			MnsServiceRequest = FALSE;
80016650:	f0 09 18 00 	cp.b	r9,r8
80016654:	ca 21       	brne	80016598 <main+0x1b8>
			MostService();
80016656:	30 09       	mov	r9,0
80016658:	4c 48       	lddpc	r8,80016768 <main+0x388>
		}

		if (TIMER_EXPIRED == mostCheckTimer.flag) // see if time for a CheckTimers call
8001665a:	b0 99       	st.b	r8[0x1],r9
8001665c:	fe b0 a5 22 	rcall	8000b0a0 <MostCheckTimers>
80016660:	c9 cb       	rjmp	80016598 <main+0x1b8>
80016662:	fe b0 6e 25 	rcall	800042ac <controller_key_fct5>
		{
			mostCheckTimer.flag = TIMER_IDLE; // timer has expired - not running now
80016666:	cd d1       	brne	80016620 <main+0x240>
80016668:	4c 88       	lddpc	r8,80016788 <main+0x3a8>
			MostCheckTimers(); // call the NetServices function
8001666a:	b0 8c       	st.b	r8[0x0],r12
8001666c:	50 0c       	stdsp	sp[0x0],r12
8001666e:	fe b0 7e 27 	rcall	800062bc <gui_clear_view>
		state_fct = STATE_FCT_IDLE;
		state = STATE_OUTPUT3;
		new_state_fct = true;
	}
	// Clear Zoom state if on and a key is pressed
	if (zoom_view && !controller_key_fct5()) {
80016672:	40 0c       	lddsp	r12,sp[0x0]
80016674:	a8 85       	st.b	r4[0x0],r5
		zoom_view = false;
80016676:	85 0c       	st.w	r2[0x0],r12
80016678:	66 08       	ld.w	r8,r3[0x0]
		gui_clear_view();
8001667a:	58 28       	cp.w	r8,2
8001667c:	cd 51       	brne	80016626 <main+0x246>
8001667e:	30 1c       	mov	r12,1
		new_state_fct = true;
		state_fct = STATE_FCT_IDLE;
80016680:	c6 ce       	rcall	80016358 <T.76>
	}
	// Clear Zoom state if on and a key is pressed
	if (zoom_view && !controller_key_fct5()) {
		zoom_view = false;
		gui_clear_view();
		new_state_fct = true;
80016682:	c8 01       	brne	80016582 <main+0x1a2>
		state_fct = STATE_FCT_IDLE;
80016684:	c8 1b       	rjmp	80016586 <main+0x1a6>
	}

	switch (state) {
80016686:	fe b0 6e 03 	rcall	8000428c <controller_key_fct1>
8001668a:	c2 c0       	breq	800166e2 <main+0x302>
		case STATE_SOURCE1:
			if (!state_machine_global(GUI_SOURCE1_ID, &state_fct))
				return;
			break;
		case STATE_OUTPUT1:
			if (!state_machine_global(GUI_OUTPUT1_ID, &state_fct))
8001668c:	30 18       	mov	r8,1
8001668e:	85 06       	st.w	r2[0x0],r6
80016690:	87 08       	st.w	r3[0x0],r8
80016692:	a8 88       	st.b	r4[0x0],r8
80016694:	cc 2b       	rjmp	80016618 <main+0x238>
80016696:	30 2c       	mov	r12,2
	if (controller_key_fct5()) {
		
		state_fct = STATE_FCT_ZOOM;
		new_state_fct = true;
	}
	else if (controller_key_fct1()) {
80016698:	c6 0e       	rcall	80016358 <T.76>
8001669a:	fe 91 ff 74 	brne	80016582 <main+0x1a2>
		state_fct = STATE_FCT_IDLE;
		state = STATE_SOURCE1;
8001669e:	c7 4b       	rjmp	80016586 <main+0x1a6>
		
		state_fct = STATE_FCT_ZOOM;
		new_state_fct = true;
	}
	else if (controller_key_fct1()) {
		state_fct = STATE_FCT_IDLE;
800166a0:	30 0c       	mov	r12,0
		state = STATE_SOURCE1;
800166a2:	c5 be       	rcall	80016358 <T.76>
		new_state_fct = true;
800166a4:	fe 91 ff 6f 	brne	80016582 <main+0x1a2>
		case STATE_OUTPUT1:
			if (!state_machine_global(GUI_OUTPUT1_ID, &state_fct))
				return;
			break;
		case STATE_OUTPUT2:
			if (!state_machine_global(GUI_OUTPUT2_ID, &state_fct))
800166a8:	c6 fb       	rjmp	80016586 <main+0x1a6>
800166aa:	31 e8       	mov	r8,30
800166ac:	ac c8       	st.b	r6[0x4],r8
800166ae:	ac b8       	st.b	r6[0x3],r8
800166b0:	ac a8       	st.b	r6[0x2],r8
800166b2:	ac d8       	st.b	r6[0x5],r8

	switch (state) {
		case STATE_IDLE:
			break;
		case STATE_SOURCE1:
			if (!state_machine_global(GUI_SOURCE1_ID, &state_fct))
800166b4:	31 eb       	mov	r11,30
800166b6:	30 0c       	mov	r12,0
800166b8:	fe b0 6d 50 	rcall	80004158 <CODEC_setVolume>
800166bc:	0d cb       	ld.ub	r11,r6[0x4]
800166be:	30 1c       	mov	r12,1
					CODEC_setVolume(1, gFwState.rVolSet);
					gFwState.fwVerCur = gFwState.fwVerStored;
					break;
					
				case 2:
					gFwState.fVolCur = AVN_DEFAULT_VOLUME;
800166c0:	fe b0 6d 4c 	rcall	80004158 <CODEC_setVolume>
800166c4:	0d 88       	ld.ub	r8,r6[0x0]
					gFwState.fVolSet = AVN_DEFAULT_VOLUME;
800166c6:	ac 98       	st.b	r6[0x1],r8
					gFwState.rVolCur = AVN_DEFAULT_VOLUME;
800166c8:	c8 ab       	rjmp	800165dc <main+0x1fc>
					gFwState.rVolSet = AVN_DEFAULT_VOLUME;
					CODEC_setVolume(0, gFwState.fVolSet);
800166ca:	31 e8       	mov	r8,30
800166cc:	ac a8       	st.b	r6[0x2],r8
800166ce:	ac b8       	st.b	r6[0x3],r8
800166d0:	30 08       	mov	r8,0
					CODEC_setVolume(1, gFwState.rVolSet);
800166d2:	ac c8       	st.b	r6[0x4],r8
800166d4:	ce fb       	rjmp	800166b2 <main+0x2d2>
800166d6:	30 1c       	mov	r12,1
800166d8:	fe b0 6d 40 	rcall	80004158 <CODEC_setVolume>
					gFwState.fwVerCur = gFwState.fwVerStored;
800166dc:	0d c8       	ld.ub	r8,r6[0x4]
					break;
800166de:	ac d8       	st.b	r6[0x5],r8
		/* Check FW Update */
		if(gFwState.fwVerCur != gFwState.fwVerStored) {
			LOG_NOR("FIRMWARE Changed(%d -> %d)\n", gFwState.fwVerCur, gFwState.fwVerStored);
			switch(gFwState.fwVerStored) {
				case 1 :
					gFwState.fVolCur = AVN_DEFAULT_VOLUME;
800166e0:	c8 fb       	rjmp	800165fe <main+0x21e>
					gFwState.fVolSet = AVN_DEFAULT_VOLUME;
800166e2:	50 0c       	stdsp	sp[0x0],r12
		/* Check FW Update */
		if(gFwState.fwVerCur != gFwState.fwVerStored) {
			LOG_NOR("FIRMWARE Changed(%d -> %d)\n", gFwState.fwVerCur, gFwState.fwVerStored);
			switch(gFwState.fwVerStored) {
				case 1 :
					gFwState.fVolCur = AVN_DEFAULT_VOLUME;
800166e4:	fe b0 6d dc 	rcall	8000429c <controller_key_fct2>
					gFwState.fVolSet = AVN_DEFAULT_VOLUME;
					gFwState.rVolCur = 0;
					gFwState.rVolSet = 0;
800166e8:	40 08       	lddsp	r8,sp[0x0]
800166ea:	18 96       	mov	r6,r12
		if(gFwState.fVolCur != gFwState.fVolSet) {
			CODEC_setVolume(0, gFwState.fVolSet);
			gFwState.fVolCur = gFwState.fVolSet;	
		}
		if(gFwState.rVolCur != gFwState.rVolSet) {
			CODEC_setVolume(1, gFwState.rVolSet);
800166ec:	c0 60       	breq	800166f8 <main+0x318>
800166ee:	30 29       	mov	r9,2
800166f0:	85 08       	st.w	r2[0x0],r8
			gFwState.rVolCur = gFwState.rVolSet;
800166f2:	87 09       	st.w	r3[0x0],r9
800166f4:	a8 85       	st.b	r4[0x0],r5
800166f6:	c9 1b       	rjmp	80016618 <main+0x238>
	else if (controller_key_fct1()) {
		state_fct = STATE_FCT_IDLE;
		state = STATE_SOURCE1;
		new_state_fct = true;
	}
	else if (controller_key_fct2()) {
800166f8:	fe b0 6d ba 	rcall	8000426c <controller_key_fct3>
800166fc:	c0 60       	breq	80016708 <main+0x328>
800166fe:	30 38       	mov	r8,3
80016700:	85 06       	st.w	r2[0x0],r6
80016702:	87 08       	st.w	r3[0x0],r8
		state_fct = STATE_FCT_IDLE;
		state = STATE_OUTPUT1;
80016704:	a8 85       	st.b	r4[0x0],r5
		state_fct = STATE_FCT_IDLE;
		state = STATE_SOURCE1;
		new_state_fct = true;
	}
	else if (controller_key_fct2()) {
		state_fct = STATE_FCT_IDLE;
80016706:	c8 9b       	rjmp	80016618 <main+0x238>
		state = STATE_OUTPUT1;
80016708:	50 0c       	stdsp	sp[0x0],r12
		new_state_fct = true;
8001670a:	fe b0 6d b9 	rcall	8000427c <controller_key_fct4>
	}
	else if (controller_key_fct3()) {
8001670e:	40 08       	lddsp	r8,sp[0x0]
80016710:	e5 f8 1a 00 	st.wne	r2[0x0],r8
		state_fct = STATE_FCT_IDLE;
		state = STATE_OUTPUT2;
80016714:	f9 b9 01 04 	movne	r9,4
80016718:	e7 f9 1a 00 	st.wne	r3[0x0],r9
		new_state_fct = true;
8001671c:	e9 f5 1e 00 	st.bne	r4[0x0],r5
	}
	else if (controller_key_fct4()) {
80016720:	c7 cb       	rjmp	80016618 <main+0x238>
80016722:	10 39       	cp.w	r9,r8
80016724:	fe 9b fe bb 	brhi	8001649a <main+0xba>
		state_fct = STATE_FCT_IDLE;
80016728:	fe 9f fe b7 	bral	80016496 <main+0xb6>
		state = STATE_OUTPUT3;
8001672c:	80 07       	ld.sh	r7,r0[0x0]
8001672e:	0a 0c       	add	r12,r5
80016730:	00 00       	add	r0,r0
		new_state_fct = true;
80016732:	42 20       	lddsp	r0,sp[0x88]
80016734:	00 00       	add	r0,r0
80016736:	42 1c       	lddsp	r12,sp[0x84]
80016738:	00 00       	add	r0,r0
8001673a:	42 18       	lddsp	r8,sp[0x84]
8001673c:	80 07       	ld.sh	r7,r0[0x0]
8001673e:	08 6c       	and	r12,r4
80016740:	00 00       	add	r0,r0
80016742:	01 9c       	ld.ub	r12,r0[0x1]
80016744:	80 07       	ld.sh	r7,r0[0x0]
80016746:	09 44       	ld.w	r4,--r4
80016748:	80 07       	ld.sh	r7,r0[0x0]
8001674a:	09 58       	ld.sh	r8,--r4
8001674c:	00 00       	add	r0,r0
8001674e:	40 06       	lddsp	r6,sp[0x0]
80016750:	80 07       	ld.sh	r7,r0[0x0]
80016752:	09 9c       	ld.ub	r12,r4[0x1]
80016754:	80 07       	ld.sh	r7,r0[0x0]
80016756:	09 a8       	ld.ub	r8,r4[0x2]
80016758:	80 07       	ld.sh	r7,r0[0x0]
8001675a:	09 b8       	ld.ub	r8,r4[0x3]
8001675c:	80 07       	ld.sh	r7,r0[0x0]
8001675e:	09 c4       	ld.ub	r4,r4[0x4]
80016760:	00 00       	add	r0,r0
80016762:	4a 90       	lddpc	r0,80016804 <__avr32_udiv64+0x78>
80016764:	80 07       	ld.sh	r7,r0[0x0]
80016766:	09 e0       	ld.ub	r0,r4[0x6]
80016768:	00 00       	add	r0,r0
8001676a:	4d 6f       	lddpc	pc,800168c0 <__avr32_udiv64+0x134>
8001676c:	00 00       	add	r0,r0
8001676e:	4d 69       	lddpc	r9,800168c4 <__avr32_udiv64+0x138>
80016770:	00 00       	add	r0,r0
80016772:	3b 4c       	mov	r12,-76
80016774:	00 00       	add	r0,r0
80016776:	3b 51       	mov	r1,-75
80016778:	00 00       	add	r0,r0
8001677a:	3b 44       	mov	r4,-76
8001677c:	00 00       	add	r0,r0
8001677e:	4a 96       	lddpc	r6,80016820 <__avr32_udiv64+0x94>
80016780:	80 07       	ld.sh	r7,r0[0x0]
80016782:	09 64       	ld.uh	r4,--r4
80016784:	80 07       	ld.sh	r7,r0[0x0]
80016786:	09 80       	ld.ub	r0,r4[0x0]
80016788:	00 00       	add	r0,r0
8001678a:	3b 40       	mov	r0,-76

8001678c <__avr32_udiv64>:
8001678c:	d4 31       	pushm	r0-r7,lr
8001678e:	1a 97       	mov	r7,sp
80016790:	20 3d       	sub	sp,12
80016792:	10 9c       	mov	r12,r8
80016794:	12 9e       	mov	lr,r9
80016796:	14 93       	mov	r3,r10
80016798:	58 09       	cp.w	r9,0
8001679a:	e0 81 00 bd 	brne	80016914 <__avr32_udiv64+0x188>
8001679e:	16 38       	cp.w	r8,r11
800167a0:	e0 88 00 40 	brls	80016820 <__avr32_udiv64+0x94>
800167a4:	f0 08 12 00 	clz	r8,r8
800167a8:	c0 d0       	breq	800167c2 <__avr32_udiv64+0x36>
800167aa:	f6 08 09 4b 	lsl	r11,r11,r8
800167ae:	f0 09 11 20 	rsub	r9,r8,32
800167b2:	f8 08 09 4c 	lsl	r12,r12,r8
800167b6:	f4 09 0a 49 	lsr	r9,r10,r9
800167ba:	f4 08 09 43 	lsl	r3,r10,r8
800167be:	f3 eb 10 0b 	or	r11,r9,r11
800167c2:	f8 0e 16 10 	lsr	lr,r12,0x10
800167c6:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800167ca:	f6 0e 0d 00 	divu	r0,r11,lr
800167ce:	e6 0b 16 10 	lsr	r11,r3,0x10
800167d2:	00 99       	mov	r9,r0
800167d4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800167d8:	e0 0a 02 48 	mul	r8,r0,r10
800167dc:	10 3b       	cp.w	r11,r8
800167de:	c0 a2       	brcc	800167f2 <__avr32_udiv64+0x66>
800167e0:	20 19       	sub	r9,1
800167e2:	18 0b       	add	r11,r12
800167e4:	18 3b       	cp.w	r11,r12
800167e6:	c0 63       	brcs	800167f2 <__avr32_udiv64+0x66>
800167e8:	10 3b       	cp.w	r11,r8
800167ea:	f7 b9 03 01 	sublo	r9,1
800167ee:	f7 dc e3 0b 	addcs	r11,r11,r12
800167f2:	f6 08 01 01 	sub	r1,r11,r8
800167f6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800167fa:	e2 0e 0d 00 	divu	r0,r1,lr
800167fe:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80016802:	00 98       	mov	r8,r0
80016804:	e0 0a 02 4a 	mul	r10,r0,r10
80016808:	14 33       	cp.w	r3,r10
8001680a:	c0 82       	brcc	8001681a <__avr32_udiv64+0x8e>
8001680c:	20 18       	sub	r8,1
8001680e:	18 03       	add	r3,r12
80016810:	18 33       	cp.w	r3,r12
80016812:	c0 43       	brcs	8001681a <__avr32_udiv64+0x8e>
80016814:	14 33       	cp.w	r3,r10
80016816:	f7 b8 03 01 	sublo	r8,1
8001681a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8001681e:	cd f8       	rjmp	800169dc <__avr32_udiv64+0x250>
80016820:	58 08       	cp.w	r8,0
80016822:	c0 51       	brne	8001682c <__avr32_udiv64+0xa0>
80016824:	30 19       	mov	r9,1
80016826:	f2 08 0d 08 	divu	r8,r9,r8
8001682a:	10 9c       	mov	r12,r8
8001682c:	f8 06 12 00 	clz	r6,r12
80016830:	c0 41       	brne	80016838 <__avr32_udiv64+0xac>
80016832:	18 1b       	sub	r11,r12
80016834:	30 19       	mov	r9,1
80016836:	c4 08       	rjmp	800168b6 <__avr32_udiv64+0x12a>
80016838:	ec 01 11 20 	rsub	r1,r6,32
8001683c:	f4 01 0a 49 	lsr	r9,r10,r1
80016840:	f8 06 09 4c 	lsl	r12,r12,r6
80016844:	f6 06 09 48 	lsl	r8,r11,r6
80016848:	f6 01 0a 41 	lsr	r1,r11,r1
8001684c:	f3 e8 10 08 	or	r8,r9,r8
80016850:	f8 03 16 10 	lsr	r3,r12,0x10
80016854:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80016858:	e2 03 0d 00 	divu	r0,r1,r3
8001685c:	f0 0b 16 10 	lsr	r11,r8,0x10
80016860:	00 9e       	mov	lr,r0
80016862:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80016866:	e0 05 02 49 	mul	r9,r0,r5
8001686a:	12 3b       	cp.w	r11,r9
8001686c:	c0 a2       	brcc	80016880 <__avr32_udiv64+0xf4>
8001686e:	20 1e       	sub	lr,1
80016870:	18 0b       	add	r11,r12
80016872:	18 3b       	cp.w	r11,r12
80016874:	c0 63       	brcs	80016880 <__avr32_udiv64+0xf4>
80016876:	12 3b       	cp.w	r11,r9
80016878:	f7 be 03 01 	sublo	lr,1
8001687c:	f7 dc e3 0b 	addcs	r11,r11,r12
80016880:	12 1b       	sub	r11,r9
80016882:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80016886:	f6 03 0d 02 	divu	r2,r11,r3
8001688a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8001688e:	04 99       	mov	r9,r2
80016890:	e4 05 02 4b 	mul	r11,r2,r5
80016894:	16 38       	cp.w	r8,r11
80016896:	c0 a2       	brcc	800168aa <__avr32_udiv64+0x11e>
80016898:	20 19       	sub	r9,1
8001689a:	18 08       	add	r8,r12
8001689c:	18 38       	cp.w	r8,r12
8001689e:	c0 63       	brcs	800168aa <__avr32_udiv64+0x11e>
800168a0:	16 38       	cp.w	r8,r11
800168a2:	f7 b9 03 01 	sublo	r9,1
800168a6:	f1 dc e3 08 	addcs	r8,r8,r12
800168aa:	f4 06 09 43 	lsl	r3,r10,r6
800168ae:	f0 0b 01 0b 	sub	r11,r8,r11
800168b2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
800168b6:	f8 06 16 10 	lsr	r6,r12,0x10
800168ba:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800168be:	f6 06 0d 00 	divu	r0,r11,r6
800168c2:	e6 0b 16 10 	lsr	r11,r3,0x10
800168c6:	00 9a       	mov	r10,r0
800168c8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800168cc:	e0 0e 02 48 	mul	r8,r0,lr
800168d0:	10 3b       	cp.w	r11,r8
800168d2:	c0 a2       	brcc	800168e6 <__avr32_udiv64+0x15a>
800168d4:	20 1a       	sub	r10,1
800168d6:	18 0b       	add	r11,r12
800168d8:	18 3b       	cp.w	r11,r12
800168da:	c0 63       	brcs	800168e6 <__avr32_udiv64+0x15a>
800168dc:	10 3b       	cp.w	r11,r8
800168de:	f7 ba 03 01 	sublo	r10,1
800168e2:	f7 dc e3 0b 	addcs	r11,r11,r12
800168e6:	f6 08 01 01 	sub	r1,r11,r8
800168ea:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800168ee:	e2 06 0d 00 	divu	r0,r1,r6
800168f2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800168f6:	00 98       	mov	r8,r0
800168f8:	e0 0e 02 4b 	mul	r11,r0,lr
800168fc:	16 33       	cp.w	r3,r11
800168fe:	c0 82       	brcc	8001690e <__avr32_udiv64+0x182>
80016900:	20 18       	sub	r8,1
80016902:	18 03       	add	r3,r12
80016904:	18 33       	cp.w	r3,r12
80016906:	c0 43       	brcs	8001690e <__avr32_udiv64+0x182>
80016908:	16 33       	cp.w	r3,r11
8001690a:	f7 b8 03 01 	sublo	r8,1
8001690e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80016912:	c6 98       	rjmp	800169e4 <__avr32_udiv64+0x258>
80016914:	16 39       	cp.w	r9,r11
80016916:	e0 8b 00 65 	brhi	800169e0 <__avr32_udiv64+0x254>
8001691a:	f2 09 12 00 	clz	r9,r9
8001691e:	c0 b1       	brne	80016934 <__avr32_udiv64+0x1a8>
80016920:	10 3a       	cp.w	r10,r8
80016922:	5f 2a       	srhs	r10
80016924:	1c 3b       	cp.w	r11,lr
80016926:	5f b8       	srhi	r8
80016928:	10 4a       	or	r10,r8
8001692a:	f2 0a 18 00 	cp.b	r10,r9
8001692e:	c5 90       	breq	800169e0 <__avr32_udiv64+0x254>
80016930:	30 18       	mov	r8,1
80016932:	c5 98       	rjmp	800169e4 <__avr32_udiv64+0x258>
80016934:	f0 09 09 46 	lsl	r6,r8,r9
80016938:	f2 03 11 20 	rsub	r3,r9,32
8001693c:	fc 09 09 4e 	lsl	lr,lr,r9
80016940:	f0 03 0a 48 	lsr	r8,r8,r3
80016944:	f6 09 09 4c 	lsl	r12,r11,r9
80016948:	f4 03 0a 42 	lsr	r2,r10,r3
8001694c:	ef 46 ff f4 	st.w	r7[-12],r6
80016950:	f6 03 0a 43 	lsr	r3,r11,r3
80016954:	18 42       	or	r2,r12
80016956:	f1 ee 10 0c 	or	r12,r8,lr
8001695a:	f8 01 16 10 	lsr	r1,r12,0x10
8001695e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80016962:	e6 01 0d 04 	divu	r4,r3,r1
80016966:	e4 03 16 10 	lsr	r3,r2,0x10
8001696a:	08 9e       	mov	lr,r4
8001696c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80016970:	e8 06 02 48 	mul	r8,r4,r6
80016974:	10 33       	cp.w	r3,r8
80016976:	c0 a2       	brcc	8001698a <__avr32_udiv64+0x1fe>
80016978:	20 1e       	sub	lr,1
8001697a:	18 03       	add	r3,r12
8001697c:	18 33       	cp.w	r3,r12
8001697e:	c0 63       	brcs	8001698a <__avr32_udiv64+0x1fe>
80016980:	10 33       	cp.w	r3,r8
80016982:	f7 be 03 01 	sublo	lr,1
80016986:	e7 dc e3 03 	addcs	r3,r3,r12
8001698a:	10 13       	sub	r3,r8
8001698c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80016990:	e6 01 0d 00 	divu	r0,r3,r1
80016994:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80016998:	00 98       	mov	r8,r0
8001699a:	e0 06 02 46 	mul	r6,r0,r6
8001699e:	0c 3b       	cp.w	r11,r6
800169a0:	c0 a2       	brcc	800169b4 <__avr32_udiv64+0x228>
800169a2:	20 18       	sub	r8,1
800169a4:	18 0b       	add	r11,r12
800169a6:	18 3b       	cp.w	r11,r12
800169a8:	c0 63       	brcs	800169b4 <__avr32_udiv64+0x228>
800169aa:	0c 3b       	cp.w	r11,r6
800169ac:	f7 dc e3 0b 	addcs	r11,r11,r12
800169b0:	f7 b8 03 01 	sublo	r8,1
800169b4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800169b8:	ee f4 ff f4 	ld.w	r4,r7[-12]
800169bc:	0c 1b       	sub	r11,r6
800169be:	f0 04 06 42 	mulu.d	r2,r8,r4
800169c2:	06 95       	mov	r5,r3
800169c4:	16 35       	cp.w	r5,r11
800169c6:	e0 8b 00 0a 	brhi	800169da <__avr32_udiv64+0x24e>
800169ca:	5f 0b       	sreq	r11
800169cc:	f4 09 09 49 	lsl	r9,r10,r9
800169d0:	12 32       	cp.w	r2,r9
800169d2:	5f b9       	srhi	r9
800169d4:	f7 e9 00 09 	and	r9,r11,r9
800169d8:	c0 60       	breq	800169e4 <__avr32_udiv64+0x258>
800169da:	20 18       	sub	r8,1
800169dc:	30 09       	mov	r9,0
800169de:	c0 38       	rjmp	800169e4 <__avr32_udiv64+0x258>
800169e0:	30 09       	mov	r9,0
800169e2:	12 98       	mov	r8,r9
800169e4:	10 9a       	mov	r10,r8
800169e6:	12 93       	mov	r3,r9
800169e8:	10 92       	mov	r2,r8
800169ea:	12 9b       	mov	r11,r9
800169ec:	2f dd       	sub	sp,-12
800169ee:	d8 32       	popm	r0-r7,pc

800169f0 <_fclose_r>:
800169f0:	d4 21       	pushm	r4-r7,lr
800169f2:	18 96       	mov	r6,r12
800169f4:	16 97       	mov	r7,r11
800169f6:	58 0b       	cp.w	r11,0
800169f8:	c0 31       	brne	800169fe <_fclose_r+0xe>
800169fa:	16 95       	mov	r5,r11
800169fc:	c4 b8       	rjmp	80016a92 <_fclose_r+0xa2>
800169fe:	cf 7c       	rcall	80016bec <__sfp_lock_acquire>
80016a00:	58 06       	cp.w	r6,0
80016a02:	c0 60       	breq	80016a0e <_fclose_r+0x1e>
80016a04:	6c 68       	ld.w	r8,r6[0x18]
80016a06:	58 08       	cp.w	r8,0
80016a08:	c0 31       	brne	80016a0e <_fclose_r+0x1e>
80016a0a:	0c 9c       	mov	r12,r6
80016a0c:	c4 4d       	rcall	80016c94 <__sinit>
80016a0e:	4a 38       	lddpc	r8,80016a98 <_fclose_r+0xa8>
80016a10:	10 37       	cp.w	r7,r8
80016a12:	c0 31       	brne	80016a18 <_fclose_r+0x28>
80016a14:	6c 07       	ld.w	r7,r6[0x0]
80016a16:	c0 a8       	rjmp	80016a2a <_fclose_r+0x3a>
80016a18:	4a 18       	lddpc	r8,80016a9c <_fclose_r+0xac>
80016a1a:	10 37       	cp.w	r7,r8
80016a1c:	c0 31       	brne	80016a22 <_fclose_r+0x32>
80016a1e:	6c 17       	ld.w	r7,r6[0x4]
80016a20:	c0 58       	rjmp	80016a2a <_fclose_r+0x3a>
80016a22:	4a 08       	lddpc	r8,80016aa0 <_fclose_r+0xb0>
80016a24:	10 37       	cp.w	r7,r8
80016a26:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80016a2a:	8e 69       	ld.sh	r9,r7[0xc]
80016a2c:	30 08       	mov	r8,0
80016a2e:	f0 09 19 00 	cp.h	r9,r8
80016a32:	c0 41       	brne	80016a3a <_fclose_r+0x4a>
80016a34:	cd dc       	rcall	80016bee <__sfp_lock_release>
80016a36:	30 05       	mov	r5,0
80016a38:	c2 d8       	rjmp	80016a92 <_fclose_r+0xa2>
80016a3a:	0e 9b       	mov	r11,r7
80016a3c:	0c 9c       	mov	r12,r6
80016a3e:	c3 bc       	rcall	80016ab4 <_fflush_r>
80016a40:	6e c8       	ld.w	r8,r7[0x30]
80016a42:	18 95       	mov	r5,r12
80016a44:	58 08       	cp.w	r8,0
80016a46:	c0 60       	breq	80016a52 <_fclose_r+0x62>
80016a48:	6e 8b       	ld.w	r11,r7[0x20]
80016a4a:	0c 9c       	mov	r12,r6
80016a4c:	5d 18       	icall	r8
80016a4e:	f9 b5 05 ff 	movlt	r5,-1
80016a52:	8e 68       	ld.sh	r8,r7[0xc]
80016a54:	ed b8 00 07 	bld	r8,0x7
80016a58:	c0 51       	brne	80016a62 <_fclose_r+0x72>
80016a5a:	6e 4b       	ld.w	r11,r7[0x10]
80016a5c:	0c 9c       	mov	r12,r6
80016a5e:	e0 a0 02 5b 	rcall	80016f14 <_free_r>
80016a62:	6e db       	ld.w	r11,r7[0x34]
80016a64:	58 0b       	cp.w	r11,0
80016a66:	c0 a0       	breq	80016a7a <_fclose_r+0x8a>
80016a68:	ee c8 ff bc 	sub	r8,r7,-68
80016a6c:	10 3b       	cp.w	r11,r8
80016a6e:	c0 40       	breq	80016a76 <_fclose_r+0x86>
80016a70:	0c 9c       	mov	r12,r6
80016a72:	e0 a0 02 51 	rcall	80016f14 <_free_r>
80016a76:	30 08       	mov	r8,0
80016a78:	8f d8       	st.w	r7[0x34],r8
80016a7a:	6f 2b       	ld.w	r11,r7[0x48]
80016a7c:	58 0b       	cp.w	r11,0
80016a7e:	c0 70       	breq	80016a8c <_fclose_r+0x9c>
80016a80:	0c 9c       	mov	r12,r6
80016a82:	e0 a0 02 49 	rcall	80016f14 <_free_r>
80016a86:	30 08       	mov	r8,0
80016a88:	ef 48 00 48 	st.w	r7[72],r8
80016a8c:	30 08       	mov	r8,0
80016a8e:	ae 68       	st.h	r7[0xc],r8
80016a90:	ca fc       	rcall	80016bee <__sfp_lock_release>
80016a92:	0a 9c       	mov	r12,r5
80016a94:	d8 22       	popm	r4-r7,pc
80016a96:	d7 03       	nop
80016a98:	80 07       	ld.sh	r7,r0[0x0]
80016a9a:	0a 2c       	rsub	r12,r5
80016a9c:	80 07       	ld.sh	r7,r0[0x0]
80016a9e:	0a 4c       	or	r12,r5
80016aa0:	80 07       	ld.sh	r7,r0[0x0]
80016aa2:	0a 6c       	and	r12,r5

80016aa4 <fclose>:
80016aa4:	d4 01       	pushm	lr
80016aa6:	48 38       	lddpc	r8,80016ab0 <fclose+0xc>
80016aa8:	18 9b       	mov	r11,r12
80016aaa:	70 0c       	ld.w	r12,r8[0x0]
80016aac:	ca 2f       	rcall	800169f0 <_fclose_r>
80016aae:	d8 02       	popm	pc
80016ab0:	00 00       	add	r0,r0
80016ab2:	01 9c       	ld.ub	r12,r0[0x1]

80016ab4 <_fflush_r>:
80016ab4:	d4 21       	pushm	r4-r7,lr
80016ab6:	16 97       	mov	r7,r11
80016ab8:	18 96       	mov	r6,r12
80016aba:	76 48       	ld.w	r8,r11[0x10]
80016abc:	58 08       	cp.w	r8,0
80016abe:	c7 c0       	breq	80016bb6 <_fflush_r+0x102>
80016ac0:	58 0c       	cp.w	r12,0
80016ac2:	c0 50       	breq	80016acc <_fflush_r+0x18>
80016ac4:	78 68       	ld.w	r8,r12[0x18]
80016ac6:	58 08       	cp.w	r8,0
80016ac8:	c0 21       	brne	80016acc <_fflush_r+0x18>
80016aca:	ce 5c       	rcall	80016c94 <__sinit>
80016acc:	4b b8       	lddpc	r8,80016bb8 <_fflush_r+0x104>
80016ace:	10 37       	cp.w	r7,r8
80016ad0:	c0 31       	brne	80016ad6 <_fflush_r+0x22>
80016ad2:	6c 07       	ld.w	r7,r6[0x0]
80016ad4:	c0 a8       	rjmp	80016ae8 <_fflush_r+0x34>
80016ad6:	4b a8       	lddpc	r8,80016bbc <_fflush_r+0x108>
80016ad8:	10 37       	cp.w	r7,r8
80016ada:	c0 31       	brne	80016ae0 <_fflush_r+0x2c>
80016adc:	6c 17       	ld.w	r7,r6[0x4]
80016ade:	c0 58       	rjmp	80016ae8 <_fflush_r+0x34>
80016ae0:	4b 88       	lddpc	r8,80016bc0 <_fflush_r+0x10c>
80016ae2:	10 37       	cp.w	r7,r8
80016ae4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80016ae8:	8e 6a       	ld.sh	r10,r7[0xc]
80016aea:	14 98       	mov	r8,r10
80016aec:	ed ba 00 03 	bld	r10,0x3
80016af0:	c4 20       	breq	80016b74 <_fflush_r+0xc0>
80016af2:	ab ba       	sbr	r10,0xb
80016af4:	ae 6a       	st.h	r7[0xc],r10
80016af6:	6e 18       	ld.w	r8,r7[0x4]
80016af8:	58 08       	cp.w	r8,0
80016afa:	e0 89 00 06 	brgt	80016b06 <_fflush_r+0x52>
80016afe:	6f 08       	ld.w	r8,r7[0x40]
80016b00:	58 08       	cp.w	r8,0
80016b02:	e0 8a 00 5a 	brle	80016bb6 <_fflush_r+0x102>
80016b06:	6e b8       	ld.w	r8,r7[0x2c]
80016b08:	58 08       	cp.w	r8,0
80016b0a:	c5 60       	breq	80016bb6 <_fflush_r+0x102>
80016b0c:	e2 1a 10 00 	andl	r10,0x1000,COH
80016b10:	c0 30       	breq	80016b16 <_fflush_r+0x62>
80016b12:	6f 55       	ld.w	r5,r7[0x54]
80016b14:	c0 f8       	rjmp	80016b32 <_fflush_r+0x7e>
80016b16:	30 19       	mov	r9,1
80016b18:	6e 8b       	ld.w	r11,r7[0x20]
80016b1a:	0c 9c       	mov	r12,r6
80016b1c:	5d 18       	icall	r8
80016b1e:	18 95       	mov	r5,r12
80016b20:	5b fc       	cp.w	r12,-1
80016b22:	c0 81       	brne	80016b32 <_fflush_r+0x7e>
80016b24:	6c 38       	ld.w	r8,r6[0xc]
80016b26:	59 d8       	cp.w	r8,29
80016b28:	c4 70       	breq	80016bb6 <_fflush_r+0x102>
80016b2a:	8e 68       	ld.sh	r8,r7[0xc]
80016b2c:	a7 a8       	sbr	r8,0x6
80016b2e:	ae 68       	st.h	r7[0xc],r8
80016b30:	d8 22       	popm	r4-r7,pc
80016b32:	8e 68       	ld.sh	r8,r7[0xc]
80016b34:	ed b8 00 02 	bld	r8,0x2
80016b38:	c0 91       	brne	80016b4a <_fflush_r+0x96>
80016b3a:	6e 18       	ld.w	r8,r7[0x4]
80016b3c:	10 15       	sub	r5,r8
80016b3e:	6e d8       	ld.w	r8,r7[0x34]
80016b40:	58 08       	cp.w	r8,0
80016b42:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80016b46:	eb d8 e1 15 	subne	r5,r5,r8
80016b4a:	6e b8       	ld.w	r8,r7[0x2c]
80016b4c:	0c 9c       	mov	r12,r6
80016b4e:	30 09       	mov	r9,0
80016b50:	0a 9a       	mov	r10,r5
80016b52:	6e 8b       	ld.w	r11,r7[0x20]
80016b54:	5d 18       	icall	r8
80016b56:	8e 68       	ld.sh	r8,r7[0xc]
80016b58:	0a 3c       	cp.w	r12,r5
80016b5a:	c2 61       	brne	80016ba6 <_fflush_r+0xf2>
80016b5c:	ab d8       	cbr	r8,0xb
80016b5e:	30 0c       	mov	r12,0
80016b60:	6e 49       	ld.w	r9,r7[0x10]
80016b62:	ae 68       	st.h	r7[0xc],r8
80016b64:	8f 1c       	st.w	r7[0x4],r12
80016b66:	8f 09       	st.w	r7[0x0],r9
80016b68:	ed b8 00 0c 	bld	r8,0xc
80016b6c:	c2 51       	brne	80016bb6 <_fflush_r+0x102>
80016b6e:	ef 45 00 54 	st.w	r7[84],r5
80016b72:	d8 22       	popm	r4-r7,pc
80016b74:	6e 45       	ld.w	r5,r7[0x10]
80016b76:	58 05       	cp.w	r5,0
80016b78:	c1 f0       	breq	80016bb6 <_fflush_r+0x102>
80016b7a:	6e 04       	ld.w	r4,r7[0x0]
80016b7c:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80016b80:	8f 05       	st.w	r7[0x0],r5
80016b82:	f9 b8 01 00 	movne	r8,0
80016b86:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80016b8a:	0a 14       	sub	r4,r5
80016b8c:	8f 28       	st.w	r7[0x8],r8
80016b8e:	c1 18       	rjmp	80016bb0 <_fflush_r+0xfc>
80016b90:	08 99       	mov	r9,r4
80016b92:	0a 9a       	mov	r10,r5
80016b94:	6e a8       	ld.w	r8,r7[0x28]
80016b96:	6e 8b       	ld.w	r11,r7[0x20]
80016b98:	0c 9c       	mov	r12,r6
80016b9a:	5d 18       	icall	r8
80016b9c:	18 14       	sub	r4,r12
80016b9e:	58 0c       	cp.w	r12,0
80016ba0:	e0 89 00 07 	brgt	80016bae <_fflush_r+0xfa>
80016ba4:	8e 68       	ld.sh	r8,r7[0xc]
80016ba6:	a7 a8       	sbr	r8,0x6
80016ba8:	3f fc       	mov	r12,-1
80016baa:	ae 68       	st.h	r7[0xc],r8
80016bac:	d8 22       	popm	r4-r7,pc
80016bae:	18 05       	add	r5,r12
80016bb0:	58 04       	cp.w	r4,0
80016bb2:	fe 99 ff ef 	brgt	80016b90 <_fflush_r+0xdc>
80016bb6:	d8 2a       	popm	r4-r7,pc,r12=0
80016bb8:	80 07       	ld.sh	r7,r0[0x0]
80016bba:	0a 2c       	rsub	r12,r5
80016bbc:	80 07       	ld.sh	r7,r0[0x0]
80016bbe:	0a 4c       	or	r12,r5
80016bc0:	80 07       	ld.sh	r7,r0[0x0]
80016bc2:	0a 6c       	and	r12,r5

80016bc4 <fflush>:
80016bc4:	d4 01       	pushm	lr
80016bc6:	18 9b       	mov	r11,r12
80016bc8:	58 0c       	cp.w	r12,0
80016bca:	c0 81       	brne	80016bda <fflush+0x16>
80016bcc:	48 68       	lddpc	r8,80016be4 <fflush+0x20>
80016bce:	fe cb 01 1a 	sub	r11,pc,282
80016bd2:	70 0c       	ld.w	r12,r8[0x0]
80016bd4:	e0 a0 03 c2 	rcall	80017358 <_fwalk_reent>
80016bd8:	d8 02       	popm	pc
80016bda:	48 48       	lddpc	r8,80016be8 <fflush+0x24>
80016bdc:	70 0c       	ld.w	r12,r8[0x0]
80016bde:	c6 bf       	rcall	80016ab4 <_fflush_r>
80016be0:	d8 02       	popm	pc
80016be2:	d7 03       	nop
80016be4:	80 07       	ld.sh	r7,r0[0x0]
80016be6:	0a 8c       	andn	r12,r5
80016be8:	00 00       	add	r0,r0
80016bea:	01 9c       	ld.ub	r12,r0[0x1]

80016bec <__sfp_lock_acquire>:
80016bec:	5e fc       	retal	r12

80016bee <__sfp_lock_release>:
80016bee:	5e fc       	retal	r12

80016bf0 <_cleanup_r>:
80016bf0:	d4 01       	pushm	lr
80016bf2:	fe cb 01 4e 	sub	r11,pc,334
80016bf6:	e0 a0 03 d9 	rcall	800173a8 <_fwalk>
80016bfa:	d8 02       	popm	pc

80016bfc <__sfmoreglue>:
80016bfc:	d4 21       	pushm	r4-r7,lr
80016bfe:	16 95       	mov	r5,r11
80016c00:	f6 06 10 5c 	mul	r6,r11,92
80016c04:	ec cb ff f4 	sub	r11,r6,-12
80016c08:	e0 a0 04 96 	rcall	80017534 <_malloc_r>
80016c0c:	18 97       	mov	r7,r12
80016c0e:	c0 90       	breq	80016c20 <__sfmoreglue+0x24>
80016c10:	99 15       	st.w	r12[0x4],r5
80016c12:	30 0b       	mov	r11,0
80016c14:	2f 4c       	sub	r12,-12
80016c16:	0c 9a       	mov	r10,r6
80016c18:	8f 2c       	st.w	r7[0x8],r12
80016c1a:	8f 0b       	st.w	r7[0x0],r11
80016c1c:	e0 a0 07 46 	rcall	80017aa8 <memset>
80016c20:	0e 9c       	mov	r12,r7
80016c22:	d8 22       	popm	r4-r7,pc

80016c24 <__sfp>:
80016c24:	d4 21       	pushm	r4-r7,lr
80016c26:	49 b8       	lddpc	r8,80016c90 <__sfp+0x6c>
80016c28:	18 96       	mov	r6,r12
80016c2a:	70 07       	ld.w	r7,r8[0x0]
80016c2c:	6e 68       	ld.w	r8,r7[0x18]
80016c2e:	58 08       	cp.w	r8,0
80016c30:	c0 31       	brne	80016c36 <__sfp+0x12>
80016c32:	0e 9c       	mov	r12,r7
80016c34:	c3 0c       	rcall	80016c94 <__sinit>
80016c36:	ee c7 ff 28 	sub	r7,r7,-216
80016c3a:	30 05       	mov	r5,0
80016c3c:	6e 2c       	ld.w	r12,r7[0x8]
80016c3e:	6e 18       	ld.w	r8,r7[0x4]
80016c40:	c0 68       	rjmp	80016c4c <__sfp+0x28>
80016c42:	98 69       	ld.sh	r9,r12[0xc]
80016c44:	ea 09 19 00 	cp.h	r9,r5
80016c48:	c1 10       	breq	80016c6a <__sfp+0x46>
80016c4a:	2a 4c       	sub	r12,-92
80016c4c:	20 18       	sub	r8,1
80016c4e:	cf a7       	brpl	80016c42 <__sfp+0x1e>
80016c50:	6e 08       	ld.w	r8,r7[0x0]
80016c52:	58 08       	cp.w	r8,0
80016c54:	c0 61       	brne	80016c60 <__sfp+0x3c>
80016c56:	30 4b       	mov	r11,4
80016c58:	0c 9c       	mov	r12,r6
80016c5a:	cd 1f       	rcall	80016bfc <__sfmoreglue>
80016c5c:	8f 0c       	st.w	r7[0x0],r12
80016c5e:	c0 30       	breq	80016c64 <__sfp+0x40>
80016c60:	6e 07       	ld.w	r7,r7[0x0]
80016c62:	ce db       	rjmp	80016c3c <__sfp+0x18>
80016c64:	30 c8       	mov	r8,12
80016c66:	8d 38       	st.w	r6[0xc],r8
80016c68:	d8 22       	popm	r4-r7,pc
80016c6a:	30 08       	mov	r8,0
80016c6c:	f9 48 00 4c 	st.w	r12[76],r8
80016c70:	99 08       	st.w	r12[0x0],r8
80016c72:	99 28       	st.w	r12[0x8],r8
80016c74:	99 18       	st.w	r12[0x4],r8
80016c76:	99 48       	st.w	r12[0x10],r8
80016c78:	99 58       	st.w	r12[0x14],r8
80016c7a:	99 68       	st.w	r12[0x18],r8
80016c7c:	99 d8       	st.w	r12[0x34],r8
80016c7e:	99 e8       	st.w	r12[0x38],r8
80016c80:	f9 48 00 48 	st.w	r12[72],r8
80016c84:	3f f8       	mov	r8,-1
80016c86:	b8 78       	st.h	r12[0xe],r8
80016c88:	30 18       	mov	r8,1
80016c8a:	b8 68       	st.h	r12[0xc],r8
80016c8c:	d8 22       	popm	r4-r7,pc
80016c8e:	d7 03       	nop
80016c90:	80 07       	ld.sh	r7,r0[0x0]
80016c92:	0a 8c       	andn	r12,r5

80016c94 <__sinit>:
80016c94:	d4 21       	pushm	r4-r7,lr
80016c96:	18 96       	mov	r6,r12
80016c98:	78 67       	ld.w	r7,r12[0x18]
80016c9a:	58 07       	cp.w	r7,0
80016c9c:	c4 91       	brne	80016d2e <__sinit+0x9a>
80016c9e:	fe c8 00 ae 	sub	r8,pc,174
80016ca2:	30 15       	mov	r5,1
80016ca4:	99 a8       	st.w	r12[0x28],r8
80016ca6:	f9 47 00 d8 	st.w	r12[216],r7
80016caa:	f9 47 00 dc 	st.w	r12[220],r7
80016cae:	f9 47 00 e0 	st.w	r12[224],r7
80016cb2:	99 65       	st.w	r12[0x18],r5
80016cb4:	cb 8f       	rcall	80016c24 <__sfp>
80016cb6:	8d 0c       	st.w	r6[0x0],r12
80016cb8:	0c 9c       	mov	r12,r6
80016cba:	cb 5f       	rcall	80016c24 <__sfp>
80016cbc:	8d 1c       	st.w	r6[0x4],r12
80016cbe:	0c 9c       	mov	r12,r6
80016cc0:	cb 2f       	rcall	80016c24 <__sfp>
80016cc2:	6c 09       	ld.w	r9,r6[0x0]
80016cc4:	30 48       	mov	r8,4
80016cc6:	93 07       	st.w	r9[0x0],r7
80016cc8:	b2 68       	st.h	r9[0xc],r8
80016cca:	93 17       	st.w	r9[0x4],r7
80016ccc:	93 27       	st.w	r9[0x8],r7
80016cce:	6c 18       	ld.w	r8,r6[0x4]
80016cd0:	b2 77       	st.h	r9[0xe],r7
80016cd2:	93 47       	st.w	r9[0x10],r7
80016cd4:	93 57       	st.w	r9[0x14],r7
80016cd6:	93 67       	st.w	r9[0x18],r7
80016cd8:	93 89       	st.w	r9[0x20],r9
80016cda:	91 07       	st.w	r8[0x0],r7
80016cdc:	91 17       	st.w	r8[0x4],r7
80016cde:	91 27       	st.w	r8[0x8],r7
80016ce0:	fe ce ed d0 	sub	lr,pc,-4656
80016ce4:	fe cb ee 04 	sub	r11,pc,-4604
80016ce8:	93 9e       	st.w	r9[0x24],lr
80016cea:	93 ab       	st.w	r9[0x28],r11
80016cec:	fe ca ee 30 	sub	r10,pc,-4560
80016cf0:	fe c4 ee 40 	sub	r4,pc,-4544
80016cf4:	93 ba       	st.w	r9[0x2c],r10
80016cf6:	93 c4       	st.w	r9[0x30],r4
80016cf8:	30 99       	mov	r9,9
80016cfa:	b0 69       	st.h	r8[0xc],r9
80016cfc:	b0 75       	st.h	r8[0xe],r5
80016cfe:	91 c4       	st.w	r8[0x30],r4
80016d00:	91 47       	st.w	r8[0x10],r7
80016d02:	91 57       	st.w	r8[0x14],r7
80016d04:	91 67       	st.w	r8[0x18],r7
80016d06:	91 88       	st.w	r8[0x20],r8
80016d08:	91 9e       	st.w	r8[0x24],lr
80016d0a:	91 ab       	st.w	r8[0x28],r11
80016d0c:	91 ba       	st.w	r8[0x2c],r10
80016d0e:	8d 2c       	st.w	r6[0x8],r12
80016d10:	31 28       	mov	r8,18
80016d12:	99 07       	st.w	r12[0x0],r7
80016d14:	b8 68       	st.h	r12[0xc],r8
80016d16:	99 17       	st.w	r12[0x4],r7
80016d18:	99 27       	st.w	r12[0x8],r7
80016d1a:	30 28       	mov	r8,2
80016d1c:	b8 78       	st.h	r12[0xe],r8
80016d1e:	99 c4       	st.w	r12[0x30],r4
80016d20:	99 67       	st.w	r12[0x18],r7
80016d22:	99 9e       	st.w	r12[0x24],lr
80016d24:	99 ab       	st.w	r12[0x28],r11
80016d26:	99 ba       	st.w	r12[0x2c],r10
80016d28:	99 47       	st.w	r12[0x10],r7
80016d2a:	99 57       	st.w	r12[0x14],r7
80016d2c:	99 8c       	st.w	r12[0x20],r12
80016d2e:	d8 22       	popm	r4-r7,pc

80016d30 <_fopen_r>:
80016d30:	d4 21       	pushm	r4-r7,lr
80016d32:	20 1d       	sub	sp,4
80016d34:	16 94       	mov	r4,r11
80016d36:	18 96       	mov	r6,r12
80016d38:	14 9b       	mov	r11,r10
80016d3a:	1a 9a       	mov	r10,sp
80016d3c:	e0 a0 22 44 	rcall	8001b1c4 <__sflags>
80016d40:	18 95       	mov	r5,r12
80016d42:	c0 31       	brne	80016d48 <_fopen_r+0x18>
80016d44:	18 97       	mov	r7,r12
80016d46:	c2 b8       	rjmp	80016d9c <_fopen_r+0x6c>
80016d48:	0c 9c       	mov	r12,r6
80016d4a:	c6 df       	rcall	80016c24 <__sfp>
80016d4c:	18 97       	mov	r7,r12
80016d4e:	c2 70       	breq	80016d9c <_fopen_r+0x6c>
80016d50:	08 9b       	mov	r11,r4
80016d52:	e0 69 01 b6 	mov	r9,438
80016d56:	40 0a       	lddsp	r10,sp[0x0]
80016d58:	0c 9c       	mov	r12,r6
80016d5a:	e0 a0 06 b1 	rcall	80017abc <_open_r>
80016d5e:	c0 74       	brge	80016d6c <_fopen_r+0x3c>
80016d60:	c4 6f       	rcall	80016bec <__sfp_lock_acquire>
80016d62:	30 08       	mov	r8,0
80016d64:	ae 68       	st.h	r7[0xc],r8
80016d66:	30 07       	mov	r7,0
80016d68:	c4 3f       	rcall	80016bee <__sfp_lock_release>
80016d6a:	c1 98       	rjmp	80016d9c <_fopen_r+0x6c>
80016d6c:	fe c8 ee 5c 	sub	r8,pc,-4516
80016d70:	8f 98       	st.w	r7[0x24],r8
80016d72:	fe c8 ee 92 	sub	r8,pc,-4462
80016d76:	8f a8       	st.w	r7[0x28],r8
80016d78:	fe c8 ee bc 	sub	r8,pc,-4420
80016d7c:	5c 85       	casts.h	r5
80016d7e:	8f b8       	st.w	r7[0x2c],r8
80016d80:	ae 65       	st.h	r7[0xc],r5
80016d82:	fe c8 ee d2 	sub	r8,pc,-4398
80016d86:	ae 7c       	st.h	r7[0xe],r12
80016d88:	8f 87       	st.w	r7[0x20],r7
80016d8a:	8f c8       	st.w	r7[0x30],r8
80016d8c:	e2 15 01 00 	andl	r5,0x100,COH
80016d90:	c0 60       	breq	80016d9c <_fopen_r+0x6c>
80016d92:	0c 9c       	mov	r12,r6
80016d94:	30 29       	mov	r9,2
80016d96:	30 0a       	mov	r10,0
80016d98:	0e 9b       	mov	r11,r7
80016d9a:	c8 5d       	rcall	800170a4 <_fseek_r>
80016d9c:	0e 9c       	mov	r12,r7
80016d9e:	2f fd       	sub	sp,-4
80016da0:	d8 22       	popm	r4-r7,pc
80016da2:	d7 03       	nop

80016da4 <fopen>:
80016da4:	d4 01       	pushm	lr
80016da6:	48 48       	lddpc	r8,80016db4 <fopen+0x10>
80016da8:	16 9a       	mov	r10,r11
80016daa:	18 9b       	mov	r11,r12
80016dac:	70 0c       	ld.w	r12,r8[0x0]
80016dae:	cc 1f       	rcall	80016d30 <_fopen_r>
80016db0:	d8 02       	popm	pc
80016db2:	d7 03       	nop
80016db4:	00 00       	add	r0,r0
80016db6:	01 9c       	ld.ub	r12,r0[0x1]

80016db8 <_fread_r>:
80016db8:	d4 31       	pushm	r0-r7,lr
80016dba:	14 90       	mov	r0,r10
80016dbc:	12 91       	mov	r1,r9
80016dbe:	16 93       	mov	r3,r11
80016dc0:	10 97       	mov	r7,r8
80016dc2:	18 95       	mov	r5,r12
80016dc4:	f2 0a 02 42 	mul	r2,r9,r10
80016dc8:	58 02       	cp.w	r2,0
80016dca:	c0 31       	brne	80016dd0 <_fread_r+0x18>
80016dcc:	04 91       	mov	r1,r2
80016dce:	c4 08       	rjmp	80016e4e <_fread_r+0x96>
80016dd0:	58 0c       	cp.w	r12,0
80016dd2:	c0 50       	breq	80016ddc <_fread_r+0x24>
80016dd4:	78 68       	ld.w	r8,r12[0x18]
80016dd6:	58 08       	cp.w	r8,0
80016dd8:	c0 21       	brne	80016ddc <_fread_r+0x24>
80016dda:	c5 df       	rcall	80016c94 <__sinit>
80016ddc:	49 e8       	lddpc	r8,80016e54 <_fread_r+0x9c>
80016dde:	10 37       	cp.w	r7,r8
80016de0:	c0 31       	brne	80016de6 <_fread_r+0x2e>
80016de2:	6a 07       	ld.w	r7,r5[0x0]
80016de4:	c0 a8       	rjmp	80016df8 <_fread_r+0x40>
80016de6:	49 d8       	lddpc	r8,80016e58 <_fread_r+0xa0>
80016de8:	10 37       	cp.w	r7,r8
80016dea:	c0 31       	brne	80016df0 <_fread_r+0x38>
80016dec:	6a 17       	ld.w	r7,r5[0x4]
80016dee:	c0 58       	rjmp	80016df8 <_fread_r+0x40>
80016df0:	49 b8       	lddpc	r8,80016e5c <_fread_r+0xa4>
80016df2:	10 37       	cp.w	r7,r8
80016df4:	eb f7 00 02 	ld.weq	r7,r5[0x8]
80016df8:	6e 18       	ld.w	r8,r7[0x4]
80016dfa:	58 08       	cp.w	r8,0
80016dfc:	c0 34       	brge	80016e02 <_fread_r+0x4a>
80016dfe:	30 08       	mov	r8,0
80016e00:	8f 18       	st.w	r7[0x4],r8
80016e02:	04 96       	mov	r6,r2
80016e04:	c1 48       	rjmp	80016e2c <_fread_r+0x74>
80016e06:	e0 a0 05 ad 	rcall	80017960 <memcpy>
80016e0a:	6e 08       	ld.w	r8,r7[0x0]
80016e0c:	08 03       	add	r3,r4
80016e0e:	08 16       	sub	r6,r4
80016e10:	0e 9b       	mov	r11,r7
80016e12:	f0 04 00 04 	add	r4,r8,r4
80016e16:	0a 9c       	mov	r12,r5
80016e18:	8f 04       	st.w	r7[0x0],r4
80016e1a:	e0 a0 07 03 	rcall	80017c20 <__srefill_r>
80016e1e:	c0 70       	breq	80016e2c <_fread_r+0x74>
80016e20:	e4 06 01 09 	sub	r9,r2,r6
80016e24:	f2 00 0d 08 	divu	r8,r9,r0
80016e28:	10 91       	mov	r1,r8
80016e2a:	c1 28       	rjmp	80016e4e <_fread_r+0x96>
80016e2c:	6e 14       	ld.w	r4,r7[0x4]
80016e2e:	6e 08       	ld.w	r8,r7[0x0]
80016e30:	06 9c       	mov	r12,r3
80016e32:	08 9a       	mov	r10,r4
80016e34:	10 9b       	mov	r11,r8
80016e36:	08 36       	cp.w	r6,r4
80016e38:	fe 9b ff e7 	brhi	80016e06 <_fread_r+0x4e>
80016e3c:	0c 9a       	mov	r10,r6
80016e3e:	e0 a0 05 91 	rcall	80017960 <memcpy>
80016e42:	6e 08       	ld.w	r8,r7[0x0]
80016e44:	0c 08       	add	r8,r6
80016e46:	8f 08       	st.w	r7[0x0],r8
80016e48:	6e 18       	ld.w	r8,r7[0x4]
80016e4a:	0c 18       	sub	r8,r6
80016e4c:	8f 18       	st.w	r7[0x4],r8
80016e4e:	02 9c       	mov	r12,r1
80016e50:	d8 32       	popm	r0-r7,pc
80016e52:	d7 03       	nop
80016e54:	80 07       	ld.sh	r7,r0[0x0]
80016e56:	0a 2c       	rsub	r12,r5
80016e58:	80 07       	ld.sh	r7,r0[0x0]
80016e5a:	0a 4c       	or	r12,r5
80016e5c:	80 07       	ld.sh	r7,r0[0x0]
80016e5e:	0a 6c       	and	r12,r5

80016e60 <fread>:
80016e60:	d4 01       	pushm	lr
80016e62:	12 98       	mov	r8,r9
80016e64:	14 99       	mov	r9,r10
80016e66:	16 9a       	mov	r10,r11
80016e68:	18 9b       	mov	r11,r12
80016e6a:	48 3c       	lddpc	r12,80016e74 <fread+0x14>
80016e6c:	78 0c       	ld.w	r12,r12[0x0]
80016e6e:	ca 5f       	rcall	80016db8 <_fread_r>
80016e70:	d8 02       	popm	pc
80016e72:	d7 03       	nop
80016e74:	00 00       	add	r0,r0
80016e76:	01 9c       	ld.ub	r12,r0[0x1]

80016e78 <_malloc_trim_r>:
80016e78:	d4 21       	pushm	r4-r7,lr
80016e7a:	16 95       	mov	r5,r11
80016e7c:	18 97       	mov	r7,r12
80016e7e:	e0 a0 06 1c 	rcall	80017ab6 <__malloc_lock>
80016e82:	4a 24       	lddpc	r4,80016f08 <_malloc_trim_r+0x90>
80016e84:	68 28       	ld.w	r8,r4[0x8]
80016e86:	70 16       	ld.w	r6,r8[0x4]
80016e88:	e0 16 ff fc 	andl	r6,0xfffc
80016e8c:	ec c8 ff 91 	sub	r8,r6,-111
80016e90:	f0 05 01 05 	sub	r5,r8,r5
80016e94:	e0 15 ff 80 	andl	r5,0xff80
80016e98:	ea c5 00 80 	sub	r5,r5,128
80016e9c:	e0 45 00 7f 	cp.w	r5,127
80016ea0:	e0 8a 00 23 	brle	80016ee6 <_malloc_trim_r+0x6e>
80016ea4:	30 0b       	mov	r11,0
80016ea6:	0e 9c       	mov	r12,r7
80016ea8:	e0 a0 07 46 	rcall	80017d34 <_sbrk_r>
80016eac:	68 28       	ld.w	r8,r4[0x8]
80016eae:	0c 08       	add	r8,r6
80016eb0:	10 3c       	cp.w	r12,r8
80016eb2:	c1 a1       	brne	80016ee6 <_malloc_trim_r+0x6e>
80016eb4:	ea 0b 11 00 	rsub	r11,r5,0
80016eb8:	0e 9c       	mov	r12,r7
80016eba:	e0 a0 07 3d 	rcall	80017d34 <_sbrk_r>
80016ebe:	5b fc       	cp.w	r12,-1
80016ec0:	c1 71       	brne	80016eee <_malloc_trim_r+0x76>
80016ec2:	30 0b       	mov	r11,0
80016ec4:	0e 9c       	mov	r12,r7
80016ec6:	e0 a0 07 37 	rcall	80017d34 <_sbrk_r>
80016eca:	68 28       	ld.w	r8,r4[0x8]
80016ecc:	f8 08 01 09 	sub	r9,r12,r8
80016ed0:	58 f9       	cp.w	r9,15
80016ed2:	e0 8a 00 0a 	brle	80016ee6 <_malloc_trim_r+0x6e>
80016ed6:	a1 a9       	sbr	r9,0x0
80016ed8:	91 19       	st.w	r8[0x4],r9
80016eda:	48 d8       	lddpc	r8,80016f0c <_malloc_trim_r+0x94>
80016edc:	70 09       	ld.w	r9,r8[0x0]
80016ede:	48 d8       	lddpc	r8,80016f10 <_malloc_trim_r+0x98>
80016ee0:	f8 09 01 09 	sub	r9,r12,r9
80016ee4:	91 09       	st.w	r8[0x0],r9
80016ee6:	0e 9c       	mov	r12,r7
80016ee8:	e0 a0 05 e8 	rcall	80017ab8 <__malloc_unlock>
80016eec:	d8 2a       	popm	r4-r7,pc,r12=0
80016eee:	68 28       	ld.w	r8,r4[0x8]
80016ef0:	0a 16       	sub	r6,r5
80016ef2:	a1 a6       	sbr	r6,0x0
80016ef4:	91 16       	st.w	r8[0x4],r6
80016ef6:	48 78       	lddpc	r8,80016f10 <_malloc_trim_r+0x98>
80016ef8:	70 09       	ld.w	r9,r8[0x0]
80016efa:	0a 19       	sub	r9,r5
80016efc:	0e 9c       	mov	r12,r7
80016efe:	91 09       	st.w	r8[0x0],r9
80016f00:	e0 a0 05 dc 	rcall	80017ab8 <__malloc_unlock>
80016f04:	da 2a       	popm	r4-r7,pc,r12=1
80016f06:	d7 03       	nop
80016f08:	00 00       	add	r0,r0
80016f0a:	01 a0       	ld.ub	r0,r0[0x2]
80016f0c:	00 00       	add	r0,r0
80016f0e:	05 ac       	ld.ub	r12,r2[0x2]
80016f10:	00 00       	add	r0,r0
80016f12:	3b 60       	mov	r0,-74

80016f14 <_free_r>:
80016f14:	d4 21       	pushm	r4-r7,lr
80016f16:	16 96       	mov	r6,r11
80016f18:	18 97       	mov	r7,r12
80016f1a:	58 0b       	cp.w	r11,0
80016f1c:	e0 80 00 c2 	breq	800170a0 <_free_r+0x18c>
80016f20:	e0 a0 05 cb 	rcall	80017ab6 <__malloc_lock>
80016f24:	20 86       	sub	r6,8
80016f26:	4c ba       	lddpc	r10,80017050 <_free_r+0x13c>
80016f28:	6c 18       	ld.w	r8,r6[0x4]
80016f2a:	74 2e       	ld.w	lr,r10[0x8]
80016f2c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80016f30:	a1 c8       	cbr	r8,0x0
80016f32:	ec 08 00 09 	add	r9,r6,r8
80016f36:	72 1b       	ld.w	r11,r9[0x4]
80016f38:	e0 1b ff fc 	andl	r11,0xfffc
80016f3c:	1c 39       	cp.w	r9,lr
80016f3e:	c1 c1       	brne	80016f76 <_free_r+0x62>
80016f40:	f6 08 00 08 	add	r8,r11,r8
80016f44:	58 0c       	cp.w	r12,0
80016f46:	c0 81       	brne	80016f56 <_free_r+0x42>
80016f48:	6c 09       	ld.w	r9,r6[0x0]
80016f4a:	12 16       	sub	r6,r9
80016f4c:	12 08       	add	r8,r9
80016f4e:	6c 3b       	ld.w	r11,r6[0xc]
80016f50:	6c 29       	ld.w	r9,r6[0x8]
80016f52:	97 29       	st.w	r11[0x8],r9
80016f54:	93 3b       	st.w	r9[0xc],r11
80016f56:	10 99       	mov	r9,r8
80016f58:	95 26       	st.w	r10[0x8],r6
80016f5a:	a1 a9       	sbr	r9,0x0
80016f5c:	8d 19       	st.w	r6[0x4],r9
80016f5e:	4b e9       	lddpc	r9,80017054 <_free_r+0x140>
80016f60:	72 09       	ld.w	r9,r9[0x0]
80016f62:	12 38       	cp.w	r8,r9
80016f64:	c0 53       	brcs	80016f6e <_free_r+0x5a>
80016f66:	4b d8       	lddpc	r8,80017058 <_free_r+0x144>
80016f68:	0e 9c       	mov	r12,r7
80016f6a:	70 0b       	ld.w	r11,r8[0x0]
80016f6c:	c8 6f       	rcall	80016e78 <_malloc_trim_r>
80016f6e:	0e 9c       	mov	r12,r7
80016f70:	e0 a0 05 a4 	rcall	80017ab8 <__malloc_unlock>
80016f74:	d8 22       	popm	r4-r7,pc
80016f76:	93 1b       	st.w	r9[0x4],r11
80016f78:	58 0c       	cp.w	r12,0
80016f7a:	c0 30       	breq	80016f80 <_free_r+0x6c>
80016f7c:	30 0c       	mov	r12,0
80016f7e:	c1 08       	rjmp	80016f9e <_free_r+0x8a>
80016f80:	6c 0e       	ld.w	lr,r6[0x0]
80016f82:	f4 c5 ff f8 	sub	r5,r10,-8
80016f86:	1c 16       	sub	r6,lr
80016f88:	1c 08       	add	r8,lr
80016f8a:	6c 2e       	ld.w	lr,r6[0x8]
80016f8c:	0a 3e       	cp.w	lr,r5
80016f8e:	f9 bc 00 01 	moveq	r12,1
80016f92:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80016f96:	eb fe 1a 02 	st.wne	r5[0x8],lr
80016f9a:	fd f5 1a 03 	st.wne	lr[0xc],r5
80016f9e:	f2 0b 00 0e 	add	lr,r9,r11
80016fa2:	7c 1e       	ld.w	lr,lr[0x4]
80016fa4:	ed be 00 00 	bld	lr,0x0
80016fa8:	c1 30       	breq	80016fce <_free_r+0xba>
80016faa:	16 08       	add	r8,r11
80016fac:	58 0c       	cp.w	r12,0
80016fae:	c0 c1       	brne	80016fc6 <_free_r+0xb2>
80016fb0:	4a 8e       	lddpc	lr,80017050 <_free_r+0x13c>
80016fb2:	72 2b       	ld.w	r11,r9[0x8]
80016fb4:	2f 8e       	sub	lr,-8
80016fb6:	1c 3b       	cp.w	r11,lr
80016fb8:	c0 71       	brne	80016fc6 <_free_r+0xb2>
80016fba:	97 36       	st.w	r11[0xc],r6
80016fbc:	97 26       	st.w	r11[0x8],r6
80016fbe:	8d 2b       	st.w	r6[0x8],r11
80016fc0:	8d 3b       	st.w	r6[0xc],r11
80016fc2:	30 1c       	mov	r12,1
80016fc4:	c0 58       	rjmp	80016fce <_free_r+0xba>
80016fc6:	72 2b       	ld.w	r11,r9[0x8]
80016fc8:	72 39       	ld.w	r9,r9[0xc]
80016fca:	93 2b       	st.w	r9[0x8],r11
80016fcc:	97 39       	st.w	r11[0xc],r9
80016fce:	10 99       	mov	r9,r8
80016fd0:	ec 08 09 08 	st.w	r6[r8],r8
80016fd4:	a1 a9       	sbr	r9,0x0
80016fd6:	8d 19       	st.w	r6[0x4],r9
80016fd8:	58 0c       	cp.w	r12,0
80016fda:	c6 01       	brne	8001709a <_free_r+0x186>
80016fdc:	e0 48 01 ff 	cp.w	r8,511
80016fe0:	e0 8b 00 13 	brhi	80017006 <_free_r+0xf2>
80016fe4:	a3 98       	lsr	r8,0x3
80016fe6:	f4 08 00 39 	add	r9,r10,r8<<0x3
80016fea:	72 2b       	ld.w	r11,r9[0x8]
80016fec:	8d 39       	st.w	r6[0xc],r9
80016fee:	8d 2b       	st.w	r6[0x8],r11
80016ff0:	97 36       	st.w	r11[0xc],r6
80016ff2:	93 26       	st.w	r9[0x8],r6
80016ff4:	a3 48       	asr	r8,0x2
80016ff6:	74 19       	ld.w	r9,r10[0x4]
80016ff8:	30 1b       	mov	r11,1
80016ffa:	f6 08 09 48 	lsl	r8,r11,r8
80016ffe:	f3 e8 10 08 	or	r8,r9,r8
80017002:	95 18       	st.w	r10[0x4],r8
80017004:	c4 b8       	rjmp	8001709a <_free_r+0x186>
80017006:	f0 0b 16 09 	lsr	r11,r8,0x9
8001700a:	58 4b       	cp.w	r11,4
8001700c:	e0 8b 00 06 	brhi	80017018 <_free_r+0x104>
80017010:	f0 0b 16 06 	lsr	r11,r8,0x6
80017014:	2c 8b       	sub	r11,-56
80017016:	c2 68       	rjmp	80017062 <_free_r+0x14e>
80017018:	59 4b       	cp.w	r11,20
8001701a:	e0 8b 00 04 	brhi	80017022 <_free_r+0x10e>
8001701e:	2a 5b       	sub	r11,-91
80017020:	c2 18       	rjmp	80017062 <_free_r+0x14e>
80017022:	e0 4b 00 54 	cp.w	r11,84
80017026:	e0 8b 00 06 	brhi	80017032 <_free_r+0x11e>
8001702a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8001702e:	29 2b       	sub	r11,-110
80017030:	c1 98       	rjmp	80017062 <_free_r+0x14e>
80017032:	e0 4b 01 54 	cp.w	r11,340
80017036:	e0 8b 00 06 	brhi	80017042 <_free_r+0x12e>
8001703a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8001703e:	28 9b       	sub	r11,-119
80017040:	c1 18       	rjmp	80017062 <_free_r+0x14e>
80017042:	e0 4b 05 54 	cp.w	r11,1364
80017046:	e0 88 00 0b 	brls	8001705c <_free_r+0x148>
8001704a:	37 eb       	mov	r11,126
8001704c:	c0 b8       	rjmp	80017062 <_free_r+0x14e>
8001704e:	d7 03       	nop
80017050:	00 00       	add	r0,r0
80017052:	01 a0       	ld.ub	r0,r0[0x2]
80017054:	00 00       	add	r0,r0
80017056:	05 a8       	ld.ub	r8,r2[0x2]
80017058:	00 00       	add	r0,r0
8001705a:	3b 5c       	mov	r12,-75
8001705c:	f0 0b 16 12 	lsr	r11,r8,0x12
80017060:	28 4b       	sub	r11,-124
80017062:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80017066:	78 29       	ld.w	r9,r12[0x8]
80017068:	18 39       	cp.w	r9,r12
8001706a:	c0 e1       	brne	80017086 <_free_r+0x172>
8001706c:	74 18       	ld.w	r8,r10[0x4]
8001706e:	a3 4b       	asr	r11,0x2
80017070:	30 1c       	mov	r12,1
80017072:	f8 0b 09 4b 	lsl	r11,r12,r11
80017076:	f1 eb 10 0b 	or	r11,r8,r11
8001707a:	12 98       	mov	r8,r9
8001707c:	95 1b       	st.w	r10[0x4],r11
8001707e:	c0 a8       	rjmp	80017092 <_free_r+0x17e>
80017080:	72 29       	ld.w	r9,r9[0x8]
80017082:	18 39       	cp.w	r9,r12
80017084:	c0 60       	breq	80017090 <_free_r+0x17c>
80017086:	72 1a       	ld.w	r10,r9[0x4]
80017088:	e0 1a ff fc 	andl	r10,0xfffc
8001708c:	14 38       	cp.w	r8,r10
8001708e:	cf 93       	brcs	80017080 <_free_r+0x16c>
80017090:	72 38       	ld.w	r8,r9[0xc]
80017092:	8d 38       	st.w	r6[0xc],r8
80017094:	8d 29       	st.w	r6[0x8],r9
80017096:	93 36       	st.w	r9[0xc],r6
80017098:	91 26       	st.w	r8[0x8],r6
8001709a:	0e 9c       	mov	r12,r7
8001709c:	e0 a0 05 0e 	rcall	80017ab8 <__malloc_unlock>
800170a0:	d8 22       	popm	r4-r7,pc
800170a2:	d7 03       	nop

800170a4 <_fseek_r>:
800170a4:	d4 31       	pushm	r0-r7,lr
800170a6:	20 fd       	sub	sp,60
800170a8:	16 97       	mov	r7,r11
800170aa:	14 91       	mov	r1,r10
800170ac:	12 95       	mov	r5,r9
800170ae:	18 96       	mov	r6,r12
800170b0:	58 0c       	cp.w	r12,0
800170b2:	c0 60       	breq	800170be <_fseek_r+0x1a>
800170b4:	78 68       	ld.w	r8,r12[0x18]
800170b6:	58 08       	cp.w	r8,0
800170b8:	c0 31       	brne	800170be <_fseek_r+0x1a>
800170ba:	fe b0 fd ed 	rcall	80016c94 <__sinit>
800170be:	4c 48       	lddpc	r8,800171cc <_fseek_r+0x128>
800170c0:	10 37       	cp.w	r7,r8
800170c2:	c0 31       	brne	800170c8 <_fseek_r+0x24>
800170c4:	6c 07       	ld.w	r7,r6[0x0]
800170c6:	c0 a8       	rjmp	800170da <_fseek_r+0x36>
800170c8:	4c 28       	lddpc	r8,800171d0 <_fseek_r+0x12c>
800170ca:	10 37       	cp.w	r7,r8
800170cc:	c0 31       	brne	800170d2 <_fseek_r+0x2e>
800170ce:	6c 17       	ld.w	r7,r6[0x4]
800170d0:	c0 58       	rjmp	800170da <_fseek_r+0x36>
800170d2:	4c 18       	lddpc	r8,800171d4 <_fseek_r+0x130>
800170d4:	10 37       	cp.w	r7,r8
800170d6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800170da:	8e 68       	ld.sh	r8,r7[0xc]
800170dc:	e2 18 01 08 	andl	r8,0x108,COH
800170e0:	e0 48 01 08 	cp.w	r8,264
800170e4:	c0 51       	brne	800170ee <_fseek_r+0x4a>
800170e6:	0e 9b       	mov	r11,r7
800170e8:	0c 9c       	mov	r12,r6
800170ea:	fe b0 fc e5 	rcall	80016ab4 <_fflush_r>
800170ee:	6e b3       	ld.w	r3,r7[0x2c]
800170f0:	58 03       	cp.w	r3,0
800170f2:	c0 31       	brne	800170f8 <_fseek_r+0x54>
800170f4:	31 d8       	mov	r8,29
800170f6:	c3 78       	rjmp	80017164 <_fseek_r+0xc0>
800170f8:	58 15       	cp.w	r5,1
800170fa:	c0 60       	breq	80017106 <_fseek_r+0x62>
800170fc:	58 25       	cp.w	r5,2
800170fe:	c3 50       	breq	80017168 <_fseek_r+0xc4>
80017100:	58 05       	cp.w	r5,0
80017102:	c3 30       	breq	80017168 <_fseek_r+0xc4>
80017104:	c2 f8       	rjmp	80017162 <_fseek_r+0xbe>
80017106:	0e 9b       	mov	r11,r7
80017108:	0c 9c       	mov	r12,r6
8001710a:	fe b0 fc d5 	rcall	80016ab4 <_fflush_r>
8001710e:	8e 6a       	ld.sh	r10,r7[0xc]
80017110:	e2 1a 10 00 	andl	r10,0x1000,COH
80017114:	c0 30       	breq	8001711a <_fseek_r+0x76>
80017116:	6f 52       	ld.w	r2,r7[0x54]
80017118:	c0 98       	rjmp	8001712a <_fseek_r+0x86>
8001711a:	0a 99       	mov	r9,r5
8001711c:	6e 8b       	ld.w	r11,r7[0x20]
8001711e:	0c 9c       	mov	r12,r6
80017120:	5d 13       	icall	r3
80017122:	18 92       	mov	r2,r12
80017124:	5b fc       	cp.w	r12,-1
80017126:	e0 80 01 02 	breq	8001732a <_fseek_r+0x286>
8001712a:	8e 68       	ld.sh	r8,r7[0xc]
8001712c:	10 99       	mov	r9,r8
8001712e:	ed b8 00 02 	bld	r8,0x2
80017132:	c0 91       	brne	80017144 <_fseek_r+0xa0>
80017134:	6e 18       	ld.w	r8,r7[0x4]
80017136:	10 12       	sub	r2,r8
80017138:	6e d8       	ld.w	r8,r7[0x34]
8001713a:	58 08       	cp.w	r8,0
8001713c:	c0 f0       	breq	8001715a <_fseek_r+0xb6>
8001713e:	6f 08       	ld.w	r8,r7[0x40]
80017140:	10 12       	sub	r2,r8
80017142:	c0 c8       	rjmp	8001715a <_fseek_r+0xb6>
80017144:	ed b8 00 03 	bld	r8,0x3
80017148:	c0 91       	brne	8001715a <_fseek_r+0xb6>
8001714a:	6e 08       	ld.w	r8,r7[0x0]
8001714c:	58 08       	cp.w	r8,0
8001714e:	ef f9 10 04 	ld.wne	r9,r7[0x10]
80017152:	f1 d9 e1 18 	subne	r8,r8,r9
80017156:	e5 d8 e1 02 	addne	r2,r2,r8
8001715a:	04 01       	add	r1,r2
8001715c:	30 05       	mov	r5,0
8001715e:	30 10       	mov	r0,1
80017160:	c0 68       	rjmp	8001716c <_fseek_r+0xc8>
80017162:	31 68       	mov	r8,22
80017164:	8d 38       	st.w	r6[0xc],r8
80017166:	ce 28       	rjmp	8001732a <_fseek_r+0x286>
80017168:	30 00       	mov	r0,0
8001716a:	00 92       	mov	r2,r0
8001716c:	6e 48       	ld.w	r8,r7[0x10]
8001716e:	58 08       	cp.w	r8,0
80017170:	c0 41       	brne	80017178 <_fseek_r+0xd4>
80017172:	0e 9b       	mov	r11,r7
80017174:	0c 9c       	mov	r12,r6
80017176:	c8 3d       	rcall	8001747c <__smakebuf_r>
80017178:	8e 68       	ld.sh	r8,r7[0xc]
8001717a:	10 99       	mov	r9,r8
8001717c:	e2 19 08 1a 	andl	r9,0x81a,COH
80017180:	e0 81 00 b5 	brne	800172ea <_fseek_r+0x246>
80017184:	e2 18 04 00 	andl	r8,0x400,COH
80017188:	c1 e1       	brne	800171c4 <_fseek_r+0x120>
8001718a:	fe c9 f2 ce 	sub	r9,pc,-3378
8001718e:	12 33       	cp.w	r3,r9
80017190:	c0 f1       	brne	800171ae <_fseek_r+0x10a>
80017192:	8e 7b       	ld.sh	r11,r7[0xe]
80017194:	f0 0b 19 00 	cp.h	r11,r8
80017198:	c0 b5       	brlt	800171ae <_fseek_r+0x10a>
8001719a:	1a 9a       	mov	r10,sp
8001719c:	0c 9c       	mov	r12,r6
8001719e:	cc 9c       	rcall	80017330 <_fstat_r>
800171a0:	c0 71       	brne	800171ae <_fseek_r+0x10a>
800171a2:	40 18       	lddsp	r8,sp[0x4]
800171a4:	e2 18 f0 00 	andl	r8,0xf000,COH
800171a8:	e0 48 80 00 	cp.w	r8,32768
800171ac:	c0 50       	breq	800171b6 <_fseek_r+0x112>
800171ae:	8e 68       	ld.sh	r8,r7[0xc]
800171b0:	ab b8       	sbr	r8,0xb
800171b2:	ae 68       	st.h	r7[0xc],r8
800171b4:	c9 b8       	rjmp	800172ea <_fseek_r+0x246>
800171b6:	8e 68       	ld.sh	r8,r7[0xc]
800171b8:	ab a8       	sbr	r8,0xa
800171ba:	ae 68       	st.h	r7[0xc],r8
800171bc:	e0 68 04 00 	mov	r8,1024
800171c0:	ef 48 00 50 	st.w	r7[80],r8
800171c4:	58 05       	cp.w	r5,0
800171c6:	c0 91       	brne	800171d8 <_fseek_r+0x134>
800171c8:	02 94       	mov	r4,r1
800171ca:	c1 08       	rjmp	800171ea <_fseek_r+0x146>
800171cc:	80 07       	ld.sh	r7,r0[0x0]
800171ce:	0a 2c       	rsub	r12,r5
800171d0:	80 07       	ld.sh	r7,r0[0x0]
800171d2:	0a 4c       	or	r12,r5
800171d4:	80 07       	ld.sh	r7,r0[0x0]
800171d6:	0a 6c       	and	r12,r5
800171d8:	1a 9a       	mov	r10,sp
800171da:	8e 7b       	ld.sh	r11,r7[0xe]
800171dc:	0c 9c       	mov	r12,r6
800171de:	ca 9c       	rcall	80017330 <_fstat_r>
800171e0:	e0 81 00 85 	brne	800172ea <_fseek_r+0x246>
800171e4:	40 44       	lddsp	r4,sp[0x10]
800171e6:	e2 04 00 04 	add	r4,r1,r4
800171ea:	58 00       	cp.w	r0,0
800171ec:	c1 71       	brne	8001721a <_fseek_r+0x176>
800171ee:	8e 68       	ld.sh	r8,r7[0xc]
800171f0:	ed b8 00 0c 	bld	r8,0xc
800171f4:	c0 31       	brne	800171fa <_fseek_r+0x156>
800171f6:	6f 5c       	ld.w	r12,r7[0x54]
800171f8:	c0 88       	rjmp	80017208 <_fseek_r+0x164>
800171fa:	00 9a       	mov	r10,r0
800171fc:	30 19       	mov	r9,1
800171fe:	6e 8b       	ld.w	r11,r7[0x20]
80017200:	0c 9c       	mov	r12,r6
80017202:	5d 13       	icall	r3
80017204:	5b fc       	cp.w	r12,-1
80017206:	c7 20       	breq	800172ea <_fseek_r+0x246>
80017208:	6e 12       	ld.w	r2,r7[0x4]
8001720a:	6e d8       	ld.w	r8,r7[0x34]
8001720c:	f8 02 01 02 	sub	r2,r12,r2
80017210:	58 08       	cp.w	r8,0
80017212:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80017216:	e5 d8 e1 12 	subne	r2,r2,r8
8001721a:	6e da       	ld.w	r10,r7[0x34]
8001721c:	6e 18       	ld.w	r8,r7[0x4]
8001721e:	6e 49       	ld.w	r9,r7[0x10]
80017220:	58 0a       	cp.w	r10,0
80017222:	c0 a0       	breq	80017236 <_fseek_r+0x192>
80017224:	10 02       	add	r2,r8
80017226:	6e f8       	ld.w	r8,r7[0x3c]
80017228:	f0 09 01 09 	sub	r9,r8,r9
8001722c:	6f 08       	ld.w	r8,r7[0x40]
8001722e:	12 12       	sub	r2,r9
80017230:	f2 08 00 08 	add	r8,r9,r8
80017234:	c0 78       	rjmp	80017242 <_fseek_r+0x19e>
80017236:	6e 0a       	ld.w	r10,r7[0x0]
80017238:	f4 09 01 09 	sub	r9,r10,r9
8001723c:	f2 08 00 08 	add	r8,r9,r8
80017240:	12 12       	sub	r2,r9
80017242:	04 34       	cp.w	r4,r2
80017244:	5f 4a       	srge	r10
80017246:	8e 69       	ld.sh	r9,r7[0xc]
80017248:	ec 19 20 00 	eorl	r9,0x2000
8001724c:	f5 e9 02 d9 	and	r9,r10,r9>>0xd
80017250:	c1 d0       	breq	8001728a <_fseek_r+0x1e6>
80017252:	e4 08 00 09 	add	r9,r2,r8
80017256:	12 34       	cp.w	r4,r9
80017258:	c1 92       	brcc	8001728a <_fseek_r+0x1e6>
8001725a:	e8 02 01 02 	sub	r2,r4,r2
8001725e:	6e 44       	ld.w	r4,r7[0x10]
80017260:	04 18       	sub	r8,r2
80017262:	e8 02 00 02 	add	r2,r4,r2
80017266:	8f 18       	st.w	r7[0x4],r8
80017268:	8f 02       	st.w	r7[0x0],r2
8001726a:	6e db       	ld.w	r11,r7[0x34]
8001726c:	58 0b       	cp.w	r11,0
8001726e:	c0 90       	breq	80017280 <_fseek_r+0x1dc>
80017270:	ee c8 ff bc 	sub	r8,r7,-68
80017274:	10 3b       	cp.w	r11,r8
80017276:	c0 30       	breq	8001727c <_fseek_r+0x1d8>
80017278:	0c 9c       	mov	r12,r6
8001727a:	c4 de       	rcall	80016f14 <_free_r>
8001727c:	30 08       	mov	r8,0
8001727e:	8f d8       	st.w	r7[0x34],r8
80017280:	8e 68       	ld.sh	r8,r7[0xc]
80017282:	30 0c       	mov	r12,0
80017284:	a5 d8       	cbr	r8,0x5
80017286:	ae 68       	st.h	r7[0xc],r8
80017288:	c5 28       	rjmp	8001732c <_fseek_r+0x288>
8001728a:	6f 42       	ld.w	r2,r7[0x50]
8001728c:	30 09       	mov	r9,0
8001728e:	5c 32       	neg	r2
80017290:	6e 8b       	ld.w	r11,r7[0x20]
80017292:	e9 e2 00 02 	and	r2,r4,r2
80017296:	0c 9c       	mov	r12,r6
80017298:	04 9a       	mov	r10,r2
8001729a:	5d 13       	icall	r3
8001729c:	5b fc       	cp.w	r12,-1
8001729e:	c2 60       	breq	800172ea <_fseek_r+0x246>
800172a0:	30 08       	mov	r8,0
800172a2:	8f 18       	st.w	r7[0x4],r8
800172a4:	6e 48       	ld.w	r8,r7[0x10]
800172a6:	8f 08       	st.w	r7[0x0],r8
800172a8:	6e db       	ld.w	r11,r7[0x34]
800172aa:	58 0b       	cp.w	r11,0
800172ac:	c0 90       	breq	800172be <_fseek_r+0x21a>
800172ae:	ee c8 ff bc 	sub	r8,r7,-68
800172b2:	10 3b       	cp.w	r11,r8
800172b4:	c0 30       	breq	800172ba <_fseek_r+0x216>
800172b6:	0c 9c       	mov	r12,r6
800172b8:	c2 ee       	rcall	80016f14 <_free_r>
800172ba:	30 08       	mov	r8,0
800172bc:	8f d8       	st.w	r7[0x34],r8
800172be:	8e 68       	ld.sh	r8,r7[0xc]
800172c0:	a5 d8       	cbr	r8,0x5
800172c2:	ae 68       	st.h	r7[0xc],r8
800172c4:	04 14       	sub	r4,r2
800172c6:	c0 31       	brne	800172cc <_fseek_r+0x228>
800172c8:	08 9c       	mov	r12,r4
800172ca:	c3 18       	rjmp	8001732c <_fseek_r+0x288>
800172cc:	0e 9b       	mov	r11,r7
800172ce:	0c 9c       	mov	r12,r6
800172d0:	e0 a0 04 a8 	rcall	80017c20 <__srefill_r>
800172d4:	c0 b1       	brne	800172ea <_fseek_r+0x246>
800172d6:	6e 18       	ld.w	r8,r7[0x4]
800172d8:	08 38       	cp.w	r8,r4
800172da:	c0 83       	brcs	800172ea <_fseek_r+0x246>
800172dc:	08 18       	sub	r8,r4
800172de:	6e 02       	ld.w	r2,r7[0x0]
800172e0:	8f 18       	st.w	r7[0x4],r8
800172e2:	e4 04 00 04 	add	r4,r2,r4
800172e6:	8f 04       	st.w	r7[0x0],r4
800172e8:	c2 28       	rjmp	8001732c <_fseek_r+0x288>
800172ea:	0e 9b       	mov	r11,r7
800172ec:	0c 9c       	mov	r12,r6
800172ee:	fe b0 fb e3 	rcall	80016ab4 <_fflush_r>
800172f2:	c1 c1       	brne	8001732a <_fseek_r+0x286>
800172f4:	0a 99       	mov	r9,r5
800172f6:	02 9a       	mov	r10,r1
800172f8:	6e 8b       	ld.w	r11,r7[0x20]
800172fa:	0c 9c       	mov	r12,r6
800172fc:	5d 13       	icall	r3
800172fe:	5b fc       	cp.w	r12,-1
80017300:	c1 50       	breq	8001732a <_fseek_r+0x286>
80017302:	6e db       	ld.w	r11,r7[0x34]
80017304:	58 0b       	cp.w	r11,0
80017306:	c0 90       	breq	80017318 <_fseek_r+0x274>
80017308:	ee c8 ff bc 	sub	r8,r7,-68
8001730c:	10 3b       	cp.w	r11,r8
8001730e:	c0 30       	breq	80017314 <_fseek_r+0x270>
80017310:	0c 9c       	mov	r12,r6
80017312:	c0 1e       	rcall	80016f14 <_free_r>
80017314:	30 08       	mov	r8,0
80017316:	8f d8       	st.w	r7[0x34],r8
80017318:	8e 68       	ld.sh	r8,r7[0xc]
8001731a:	e0 18 f7 df 	andl	r8,0xf7df
8001731e:	30 0c       	mov	r12,0
80017320:	ae 68       	st.h	r7[0xc],r8
80017322:	8f 1c       	st.w	r7[0x4],r12
80017324:	6e 48       	ld.w	r8,r7[0x10]
80017326:	8f 08       	st.w	r7[0x0],r8
80017328:	c0 28       	rjmp	8001732c <_fseek_r+0x288>
8001732a:	3f fc       	mov	r12,-1
8001732c:	2f 1d       	sub	sp,-60
8001732e:	d8 32       	popm	r0-r7,pc

80017330 <_fstat_r>:
80017330:	d4 21       	pushm	r4-r7,lr
80017332:	16 98       	mov	r8,r11
80017334:	18 97       	mov	r7,r12
80017336:	10 9c       	mov	r12,r8
80017338:	30 08       	mov	r8,0
8001733a:	48 76       	lddpc	r6,80017354 <_fstat_r+0x24>
8001733c:	14 9b       	mov	r11,r10
8001733e:	8d 08       	st.w	r6[0x0],r8
80017340:	e0 a0 06 5a 	rcall	80017ff4 <_fstat>
80017344:	5b fc       	cp.w	r12,-1
80017346:	c0 51       	brne	80017350 <_fstat_r+0x20>
80017348:	6c 08       	ld.w	r8,r6[0x0]
8001734a:	58 08       	cp.w	r8,0
8001734c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80017350:	d8 22       	popm	r4-r7,pc
80017352:	d7 03       	nop
80017354:	00 00       	add	r0,r0
80017356:	4f 74       	lddpc	r4,80017530 <__smakebuf_r+0xb4>

80017358 <_fwalk_reent>:
80017358:	d4 31       	pushm	r0-r7,lr
8001735a:	30 05       	mov	r5,0
8001735c:	18 93       	mov	r3,r12
8001735e:	16 90       	mov	r0,r11
80017360:	0a 91       	mov	r1,r5
80017362:	fe b0 fc 45 	rcall	80016bec <__sfp_lock_acquire>
80017366:	3f f2       	mov	r2,-1
80017368:	e6 c7 ff 28 	sub	r7,r3,-216
8001736c:	c1 78       	rjmp	8001739a <_fwalk_reent+0x42>
8001736e:	6e 26       	ld.w	r6,r7[0x8]
80017370:	6e 14       	ld.w	r4,r7[0x4]
80017372:	2f 46       	sub	r6,-12
80017374:	c0 d8       	rjmp	8001738e <_fwalk_reent+0x36>
80017376:	8c 08       	ld.sh	r8,r6[0x0]
80017378:	e2 08 19 00 	cp.h	r8,r1
8001737c:	c0 80       	breq	8001738c <_fwalk_reent+0x34>
8001737e:	8c 18       	ld.sh	r8,r6[0x2]
80017380:	e4 08 19 00 	cp.h	r8,r2
80017384:	c0 40       	breq	8001738c <_fwalk_reent+0x34>
80017386:	06 9c       	mov	r12,r3
80017388:	5d 10       	icall	r0
8001738a:	18 45       	or	r5,r12
8001738c:	2a 46       	sub	r6,-92
8001738e:	20 14       	sub	r4,1
80017390:	ec cb 00 0c 	sub	r11,r6,12
80017394:	58 04       	cp.w	r4,0
80017396:	cf 04       	brge	80017376 <_fwalk_reent+0x1e>
80017398:	6e 07       	ld.w	r7,r7[0x0]
8001739a:	58 07       	cp.w	r7,0
8001739c:	ce 91       	brne	8001736e <_fwalk_reent+0x16>
8001739e:	fe b0 fc 28 	rcall	80016bee <__sfp_lock_release>
800173a2:	0a 9c       	mov	r12,r5
800173a4:	d8 32       	popm	r0-r7,pc
800173a6:	d7 03       	nop

800173a8 <_fwalk>:
800173a8:	d4 31       	pushm	r0-r7,lr
800173aa:	30 05       	mov	r5,0
800173ac:	16 91       	mov	r1,r11
800173ae:	f8 c7 ff 28 	sub	r7,r12,-216
800173b2:	0a 92       	mov	r2,r5
800173b4:	fe b0 fc 1c 	rcall	80016bec <__sfp_lock_acquire>
800173b8:	3f f3       	mov	r3,-1
800173ba:	c1 68       	rjmp	800173e6 <_fwalk+0x3e>
800173bc:	6e 26       	ld.w	r6,r7[0x8]
800173be:	6e 14       	ld.w	r4,r7[0x4]
800173c0:	2f 46       	sub	r6,-12
800173c2:	c0 c8       	rjmp	800173da <_fwalk+0x32>
800173c4:	8c 08       	ld.sh	r8,r6[0x0]
800173c6:	e4 08 19 00 	cp.h	r8,r2
800173ca:	c0 70       	breq	800173d8 <_fwalk+0x30>
800173cc:	8c 18       	ld.sh	r8,r6[0x2]
800173ce:	e6 08 19 00 	cp.h	r8,r3
800173d2:	c0 30       	breq	800173d8 <_fwalk+0x30>
800173d4:	5d 11       	icall	r1
800173d6:	18 45       	or	r5,r12
800173d8:	2a 46       	sub	r6,-92
800173da:	20 14       	sub	r4,1
800173dc:	ec cc 00 0c 	sub	r12,r6,12
800173e0:	58 04       	cp.w	r4,0
800173e2:	cf 14       	brge	800173c4 <_fwalk+0x1c>
800173e4:	6e 07       	ld.w	r7,r7[0x0]
800173e6:	58 07       	cp.w	r7,0
800173e8:	ce a1       	brne	800173bc <_fwalk+0x14>
800173ea:	fe b0 fc 02 	rcall	80016bee <__sfp_lock_release>
800173ee:	0a 9c       	mov	r12,r5
800173f0:	d8 32       	popm	r0-r7,pc
800173f2:	d7 03       	nop

800173f4 <_fwrite_r>:
800173f4:	d4 31       	pushm	r0-r7,lr
800173f6:	20 5d       	sub	sp,20
800173f8:	12 96       	mov	r6,r9
800173fa:	fa c9 ff f4 	sub	r9,sp,-12
800173fe:	ec 0a 02 45 	mul	r5,r6,r10
80017402:	50 09       	stdsp	sp[0x0],r9
80017404:	50 3b       	stdsp	sp[0xc],r11
80017406:	30 19       	mov	r9,1
80017408:	50 45       	stdsp	sp[0x10],r5
8001740a:	50 25       	stdsp	sp[0x8],r5
8001740c:	50 19       	stdsp	sp[0x4],r9
8001740e:	14 97       	mov	r7,r10
80017410:	10 93       	mov	r3,r8
80017412:	18 94       	mov	r4,r12
80017414:	58 0c       	cp.w	r12,0
80017416:	c0 60       	breq	80017422 <_fwrite_r+0x2e>
80017418:	78 68       	ld.w	r8,r12[0x18]
8001741a:	58 08       	cp.w	r8,0
8001741c:	c0 31       	brne	80017422 <_fwrite_r+0x2e>
8001741e:	fe b0 fc 3b 	rcall	80016c94 <__sinit>
80017422:	48 e8       	lddpc	r8,80017458 <_fwrite_r+0x64>
80017424:	10 33       	cp.w	r3,r8
80017426:	c0 31       	brne	8001742c <_fwrite_r+0x38>
80017428:	68 03       	ld.w	r3,r4[0x0]
8001742a:	c0 a8       	rjmp	8001743e <_fwrite_r+0x4a>
8001742c:	48 c8       	lddpc	r8,8001745c <_fwrite_r+0x68>
8001742e:	10 33       	cp.w	r3,r8
80017430:	c0 31       	brne	80017436 <_fwrite_r+0x42>
80017432:	68 13       	ld.w	r3,r4[0x4]
80017434:	c0 58       	rjmp	8001743e <_fwrite_r+0x4a>
80017436:	48 b8       	lddpc	r8,80017460 <_fwrite_r+0x6c>
80017438:	10 33       	cp.w	r3,r8
8001743a:	e9 f3 00 02 	ld.weq	r3,r4[0x8]
8001743e:	06 9b       	mov	r11,r3
80017440:	08 9c       	mov	r12,r4
80017442:	1a 9a       	mov	r10,sp
80017444:	e0 a0 1e f4 	rcall	8001b22c <__sfvwrite_r>
80017448:	c0 50       	breq	80017452 <_fwrite_r+0x5e>
8001744a:	40 28       	lddsp	r8,sp[0x8]
8001744c:	10 15       	sub	r5,r8
8001744e:	ea 07 0d 06 	divu	r6,r5,r7
80017452:	0c 9c       	mov	r12,r6
80017454:	2f bd       	sub	sp,-20
80017456:	d8 32       	popm	r0-r7,pc
80017458:	80 07       	ld.sh	r7,r0[0x0]
8001745a:	0a 2c       	rsub	r12,r5
8001745c:	80 07       	ld.sh	r7,r0[0x0]
8001745e:	0a 4c       	or	r12,r5
80017460:	80 07       	ld.sh	r7,r0[0x0]
80017462:	0a 6c       	and	r12,r5

80017464 <fwrite>:
80017464:	d4 01       	pushm	lr
80017466:	12 98       	mov	r8,r9
80017468:	14 99       	mov	r9,r10
8001746a:	16 9a       	mov	r10,r11
8001746c:	18 9b       	mov	r11,r12
8001746e:	48 3c       	lddpc	r12,80017478 <fwrite+0x14>
80017470:	78 0c       	ld.w	r12,r12[0x0]
80017472:	cc 1f       	rcall	800173f4 <_fwrite_r>
80017474:	d8 02       	popm	pc
80017476:	d7 03       	nop
80017478:	00 00       	add	r0,r0
8001747a:	01 9c       	ld.ub	r12,r0[0x1]

8001747c <__smakebuf_r>:
8001747c:	d4 21       	pushm	r4-r7,lr
8001747e:	20 fd       	sub	sp,60
80017480:	96 68       	ld.sh	r8,r11[0xc]
80017482:	16 97       	mov	r7,r11
80017484:	18 96       	mov	r6,r12
80017486:	e2 18 00 02 	andl	r8,0x2,COH
8001748a:	c3 b1       	brne	80017500 <__smakebuf_r+0x84>
8001748c:	96 7b       	ld.sh	r11,r11[0xe]
8001748e:	f0 0b 19 00 	cp.h	r11,r8
80017492:	c0 45       	brlt	8001749a <__smakebuf_r+0x1e>
80017494:	1a 9a       	mov	r10,sp
80017496:	c4 df       	rcall	80017330 <_fstat_r>
80017498:	c0 f4       	brge	800174b6 <__smakebuf_r+0x3a>
8001749a:	8e 65       	ld.sh	r5,r7[0xc]
8001749c:	0a 98       	mov	r8,r5
8001749e:	ab b8       	sbr	r8,0xb
800174a0:	e2 15 00 80 	andl	r5,0x80,COH
800174a4:	ae 68       	st.h	r7[0xc],r8
800174a6:	30 04       	mov	r4,0
800174a8:	e0 68 04 00 	mov	r8,1024
800174ac:	f9 b5 01 40 	movne	r5,64
800174b0:	f0 05 17 00 	moveq	r5,r8
800174b4:	c1 c8       	rjmp	800174ec <__smakebuf_r+0x70>
800174b6:	40 18       	lddsp	r8,sp[0x4]
800174b8:	e2 18 f0 00 	andl	r8,0xf000,COH
800174bc:	e0 48 20 00 	cp.w	r8,8192
800174c0:	5f 04       	sreq	r4
800174c2:	e0 48 80 00 	cp.w	r8,32768
800174c6:	c0 e1       	brne	800174e2 <__smakebuf_r+0x66>
800174c8:	6e b9       	ld.w	r9,r7[0x2c]
800174ca:	fe c8 f6 0e 	sub	r8,pc,-2546
800174ce:	10 39       	cp.w	r9,r8
800174d0:	c0 91       	brne	800174e2 <__smakebuf_r+0x66>
800174d2:	8e 68       	ld.sh	r8,r7[0xc]
800174d4:	e0 65 04 00 	mov	r5,1024
800174d8:	ab a8       	sbr	r8,0xa
800174da:	ef 45 00 50 	st.w	r7[80],r5
800174de:	ae 68       	st.h	r7[0xc],r8
800174e0:	c0 68       	rjmp	800174ec <__smakebuf_r+0x70>
800174e2:	8e 68       	ld.sh	r8,r7[0xc]
800174e4:	e0 65 04 00 	mov	r5,1024
800174e8:	ab b8       	sbr	r8,0xb
800174ea:	ae 68       	st.h	r7[0xc],r8
800174ec:	0a 9b       	mov	r11,r5
800174ee:	0c 9c       	mov	r12,r6
800174f0:	c2 2c       	rcall	80017534 <_malloc_r>
800174f2:	8e 68       	ld.sh	r8,r7[0xc]
800174f4:	c0 d1       	brne	8001750e <__smakebuf_r+0x92>
800174f6:	ed b8 00 09 	bld	r8,0x9
800174fa:	c1 b0       	breq	80017530 <__smakebuf_r+0xb4>
800174fc:	a1 b8       	sbr	r8,0x1
800174fe:	ae 68       	st.h	r7[0xc],r8
80017500:	ee c8 ff b9 	sub	r8,r7,-71
80017504:	8f 48       	st.w	r7[0x10],r8
80017506:	8f 08       	st.w	r7[0x0],r8
80017508:	30 18       	mov	r8,1
8001750a:	8f 58       	st.w	r7[0x14],r8
8001750c:	c1 28       	rjmp	80017530 <__smakebuf_r+0xb4>
8001750e:	a7 b8       	sbr	r8,0x7
80017510:	8f 4c       	st.w	r7[0x10],r12
80017512:	ae 68       	st.h	r7[0xc],r8
80017514:	8f 55       	st.w	r7[0x14],r5
80017516:	fe c8 09 26 	sub	r8,pc,2342
8001751a:	8f 0c       	st.w	r7[0x0],r12
8001751c:	8d a8       	st.w	r6[0x28],r8
8001751e:	58 04       	cp.w	r4,0
80017520:	c0 80       	breq	80017530 <__smakebuf_r+0xb4>
80017522:	8e 7c       	ld.sh	r12,r7[0xe]
80017524:	e0 a0 05 50 	rcall	80017fc4 <isatty>
80017528:	c0 40       	breq	80017530 <__smakebuf_r+0xb4>
8001752a:	8e 68       	ld.sh	r8,r7[0xc]
8001752c:	a1 a8       	sbr	r8,0x0
8001752e:	ae 68       	st.h	r7[0xc],r8
80017530:	2f 1d       	sub	sp,-60
80017532:	d8 22       	popm	r4-r7,pc

80017534 <_malloc_r>:
80017534:	d4 31       	pushm	r0-r7,lr
80017536:	f6 c8 ff f5 	sub	r8,r11,-11
8001753a:	18 95       	mov	r5,r12
8001753c:	10 97       	mov	r7,r8
8001753e:	e0 17 ff f8 	andl	r7,0xfff8
80017542:	59 68       	cp.w	r8,22
80017544:	f9 b7 08 10 	movls	r7,16
80017548:	16 37       	cp.w	r7,r11
8001754a:	5f 38       	srlo	r8
8001754c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80017550:	c0 50       	breq	8001755a <_malloc_r+0x26>
80017552:	30 c8       	mov	r8,12
80017554:	99 38       	st.w	r12[0xc],r8
80017556:	e0 8f 01 ec 	bral	8001792e <_malloc_r+0x3fa>
8001755a:	e0 a0 02 ae 	rcall	80017ab6 <__malloc_lock>
8001755e:	e0 47 01 f7 	cp.w	r7,503
80017562:	e0 8b 00 1c 	brhi	8001759a <_malloc_r+0x66>
80017566:	ee 03 16 03 	lsr	r3,r7,0x3
8001756a:	4c c8       	lddpc	r8,80017698 <_malloc_r+0x164>
8001756c:	f0 03 00 38 	add	r8,r8,r3<<0x3
80017570:	70 36       	ld.w	r6,r8[0xc]
80017572:	10 36       	cp.w	r6,r8
80017574:	c0 61       	brne	80017580 <_malloc_r+0x4c>
80017576:	ec c8 ff f8 	sub	r8,r6,-8
8001757a:	70 36       	ld.w	r6,r8[0xc]
8001757c:	10 36       	cp.w	r6,r8
8001757e:	c0 c0       	breq	80017596 <_malloc_r+0x62>
80017580:	6c 18       	ld.w	r8,r6[0x4]
80017582:	e0 18 ff fc 	andl	r8,0xfffc
80017586:	6c 3a       	ld.w	r10,r6[0xc]
80017588:	ec 08 00 09 	add	r9,r6,r8
8001758c:	0a 9c       	mov	r12,r5
8001758e:	6c 28       	ld.w	r8,r6[0x8]
80017590:	95 28       	st.w	r10[0x8],r8
80017592:	91 3a       	st.w	r8[0xc],r10
80017594:	c4 68       	rjmp	80017620 <_malloc_r+0xec>
80017596:	2f e3       	sub	r3,-2
80017598:	c4 c8       	rjmp	80017630 <_malloc_r+0xfc>
8001759a:	ee 03 16 09 	lsr	r3,r7,0x9
8001759e:	c0 41       	brne	800175a6 <_malloc_r+0x72>
800175a0:	ee 03 16 03 	lsr	r3,r7,0x3
800175a4:	c2 68       	rjmp	800175f0 <_malloc_r+0xbc>
800175a6:	58 43       	cp.w	r3,4
800175a8:	e0 8b 00 06 	brhi	800175b4 <_malloc_r+0x80>
800175ac:	ee 03 16 06 	lsr	r3,r7,0x6
800175b0:	2c 83       	sub	r3,-56
800175b2:	c1 f8       	rjmp	800175f0 <_malloc_r+0xbc>
800175b4:	59 43       	cp.w	r3,20
800175b6:	e0 8b 00 04 	brhi	800175be <_malloc_r+0x8a>
800175ba:	2a 53       	sub	r3,-91
800175bc:	c1 a8       	rjmp	800175f0 <_malloc_r+0xbc>
800175be:	e0 43 00 54 	cp.w	r3,84
800175c2:	e0 8b 00 06 	brhi	800175ce <_malloc_r+0x9a>
800175c6:	ee 03 16 0c 	lsr	r3,r7,0xc
800175ca:	29 23       	sub	r3,-110
800175cc:	c1 28       	rjmp	800175f0 <_malloc_r+0xbc>
800175ce:	e0 43 01 54 	cp.w	r3,340
800175d2:	e0 8b 00 06 	brhi	800175de <_malloc_r+0xaa>
800175d6:	ee 03 16 0f 	lsr	r3,r7,0xf
800175da:	28 93       	sub	r3,-119
800175dc:	c0 a8       	rjmp	800175f0 <_malloc_r+0xbc>
800175de:	e0 43 05 54 	cp.w	r3,1364
800175e2:	e0 88 00 04 	brls	800175ea <_malloc_r+0xb6>
800175e6:	37 e3       	mov	r3,126
800175e8:	c0 48       	rjmp	800175f0 <_malloc_r+0xbc>
800175ea:	ee 03 16 12 	lsr	r3,r7,0x12
800175ee:	28 43       	sub	r3,-124
800175f0:	4a aa       	lddpc	r10,80017698 <_malloc_r+0x164>
800175f2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800175f6:	74 36       	ld.w	r6,r10[0xc]
800175f8:	c1 98       	rjmp	8001762a <_malloc_r+0xf6>
800175fa:	6c 19       	ld.w	r9,r6[0x4]
800175fc:	e0 19 ff fc 	andl	r9,0xfffc
80017600:	f2 07 01 0b 	sub	r11,r9,r7
80017604:	58 fb       	cp.w	r11,15
80017606:	e0 8a 00 04 	brle	8001760e <_malloc_r+0xda>
8001760a:	20 13       	sub	r3,1
8001760c:	c1 18       	rjmp	8001762e <_malloc_r+0xfa>
8001760e:	6c 38       	ld.w	r8,r6[0xc]
80017610:	58 0b       	cp.w	r11,0
80017612:	c0 b5       	brlt	80017628 <_malloc_r+0xf4>
80017614:	6c 2a       	ld.w	r10,r6[0x8]
80017616:	ec 09 00 09 	add	r9,r6,r9
8001761a:	0a 9c       	mov	r12,r5
8001761c:	91 2a       	st.w	r8[0x8],r10
8001761e:	95 38       	st.w	r10[0xc],r8
80017620:	72 18       	ld.w	r8,r9[0x4]
80017622:	a1 a8       	sbr	r8,0x0
80017624:	93 18       	st.w	r9[0x4],r8
80017626:	cb a8       	rjmp	8001779a <_malloc_r+0x266>
80017628:	10 96       	mov	r6,r8
8001762a:	14 36       	cp.w	r6,r10
8001762c:	ce 71       	brne	800175fa <_malloc_r+0xc6>
8001762e:	2f f3       	sub	r3,-1
80017630:	49 aa       	lddpc	r10,80017698 <_malloc_r+0x164>
80017632:	f4 cc ff f8 	sub	r12,r10,-8
80017636:	78 26       	ld.w	r6,r12[0x8]
80017638:	18 36       	cp.w	r6,r12
8001763a:	c6 c0       	breq	80017712 <_malloc_r+0x1de>
8001763c:	6c 19       	ld.w	r9,r6[0x4]
8001763e:	e0 19 ff fc 	andl	r9,0xfffc
80017642:	f2 07 01 08 	sub	r8,r9,r7
80017646:	58 f8       	cp.w	r8,15
80017648:	e0 89 00 8e 	brgt	80017764 <_malloc_r+0x230>
8001764c:	99 3c       	st.w	r12[0xc],r12
8001764e:	99 2c       	st.w	r12[0x8],r12
80017650:	58 08       	cp.w	r8,0
80017652:	c0 55       	brlt	8001765c <_malloc_r+0x128>
80017654:	ec 09 00 09 	add	r9,r6,r9
80017658:	0a 9c       	mov	r12,r5
8001765a:	ce 3b       	rjmp	80017620 <_malloc_r+0xec>
8001765c:	e0 49 01 ff 	cp.w	r9,511
80017660:	e0 8b 00 13 	brhi	80017686 <_malloc_r+0x152>
80017664:	a3 99       	lsr	r9,0x3
80017666:	f4 09 00 38 	add	r8,r10,r9<<0x3
8001766a:	70 2b       	ld.w	r11,r8[0x8]
8001766c:	8d 38       	st.w	r6[0xc],r8
8001766e:	8d 2b       	st.w	r6[0x8],r11
80017670:	97 36       	st.w	r11[0xc],r6
80017672:	91 26       	st.w	r8[0x8],r6
80017674:	a3 49       	asr	r9,0x2
80017676:	74 18       	ld.w	r8,r10[0x4]
80017678:	30 1b       	mov	r11,1
8001767a:	f6 09 09 49 	lsl	r9,r11,r9
8001767e:	f1 e9 10 09 	or	r9,r8,r9
80017682:	95 19       	st.w	r10[0x4],r9
80017684:	c4 78       	rjmp	80017712 <_malloc_r+0x1de>
80017686:	f2 0a 16 09 	lsr	r10,r9,0x9
8001768a:	58 4a       	cp.w	r10,4
8001768c:	e0 8b 00 08 	brhi	8001769c <_malloc_r+0x168>
80017690:	f2 0a 16 06 	lsr	r10,r9,0x6
80017694:	2c 8a       	sub	r10,-56
80017696:	c2 18       	rjmp	800176d8 <_malloc_r+0x1a4>
80017698:	00 00       	add	r0,r0
8001769a:	01 a0       	ld.ub	r0,r0[0x2]
8001769c:	59 4a       	cp.w	r10,20
8001769e:	e0 8b 00 04 	brhi	800176a6 <_malloc_r+0x172>
800176a2:	2a 5a       	sub	r10,-91
800176a4:	c1 a8       	rjmp	800176d8 <_malloc_r+0x1a4>
800176a6:	e0 4a 00 54 	cp.w	r10,84
800176aa:	e0 8b 00 06 	brhi	800176b6 <_malloc_r+0x182>
800176ae:	f2 0a 16 0c 	lsr	r10,r9,0xc
800176b2:	29 2a       	sub	r10,-110
800176b4:	c1 28       	rjmp	800176d8 <_malloc_r+0x1a4>
800176b6:	e0 4a 01 54 	cp.w	r10,340
800176ba:	e0 8b 00 06 	brhi	800176c6 <_malloc_r+0x192>
800176be:	f2 0a 16 0f 	lsr	r10,r9,0xf
800176c2:	28 9a       	sub	r10,-119
800176c4:	c0 a8       	rjmp	800176d8 <_malloc_r+0x1a4>
800176c6:	e0 4a 05 54 	cp.w	r10,1364
800176ca:	e0 88 00 04 	brls	800176d2 <_malloc_r+0x19e>
800176ce:	37 ea       	mov	r10,126
800176d0:	c0 48       	rjmp	800176d8 <_malloc_r+0x1a4>
800176d2:	f2 0a 16 12 	lsr	r10,r9,0x12
800176d6:	28 4a       	sub	r10,-124
800176d8:	4c 7b       	lddpc	r11,800177f4 <_malloc_r+0x2c0>
800176da:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800176de:	68 28       	ld.w	r8,r4[0x8]
800176e0:	08 38       	cp.w	r8,r4
800176e2:	c0 e1       	brne	800176fe <_malloc_r+0x1ca>
800176e4:	76 19       	ld.w	r9,r11[0x4]
800176e6:	a3 4a       	asr	r10,0x2
800176e8:	30 1e       	mov	lr,1
800176ea:	fc 0a 09 4a 	lsl	r10,lr,r10
800176ee:	f3 ea 10 0a 	or	r10,r9,r10
800176f2:	10 99       	mov	r9,r8
800176f4:	97 1a       	st.w	r11[0x4],r10
800176f6:	c0 a8       	rjmp	8001770a <_malloc_r+0x1d6>
800176f8:	70 28       	ld.w	r8,r8[0x8]
800176fa:	08 38       	cp.w	r8,r4
800176fc:	c0 60       	breq	80017708 <_malloc_r+0x1d4>
800176fe:	70 1a       	ld.w	r10,r8[0x4]
80017700:	e0 1a ff fc 	andl	r10,0xfffc
80017704:	14 39       	cp.w	r9,r10
80017706:	cf 93       	brcs	800176f8 <_malloc_r+0x1c4>
80017708:	70 39       	ld.w	r9,r8[0xc]
8001770a:	8d 39       	st.w	r6[0xc],r9
8001770c:	8d 28       	st.w	r6[0x8],r8
8001770e:	91 36       	st.w	r8[0xc],r6
80017710:	93 26       	st.w	r9[0x8],r6
80017712:	e6 08 14 02 	asr	r8,r3,0x2
80017716:	30 1b       	mov	r11,1
80017718:	4b 74       	lddpc	r4,800177f4 <_malloc_r+0x2c0>
8001771a:	f6 08 09 4b 	lsl	r11,r11,r8
8001771e:	68 18       	ld.w	r8,r4[0x4]
80017720:	10 3b       	cp.w	r11,r8
80017722:	e0 8b 00 6b 	brhi	800177f8 <_malloc_r+0x2c4>
80017726:	f7 e8 00 09 	and	r9,r11,r8
8001772a:	c0 b1       	brne	80017740 <_malloc_r+0x20c>
8001772c:	e0 13 ff fc 	andl	r3,0xfffc
80017730:	a1 7b       	lsl	r11,0x1
80017732:	2f c3       	sub	r3,-4
80017734:	c0 38       	rjmp	8001773a <_malloc_r+0x206>
80017736:	2f c3       	sub	r3,-4
80017738:	a1 7b       	lsl	r11,0x1
8001773a:	f7 e8 00 09 	and	r9,r11,r8
8001773e:	cf c0       	breq	80017736 <_malloc_r+0x202>
80017740:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80017744:	06 92       	mov	r2,r3
80017746:	1c 91       	mov	r1,lr
80017748:	62 36       	ld.w	r6,r1[0xc]
8001774a:	c2 d8       	rjmp	800177a4 <_malloc_r+0x270>
8001774c:	6c 1a       	ld.w	r10,r6[0x4]
8001774e:	e0 1a ff fc 	andl	r10,0xfffc
80017752:	f4 07 01 08 	sub	r8,r10,r7
80017756:	58 f8       	cp.w	r8,15
80017758:	e0 8a 00 15 	brle	80017782 <_malloc_r+0x24e>
8001775c:	6c 3a       	ld.w	r10,r6[0xc]
8001775e:	6c 29       	ld.w	r9,r6[0x8]
80017760:	95 29       	st.w	r10[0x8],r9
80017762:	93 3a       	st.w	r9[0xc],r10
80017764:	0e 99       	mov	r9,r7
80017766:	ec 07 00 07 	add	r7,r6,r7
8001776a:	a1 a9       	sbr	r9,0x0
8001776c:	99 37       	st.w	r12[0xc],r7
8001776e:	99 27       	st.w	r12[0x8],r7
80017770:	8d 19       	st.w	r6[0x4],r9
80017772:	ee 08 09 08 	st.w	r7[r8],r8
80017776:	8f 2c       	st.w	r7[0x8],r12
80017778:	8f 3c       	st.w	r7[0xc],r12
8001777a:	a1 a8       	sbr	r8,0x0
8001777c:	0a 9c       	mov	r12,r5
8001777e:	8f 18       	st.w	r7[0x4],r8
80017780:	c0 d8       	rjmp	8001779a <_malloc_r+0x266>
80017782:	6c 39       	ld.w	r9,r6[0xc]
80017784:	58 08       	cp.w	r8,0
80017786:	c0 e5       	brlt	800177a2 <_malloc_r+0x26e>
80017788:	ec 0a 00 0a 	add	r10,r6,r10
8001778c:	74 18       	ld.w	r8,r10[0x4]
8001778e:	a1 a8       	sbr	r8,0x0
80017790:	0a 9c       	mov	r12,r5
80017792:	95 18       	st.w	r10[0x4],r8
80017794:	6c 28       	ld.w	r8,r6[0x8]
80017796:	93 28       	st.w	r9[0x8],r8
80017798:	91 39       	st.w	r8[0xc],r9
8001779a:	c8 fd       	rcall	80017ab8 <__malloc_unlock>
8001779c:	ec cc ff f8 	sub	r12,r6,-8
800177a0:	d8 32       	popm	r0-r7,pc
800177a2:	12 96       	mov	r6,r9
800177a4:	02 36       	cp.w	r6,r1
800177a6:	cd 31       	brne	8001774c <_malloc_r+0x218>
800177a8:	2f f2       	sub	r2,-1
800177aa:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800177ae:	c0 30       	breq	800177b4 <_malloc_r+0x280>
800177b0:	2f 81       	sub	r1,-8
800177b2:	cc bb       	rjmp	80017748 <_malloc_r+0x214>
800177b4:	1c 98       	mov	r8,lr
800177b6:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800177ba:	c0 81       	brne	800177ca <_malloc_r+0x296>
800177bc:	68 19       	ld.w	r9,r4[0x4]
800177be:	f6 08 11 ff 	rsub	r8,r11,-1
800177c2:	f3 e8 00 08 	and	r8,r9,r8
800177c6:	89 18       	st.w	r4[0x4],r8
800177c8:	c0 78       	rjmp	800177d6 <_malloc_r+0x2a2>
800177ca:	f0 c9 00 08 	sub	r9,r8,8
800177ce:	20 13       	sub	r3,1
800177d0:	70 08       	ld.w	r8,r8[0x0]
800177d2:	12 38       	cp.w	r8,r9
800177d4:	cf 10       	breq	800177b6 <_malloc_r+0x282>
800177d6:	a1 7b       	lsl	r11,0x1
800177d8:	68 18       	ld.w	r8,r4[0x4]
800177da:	10 3b       	cp.w	r11,r8
800177dc:	e0 8b 00 0e 	brhi	800177f8 <_malloc_r+0x2c4>
800177e0:	58 0b       	cp.w	r11,0
800177e2:	c0 b0       	breq	800177f8 <_malloc_r+0x2c4>
800177e4:	04 93       	mov	r3,r2
800177e6:	c0 38       	rjmp	800177ec <_malloc_r+0x2b8>
800177e8:	2f c3       	sub	r3,-4
800177ea:	a1 7b       	lsl	r11,0x1
800177ec:	f7 e8 00 09 	and	r9,r11,r8
800177f0:	ca 81       	brne	80017740 <_malloc_r+0x20c>
800177f2:	cf bb       	rjmp	800177e8 <_malloc_r+0x2b4>
800177f4:	00 00       	add	r0,r0
800177f6:	01 a0       	ld.ub	r0,r0[0x2]
800177f8:	68 23       	ld.w	r3,r4[0x8]
800177fa:	66 12       	ld.w	r2,r3[0x4]
800177fc:	e0 12 ff fc 	andl	r2,0xfffc
80017800:	0e 32       	cp.w	r2,r7
80017802:	5f 39       	srlo	r9
80017804:	e4 07 01 08 	sub	r8,r2,r7
80017808:	58 f8       	cp.w	r8,15
8001780a:	5f aa       	srle	r10
8001780c:	f5 e9 10 09 	or	r9,r10,r9
80017810:	e0 80 00 9a 	breq	80017944 <_malloc_r+0x410>
80017814:	4c 78       	lddpc	r8,80017930 <_malloc_r+0x3fc>
80017816:	70 01       	ld.w	r1,r8[0x0]
80017818:	4c 78       	lddpc	r8,80017934 <_malloc_r+0x400>
8001781a:	2f 01       	sub	r1,-16
8001781c:	70 08       	ld.w	r8,r8[0x0]
8001781e:	0e 01       	add	r1,r7
80017820:	5b f8       	cp.w	r8,-1
80017822:	c0 40       	breq	8001782a <_malloc_r+0x2f6>
80017824:	28 11       	sub	r1,-127
80017826:	e0 11 ff 80 	andl	r1,0xff80
8001782a:	02 9b       	mov	r11,r1
8001782c:	0a 9c       	mov	r12,r5
8001782e:	e0 a0 02 83 	rcall	80017d34 <_sbrk_r>
80017832:	18 96       	mov	r6,r12
80017834:	5b fc       	cp.w	r12,-1
80017836:	c6 e0       	breq	80017912 <_malloc_r+0x3de>
80017838:	e6 02 00 08 	add	r8,r3,r2
8001783c:	10 3c       	cp.w	r12,r8
8001783e:	c0 32       	brcc	80017844 <_malloc_r+0x310>
80017840:	08 33       	cp.w	r3,r4
80017842:	c6 81       	brne	80017912 <_malloc_r+0x3de>
80017844:	4b da       	lddpc	r10,80017938 <_malloc_r+0x404>
80017846:	74 09       	ld.w	r9,r10[0x0]
80017848:	e2 09 00 09 	add	r9,r1,r9
8001784c:	95 09       	st.w	r10[0x0],r9
8001784e:	10 36       	cp.w	r6,r8
80017850:	c0 a1       	brne	80017864 <_malloc_r+0x330>
80017852:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80017856:	c0 71       	brne	80017864 <_malloc_r+0x330>
80017858:	e2 02 00 02 	add	r2,r1,r2
8001785c:	68 28       	ld.w	r8,r4[0x8]
8001785e:	a1 a2       	sbr	r2,0x0
80017860:	91 12       	st.w	r8[0x4],r2
80017862:	c4 c8       	rjmp	800178fa <_malloc_r+0x3c6>
80017864:	4b 4a       	lddpc	r10,80017934 <_malloc_r+0x400>
80017866:	74 0b       	ld.w	r11,r10[0x0]
80017868:	5b fb       	cp.w	r11,-1
8001786a:	c0 31       	brne	80017870 <_malloc_r+0x33c>
8001786c:	95 06       	st.w	r10[0x0],r6
8001786e:	c0 68       	rjmp	8001787a <_malloc_r+0x346>
80017870:	ec 09 00 09 	add	r9,r6,r9
80017874:	4b 1a       	lddpc	r10,80017938 <_malloc_r+0x404>
80017876:	10 19       	sub	r9,r8
80017878:	95 09       	st.w	r10[0x0],r9
8001787a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8001787e:	f0 09 11 08 	rsub	r9,r8,8
80017882:	58 08       	cp.w	r8,0
80017884:	f2 08 17 10 	movne	r8,r9
80017888:	ed d8 e1 06 	addne	r6,r6,r8
8001788c:	28 08       	sub	r8,-128
8001788e:	ec 01 00 01 	add	r1,r6,r1
80017892:	0a 9c       	mov	r12,r5
80017894:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80017898:	f0 01 01 01 	sub	r1,r8,r1
8001789c:	02 9b       	mov	r11,r1
8001789e:	e0 a0 02 4b 	rcall	80017d34 <_sbrk_r>
800178a2:	4a 68       	lddpc	r8,80017938 <_malloc_r+0x404>
800178a4:	5b fc       	cp.w	r12,-1
800178a6:	ec 0c 17 00 	moveq	r12,r6
800178aa:	f9 b1 00 00 	moveq	r1,0
800178ae:	70 09       	ld.w	r9,r8[0x0]
800178b0:	0c 1c       	sub	r12,r6
800178b2:	89 26       	st.w	r4[0x8],r6
800178b4:	02 0c       	add	r12,r1
800178b6:	12 01       	add	r1,r9
800178b8:	a1 ac       	sbr	r12,0x0
800178ba:	91 01       	st.w	r8[0x0],r1
800178bc:	8d 1c       	st.w	r6[0x4],r12
800178be:	08 33       	cp.w	r3,r4
800178c0:	c1 d0       	breq	800178fa <_malloc_r+0x3c6>
800178c2:	58 f2       	cp.w	r2,15
800178c4:	e0 8b 00 05 	brhi	800178ce <_malloc_r+0x39a>
800178c8:	30 18       	mov	r8,1
800178ca:	8d 18       	st.w	r6[0x4],r8
800178cc:	c2 38       	rjmp	80017912 <_malloc_r+0x3de>
800178ce:	30 59       	mov	r9,5
800178d0:	20 c2       	sub	r2,12
800178d2:	e0 12 ff f8 	andl	r2,0xfff8
800178d6:	e6 02 00 08 	add	r8,r3,r2
800178da:	91 29       	st.w	r8[0x8],r9
800178dc:	91 19       	st.w	r8[0x4],r9
800178de:	66 18       	ld.w	r8,r3[0x4]
800178e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800178e4:	e5 e8 10 08 	or	r8,r2,r8
800178e8:	87 18       	st.w	r3[0x4],r8
800178ea:	58 f2       	cp.w	r2,15
800178ec:	e0 88 00 07 	brls	800178fa <_malloc_r+0x3c6>
800178f0:	e6 cb ff f8 	sub	r11,r3,-8
800178f4:	0a 9c       	mov	r12,r5
800178f6:	fe b0 fb 0f 	rcall	80016f14 <_free_r>
800178fa:	49 19       	lddpc	r9,8001793c <_malloc_r+0x408>
800178fc:	72 0a       	ld.w	r10,r9[0x0]
800178fe:	48 f8       	lddpc	r8,80017938 <_malloc_r+0x404>
80017900:	70 08       	ld.w	r8,r8[0x0]
80017902:	14 38       	cp.w	r8,r10
80017904:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80017908:	48 e9       	lddpc	r9,80017940 <_malloc_r+0x40c>
8001790a:	72 0a       	ld.w	r10,r9[0x0]
8001790c:	14 38       	cp.w	r8,r10
8001790e:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80017912:	68 28       	ld.w	r8,r4[0x8]
80017914:	70 18       	ld.w	r8,r8[0x4]
80017916:	e0 18 ff fc 	andl	r8,0xfffc
8001791a:	0e 38       	cp.w	r8,r7
8001791c:	5f 39       	srlo	r9
8001791e:	0e 18       	sub	r8,r7
80017920:	58 f8       	cp.w	r8,15
80017922:	5f aa       	srle	r10
80017924:	f5 e9 10 09 	or	r9,r10,r9
80017928:	c0 e0       	breq	80017944 <_malloc_r+0x410>
8001792a:	0a 9c       	mov	r12,r5
8001792c:	cc 6c       	rcall	80017ab8 <__malloc_unlock>
8001792e:	d8 3a       	popm	r0-r7,pc,r12=0
80017930:	00 00       	add	r0,r0
80017932:	3b 5c       	mov	r12,-75
80017934:	00 00       	add	r0,r0
80017936:	05 ac       	ld.ub	r12,r2[0x2]
80017938:	00 00       	add	r0,r0
8001793a:	3b 60       	mov	r0,-74
8001793c:	00 00       	add	r0,r0
8001793e:	3b 58       	mov	r8,-75
80017940:	00 00       	add	r0,r0
80017942:	3b 54       	mov	r4,-75
80017944:	68 26       	ld.w	r6,r4[0x8]
80017946:	a1 a8       	sbr	r8,0x0
80017948:	0e 99       	mov	r9,r7
8001794a:	a1 a9       	sbr	r9,0x0
8001794c:	8d 19       	st.w	r6[0x4],r9
8001794e:	ec 07 00 07 	add	r7,r6,r7
80017952:	0a 9c       	mov	r12,r5
80017954:	89 27       	st.w	r4[0x8],r7
80017956:	8f 18       	st.w	r7[0x4],r8
80017958:	cb 0c       	rcall	80017ab8 <__malloc_unlock>
8001795a:	ec cc ff f8 	sub	r12,r6,-8
8001795e:	d8 32       	popm	r0-r7,pc

80017960 <memcpy>:
80017960:	58 8a       	cp.w	r10,8
80017962:	c2 f5       	brlt	800179c0 <memcpy+0x60>
80017964:	f9 eb 10 09 	or	r9,r12,r11
80017968:	e2 19 00 03 	andl	r9,0x3,COH
8001796c:	e0 81 00 97 	brne	80017a9a <memcpy+0x13a>
80017970:	e0 4a 00 20 	cp.w	r10,32
80017974:	c3 b4       	brge	800179ea <memcpy+0x8a>
80017976:	f4 08 14 02 	asr	r8,r10,0x2
8001797a:	f0 09 11 08 	rsub	r9,r8,8
8001797e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80017982:	76 69       	ld.w	r9,r11[0x18]
80017984:	99 69       	st.w	r12[0x18],r9
80017986:	76 59       	ld.w	r9,r11[0x14]
80017988:	99 59       	st.w	r12[0x14],r9
8001798a:	76 49       	ld.w	r9,r11[0x10]
8001798c:	99 49       	st.w	r12[0x10],r9
8001798e:	76 39       	ld.w	r9,r11[0xc]
80017990:	99 39       	st.w	r12[0xc],r9
80017992:	76 29       	ld.w	r9,r11[0x8]
80017994:	99 29       	st.w	r12[0x8],r9
80017996:	76 19       	ld.w	r9,r11[0x4]
80017998:	99 19       	st.w	r12[0x4],r9
8001799a:	76 09       	ld.w	r9,r11[0x0]
8001799c:	99 09       	st.w	r12[0x0],r9
8001799e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800179a2:	f8 08 00 28 	add	r8,r12,r8<<0x2
800179a6:	e0 1a 00 03 	andl	r10,0x3
800179aa:	f4 0a 11 04 	rsub	r10,r10,4
800179ae:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800179b2:	17 a9       	ld.ub	r9,r11[0x2]
800179b4:	b0 a9       	st.b	r8[0x2],r9
800179b6:	17 99       	ld.ub	r9,r11[0x1]
800179b8:	b0 99       	st.b	r8[0x1],r9
800179ba:	17 89       	ld.ub	r9,r11[0x0]
800179bc:	b0 89       	st.b	r8[0x0],r9
800179be:	5e fc       	retal	r12
800179c0:	f4 0a 11 09 	rsub	r10,r10,9
800179c4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800179c8:	17 f9       	ld.ub	r9,r11[0x7]
800179ca:	b8 f9       	st.b	r12[0x7],r9
800179cc:	17 e9       	ld.ub	r9,r11[0x6]
800179ce:	b8 e9       	st.b	r12[0x6],r9
800179d0:	17 d9       	ld.ub	r9,r11[0x5]
800179d2:	b8 d9       	st.b	r12[0x5],r9
800179d4:	17 c9       	ld.ub	r9,r11[0x4]
800179d6:	b8 c9       	st.b	r12[0x4],r9
800179d8:	17 b9       	ld.ub	r9,r11[0x3]
800179da:	b8 b9       	st.b	r12[0x3],r9
800179dc:	17 a9       	ld.ub	r9,r11[0x2]
800179de:	b8 a9       	st.b	r12[0x2],r9
800179e0:	17 99       	ld.ub	r9,r11[0x1]
800179e2:	b8 99       	st.b	r12[0x1],r9
800179e4:	17 89       	ld.ub	r9,r11[0x0]
800179e6:	b8 89       	st.b	r12[0x0],r9
800179e8:	5e fc       	retal	r12
800179ea:	eb cd 40 c0 	pushm	r6-r7,lr
800179ee:	18 99       	mov	r9,r12
800179f0:	22 0a       	sub	r10,32
800179f2:	b7 07       	ld.d	r6,r11++
800179f4:	b3 26       	st.d	r9++,r6
800179f6:	b7 07       	ld.d	r6,r11++
800179f8:	b3 26       	st.d	r9++,r6
800179fa:	b7 07       	ld.d	r6,r11++
800179fc:	b3 26       	st.d	r9++,r6
800179fe:	b7 07       	ld.d	r6,r11++
80017a00:	b3 26       	st.d	r9++,r6
80017a02:	22 0a       	sub	r10,32
80017a04:	cf 74       	brge	800179f2 <memcpy+0x92>
80017a06:	2f 0a       	sub	r10,-16
80017a08:	c0 65       	brlt	80017a14 <memcpy+0xb4>
80017a0a:	b7 07       	ld.d	r6,r11++
80017a0c:	b3 26       	st.d	r9++,r6
80017a0e:	b7 07       	ld.d	r6,r11++
80017a10:	b3 26       	st.d	r9++,r6
80017a12:	21 0a       	sub	r10,16
80017a14:	5c 3a       	neg	r10
80017a16:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80017a1a:	d7 03       	nop
80017a1c:	d7 03       	nop
80017a1e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80017a22:	f3 66 00 0e 	st.b	r9[14],r6
80017a26:	f7 36 00 0d 	ld.ub	r6,r11[13]
80017a2a:	f3 66 00 0d 	st.b	r9[13],r6
80017a2e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80017a32:	f3 66 00 0c 	st.b	r9[12],r6
80017a36:	f7 36 00 0b 	ld.ub	r6,r11[11]
80017a3a:	f3 66 00 0b 	st.b	r9[11],r6
80017a3e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80017a42:	f3 66 00 0a 	st.b	r9[10],r6
80017a46:	f7 36 00 09 	ld.ub	r6,r11[9]
80017a4a:	f3 66 00 09 	st.b	r9[9],r6
80017a4e:	f7 36 00 08 	ld.ub	r6,r11[8]
80017a52:	f3 66 00 08 	st.b	r9[8],r6
80017a56:	f7 36 00 07 	ld.ub	r6,r11[7]
80017a5a:	f3 66 00 07 	st.b	r9[7],r6
80017a5e:	f7 36 00 06 	ld.ub	r6,r11[6]
80017a62:	f3 66 00 06 	st.b	r9[6],r6
80017a66:	f7 36 00 05 	ld.ub	r6,r11[5]
80017a6a:	f3 66 00 05 	st.b	r9[5],r6
80017a6e:	f7 36 00 04 	ld.ub	r6,r11[4]
80017a72:	f3 66 00 04 	st.b	r9[4],r6
80017a76:	f7 36 00 03 	ld.ub	r6,r11[3]
80017a7a:	f3 66 00 03 	st.b	r9[3],r6
80017a7e:	f7 36 00 02 	ld.ub	r6,r11[2]
80017a82:	f3 66 00 02 	st.b	r9[2],r6
80017a86:	f7 36 00 01 	ld.ub	r6,r11[1]
80017a8a:	f3 66 00 01 	st.b	r9[1],r6
80017a8e:	f7 36 00 00 	ld.ub	r6,r11[0]
80017a92:	f3 66 00 00 	st.b	r9[0],r6
80017a96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80017a9a:	20 1a       	sub	r10,1
80017a9c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80017aa0:	f8 0a 0b 09 	st.b	r12[r10],r9
80017aa4:	cf b1       	brne	80017a9a <memcpy+0x13a>
80017aa6:	5e fc       	retal	r12

80017aa8 <memset>:
80017aa8:	18 98       	mov	r8,r12
80017aaa:	c0 38       	rjmp	80017ab0 <memset+0x8>
80017aac:	10 cb       	st.b	r8++,r11
80017aae:	20 1a       	sub	r10,1
80017ab0:	58 0a       	cp.w	r10,0
80017ab2:	cf d1       	brne	80017aac <memset+0x4>
80017ab4:	5e fc       	retal	r12

80017ab6 <__malloc_lock>:
80017ab6:	5e fc       	retal	r12

80017ab8 <__malloc_unlock>:
80017ab8:	5e fc       	retal	r12
80017aba:	d7 03       	nop

80017abc <_open_r>:
80017abc:	d4 21       	pushm	r4-r7,lr
80017abe:	16 98       	mov	r8,r11
80017ac0:	18 97       	mov	r7,r12
80017ac2:	10 9c       	mov	r12,r8
80017ac4:	30 08       	mov	r8,0
80017ac6:	14 9b       	mov	r11,r10
80017ac8:	48 66       	lddpc	r6,80017ae0 <_open_r+0x24>
80017aca:	12 9a       	mov	r10,r9
80017acc:	8d 08       	st.w	r6[0x0],r8
80017ace:	e0 a0 02 57 	rcall	80017f7c <_open>
80017ad2:	5b fc       	cp.w	r12,-1
80017ad4:	c0 51       	brne	80017ade <_open_r+0x22>
80017ad6:	6c 08       	ld.w	r8,r6[0x0]
80017ad8:	58 08       	cp.w	r8,0
80017ada:	ef f8 1a 03 	st.wne	r7[0xc],r8
80017ade:	d8 22       	popm	r4-r7,pc
80017ae0:	00 00       	add	r0,r0
80017ae2:	4f 74       	lddpc	r4,80017cbc <__srefill_r+0x9c>

80017ae4 <printf>:
80017ae4:	d4 21       	pushm	r4-r7,lr
80017ae6:	48 b8       	lddpc	r8,80017b10 <printf+0x2c>
80017ae8:	fa c4 ff ec 	sub	r4,sp,-20
80017aec:	18 96       	mov	r6,r12
80017aee:	70 07       	ld.w	r7,r8[0x0]
80017af0:	58 07       	cp.w	r7,0
80017af2:	c0 70       	breq	80017b00 <printf+0x1c>
80017af4:	6e 68       	ld.w	r8,r7[0x18]
80017af6:	58 08       	cp.w	r8,0
80017af8:	c0 41       	brne	80017b00 <printf+0x1c>
80017afa:	0e 9c       	mov	r12,r7
80017afc:	fe b0 f8 cc 	rcall	80016c94 <__sinit>
80017b00:	08 99       	mov	r9,r4
80017b02:	0c 9a       	mov	r10,r6
80017b04:	0e 9c       	mov	r12,r7
80017b06:	6e 1b       	ld.w	r11,r7[0x4]
80017b08:	e0 a0 04 58 	rcall	800183b8 <_vfprintf_r>
80017b0c:	d8 22       	popm	r4-r7,pc
80017b0e:	d7 03       	nop
80017b10:	00 00       	add	r0,r0
80017b12:	01 9c       	ld.ub	r12,r0[0x1]

80017b14 <putchar>:
80017b14:	d4 21       	pushm	r4-r7,lr
80017b16:	48 98       	lddpc	r8,80017b38 <putchar+0x24>
80017b18:	18 97       	mov	r7,r12
80017b1a:	70 0c       	ld.w	r12,r8[0x0]
80017b1c:	58 0c       	cp.w	r12,0
80017b1e:	c0 60       	breq	80017b2a <putchar+0x16>
80017b20:	78 68       	ld.w	r8,r12[0x18]
80017b22:	58 08       	cp.w	r8,0
80017b24:	c0 31       	brne	80017b2a <putchar+0x16>
80017b26:	fe b0 f8 b7 	rcall	80016c94 <__sinit>
80017b2a:	48 48       	lddpc	r8,80017b38 <putchar+0x24>
80017b2c:	70 08       	ld.w	r8,r8[0x0]
80017b2e:	0e 9b       	mov	r11,r7
80017b30:	10 9c       	mov	r12,r8
80017b32:	70 1a       	ld.w	r10,r8[0x4]
80017b34:	c0 4c       	rcall	80017b3c <_putc_r>
80017b36:	d8 22       	popm	r4-r7,pc
80017b38:	00 00       	add	r0,r0
80017b3a:	01 9c       	ld.ub	r12,r0[0x1]

80017b3c <_putc_r>:
80017b3c:	d4 21       	pushm	r4-r7,lr
80017b3e:	20 2d       	sub	sp,8
80017b40:	18 97       	mov	r7,r12
80017b42:	58 0c       	cp.w	r12,0
80017b44:	c0 a0       	breq	80017b58 <_putc_r+0x1c>
80017b46:	78 68       	ld.w	r8,r12[0x18]
80017b48:	58 08       	cp.w	r8,0
80017b4a:	c0 71       	brne	80017b58 <_putc_r+0x1c>
80017b4c:	50 1b       	stdsp	sp[0x4],r11
80017b4e:	50 0a       	stdsp	sp[0x0],r10
80017b50:	fe b0 f8 a2 	rcall	80016c94 <__sinit>
80017b54:	40 0a       	lddsp	r10,sp[0x0]
80017b56:	40 1b       	lddsp	r11,sp[0x4]
80017b58:	49 78       	lddpc	r8,80017bb4 <_putc_r+0x78>
80017b5a:	10 3a       	cp.w	r10,r8
80017b5c:	c0 31       	brne	80017b62 <_putc_r+0x26>
80017b5e:	6e 0a       	ld.w	r10,r7[0x0]
80017b60:	c0 a8       	rjmp	80017b74 <_putc_r+0x38>
80017b62:	49 68       	lddpc	r8,80017bb8 <_putc_r+0x7c>
80017b64:	10 3a       	cp.w	r10,r8
80017b66:	c0 31       	brne	80017b6c <_putc_r+0x30>
80017b68:	6e 1a       	ld.w	r10,r7[0x4]
80017b6a:	c0 58       	rjmp	80017b74 <_putc_r+0x38>
80017b6c:	49 48       	lddpc	r8,80017bbc <_putc_r+0x80>
80017b6e:	10 3a       	cp.w	r10,r8
80017b70:	ef fa 00 02 	ld.weq	r10,r7[0x8]
80017b74:	74 28       	ld.w	r8,r10[0x8]
80017b76:	20 18       	sub	r8,1
80017b78:	95 28       	st.w	r10[0x8],r8
80017b7a:	c1 57       	brpl	80017ba4 <_putc_r+0x68>
80017b7c:	74 69       	ld.w	r9,r10[0x18]
80017b7e:	12 38       	cp.w	r8,r9
80017b80:	c0 e5       	brlt	80017b9c <_putc_r+0x60>
80017b82:	74 08       	ld.w	r8,r10[0x0]
80017b84:	b0 8b       	st.b	r8[0x0],r11
80017b86:	30 a9       	mov	r9,10
80017b88:	74 08       	ld.w	r8,r10[0x0]
80017b8a:	11 8c       	ld.ub	r12,r8[0x0]
80017b8c:	f2 0c 18 00 	cp.b	r12,r9
80017b90:	c0 30       	breq	80017b96 <_putc_r+0x5a>
80017b92:	2f f8       	sub	r8,-1
80017b94:	c0 c8       	rjmp	80017bac <_putc_r+0x70>
80017b96:	0e 9c       	mov	r12,r7
80017b98:	30 ab       	mov	r11,10
80017b9a:	c0 28       	rjmp	80017b9e <_putc_r+0x62>
80017b9c:	0e 9c       	mov	r12,r7
80017b9e:	e0 a0 13 a3 	rcall	8001a2e4 <__swbuf_r>
80017ba2:	c0 68       	rjmp	80017bae <_putc_r+0x72>
80017ba4:	74 08       	ld.w	r8,r10[0x0]
80017ba6:	b0 8b       	st.b	r8[0x0],r11
80017ba8:	74 08       	ld.w	r8,r10[0x0]
80017baa:	11 3c       	ld.ub	r12,r8++
80017bac:	95 08       	st.w	r10[0x0],r8
80017bae:	2f ed       	sub	sp,-8
80017bb0:	d8 22       	popm	r4-r7,pc
80017bb2:	d7 03       	nop
80017bb4:	80 07       	ld.sh	r7,r0[0x0]
80017bb6:	0a 2c       	rsub	r12,r5
80017bb8:	80 07       	ld.sh	r7,r0[0x0]
80017bba:	0a 4c       	or	r12,r5
80017bbc:	80 07       	ld.sh	r7,r0[0x0]
80017bbe:	0a 6c       	and	r12,r5

80017bc0 <_puts_r>:
80017bc0:	d4 21       	pushm	r4-r7,lr
80017bc2:	20 7d       	sub	sp,28
80017bc4:	16 96       	mov	r6,r11
80017bc6:	18 97       	mov	r7,r12
80017bc8:	16 9c       	mov	r12,r11
80017bca:	cc dd       	rcall	80017f64 <strlen>
80017bcc:	f8 c8 ff ff 	sub	r8,r12,-1
80017bd0:	50 68       	stdsp	sp[0x18],r8
80017bd2:	48 f8       	lddpc	r8,80017c0c <_puts_r+0x4c>
80017bd4:	50 28       	stdsp	sp[0x8],r8
80017bd6:	30 18       	mov	r8,1
80017bd8:	50 06       	stdsp	sp[0x0],r6
80017bda:	50 38       	stdsp	sp[0xc],r8
80017bdc:	50 1c       	stdsp	sp[0x4],r12
80017bde:	30 28       	mov	r8,2
80017be0:	50 4d       	stdsp	sp[0x10],sp
80017be2:	50 58       	stdsp	sp[0x14],r8
80017be4:	58 07       	cp.w	r7,0
80017be6:	c0 70       	breq	80017bf4 <_puts_r+0x34>
80017be8:	6e 68       	ld.w	r8,r7[0x18]
80017bea:	58 08       	cp.w	r8,0
80017bec:	c0 41       	brne	80017bf4 <_puts_r+0x34>
80017bee:	0e 9c       	mov	r12,r7
80017bf0:	fe b0 f8 52 	rcall	80016c94 <__sinit>
80017bf4:	0e 9c       	mov	r12,r7
80017bf6:	fa ca ff f0 	sub	r10,sp,-16
80017bfa:	6e 1b       	ld.w	r11,r7[0x4]
80017bfc:	e0 a0 1b 18 	rcall	8001b22c <__sfvwrite_r>
80017c00:	f9 bc 01 ff 	movne	r12,-1
80017c04:	f9 bc 00 0a 	moveq	r12,10
80017c08:	2f 9d       	sub	sp,-28
80017c0a:	d8 22       	popm	r4-r7,pc
80017c0c:	80 07       	ld.sh	r7,r0[0x0]
80017c0e:	0a 00       	add	r0,r5

80017c10 <puts>:
80017c10:	d4 01       	pushm	lr
80017c12:	48 38       	lddpc	r8,80017c1c <puts+0xc>
80017c14:	18 9b       	mov	r11,r12
80017c16:	70 0c       	ld.w	r12,r8[0x0]
80017c18:	cd 4f       	rcall	80017bc0 <_puts_r>
80017c1a:	d8 02       	popm	pc
80017c1c:	00 00       	add	r0,r0
80017c1e:	01 9c       	ld.ub	r12,r0[0x1]

80017c20 <__srefill_r>:
80017c20:	d4 21       	pushm	r4-r7,lr
80017c22:	16 97       	mov	r7,r11
80017c24:	18 96       	mov	r6,r12
80017c26:	58 0c       	cp.w	r12,0
80017c28:	c0 60       	breq	80017c34 <__srefill_r+0x14>
80017c2a:	78 68       	ld.w	r8,r12[0x18]
80017c2c:	58 08       	cp.w	r8,0
80017c2e:	c0 31       	brne	80017c34 <__srefill_r+0x14>
80017c30:	fe b0 f8 32 	rcall	80016c94 <__sinit>
80017c34:	4b 78       	lddpc	r8,80017d10 <__srefill_r+0xf0>
80017c36:	10 37       	cp.w	r7,r8
80017c38:	c0 31       	brne	80017c3e <__srefill_r+0x1e>
80017c3a:	6c 07       	ld.w	r7,r6[0x0]
80017c3c:	c0 a8       	rjmp	80017c50 <__srefill_r+0x30>
80017c3e:	4b 68       	lddpc	r8,80017d14 <__srefill_r+0xf4>
80017c40:	10 37       	cp.w	r7,r8
80017c42:	c0 31       	brne	80017c48 <__srefill_r+0x28>
80017c44:	6c 17       	ld.w	r7,r6[0x4]
80017c46:	c0 58       	rjmp	80017c50 <__srefill_r+0x30>
80017c48:	4b 48       	lddpc	r8,80017d18 <__srefill_r+0xf8>
80017c4a:	10 37       	cp.w	r7,r8
80017c4c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80017c50:	30 08       	mov	r8,0
80017c52:	8f 18       	st.w	r7[0x4],r8
80017c54:	8e 68       	ld.sh	r8,r7[0xc]
80017c56:	ed b8 00 05 	bld	r8,0x5
80017c5a:	c5 a0       	breq	80017d0e <__srefill_r+0xee>
80017c5c:	ed b8 00 02 	bld	r8,0x2
80017c60:	c1 a0       	breq	80017c94 <__srefill_r+0x74>
80017c62:	ed b8 00 04 	bld	r8,0x4
80017c66:	c0 60       	breq	80017c72 <__srefill_r+0x52>
80017c68:	a7 a8       	sbr	r8,0x6
80017c6a:	ae 68       	st.h	r7[0xc],r8
80017c6c:	30 98       	mov	r8,9
80017c6e:	8d 38       	st.w	r6[0xc],r8
80017c70:	c4 e8       	rjmp	80017d0c <__srefill_r+0xec>
80017c72:	ed b8 00 03 	bld	r8,0x3
80017c76:	c0 b1       	brne	80017c8c <__srefill_r+0x6c>
80017c78:	0e 9b       	mov	r11,r7
80017c7a:	0c 9c       	mov	r12,r6
80017c7c:	fe b0 f7 1c 	rcall	80016ab4 <_fflush_r>
80017c80:	c4 71       	brne	80017d0e <__srefill_r+0xee>
80017c82:	8e 68       	ld.sh	r8,r7[0xc]
80017c84:	8f 6c       	st.w	r7[0x18],r12
80017c86:	a3 d8       	cbr	r8,0x3
80017c88:	8f 2c       	st.w	r7[0x8],r12
80017c8a:	ae 68       	st.h	r7[0xc],r8
80017c8c:	8e 68       	ld.sh	r8,r7[0xc]
80017c8e:	a3 a8       	sbr	r8,0x2
80017c90:	ae 68       	st.h	r7[0xc],r8
80017c92:	c1 48       	rjmp	80017cba <__srefill_r+0x9a>
80017c94:	6e db       	ld.w	r11,r7[0x34]
80017c96:	58 0b       	cp.w	r11,0
80017c98:	c1 10       	breq	80017cba <__srefill_r+0x9a>
80017c9a:	ee c8 ff bc 	sub	r8,r7,-68
80017c9e:	10 3b       	cp.w	r11,r8
80017ca0:	c0 40       	breq	80017ca8 <__srefill_r+0x88>
80017ca2:	0c 9c       	mov	r12,r6
80017ca4:	fe b0 f9 38 	rcall	80016f14 <_free_r>
80017ca8:	30 0c       	mov	r12,0
80017caa:	6f 08       	ld.w	r8,r7[0x40]
80017cac:	8f dc       	st.w	r7[0x34],r12
80017cae:	8f 18       	st.w	r7[0x4],r8
80017cb0:	58 08       	cp.w	r8,0
80017cb2:	c0 40       	breq	80017cba <__srefill_r+0x9a>
80017cb4:	6e f8       	ld.w	r8,r7[0x3c]
80017cb6:	8f 08       	st.w	r7[0x0],r8
80017cb8:	d8 22       	popm	r4-r7,pc
80017cba:	6e 48       	ld.w	r8,r7[0x10]
80017cbc:	58 08       	cp.w	r8,0
80017cbe:	c0 51       	brne	80017cc8 <__srefill_r+0xa8>
80017cc0:	0e 9b       	mov	r11,r7
80017cc2:	0c 9c       	mov	r12,r6
80017cc4:	fe b0 fb dc 	rcall	8001747c <__smakebuf_r>
80017cc8:	8e 68       	ld.sh	r8,r7[0xc]
80017cca:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80017cce:	c0 70       	breq	80017cdc <__srefill_r+0xbc>
80017cd0:	49 38       	lddpc	r8,80017d1c <__srefill_r+0xfc>
80017cd2:	fe cb ff b2 	sub	r11,pc,-78
80017cd6:	70 0c       	ld.w	r12,r8[0x0]
80017cd8:	fe b0 fb 68 	rcall	800173a8 <_fwalk>
80017cdc:	6e 4a       	ld.w	r10,r7[0x10]
80017cde:	6e 98       	ld.w	r8,r7[0x24]
80017ce0:	0c 9c       	mov	r12,r6
80017ce2:	8f 0a       	st.w	r7[0x0],r10
80017ce4:	6e 59       	ld.w	r9,r7[0x14]
80017ce6:	6e 8b       	ld.w	r11,r7[0x20]
80017ce8:	5d 18       	icall	r8
80017cea:	8e 68       	ld.sh	r8,r7[0xc]
80017cec:	8f 1c       	st.w	r7[0x4],r12
80017cee:	ad d8       	cbr	r8,0xd
80017cf0:	ae 68       	st.h	r7[0xc],r8
80017cf2:	58 0c       	cp.w	r12,0
80017cf4:	e0 8a 00 03 	brle	80017cfa <__srefill_r+0xda>
80017cf8:	d8 2a       	popm	r4-r7,pc,r12=0
80017cfa:	58 0c       	cp.w	r12,0
80017cfc:	c0 41       	brne	80017d04 <__srefill_r+0xe4>
80017cfe:	a5 b8       	sbr	r8,0x5
80017d00:	ae 68       	st.h	r7[0xc],r8
80017d02:	c0 58       	rjmp	80017d0c <__srefill_r+0xec>
80017d04:	a7 a8       	sbr	r8,0x6
80017d06:	ae 68       	st.h	r7[0xc],r8
80017d08:	30 08       	mov	r8,0
80017d0a:	8f 18       	st.w	r7[0x4],r8
80017d0c:	dc 2a       	popm	r4-r7,pc,r12=-1
80017d0e:	dc 2a       	popm	r4-r7,pc,r12=-1
80017d10:	80 07       	ld.sh	r7,r0[0x0]
80017d12:	0a 2c       	rsub	r12,r5
80017d14:	80 07       	ld.sh	r7,r0[0x0]
80017d16:	0a 4c       	or	r12,r5
80017d18:	80 07       	ld.sh	r7,r0[0x0]
80017d1a:	0a 6c       	and	r12,r5
80017d1c:	80 07       	ld.sh	r7,r0[0x0]
80017d1e:	0a 8c       	andn	r12,r5

80017d20 <lflush>:
80017d20:	d4 01       	pushm	lr
80017d22:	98 68       	ld.sh	r8,r12[0xc]
80017d24:	e2 18 00 09 	andl	r8,0x9,COH
80017d28:	58 98       	cp.w	r8,9
80017d2a:	c0 20       	breq	80017d2e <lflush+0xe>
80017d2c:	d8 0a       	popm	pc,r12=0
80017d2e:	fe b0 f7 4b 	rcall	80016bc4 <fflush>
80017d32:	d8 02       	popm	pc

80017d34 <_sbrk_r>:
80017d34:	d4 21       	pushm	r4-r7,lr
80017d36:	30 08       	mov	r8,0
80017d38:	18 97       	mov	r7,r12
80017d3a:	48 66       	lddpc	r6,80017d50 <_sbrk_r+0x1c>
80017d3c:	16 9c       	mov	r12,r11
80017d3e:	8d 08       	st.w	r6[0x0],r8
80017d40:	c8 0d       	rcall	80018040 <_sbrk>
80017d42:	5b fc       	cp.w	r12,-1
80017d44:	c0 51       	brne	80017d4e <_sbrk_r+0x1a>
80017d46:	6c 08       	ld.w	r8,r6[0x0]
80017d48:	58 08       	cp.w	r8,0
80017d4a:	ef f8 1a 03 	st.wne	r7[0xc],r8
80017d4e:	d8 22       	popm	r4-r7,pc
80017d50:	00 00       	add	r0,r0
80017d52:	4f 74       	lddpc	r4,80017f2c <__sread+0x1c>

80017d54 <setbuf>:
80017d54:	d4 01       	pushm	lr
80017d56:	e0 69 04 00 	mov	r9,1024
80017d5a:	58 0b       	cp.w	r11,0
80017d5c:	f9 ba 00 02 	moveq	r10,2
80017d60:	f9 ba 01 00 	movne	r10,0
80017d64:	c0 2c       	rcall	80017d68 <setvbuf>
80017d66:	d8 02       	popm	pc

80017d68 <setvbuf>:
80017d68:	d4 31       	pushm	r0-r7,lr
80017d6a:	4b f8       	lddpc	r8,80017e64 <setvbuf+0xfc>
80017d6c:	18 97       	mov	r7,r12
80017d6e:	16 96       	mov	r6,r11
80017d70:	14 95       	mov	r5,r10
80017d72:	12 94       	mov	r4,r9
80017d74:	70 0c       	ld.w	r12,r8[0x0]
80017d76:	58 0c       	cp.w	r12,0
80017d78:	c0 60       	breq	80017d84 <setvbuf+0x1c>
80017d7a:	78 68       	ld.w	r8,r12[0x18]
80017d7c:	58 08       	cp.w	r8,0
80017d7e:	c0 31       	brne	80017d84 <setvbuf+0x1c>
80017d80:	fe b0 f7 8a 	rcall	80016c94 <__sinit>
80017d84:	4b 98       	lddpc	r8,80017e68 <setvbuf+0x100>
80017d86:	10 37       	cp.w	r7,r8
80017d88:	c0 51       	brne	80017d92 <setvbuf+0x2a>
80017d8a:	4b 78       	lddpc	r8,80017e64 <setvbuf+0xfc>
80017d8c:	70 08       	ld.w	r8,r8[0x0]
80017d8e:	70 07       	ld.w	r7,r8[0x0]
80017d90:	c0 e8       	rjmp	80017dac <setvbuf+0x44>
80017d92:	4b 78       	lddpc	r8,80017e6c <setvbuf+0x104>
80017d94:	10 37       	cp.w	r7,r8
80017d96:	c0 51       	brne	80017da0 <setvbuf+0x38>
80017d98:	4b 38       	lddpc	r8,80017e64 <setvbuf+0xfc>
80017d9a:	70 08       	ld.w	r8,r8[0x0]
80017d9c:	70 17       	ld.w	r7,r8[0x4]
80017d9e:	c0 78       	rjmp	80017dac <setvbuf+0x44>
80017da0:	4b 48       	lddpc	r8,80017e70 <setvbuf+0x108>
80017da2:	10 37       	cp.w	r7,r8
80017da4:	c0 41       	brne	80017dac <setvbuf+0x44>
80017da6:	4b 08       	lddpc	r8,80017e64 <setvbuf+0xfc>
80017da8:	70 08       	ld.w	r8,r8[0x0]
80017daa:	70 27       	ld.w	r7,r8[0x8]
80017dac:	58 25       	cp.w	r5,2
80017dae:	5f b8       	srhi	r8
80017db0:	f1 e4 13 f8 	or	r8,r8,r4>>0x1f
80017db4:	c0 20       	breq	80017db8 <setvbuf+0x50>
80017db6:	dc 3a       	popm	r0-r7,pc,r12=-1
80017db8:	4a b3       	lddpc	r3,80017e64 <setvbuf+0xfc>
80017dba:	0e 9b       	mov	r11,r7
80017dbc:	66 0c       	ld.w	r12,r3[0x0]
80017dbe:	fe b0 f6 7b 	rcall	80016ab4 <_fflush_r>
80017dc2:	30 08       	mov	r8,0
80017dc4:	8f 68       	st.w	r7[0x18],r8
80017dc6:	8f 18       	st.w	r7[0x4],r8
80017dc8:	8e 68       	ld.sh	r8,r7[0xc]
80017dca:	ed b8 00 07 	bld	r8,0x7
80017dce:	c0 51       	brne	80017dd8 <setvbuf+0x70>
80017dd0:	66 0c       	ld.w	r12,r3[0x0]
80017dd2:	6e 4b       	ld.w	r11,r7[0x10]
80017dd4:	fe b0 f8 a0 	rcall	80016f14 <_free_r>
80017dd8:	8e 68       	ld.sh	r8,r7[0xc]
80017dda:	e0 18 ff 7c 	andl	r8,0xff7c
80017dde:	ae 68       	st.h	r7[0xc],r8
80017de0:	58 25       	cp.w	r5,2
80017de2:	c0 31       	brne	80017de8 <setvbuf+0x80>
80017de4:	30 0c       	mov	r12,0
80017de6:	c1 38       	rjmp	80017e0c <setvbuf+0xa4>
80017de8:	58 06       	cp.w	r6,0
80017dea:	c2 11       	brne	80017e2c <setvbuf+0xc4>
80017dec:	e0 63 04 00 	mov	r3,1024
80017df0:	58 04       	cp.w	r4,0
80017df2:	e6 04 17 00 	moveq	r4,r3
80017df6:	08 9c       	mov	r12,r4
80017df8:	e0 a0 1b 7e 	rcall	8001b4f4 <malloc>
80017dfc:	18 96       	mov	r6,r12
80017dfe:	c1 41       	brne	80017e26 <setvbuf+0xbe>
80017e00:	06 9c       	mov	r12,r3
80017e02:	e0 a0 1b 79 	rcall	8001b4f4 <malloc>
80017e06:	18 96       	mov	r6,r12
80017e08:	c0 e1       	brne	80017e24 <setvbuf+0xbc>
80017e0a:	3f fc       	mov	r12,-1
80017e0c:	8e 68       	ld.sh	r8,r7[0xc]
80017e0e:	a1 b8       	sbr	r8,0x1
80017e10:	ae 68       	st.h	r7[0xc],r8
80017e12:	ee c8 ff b9 	sub	r8,r7,-71
80017e16:	8f 48       	st.w	r7[0x10],r8
80017e18:	8f 08       	st.w	r7[0x0],r8
80017e1a:	30 08       	mov	r8,0
80017e1c:	8f 28       	st.w	r7[0x8],r8
80017e1e:	30 18       	mov	r8,1
80017e20:	8f 58       	st.w	r7[0x14],r8
80017e22:	d8 32       	popm	r0-r7,pc
80017e24:	06 94       	mov	r4,r3
80017e26:	8e 68       	ld.sh	r8,r7[0xc]
80017e28:	a7 b8       	sbr	r8,0x7
80017e2a:	ae 68       	st.h	r7[0xc],r8
80017e2c:	58 15       	cp.w	r5,1
80017e2e:	c0 71       	brne	80017e3c <setvbuf+0xd4>
80017e30:	8e 68       	ld.sh	r8,r7[0xc]
80017e32:	a1 a8       	sbr	r8,0x0
80017e34:	ae 68       	st.h	r7[0xc],r8
80017e36:	e8 08 11 00 	rsub	r8,r4,0
80017e3a:	8f 68       	st.w	r7[0x18],r8
80017e3c:	48 a8       	lddpc	r8,80017e64 <setvbuf+0xfc>
80017e3e:	fe c9 12 4e 	sub	r9,pc,4686
80017e42:	70 08       	ld.w	r8,r8[0x0]
80017e44:	8f 46       	st.w	r7[0x10],r6
80017e46:	91 a9       	st.w	r8[0x28],r9
80017e48:	8f 06       	st.w	r7[0x0],r6
80017e4a:	8f 54       	st.w	r7[0x14],r4
80017e4c:	8e 68       	ld.sh	r8,r7[0xc]
80017e4e:	10 9c       	mov	r12,r8
80017e50:	e2 1c 00 08 	andl	r12,0x8,COH
80017e54:	c0 70       	breq	80017e62 <setvbuf+0xfa>
80017e56:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80017e5a:	30 0c       	mov	r12,0
80017e5c:	f9 b4 01 00 	movne	r4,0
80017e60:	8f 24       	st.w	r7[0x8],r4
80017e62:	d8 32       	popm	r0-r7,pc
80017e64:	00 00       	add	r0,r0
80017e66:	01 9c       	ld.ub	r12,r0[0x1]
80017e68:	80 07       	ld.sh	r7,r0[0x0]
80017e6a:	0a 2c       	rsub	r12,r5
80017e6c:	80 07       	ld.sh	r7,r0[0x0]
80017e6e:	0a 4c       	or	r12,r5
80017e70:	80 07       	ld.sh	r7,r0[0x0]
80017e72:	0a 6c       	and	r12,r5

80017e74 <sprintf>:
80017e74:	d4 01       	pushm	lr
80017e76:	21 7d       	sub	sp,92
80017e78:	e0 68 ff ff 	mov	r8,65535
80017e7c:	ea 18 7f ff 	orh	r8,0x7fff
80017e80:	50 58       	stdsp	sp[0x14],r8
80017e82:	50 28       	stdsp	sp[0x8],r8
80017e84:	e0 68 02 08 	mov	r8,520
80017e88:	ba 68       	st.h	sp[0xc],r8
80017e8a:	3f f8       	mov	r8,-1
80017e8c:	ba 78       	st.h	sp[0xe],r8
80017e8e:	48 88       	lddpc	r8,80017eac <sprintf+0x38>
80017e90:	50 4c       	stdsp	sp[0x10],r12
80017e92:	16 9a       	mov	r10,r11
80017e94:	50 0c       	stdsp	sp[0x0],r12
80017e96:	fa c9 ff a0 	sub	r9,sp,-96
80017e9a:	70 0c       	ld.w	r12,r8[0x0]
80017e9c:	1a 9b       	mov	r11,sp
80017e9e:	e0 a0 02 8d 	rcall	800183b8 <_vfprintf_r>
80017ea2:	30 09       	mov	r9,0
80017ea4:	40 08       	lddsp	r8,sp[0x0]
80017ea6:	b0 89       	st.b	r8[0x0],r9
80017ea8:	2e 9d       	sub	sp,-92
80017eaa:	d8 02       	popm	pc
80017eac:	00 00       	add	r0,r0
80017eae:	01 9c       	ld.ub	r12,r0[0x1]

80017eb0 <__sclose>:
80017eb0:	d4 01       	pushm	lr
80017eb2:	96 7b       	ld.sh	r11,r11[0xe]
80017eb4:	e0 a0 12 f0 	rcall	8001a494 <_close_r>
80017eb8:	d8 02       	popm	pc
80017eba:	d7 03       	nop

80017ebc <__sseek>:
80017ebc:	d4 21       	pushm	r4-r7,lr
80017ebe:	16 97       	mov	r7,r11
80017ec0:	96 7b       	ld.sh	r11,r11[0xe]
80017ec2:	e0 a0 1b 05 	rcall	8001b4cc <_lseek_r>
80017ec6:	8e 68       	ld.sh	r8,r7[0xc]
80017ec8:	10 99       	mov	r9,r8
80017eca:	ad c8       	cbr	r8,0xc
80017ecc:	ad a9       	sbr	r9,0xc
80017ece:	5b fc       	cp.w	r12,-1
80017ed0:	ef f8 0c 06 	st.heq	r7[0xc],r8
80017ed4:	ef f9 1c 06 	st.hne	r7[0xc],r9
80017ed8:	ef fc 1a 15 	st.wne	r7[0x54],r12
80017edc:	d8 22       	popm	r4-r7,pc
80017ede:	d7 03       	nop

80017ee0 <__swrite>:
80017ee0:	d4 21       	pushm	r4-r7,lr
80017ee2:	96 68       	ld.sh	r8,r11[0xc]
80017ee4:	16 97       	mov	r7,r11
80017ee6:	14 95       	mov	r5,r10
80017ee8:	12 94       	mov	r4,r9
80017eea:	e2 18 01 00 	andl	r8,0x100,COH
80017eee:	18 96       	mov	r6,r12
80017ef0:	c0 60       	breq	80017efc <__swrite+0x1c>
80017ef2:	30 29       	mov	r9,2
80017ef4:	30 0a       	mov	r10,0
80017ef6:	96 7b       	ld.sh	r11,r11[0xe]
80017ef8:	e0 a0 1a ea 	rcall	8001b4cc <_lseek_r>
80017efc:	8e 68       	ld.sh	r8,r7[0xc]
80017efe:	ad c8       	cbr	r8,0xc
80017f00:	08 99       	mov	r9,r4
80017f02:	0a 9a       	mov	r10,r5
80017f04:	8e 7b       	ld.sh	r11,r7[0xe]
80017f06:	0c 9c       	mov	r12,r6
80017f08:	ae 68       	st.h	r7[0xc],r8
80017f0a:	e0 a0 12 43 	rcall	8001a390 <_write_r>
80017f0e:	d8 22       	popm	r4-r7,pc

80017f10 <__sread>:
80017f10:	d4 21       	pushm	r4-r7,lr
80017f12:	16 97       	mov	r7,r11
80017f14:	96 7b       	ld.sh	r11,r11[0xe]
80017f16:	e0 a0 1e 0b 	rcall	8001bb2c <_read_r>
80017f1a:	c0 65       	brlt	80017f26 <__sread+0x16>
80017f1c:	6f 58       	ld.w	r8,r7[0x54]
80017f1e:	18 08       	add	r8,r12
80017f20:	ef 48 00 54 	st.w	r7[84],r8
80017f24:	d8 22       	popm	r4-r7,pc
80017f26:	8e 68       	ld.sh	r8,r7[0xc]
80017f28:	ad c8       	cbr	r8,0xc
80017f2a:	ae 68       	st.h	r7[0xc],r8
80017f2c:	d8 22       	popm	r4-r7,pc
80017f2e:	d7 03       	nop

80017f30 <strcat>:
80017f30:	18 99       	mov	r9,r12
80017f32:	30 08       	mov	r8,0
80017f34:	c0 28       	rjmp	80017f38 <strcat+0x8>
80017f36:	2f f9       	sub	r9,-1
80017f38:	13 8a       	ld.ub	r10,r9[0x0]
80017f3a:	f0 0a 18 00 	cp.b	r10,r8
80017f3e:	cf c1       	brne	80017f36 <strcat+0x6>
80017f40:	30 08       	mov	r8,0
80017f42:	f6 08 07 0a 	ld.ub	r10,r11[r8]
80017f46:	f2 08 0b 0a 	st.b	r9[r8],r10
80017f4a:	2f f8       	sub	r8,-1
80017f4c:	58 0a       	cp.w	r10,0
80017f4e:	cf a1       	brne	80017f42 <strcat+0x12>
80017f50:	5e fc       	retal	r12

80017f52 <strcpy>:
80017f52:	30 08       	mov	r8,0
80017f54:	f6 08 07 09 	ld.ub	r9,r11[r8]
80017f58:	f8 08 0b 09 	st.b	r12[r8],r9
80017f5c:	2f f8       	sub	r8,-1
80017f5e:	58 09       	cp.w	r9,0
80017f60:	cf a1       	brne	80017f54 <strcpy+0x2>
80017f62:	5e fc       	retal	r12

80017f64 <strlen>:
80017f64:	30 09       	mov	r9,0
80017f66:	18 98       	mov	r8,r12
80017f68:	c0 28       	rjmp	80017f6c <strlen+0x8>
80017f6a:	2f f8       	sub	r8,-1
80017f6c:	11 8a       	ld.ub	r10,r8[0x0]
80017f6e:	f2 0a 18 00 	cp.b	r10,r9
80017f72:	cf c1       	brne	80017f6a <strlen+0x6>
80017f74:	f0 0c 01 0c 	sub	r12,r8,r12
80017f78:	5e fc       	retal	r12
80017f7a:	d7 03       	nop

80017f7c <_open>:
80017f7c:	30 18       	mov	r8,1
80017f7e:	d6 73       	breakpoint
80017f80:	3f fc       	mov	r12,-1
80017f82:	35 8b       	mov	r11,88
80017f84:	58 0c       	cp.w	r12,0
80017f86:	5e 4c       	retge	r12
80017f88:	48 2a       	lddpc	r10,80017f90 <_open+0x14>
80017f8a:	95 0b       	st.w	r10[0x0],r11
80017f8c:	5e fc       	retal	r12
80017f8e:	d7 03       	nop
80017f90:	00 00       	add	r0,r0
80017f92:	4f 74       	lddpc	r4,8001816c <get_arg+0xf0>

80017f94 <_close>:
80017f94:	30 28       	mov	r8,2
80017f96:	d6 73       	breakpoint
80017f98:	3f fc       	mov	r12,-1
80017f9a:	35 8b       	mov	r11,88
80017f9c:	58 0c       	cp.w	r12,0
80017f9e:	5e 4c       	retge	r12
80017fa0:	48 2a       	lddpc	r10,80017fa8 <_close+0x14>
80017fa2:	95 0b       	st.w	r10[0x0],r11
80017fa4:	5e fc       	retal	r12
80017fa6:	d7 03       	nop
80017fa8:	00 00       	add	r0,r0
80017faa:	4f 74       	lddpc	r4,80018184 <get_arg+0x108>

80017fac <_lseek>:
80017fac:	30 58       	mov	r8,5
80017fae:	d6 73       	breakpoint
80017fb0:	3f fc       	mov	r12,-1
80017fb2:	35 8b       	mov	r11,88
80017fb4:	58 0c       	cp.w	r12,0
80017fb6:	5e 4c       	retge	r12
80017fb8:	48 2a       	lddpc	r10,80017fc0 <_lseek+0x14>
80017fba:	95 0b       	st.w	r10[0x0],r11
80017fbc:	5e fc       	retal	r12
80017fbe:	d7 03       	nop
80017fc0:	00 00       	add	r0,r0
80017fc2:	4f 74       	lddpc	r4,8001819c <get_arg+0x120>

80017fc4 <isatty>:
80017fc4:	30 b8       	mov	r8,11
80017fc6:	d6 73       	breakpoint
80017fc8:	3f fc       	mov	r12,-1
80017fca:	35 8b       	mov	r11,88
80017fcc:	58 0c       	cp.w	r12,0
80017fce:	5e 4c       	retge	r12
80017fd0:	48 2a       	lddpc	r10,80017fd8 <isatty+0x14>
80017fd2:	95 0b       	st.w	r10[0x0],r11
80017fd4:	5e fc       	retal	r12
80017fd6:	d7 03       	nop
80017fd8:	00 00       	add	r0,r0
80017fda:	4f 74       	lddpc	r4,800181b4 <get_arg+0x138>

80017fdc <_fstat_host>:
80017fdc:	30 98       	mov	r8,9
80017fde:	d6 73       	breakpoint
80017fe0:	3f fc       	mov	r12,-1
80017fe2:	35 8b       	mov	r11,88
80017fe4:	58 0c       	cp.w	r12,0
80017fe6:	5e 4c       	retge	r12
80017fe8:	48 2a       	lddpc	r10,80017ff0 <_fstat_host+0x14>
80017fea:	95 0b       	st.w	r10[0x0],r11
80017fec:	5e fc       	retal	r12
80017fee:	d7 03       	nop
80017ff0:	00 00       	add	r0,r0
80017ff2:	4f 74       	lddpc	r4,800181cc <get_arg+0x150>

80017ff4 <_fstat>:
80017ff4:	d4 21       	pushm	r4-r7,lr
80017ff6:	21 0d       	sub	sp,64
80017ff8:	16 97       	mov	r7,r11
80017ffa:	1a 9b       	mov	r11,sp
80017ffc:	cf 0f       	rcall	80017fdc <_fstat_host>
80017ffe:	c0 34       	brge	80018004 <_fstat+0x10>
80018000:	3f fc       	mov	r12,-1
80018002:	c1 c8       	rjmp	8001803a <_fstat+0x46>
80018004:	40 08       	lddsp	r8,sp[0x0]
80018006:	ae 08       	st.h	r7[0x0],r8
80018008:	40 18       	lddsp	r8,sp[0x4]
8001800a:	ae 18       	st.h	r7[0x2],r8
8001800c:	40 28       	lddsp	r8,sp[0x8]
8001800e:	8f 18       	st.w	r7[0x4],r8
80018010:	40 38       	lddsp	r8,sp[0xc]
80018012:	ae 48       	st.h	r7[0x8],r8
80018014:	40 48       	lddsp	r8,sp[0x10]
80018016:	ae 58       	st.h	r7[0xa],r8
80018018:	40 58       	lddsp	r8,sp[0x14]
8001801a:	ae 68       	st.h	r7[0xc],r8
8001801c:	40 68       	lddsp	r8,sp[0x18]
8001801e:	ae 78       	st.h	r7[0xe],r8
80018020:	40 88       	lddsp	r8,sp[0x20]
80018022:	8f 48       	st.w	r7[0x10],r8
80018024:	40 a8       	lddsp	r8,sp[0x28]
80018026:	8f b8       	st.w	r7[0x2c],r8
80018028:	40 c8       	lddsp	r8,sp[0x30]
8001802a:	8f c8       	st.w	r7[0x30],r8
8001802c:	40 d8       	lddsp	r8,sp[0x34]
8001802e:	8f 58       	st.w	r7[0x14],r8
80018030:	40 e8       	lddsp	r8,sp[0x38]
80018032:	30 0c       	mov	r12,0
80018034:	8f 78       	st.w	r7[0x1c],r8
80018036:	40 f8       	lddsp	r8,sp[0x3c]
80018038:	8f 98       	st.w	r7[0x24],r8
8001803a:	2f 0d       	sub	sp,-64
8001803c:	d8 22       	popm	r4-r7,pc
8001803e:	d7 03       	nop

80018040 <_sbrk>:
80018040:	d4 01       	pushm	lr
80018042:	48 c8       	lddpc	r8,80018070 <_sbrk+0x30>
80018044:	70 09       	ld.w	r9,r8[0x0]
80018046:	58 09       	cp.w	r9,0
80018048:	c0 31       	brne	8001804e <_sbrk+0xe>
8001804a:	48 b9       	lddpc	r9,80018074 <_sbrk+0x34>
8001804c:	91 09       	st.w	r8[0x0],r9
8001804e:	48 99       	lddpc	r9,80018070 <_sbrk+0x30>
80018050:	48 aa       	lddpc	r10,80018078 <_sbrk+0x38>
80018052:	72 08       	ld.w	r8,r9[0x0]
80018054:	f0 0c 00 0c 	add	r12,r8,r12
80018058:	14 3c       	cp.w	r12,r10
8001805a:	e0 8b 00 04 	brhi	80018062 <_sbrk+0x22>
8001805e:	93 0c       	st.w	r9[0x0],r12
80018060:	c0 68       	rjmp	8001806c <_sbrk+0x2c>
80018062:	e0 a0 18 ab 	rcall	8001b1b8 <__errno>
80018066:	30 c8       	mov	r8,12
80018068:	99 08       	st.w	r12[0x0],r8
8001806a:	3f f8       	mov	r8,-1
8001806c:	10 9c       	mov	r12,r8
8001806e:	d8 02       	popm	pc
80018070:	00 00       	add	r0,r0
80018072:	3b 88       	mov	r8,-72
80018074:	00 00       	add	r0,r0
80018076:	4f 78       	lddpc	r8,80018250 <get_arg+0x1d4>
80018078:	00 00       	add	r0,r0
8001807a:	f0 00       	*unknown*

8001807c <get_arg>:
8001807c:	d4 31       	pushm	r0-r7,lr
8001807e:	20 8d       	sub	sp,32
80018080:	fa c4 ff bc 	sub	r4,sp,-68
80018084:	50 4b       	stdsp	sp[0x10],r11
80018086:	68 2e       	ld.w	lr,r4[0x8]
80018088:	50 58       	stdsp	sp[0x14],r8
8001808a:	12 96       	mov	r6,r9
8001808c:	7c 0b       	ld.w	r11,lr[0x0]
8001808e:	70 05       	ld.w	r5,r8[0x0]
80018090:	50 6e       	stdsp	sp[0x18],lr
80018092:	58 0b       	cp.w	r11,0
80018094:	f4 0b 17 00 	moveq	r11,r10
80018098:	68 03       	ld.w	r3,r4[0x0]
8001809a:	68 11       	ld.w	r1,r4[0x4]
8001809c:	40 49       	lddsp	r9,sp[0x10]
8001809e:	30 08       	mov	r8,0
800180a0:	c2 e9       	rjmp	800182fc <get_arg+0x280>
800180a2:	2f fb       	sub	r11,-1
800180a4:	32 5c       	mov	r12,37
800180a6:	17 8a       	ld.ub	r10,r11[0x0]
800180a8:	f8 0a 18 00 	cp.b	r10,r12
800180ac:	5f 1e       	srne	lr
800180ae:	f0 0a 18 00 	cp.b	r10,r8
800180b2:	5f 1c       	srne	r12
800180b4:	fd ec 00 0c 	and	r12,lr,r12
800180b8:	f0 0c 18 00 	cp.b	r12,r8
800180bc:	cf 31       	brne	800180a2 <get_arg+0x26>
800180be:	58 0a       	cp.w	r10,0
800180c0:	e0 80 01 2b 	breq	80018316 <get_arg+0x29a>
800180c4:	30 0c       	mov	r12,0
800180c6:	3f fa       	mov	r10,-1
800180c8:	18 90       	mov	r0,r12
800180ca:	50 3a       	stdsp	sp[0xc],r10
800180cc:	18 94       	mov	r4,r12
800180ce:	18 92       	mov	r2,r12
800180d0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800180d4:	16 97       	mov	r7,r11
800180d6:	50 7c       	stdsp	sp[0x1c],r12
800180d8:	4c ec       	lddpc	r12,80018210 <get_arg+0x194>
800180da:	0f 3a       	ld.ub	r10,r7++
800180dc:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800180e0:	40 7c       	lddsp	r12,sp[0x1c]
800180e2:	1c 0c       	add	r12,lr
800180e4:	4c ce       	lddpc	lr,80018214 <get_arg+0x198>
800180e6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800180ea:	20 1e       	sub	lr,1
800180ec:	50 0e       	stdsp	sp[0x0],lr
800180ee:	4c be       	lddpc	lr,80018218 <get_arg+0x19c>
800180f0:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800180f4:	50 7c       	stdsp	sp[0x1c],r12
800180f6:	40 0c       	lddsp	r12,sp[0x0]
800180f8:	58 7c       	cp.w	r12,7
800180fa:	e0 8b 00 fa 	brhi	800182ee <get_arg+0x272>
800180fe:	4c 8e       	lddpc	lr,8001821c <get_arg+0x1a0>
80018100:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80018104:	36 8b       	mov	r11,104
80018106:	f6 0a 18 00 	cp.b	r10,r11
8001810a:	e0 80 00 f2 	breq	800182ee <get_arg+0x272>
8001810e:	37 1b       	mov	r11,113
80018110:	f6 0a 18 00 	cp.b	r10,r11
80018114:	c0 70       	breq	80018122 <get_arg+0xa6>
80018116:	34 cb       	mov	r11,76
80018118:	f6 0a 18 00 	cp.b	r10,r11
8001811c:	c0 51       	brne	80018126 <get_arg+0xaa>
8001811e:	a3 b4       	sbr	r4,0x3
80018120:	ce 78       	rjmp	800182ee <get_arg+0x272>
80018122:	a5 b4       	sbr	r4,0x5
80018124:	ce 58       	rjmp	800182ee <get_arg+0x272>
80018126:	08 9a       	mov	r10,r4
80018128:	0e 9b       	mov	r11,r7
8001812a:	a5 aa       	sbr	r10,0x4
8001812c:	17 3c       	ld.ub	r12,r11++
8001812e:	a5 b4       	sbr	r4,0x5
80018130:	36 ce       	mov	lr,108
80018132:	fc 0c 18 00 	cp.b	r12,lr
80018136:	e0 80 00 dd 	breq	800182f0 <get_arg+0x274>
8001813a:	14 94       	mov	r4,r10
8001813c:	cd 98       	rjmp	800182ee <get_arg+0x272>
8001813e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80018142:	36 7c       	mov	r12,103
80018144:	f8 0a 18 00 	cp.b	r10,r12
80018148:	e0 8b 00 27 	brhi	80018196 <get_arg+0x11a>
8001814c:	36 5b       	mov	r11,101
8001814e:	f6 0a 18 00 	cp.b	r10,r11
80018152:	c4 82       	brcc	800181e2 <get_arg+0x166>
80018154:	34 fb       	mov	r11,79
80018156:	f6 0a 18 00 	cp.b	r10,r11
8001815a:	c4 80       	breq	800181ea <get_arg+0x16e>
8001815c:	e0 8b 00 0c 	brhi	80018174 <get_arg+0xf8>
80018160:	34 5b       	mov	r11,69
80018162:	f6 0a 18 00 	cp.b	r10,r11
80018166:	c3 e0       	breq	800181e2 <get_arg+0x166>
80018168:	34 7b       	mov	r11,71
8001816a:	f6 0a 18 00 	cp.b	r10,r11
8001816e:	c3 a0       	breq	800181e2 <get_arg+0x166>
80018170:	34 4b       	mov	r11,68
80018172:	c0 88       	rjmp	80018182 <get_arg+0x106>
80018174:	35 8b       	mov	r11,88
80018176:	f6 0a 18 00 	cp.b	r10,r11
8001817a:	c2 c0       	breq	800181d2 <get_arg+0x156>
8001817c:	e0 8b 00 07 	brhi	8001818a <get_arg+0x10e>
80018180:	35 5b       	mov	r11,85
80018182:	f6 0a 18 00 	cp.b	r10,r11
80018186:	c3 51       	brne	800181f0 <get_arg+0x174>
80018188:	c3 18       	rjmp	800181ea <get_arg+0x16e>
8001818a:	36 3b       	mov	r11,99
8001818c:	f6 0a 18 00 	cp.b	r10,r11
80018190:	c2 f0       	breq	800181ee <get_arg+0x172>
80018192:	36 4b       	mov	r11,100
80018194:	c0 e8       	rjmp	800181b0 <get_arg+0x134>
80018196:	37 0b       	mov	r11,112
80018198:	f6 0a 18 00 	cp.b	r10,r11
8001819c:	c2 50       	breq	800181e6 <get_arg+0x16a>
8001819e:	e0 8b 00 0d 	brhi	800181b8 <get_arg+0x13c>
800181a2:	36 eb       	mov	r11,110
800181a4:	f6 0a 18 00 	cp.b	r10,r11
800181a8:	c1 f0       	breq	800181e6 <get_arg+0x16a>
800181aa:	e0 8b 00 14 	brhi	800181d2 <get_arg+0x156>
800181ae:	36 9b       	mov	r11,105
800181b0:	f6 0a 18 00 	cp.b	r10,r11
800181b4:	c1 e1       	brne	800181f0 <get_arg+0x174>
800181b6:	c0 e8       	rjmp	800181d2 <get_arg+0x156>
800181b8:	37 5b       	mov	r11,117
800181ba:	f6 0a 18 00 	cp.b	r10,r11
800181be:	c0 a0       	breq	800181d2 <get_arg+0x156>
800181c0:	37 8b       	mov	r11,120
800181c2:	f6 0a 18 00 	cp.b	r10,r11
800181c6:	c0 60       	breq	800181d2 <get_arg+0x156>
800181c8:	37 3b       	mov	r11,115
800181ca:	f6 0a 18 00 	cp.b	r10,r11
800181ce:	c1 11       	brne	800181f0 <get_arg+0x174>
800181d0:	c0 b8       	rjmp	800181e6 <get_arg+0x16a>
800181d2:	ed b4 00 04 	bld	r4,0x4
800181d6:	c0 a0       	breq	800181ea <get_arg+0x16e>
800181d8:	ed b4 00 05 	bld	r4,0x5
800181dc:	c0 91       	brne	800181ee <get_arg+0x172>
800181de:	30 20       	mov	r0,2
800181e0:	c0 88       	rjmp	800181f0 <get_arg+0x174>
800181e2:	30 40       	mov	r0,4
800181e4:	c0 68       	rjmp	800181f0 <get_arg+0x174>
800181e6:	30 30       	mov	r0,3
800181e8:	c0 48       	rjmp	800181f0 <get_arg+0x174>
800181ea:	30 10       	mov	r0,1
800181ec:	c0 28       	rjmp	800181f0 <get_arg+0x174>
800181ee:	30 00       	mov	r0,0
800181f0:	40 3b       	lddsp	r11,sp[0xc]
800181f2:	5b fb       	cp.w	r11,-1
800181f4:	c0 40       	breq	800181fc <get_arg+0x180>
800181f6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800181fa:	c7 a8       	rjmp	800182ee <get_arg+0x272>
800181fc:	58 60       	cp.w	r0,6
800181fe:	e0 8b 00 78 	brhi	800182ee <get_arg+0x272>
80018202:	6c 0a       	ld.w	r10,r6[0x0]
80018204:	ea cc ff ff 	sub	r12,r5,-1
80018208:	48 6e       	lddpc	lr,80018220 <get_arg+0x1a4>
8001820a:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8001820e:	d7 03       	nop
80018210:	80 07       	ld.sh	r7,r0[0x0]
80018212:	0d 60       	ld.uh	r0,--r6
80018214:	80 07       	ld.sh	r7,r0[0x0]
80018216:	0c 9c       	mov	r12,r6
80018218:	80 07       	ld.sh	r7,r0[0x0]
8001821a:	0c 30       	cp.w	r0,r6
8001821c:	80 07       	ld.sh	r7,r0[0x0]
8001821e:	0a 90       	mov	r0,r5
80018220:	80 07       	ld.sh	r7,r0[0x0]
80018222:	0a b0       	st.h	r5++,r0
80018224:	f4 cb ff f8 	sub	r11,r10,-8
80018228:	8d 0b       	st.w	r6[0x0],r11
8001822a:	f4 ea 00 00 	ld.d	r10,r10[0]
8001822e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80018232:	c0 f8       	rjmp	80018250 <get_arg+0x1d4>
80018234:	f4 cb ff fc 	sub	r11,r10,-4
80018238:	8d 0b       	st.w	r6[0x0],r11
8001823a:	74 0a       	ld.w	r10,r10[0x0]
8001823c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80018240:	c0 88       	rjmp	80018250 <get_arg+0x1d4>
80018242:	f4 cb ff f8 	sub	r11,r10,-8
80018246:	8d 0b       	st.w	r6[0x0],r11
80018248:	f4 ea 00 00 	ld.d	r10,r10[0]
8001824c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80018250:	0e 9b       	mov	r11,r7
80018252:	18 95       	mov	r5,r12
80018254:	c4 e8       	rjmp	800182f0 <get_arg+0x274>
80018256:	62 0a       	ld.w	r10,r1[0x0]
80018258:	5b fa       	cp.w	r10,-1
8001825a:	c0 b1       	brne	80018270 <get_arg+0x1f4>
8001825c:	50 19       	stdsp	sp[0x4],r9
8001825e:	50 28       	stdsp	sp[0x8],r8
80018260:	e0 6a 00 80 	mov	r10,128
80018264:	30 0b       	mov	r11,0
80018266:	02 9c       	mov	r12,r1
80018268:	fe b0 fc 20 	rcall	80017aa8 <memset>
8001826c:	40 28       	lddsp	r8,sp[0x8]
8001826e:	40 19       	lddsp	r9,sp[0x4]
80018270:	e4 cc 00 01 	sub	r12,r2,1
80018274:	0e 9b       	mov	r11,r7
80018276:	50 3c       	stdsp	sp[0xc],r12
80018278:	f2 0c 0c 49 	max	r9,r9,r12
8001827c:	c3 a8       	rjmp	800182f0 <get_arg+0x274>
8001827e:	62 0a       	ld.w	r10,r1[0x0]
80018280:	5b fa       	cp.w	r10,-1
80018282:	c0 b1       	brne	80018298 <get_arg+0x21c>
80018284:	50 19       	stdsp	sp[0x4],r9
80018286:	50 28       	stdsp	sp[0x8],r8
80018288:	e0 6a 00 80 	mov	r10,128
8001828c:	30 0b       	mov	r11,0
8001828e:	02 9c       	mov	r12,r1
80018290:	fe b0 fc 0c 	rcall	80017aa8 <memset>
80018294:	40 28       	lddsp	r8,sp[0x8]
80018296:	40 19       	lddsp	r9,sp[0x4]
80018298:	20 12       	sub	r2,1
8001829a:	30 0a       	mov	r10,0
8001829c:	0e 9b       	mov	r11,r7
8001829e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800182a2:	f2 02 0c 49 	max	r9,r9,r2
800182a6:	c2 58       	rjmp	800182f0 <get_arg+0x274>
800182a8:	16 97       	mov	r7,r11
800182aa:	6c 0a       	ld.w	r10,r6[0x0]
800182ac:	f4 cb ff fc 	sub	r11,r10,-4
800182b0:	8d 0b       	st.w	r6[0x0],r11
800182b2:	74 0a       	ld.w	r10,r10[0x0]
800182b4:	0e 9b       	mov	r11,r7
800182b6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800182ba:	2f f5       	sub	r5,-1
800182bc:	c1 a8       	rjmp	800182f0 <get_arg+0x274>
800182be:	f4 c2 00 30 	sub	r2,r10,48
800182c2:	c0 68       	rjmp	800182ce <get_arg+0x252>
800182c4:	e4 02 00 22 	add	r2,r2,r2<<0x2
800182c8:	2f f7       	sub	r7,-1
800182ca:	f4 02 00 12 	add	r2,r10,r2<<0x1
800182ce:	0f 8a       	ld.ub	r10,r7[0x0]
800182d0:	58 0a       	cp.w	r10,0
800182d2:	c0 e0       	breq	800182ee <get_arg+0x272>
800182d4:	23 0a       	sub	r10,48
800182d6:	58 9a       	cp.w	r10,9
800182d8:	fe 98 ff f6 	brls	800182c4 <get_arg+0x248>
800182dc:	c0 98       	rjmp	800182ee <get_arg+0x272>
800182de:	2f f7       	sub	r7,-1
800182e0:	0f 8a       	ld.ub	r10,r7[0x0]
800182e2:	58 0a       	cp.w	r10,0
800182e4:	c0 50       	breq	800182ee <get_arg+0x272>
800182e6:	23 0a       	sub	r10,48
800182e8:	58 9a       	cp.w	r10,9
800182ea:	fe 98 ff fa 	brls	800182de <get_arg+0x262>
800182ee:	0e 9b       	mov	r11,r7
800182f0:	40 7c       	lddsp	r12,sp[0x1c]
800182f2:	30 ba       	mov	r10,11
800182f4:	f4 0c 18 00 	cp.b	r12,r10
800182f8:	fe 91 fe ec 	brne	800180d0 <get_arg+0x54>
800182fc:	40 42       	lddsp	r2,sp[0x10]
800182fe:	17 8c       	ld.ub	r12,r11[0x0]
80018300:	0a 32       	cp.w	r2,r5
80018302:	5f 4a       	srge	r10
80018304:	f0 0c 18 00 	cp.b	r12,r8
80018308:	5f 1c       	srne	r12
8001830a:	f9 ea 00 0a 	and	r10,r12,r10
8001830e:	f0 0a 18 00 	cp.b	r10,r8
80018312:	fe 91 fe c9 	brne	800180a4 <get_arg+0x28>
80018316:	30 08       	mov	r8,0
80018318:	40 4e       	lddsp	lr,sp[0x10]
8001831a:	17 8a       	ld.ub	r10,r11[0x0]
8001831c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80018320:	f0 0a 18 00 	cp.b	r10,r8
80018324:	fc 09 17 10 	movne	r9,lr
80018328:	e6 05 00 38 	add	r8,r3,r5<<0x3
8001832c:	06 9e       	mov	lr,r3
8001832e:	c2 a8       	rjmp	80018382 <get_arg+0x306>
80018330:	62 0a       	ld.w	r10,r1[0x0]
80018332:	58 3a       	cp.w	r10,3
80018334:	c1 e0       	breq	80018370 <get_arg+0x2f4>
80018336:	e0 89 00 07 	brgt	80018344 <get_arg+0x2c8>
8001833a:	58 1a       	cp.w	r10,1
8001833c:	c1 a0       	breq	80018370 <get_arg+0x2f4>
8001833e:	58 2a       	cp.w	r10,2
80018340:	c1 81       	brne	80018370 <get_arg+0x2f4>
80018342:	c0 58       	rjmp	8001834c <get_arg+0x2d0>
80018344:	58 5a       	cp.w	r10,5
80018346:	c0 c0       	breq	8001835e <get_arg+0x2e2>
80018348:	c0 b5       	brlt	8001835e <get_arg+0x2e2>
8001834a:	c1 38       	rjmp	80018370 <get_arg+0x2f4>
8001834c:	6c 0a       	ld.w	r10,r6[0x0]
8001834e:	f4 cc ff f8 	sub	r12,r10,-8
80018352:	8d 0c       	st.w	r6[0x0],r12
80018354:	f4 e2 00 00 	ld.d	r2,r10[0]
80018358:	f0 e3 00 00 	st.d	r8[0],r2
8001835c:	c1 08       	rjmp	8001837c <get_arg+0x300>
8001835e:	6c 0a       	ld.w	r10,r6[0x0]
80018360:	f4 cc ff f8 	sub	r12,r10,-8
80018364:	8d 0c       	st.w	r6[0x0],r12
80018366:	f4 e2 00 00 	ld.d	r2,r10[0]
8001836a:	f0 e3 00 00 	st.d	r8[0],r2
8001836e:	c0 78       	rjmp	8001837c <get_arg+0x300>
80018370:	6c 0a       	ld.w	r10,r6[0x0]
80018372:	f4 cc ff fc 	sub	r12,r10,-4
80018376:	8d 0c       	st.w	r6[0x0],r12
80018378:	74 0a       	ld.w	r10,r10[0x0]
8001837a:	91 0a       	st.w	r8[0x0],r10
8001837c:	2f f5       	sub	r5,-1
8001837e:	2f 88       	sub	r8,-8
80018380:	2f c1       	sub	r1,-4
80018382:	12 35       	cp.w	r5,r9
80018384:	fe 9a ff d6 	brle	80018330 <get_arg+0x2b4>
80018388:	1c 93       	mov	r3,lr
8001838a:	40 52       	lddsp	r2,sp[0x14]
8001838c:	40 6e       	lddsp	lr,sp[0x18]
8001838e:	85 05       	st.w	r2[0x0],r5
80018390:	9d 0b       	st.w	lr[0x0],r11
80018392:	40 4b       	lddsp	r11,sp[0x10]
80018394:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80018398:	2f 8d       	sub	sp,-32
8001839a:	d8 32       	popm	r0-r7,pc

8001839c <__sprint_r>:
8001839c:	d4 21       	pushm	r4-r7,lr
8001839e:	14 97       	mov	r7,r10
800183a0:	74 28       	ld.w	r8,r10[0x8]
800183a2:	58 08       	cp.w	r8,0
800183a4:	c0 41       	brne	800183ac <__sprint_r+0x10>
800183a6:	95 18       	st.w	r10[0x4],r8
800183a8:	10 9c       	mov	r12,r8
800183aa:	d8 22       	popm	r4-r7,pc
800183ac:	e0 a0 17 40 	rcall	8001b22c <__sfvwrite_r>
800183b0:	30 08       	mov	r8,0
800183b2:	8f 18       	st.w	r7[0x4],r8
800183b4:	8f 28       	st.w	r7[0x8],r8
800183b6:	d8 22       	popm	r4-r7,pc

800183b8 <_vfprintf_r>:
800183b8:	d4 31       	pushm	r0-r7,lr
800183ba:	fa cd 06 bc 	sub	sp,sp,1724
800183be:	51 09       	stdsp	sp[0x40],r9
800183c0:	16 91       	mov	r1,r11
800183c2:	14 97       	mov	r7,r10
800183c4:	18 95       	mov	r5,r12
800183c6:	e0 a0 18 7f 	rcall	8001b4c4 <_localeconv_r>
800183ca:	78 0c       	ld.w	r12,r12[0x0]
800183cc:	50 cc       	stdsp	sp[0x30],r12
800183ce:	58 05       	cp.w	r5,0
800183d0:	c0 70       	breq	800183de <_vfprintf_r+0x26>
800183d2:	6a 68       	ld.w	r8,r5[0x18]
800183d4:	58 08       	cp.w	r8,0
800183d6:	c0 41       	brne	800183de <_vfprintf_r+0x26>
800183d8:	0a 9c       	mov	r12,r5
800183da:	fe b0 f4 5d 	rcall	80016c94 <__sinit>
800183de:	4d 08       	lddpc	r8,8001851c <_vfprintf_r+0x164>
800183e0:	10 31       	cp.w	r1,r8
800183e2:	c0 31       	brne	800183e8 <_vfprintf_r+0x30>
800183e4:	6a 01       	ld.w	r1,r5[0x0]
800183e6:	c0 a8       	rjmp	800183fa <_vfprintf_r+0x42>
800183e8:	4c e8       	lddpc	r8,80018520 <_vfprintf_r+0x168>
800183ea:	10 31       	cp.w	r1,r8
800183ec:	c0 31       	brne	800183f2 <_vfprintf_r+0x3a>
800183ee:	6a 11       	ld.w	r1,r5[0x4]
800183f0:	c0 58       	rjmp	800183fa <_vfprintf_r+0x42>
800183f2:	4c d8       	lddpc	r8,80018524 <_vfprintf_r+0x16c>
800183f4:	10 31       	cp.w	r1,r8
800183f6:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800183fa:	82 68       	ld.sh	r8,r1[0xc]
800183fc:	ed b8 00 03 	bld	r8,0x3
80018400:	c0 41       	brne	80018408 <_vfprintf_r+0x50>
80018402:	62 48       	ld.w	r8,r1[0x10]
80018404:	58 08       	cp.w	r8,0
80018406:	c0 71       	brne	80018414 <_vfprintf_r+0x5c>
80018408:	02 9b       	mov	r11,r1
8001840a:	0a 9c       	mov	r12,r5
8001840c:	e0 a0 0f d6 	rcall	8001a3b8 <__swsetup_r>
80018410:	e0 81 0f 63 	brne	8001a2d6 <_vfprintf_r+0x1f1e>
80018414:	82 68       	ld.sh	r8,r1[0xc]
80018416:	10 99       	mov	r9,r8
80018418:	e2 19 00 1a 	andl	r9,0x1a,COH
8001841c:	58 a9       	cp.w	r9,10
8001841e:	c3 c1       	brne	80018496 <_vfprintf_r+0xde>
80018420:	82 79       	ld.sh	r9,r1[0xe]
80018422:	30 0a       	mov	r10,0
80018424:	f4 09 19 00 	cp.h	r9,r10
80018428:	c3 75       	brlt	80018496 <_vfprintf_r+0xde>
8001842a:	a1 d8       	cbr	r8,0x1
8001842c:	fb 58 05 d0 	st.h	sp[1488],r8
80018430:	62 88       	ld.w	r8,r1[0x20]
80018432:	fb 48 05 e4 	st.w	sp[1508],r8
80018436:	62 a8       	ld.w	r8,r1[0x28]
80018438:	fb 48 05 ec 	st.w	sp[1516],r8
8001843c:	fa c8 ff bc 	sub	r8,sp,-68
80018440:	fb 48 05 d4 	st.w	sp[1492],r8
80018444:	fb 48 05 c4 	st.w	sp[1476],r8
80018448:	e0 68 04 00 	mov	r8,1024
8001844c:	fb 48 05 d8 	st.w	sp[1496],r8
80018450:	fb 48 05 cc 	st.w	sp[1484],r8
80018454:	30 08       	mov	r8,0
80018456:	fb 59 05 d2 	st.h	sp[1490],r9
8001845a:	0e 9a       	mov	r10,r7
8001845c:	41 09       	lddsp	r9,sp[0x40]
8001845e:	fa c7 fa 3c 	sub	r7,sp,-1476
80018462:	fb 48 05 dc 	st.w	sp[1500],r8
80018466:	0a 9c       	mov	r12,r5
80018468:	0e 9b       	mov	r11,r7
8001846a:	ca 7f       	rcall	800183b8 <_vfprintf_r>
8001846c:	50 bc       	stdsp	sp[0x2c],r12
8001846e:	c0 95       	brlt	80018480 <_vfprintf_r+0xc8>
80018470:	0e 9b       	mov	r11,r7
80018472:	0a 9c       	mov	r12,r5
80018474:	fe b0 f3 20 	rcall	80016ab4 <_fflush_r>
80018478:	40 be       	lddsp	lr,sp[0x2c]
8001847a:	f9 be 01 ff 	movne	lr,-1
8001847e:	50 be       	stdsp	sp[0x2c],lr
80018480:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80018484:	ed b8 00 06 	bld	r8,0x6
80018488:	e0 81 0f 29 	brne	8001a2da <_vfprintf_r+0x1f22>
8001848c:	82 68       	ld.sh	r8,r1[0xc]
8001848e:	a7 a8       	sbr	r8,0x6
80018490:	a2 68       	st.h	r1[0xc],r8
80018492:	e0 8f 0f 24 	bral	8001a2da <_vfprintf_r+0x1f22>
80018496:	30 08       	mov	r8,0
80018498:	fb 48 06 b4 	st.w	sp[1716],r8
8001849c:	fb 48 06 90 	st.w	sp[1680],r8
800184a0:	fb 48 06 8c 	st.w	sp[1676],r8
800184a4:	fb 48 06 b0 	st.w	sp[1712],r8
800184a8:	30 08       	mov	r8,0
800184aa:	30 09       	mov	r9,0
800184ac:	50 a7       	stdsp	sp[0x28],r7
800184ae:	50 78       	stdsp	sp[0x1c],r8
800184b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800184b4:	3f f8       	mov	r8,-1
800184b6:	50 59       	stdsp	sp[0x14],r9
800184b8:	fb 43 06 88 	st.w	sp[1672],r3
800184bc:	fb 48 05 44 	st.w	sp[1348],r8
800184c0:	12 9c       	mov	r12,r9
800184c2:	50 69       	stdsp	sp[0x18],r9
800184c4:	50 d9       	stdsp	sp[0x34],r9
800184c6:	50 e9       	stdsp	sp[0x38],r9
800184c8:	50 b9       	stdsp	sp[0x2c],r9
800184ca:	12 97       	mov	r7,r9
800184cc:	0a 94       	mov	r4,r5
800184ce:	40 a2       	lddsp	r2,sp[0x28]
800184d0:	32 5a       	mov	r10,37
800184d2:	30 08       	mov	r8,0
800184d4:	c0 28       	rjmp	800184d8 <_vfprintf_r+0x120>
800184d6:	2f f2       	sub	r2,-1
800184d8:	05 89       	ld.ub	r9,r2[0x0]
800184da:	f0 09 18 00 	cp.b	r9,r8
800184de:	5f 1b       	srne	r11
800184e0:	f4 09 18 00 	cp.b	r9,r10
800184e4:	5f 19       	srne	r9
800184e6:	f3 eb 00 0b 	and	r11,r9,r11
800184ea:	f0 0b 18 00 	cp.b	r11,r8
800184ee:	cf 41       	brne	800184d6 <_vfprintf_r+0x11e>
800184f0:	40 ab       	lddsp	r11,sp[0x28]
800184f2:	e4 0b 01 06 	sub	r6,r2,r11
800184f6:	c2 50       	breq	80018540 <_vfprintf_r+0x188>
800184f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800184fc:	0c 08       	add	r8,r6
800184fe:	87 0b       	st.w	r3[0x0],r11
80018500:	fb 48 06 90 	st.w	sp[1680],r8
80018504:	87 16       	st.w	r3[0x4],r6
80018506:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001850a:	2f f8       	sub	r8,-1
8001850c:	fb 48 06 8c 	st.w	sp[1676],r8
80018510:	58 78       	cp.w	r8,7
80018512:	e0 89 00 0b 	brgt	80018528 <_vfprintf_r+0x170>
80018516:	2f 83       	sub	r3,-8
80018518:	c1 18       	rjmp	8001853a <_vfprintf_r+0x182>
8001851a:	d7 03       	nop
8001851c:	80 07       	ld.sh	r7,r0[0x0]
8001851e:	0a 2c       	rsub	r12,r5
80018520:	80 07       	ld.sh	r7,r0[0x0]
80018522:	0a 4c       	or	r12,r5
80018524:	80 07       	ld.sh	r7,r0[0x0]
80018526:	0a 6c       	and	r12,r5
80018528:	fa ca f9 78 	sub	r10,sp,-1672
8001852c:	02 9b       	mov	r11,r1
8001852e:	08 9c       	mov	r12,r4
80018530:	c3 6f       	rcall	8001839c <__sprint_r>
80018532:	e0 81 0e ce 	brne	8001a2ce <_vfprintf_r+0x1f16>
80018536:	fa c3 f9 e0 	sub	r3,sp,-1568
8001853a:	40 ba       	lddsp	r10,sp[0x2c]
8001853c:	0c 0a       	add	r10,r6
8001853e:	50 ba       	stdsp	sp[0x2c],r10
80018540:	05 89       	ld.ub	r9,r2[0x0]
80018542:	30 08       	mov	r8,0
80018544:	f0 09 18 00 	cp.b	r9,r8
80018548:	e0 80 0e b2 	breq	8001a2ac <_vfprintf_r+0x1ef4>
8001854c:	30 09       	mov	r9,0
8001854e:	fb 68 06 bb 	st.b	sp[1723],r8
80018552:	0e 96       	mov	r6,r7
80018554:	e4 c8 ff ff 	sub	r8,r2,-1
80018558:	3f fe       	mov	lr,-1
8001855a:	50 93       	stdsp	sp[0x24],r3
8001855c:	50 41       	stdsp	sp[0x10],r1
8001855e:	0e 93       	mov	r3,r7
80018560:	04 91       	mov	r1,r2
80018562:	50 89       	stdsp	sp[0x20],r9
80018564:	50 a8       	stdsp	sp[0x28],r8
80018566:	50 2e       	stdsp	sp[0x8],lr
80018568:	50 39       	stdsp	sp[0xc],r9
8001856a:	12 95       	mov	r5,r9
8001856c:	12 90       	mov	r0,r9
8001856e:	10 97       	mov	r7,r8
80018570:	08 92       	mov	r2,r4
80018572:	c0 78       	rjmp	80018580 <_vfprintf_r+0x1c8>
80018574:	3f fc       	mov	r12,-1
80018576:	08 97       	mov	r7,r4
80018578:	50 2c       	stdsp	sp[0x8],r12
8001857a:	c0 38       	rjmp	80018580 <_vfprintf_r+0x1c8>
8001857c:	30 0b       	mov	r11,0
8001857e:	50 3b       	stdsp	sp[0xc],r11
80018580:	0f 38       	ld.ub	r8,r7++
80018582:	c0 28       	rjmp	80018586 <_vfprintf_r+0x1ce>
80018584:	12 90       	mov	r0,r9
80018586:	f0 c9 00 20 	sub	r9,r8,32
8001858a:	e0 49 00 58 	cp.w	r9,88
8001858e:	e0 8b 0a 36 	brhi	800199fa <_vfprintf_r+0x1642>
80018592:	4d 9a       	lddpc	r10,800186f4 <_vfprintf_r+0x33c>
80018594:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80018598:	50 a7       	stdsp	sp[0x28],r7
8001859a:	50 80       	stdsp	sp[0x20],r0
8001859c:	0c 97       	mov	r7,r6
8001859e:	04 94       	mov	r4,r2
800185a0:	06 96       	mov	r6,r3
800185a2:	02 92       	mov	r2,r1
800185a4:	4d 59       	lddpc	r9,800186f8 <_vfprintf_r+0x340>
800185a6:	40 93       	lddsp	r3,sp[0x24]
800185a8:	10 90       	mov	r0,r8
800185aa:	40 41       	lddsp	r1,sp[0x10]
800185ac:	50 d9       	stdsp	sp[0x34],r9
800185ae:	e0 8f 08 95 	bral	800196d8 <_vfprintf_r+0x1320>
800185b2:	30 08       	mov	r8,0
800185b4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800185b8:	f0 09 18 00 	cp.b	r9,r8
800185bc:	ce 21       	brne	80018580 <_vfprintf_r+0x1c8>
800185be:	32 08       	mov	r8,32
800185c0:	c6 e8       	rjmp	8001869c <_vfprintf_r+0x2e4>
800185c2:	a1 a5       	sbr	r5,0x0
800185c4:	cd eb       	rjmp	80018580 <_vfprintf_r+0x1c8>
800185c6:	0f 89       	ld.ub	r9,r7[0x0]
800185c8:	f2 c8 00 30 	sub	r8,r9,48
800185cc:	58 98       	cp.w	r8,9
800185ce:	e0 8b 00 1d 	brhi	80018608 <_vfprintf_r+0x250>
800185d2:	ee c8 ff ff 	sub	r8,r7,-1
800185d6:	30 0b       	mov	r11,0
800185d8:	23 09       	sub	r9,48
800185da:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800185de:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800185e2:	11 39       	ld.ub	r9,r8++
800185e4:	f2 ca 00 30 	sub	r10,r9,48
800185e8:	58 9a       	cp.w	r10,9
800185ea:	fe 98 ff f7 	brls	800185d8 <_vfprintf_r+0x220>
800185ee:	e0 49 00 24 	cp.w	r9,36
800185f2:	cc 51       	brne	8001857c <_vfprintf_r+0x1c4>
800185f4:	e0 4b 00 20 	cp.w	r11,32
800185f8:	e0 89 0e 6a 	brgt	8001a2cc <_vfprintf_r+0x1f14>
800185fc:	20 1b       	sub	r11,1
800185fe:	fa f9 06 b4 	ld.w	r9,sp[1716]
80018602:	12 3b       	cp.w	r11,r9
80018604:	c0 95       	brlt	80018616 <_vfprintf_r+0x25e>
80018606:	c1 08       	rjmp	80018626 <_vfprintf_r+0x26e>
80018608:	fa f9 06 b4 	ld.w	r9,sp[1716]
8001860c:	ec ca ff ff 	sub	r10,r6,-1
80018610:	12 36       	cp.w	r6,r9
80018612:	c1 f5       	brlt	80018650 <_vfprintf_r+0x298>
80018614:	c2 68       	rjmp	80018660 <_vfprintf_r+0x2a8>
80018616:	fa ce f9 44 	sub	lr,sp,-1724
8001861a:	10 97       	mov	r7,r8
8001861c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80018620:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80018624:	c3 58       	rjmp	8001868e <_vfprintf_r+0x2d6>
80018626:	10 97       	mov	r7,r8
80018628:	fa c8 f9 50 	sub	r8,sp,-1712
8001862c:	1a d8       	st.w	--sp,r8
8001862e:	fa c8 fa b8 	sub	r8,sp,-1352
80018632:	1a d8       	st.w	--sp,r8
80018634:	fa c8 fb b4 	sub	r8,sp,-1100
80018638:	02 9a       	mov	r10,r1
8001863a:	1a d8       	st.w	--sp,r8
8001863c:	04 9c       	mov	r12,r2
8001863e:	fa c8 f9 40 	sub	r8,sp,-1728
80018642:	fa c9 ff b4 	sub	r9,sp,-76
80018646:	fe b0 fd 1b 	rcall	8001807c <get_arg>
8001864a:	2f dd       	sub	sp,-12
8001864c:	78 00       	ld.w	r0,r12[0x0]
8001864e:	c2 08       	rjmp	8001868e <_vfprintf_r+0x2d6>
80018650:	fa cc f9 44 	sub	r12,sp,-1724
80018654:	14 96       	mov	r6,r10
80018656:	f8 03 00 38 	add	r8,r12,r3<<0x3
8001865a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8001865e:	c1 88       	rjmp	8001868e <_vfprintf_r+0x2d6>
80018660:	41 08       	lddsp	r8,sp[0x40]
80018662:	59 f9       	cp.w	r9,31
80018664:	e0 89 00 11 	brgt	80018686 <_vfprintf_r+0x2ce>
80018668:	f0 cb ff fc 	sub	r11,r8,-4
8001866c:	51 0b       	stdsp	sp[0x40],r11
8001866e:	70 00       	ld.w	r0,r8[0x0]
80018670:	fa cb f9 44 	sub	r11,sp,-1724
80018674:	f6 09 00 38 	add	r8,r11,r9<<0x3
80018678:	f1 40 fd 88 	st.w	r8[-632],r0
8001867c:	2f f9       	sub	r9,-1
8001867e:	14 96       	mov	r6,r10
80018680:	fb 49 06 b4 	st.w	sp[1716],r9
80018684:	c0 58       	rjmp	8001868e <_vfprintf_r+0x2d6>
80018686:	70 00       	ld.w	r0,r8[0x0]
80018688:	14 96       	mov	r6,r10
8001868a:	2f c8       	sub	r8,-4
8001868c:	51 08       	stdsp	sp[0x40],r8
8001868e:	58 00       	cp.w	r0,0
80018690:	fe 94 ff 78 	brge	80018580 <_vfprintf_r+0x1c8>
80018694:	5c 30       	neg	r0
80018696:	a3 a5       	sbr	r5,0x2
80018698:	c7 4b       	rjmp	80018580 <_vfprintf_r+0x1c8>
8001869a:	32 b8       	mov	r8,43
8001869c:	fb 68 06 bb 	st.b	sp[1723],r8
800186a0:	c7 0b       	rjmp	80018580 <_vfprintf_r+0x1c8>
800186a2:	0f 38       	ld.ub	r8,r7++
800186a4:	e0 48 00 2a 	cp.w	r8,42
800186a8:	c0 30       	breq	800186ae <_vfprintf_r+0x2f6>
800186aa:	30 09       	mov	r9,0
800186ac:	c7 d8       	rjmp	800187a6 <_vfprintf_r+0x3ee>
800186ae:	0f 88       	ld.ub	r8,r7[0x0]
800186b0:	f0 c9 00 30 	sub	r9,r8,48
800186b4:	58 99       	cp.w	r9,9
800186b6:	e0 8b 00 23 	brhi	800186fc <_vfprintf_r+0x344>
800186ba:	ee c4 ff ff 	sub	r4,r7,-1
800186be:	30 0b       	mov	r11,0
800186c0:	23 08       	sub	r8,48
800186c2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800186c6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800186ca:	09 38       	ld.ub	r8,r4++
800186cc:	f0 c9 00 30 	sub	r9,r8,48
800186d0:	58 99       	cp.w	r9,9
800186d2:	fe 98 ff f7 	brls	800186c0 <_vfprintf_r+0x308>
800186d6:	e0 48 00 24 	cp.w	r8,36
800186da:	fe 91 ff 51 	brne	8001857c <_vfprintf_r+0x1c4>
800186de:	e0 4b 00 20 	cp.w	r11,32
800186e2:	e0 89 0d f5 	brgt	8001a2cc <_vfprintf_r+0x1f14>
800186e6:	20 1b       	sub	r11,1
800186e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800186ec:	10 3b       	cp.w	r11,r8
800186ee:	c0 e5       	brlt	8001870a <_vfprintf_r+0x352>
800186f0:	c1 58       	rjmp	8001871a <_vfprintf_r+0x362>
800186f2:	d7 03       	nop
800186f4:	80 07       	ld.sh	r7,r0[0x0]
800186f6:	0a cc       	st.b	r5++,r12
800186f8:	80 07       	ld.sh	r7,r0[0x0]
800186fa:	0d 08       	ld.w	r8,r6++
800186fc:	fa fa 06 b4 	ld.w	r10,sp[1716]
80018700:	ec c9 ff ff 	sub	r9,r6,-1
80018704:	14 36       	cp.w	r6,r10
80018706:	c1 f5       	brlt	80018744 <_vfprintf_r+0x38c>
80018708:	c2 88       	rjmp	80018758 <_vfprintf_r+0x3a0>
8001870a:	fa ca f9 44 	sub	r10,sp,-1724
8001870e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80018712:	f6 fb fd 88 	ld.w	r11,r11[-632]
80018716:	50 2b       	stdsp	sp[0x8],r11
80018718:	c3 c8       	rjmp	80018790 <_vfprintf_r+0x3d8>
8001871a:	fa c8 f9 50 	sub	r8,sp,-1712
8001871e:	1a d8       	st.w	--sp,r8
80018720:	fa c8 fa b8 	sub	r8,sp,-1352
80018724:	1a d8       	st.w	--sp,r8
80018726:	fa c8 fb b4 	sub	r8,sp,-1100
8001872a:	02 9a       	mov	r10,r1
8001872c:	1a d8       	st.w	--sp,r8
8001872e:	04 9c       	mov	r12,r2
80018730:	fa c8 f9 40 	sub	r8,sp,-1728
80018734:	fa c9 ff b4 	sub	r9,sp,-76
80018738:	fe b0 fc a2 	rcall	8001807c <get_arg>
8001873c:	2f dd       	sub	sp,-12
8001873e:	78 0c       	ld.w	r12,r12[0x0]
80018740:	50 2c       	stdsp	sp[0x8],r12
80018742:	c2 78       	rjmp	80018790 <_vfprintf_r+0x3d8>
80018744:	12 96       	mov	r6,r9
80018746:	0e 94       	mov	r4,r7
80018748:	fa c9 f9 44 	sub	r9,sp,-1724
8001874c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80018750:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80018754:	50 28       	stdsp	sp[0x8],r8
80018756:	c1 d8       	rjmp	80018790 <_vfprintf_r+0x3d8>
80018758:	41 08       	lddsp	r8,sp[0x40]
8001875a:	59 fa       	cp.w	r10,31
8001875c:	e0 89 00 14 	brgt	80018784 <_vfprintf_r+0x3cc>
80018760:	f0 cb ff fc 	sub	r11,r8,-4
80018764:	70 08       	ld.w	r8,r8[0x0]
80018766:	51 0b       	stdsp	sp[0x40],r11
80018768:	50 28       	stdsp	sp[0x8],r8
8001876a:	fa c6 f9 44 	sub	r6,sp,-1724
8001876e:	40 2e       	lddsp	lr,sp[0x8]
80018770:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80018774:	f1 4e fd 88 	st.w	r8[-632],lr
80018778:	2f fa       	sub	r10,-1
8001877a:	0e 94       	mov	r4,r7
8001877c:	fb 4a 06 b4 	st.w	sp[1716],r10
80018780:	12 96       	mov	r6,r9
80018782:	c0 78       	rjmp	80018790 <_vfprintf_r+0x3d8>
80018784:	70 0c       	ld.w	r12,r8[0x0]
80018786:	0e 94       	mov	r4,r7
80018788:	2f c8       	sub	r8,-4
8001878a:	50 2c       	stdsp	sp[0x8],r12
8001878c:	12 96       	mov	r6,r9
8001878e:	51 08       	stdsp	sp[0x40],r8
80018790:	40 2b       	lddsp	r11,sp[0x8]
80018792:	58 0b       	cp.w	r11,0
80018794:	fe 95 fe f0 	brlt	80018574 <_vfprintf_r+0x1bc>
80018798:	08 97       	mov	r7,r4
8001879a:	cf 3a       	rjmp	80018580 <_vfprintf_r+0x1c8>
8001879c:	f2 09 00 29 	add	r9,r9,r9<<0x2
800187a0:	0f 38       	ld.ub	r8,r7++
800187a2:	f4 09 00 19 	add	r9,r10,r9<<0x1
800187a6:	f0 ca 00 30 	sub	r10,r8,48
800187aa:	58 9a       	cp.w	r10,9
800187ac:	fe 98 ff f8 	brls	8001879c <_vfprintf_r+0x3e4>
800187b0:	3f fa       	mov	r10,-1
800187b2:	f2 0a 0c 49 	max	r9,r9,r10
800187b6:	50 29       	stdsp	sp[0x8],r9
800187b8:	ce 7a       	rjmp	80018586 <_vfprintf_r+0x1ce>
800187ba:	a7 b5       	sbr	r5,0x7
800187bc:	ce 2a       	rjmp	80018580 <_vfprintf_r+0x1c8>
800187be:	30 09       	mov	r9,0
800187c0:	23 08       	sub	r8,48
800187c2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800187c6:	f0 09 00 19 	add	r9,r8,r9<<0x1
800187ca:	0f 38       	ld.ub	r8,r7++
800187cc:	f0 ca 00 30 	sub	r10,r8,48
800187d0:	58 9a       	cp.w	r10,9
800187d2:	fe 98 ff f7 	brls	800187c0 <_vfprintf_r+0x408>
800187d6:	e0 48 00 24 	cp.w	r8,36
800187da:	fe 91 fe d5 	brne	80018584 <_vfprintf_r+0x1cc>
800187de:	e0 49 00 20 	cp.w	r9,32
800187e2:	e0 89 0d 75 	brgt	8001a2cc <_vfprintf_r+0x1f14>
800187e6:	f2 c3 00 01 	sub	r3,r9,1
800187ea:	30 19       	mov	r9,1
800187ec:	50 39       	stdsp	sp[0xc],r9
800187ee:	cc 9a       	rjmp	80018580 <_vfprintf_r+0x1c8>
800187f0:	a3 b5       	sbr	r5,0x3
800187f2:	cc 7a       	rjmp	80018580 <_vfprintf_r+0x1c8>
800187f4:	a7 a5       	sbr	r5,0x6
800187f6:	cc 5a       	rjmp	80018580 <_vfprintf_r+0x1c8>
800187f8:	0a 98       	mov	r8,r5
800187fa:	a5 b5       	sbr	r5,0x5
800187fc:	a5 a8       	sbr	r8,0x4
800187fe:	0f 89       	ld.ub	r9,r7[0x0]
80018800:	36 ce       	mov	lr,108
80018802:	fc 09 18 00 	cp.b	r9,lr
80018806:	f7 b7 00 ff 	subeq	r7,-1
8001880a:	f0 05 17 10 	movne	r5,r8
8001880e:	cb 9a       	rjmp	80018580 <_vfprintf_r+0x1c8>
80018810:	a5 b5       	sbr	r5,0x5
80018812:	cb 7a       	rjmp	80018580 <_vfprintf_r+0x1c8>
80018814:	50 a7       	stdsp	sp[0x28],r7
80018816:	50 80       	stdsp	sp[0x20],r0
80018818:	0c 97       	mov	r7,r6
8001881a:	10 90       	mov	r0,r8
8001881c:	06 96       	mov	r6,r3
8001881e:	04 94       	mov	r4,r2
80018820:	40 93       	lddsp	r3,sp[0x24]
80018822:	02 92       	mov	r2,r1
80018824:	0e 99       	mov	r9,r7
80018826:	40 41       	lddsp	r1,sp[0x10]
80018828:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001882c:	40 3c       	lddsp	r12,sp[0xc]
8001882e:	58 0c       	cp.w	r12,0
80018830:	c1 d0       	breq	8001886a <_vfprintf_r+0x4b2>
80018832:	10 36       	cp.w	r6,r8
80018834:	c0 64       	brge	80018840 <_vfprintf_r+0x488>
80018836:	fa cb f9 44 	sub	r11,sp,-1724
8001883a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001883e:	c1 d8       	rjmp	80018878 <_vfprintf_r+0x4c0>
80018840:	fa c8 f9 50 	sub	r8,sp,-1712
80018844:	1a d8       	st.w	--sp,r8
80018846:	fa c8 fa b8 	sub	r8,sp,-1352
8001884a:	1a d8       	st.w	--sp,r8
8001884c:	fa c8 fb b4 	sub	r8,sp,-1100
80018850:	1a d8       	st.w	--sp,r8
80018852:	fa c8 f9 40 	sub	r8,sp,-1728
80018856:	fa c9 ff b4 	sub	r9,sp,-76
8001885a:	04 9a       	mov	r10,r2
8001885c:	0c 9b       	mov	r11,r6
8001885e:	08 9c       	mov	r12,r4
80018860:	fe b0 fc 0e 	rcall	8001807c <get_arg>
80018864:	2f dd       	sub	sp,-12
80018866:	19 b8       	ld.ub	r8,r12[0x3]
80018868:	c2 28       	rjmp	800188ac <_vfprintf_r+0x4f4>
8001886a:	2f f7       	sub	r7,-1
8001886c:	10 39       	cp.w	r9,r8
8001886e:	c0 84       	brge	8001887e <_vfprintf_r+0x4c6>
80018870:	fa ca f9 44 	sub	r10,sp,-1724
80018874:	f4 06 00 36 	add	r6,r10,r6<<0x3
80018878:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8001887c:	c1 88       	rjmp	800188ac <_vfprintf_r+0x4f4>
8001887e:	41 09       	lddsp	r9,sp[0x40]
80018880:	59 f8       	cp.w	r8,31
80018882:	e0 89 00 12 	brgt	800188a6 <_vfprintf_r+0x4ee>
80018886:	f2 ca ff fc 	sub	r10,r9,-4
8001888a:	51 0a       	stdsp	sp[0x40],r10
8001888c:	72 09       	ld.w	r9,r9[0x0]
8001888e:	fa c6 f9 44 	sub	r6,sp,-1724
80018892:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80018896:	2f f8       	sub	r8,-1
80018898:	f5 49 fd 88 	st.w	r10[-632],r9
8001889c:	fb 48 06 b4 	st.w	sp[1716],r8
800188a0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800188a4:	c0 48       	rjmp	800188ac <_vfprintf_r+0x4f4>
800188a6:	13 b8       	ld.ub	r8,r9[0x3]
800188a8:	2f c9       	sub	r9,-4
800188aa:	51 09       	stdsp	sp[0x40],r9
800188ac:	fb 68 06 60 	st.b	sp[1632],r8
800188b0:	30 0e       	mov	lr,0
800188b2:	30 08       	mov	r8,0
800188b4:	30 12       	mov	r2,1
800188b6:	fb 68 06 bb 	st.b	sp[1723],r8
800188ba:	50 2e       	stdsp	sp[0x8],lr
800188bc:	e0 8f 08 b1 	bral	80019a1e <_vfprintf_r+0x1666>
800188c0:	50 a7       	stdsp	sp[0x28],r7
800188c2:	50 80       	stdsp	sp[0x20],r0
800188c4:	0c 97       	mov	r7,r6
800188c6:	04 94       	mov	r4,r2
800188c8:	06 96       	mov	r6,r3
800188ca:	02 92       	mov	r2,r1
800188cc:	40 93       	lddsp	r3,sp[0x24]
800188ce:	10 90       	mov	r0,r8
800188d0:	40 41       	lddsp	r1,sp[0x10]
800188d2:	a5 a5       	sbr	r5,0x4
800188d4:	c0 a8       	rjmp	800188e8 <_vfprintf_r+0x530>
800188d6:	50 a7       	stdsp	sp[0x28],r7
800188d8:	50 80       	stdsp	sp[0x20],r0
800188da:	0c 97       	mov	r7,r6
800188dc:	04 94       	mov	r4,r2
800188de:	06 96       	mov	r6,r3
800188e0:	02 92       	mov	r2,r1
800188e2:	40 93       	lddsp	r3,sp[0x24]
800188e4:	10 90       	mov	r0,r8
800188e6:	40 41       	lddsp	r1,sp[0x10]
800188e8:	ed b5 00 05 	bld	r5,0x5
800188ec:	c5 11       	brne	8001898e <_vfprintf_r+0x5d6>
800188ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800188f2:	40 3c       	lddsp	r12,sp[0xc]
800188f4:	58 0c       	cp.w	r12,0
800188f6:	c1 e0       	breq	80018932 <_vfprintf_r+0x57a>
800188f8:	10 36       	cp.w	r6,r8
800188fa:	c0 64       	brge	80018906 <_vfprintf_r+0x54e>
800188fc:	fa cb f9 44 	sub	r11,sp,-1724
80018900:	f6 06 00 36 	add	r6,r11,r6<<0x3
80018904:	c2 08       	rjmp	80018944 <_vfprintf_r+0x58c>
80018906:	fa c8 f9 50 	sub	r8,sp,-1712
8001890a:	1a d8       	st.w	--sp,r8
8001890c:	fa c8 fa b8 	sub	r8,sp,-1352
80018910:	0c 9b       	mov	r11,r6
80018912:	1a d8       	st.w	--sp,r8
80018914:	fa c8 fb b4 	sub	r8,sp,-1100
80018918:	1a d8       	st.w	--sp,r8
8001891a:	fa c9 ff b4 	sub	r9,sp,-76
8001891e:	fa c8 f9 40 	sub	r8,sp,-1728
80018922:	04 9a       	mov	r10,r2
80018924:	08 9c       	mov	r12,r4
80018926:	fe b0 fb ab 	rcall	8001807c <get_arg>
8001892a:	2f dd       	sub	sp,-12
8001892c:	78 1b       	ld.w	r11,r12[0x4]
8001892e:	78 09       	ld.w	r9,r12[0x0]
80018930:	c2 b8       	rjmp	80018986 <_vfprintf_r+0x5ce>
80018932:	ee ca ff ff 	sub	r10,r7,-1
80018936:	10 37       	cp.w	r7,r8
80018938:	c0 b4       	brge	8001894e <_vfprintf_r+0x596>
8001893a:	fa c9 f9 44 	sub	r9,sp,-1724
8001893e:	14 97       	mov	r7,r10
80018940:	f2 06 00 36 	add	r6,r9,r6<<0x3
80018944:	ec fb fd 8c 	ld.w	r11,r6[-628]
80018948:	ec f9 fd 88 	ld.w	r9,r6[-632]
8001894c:	c1 d8       	rjmp	80018986 <_vfprintf_r+0x5ce>
8001894e:	41 09       	lddsp	r9,sp[0x40]
80018950:	59 f8       	cp.w	r8,31
80018952:	e0 89 00 14 	brgt	8001897a <_vfprintf_r+0x5c2>
80018956:	f2 cb ff f8 	sub	r11,r9,-8
8001895a:	51 0b       	stdsp	sp[0x40],r11
8001895c:	fa c6 f9 44 	sub	r6,sp,-1724
80018960:	72 1b       	ld.w	r11,r9[0x4]
80018962:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80018966:	72 09       	ld.w	r9,r9[0x0]
80018968:	f9 4b fd 8c 	st.w	r12[-628],r11
8001896c:	f9 49 fd 88 	st.w	r12[-632],r9
80018970:	2f f8       	sub	r8,-1
80018972:	14 97       	mov	r7,r10
80018974:	fb 48 06 b4 	st.w	sp[1716],r8
80018978:	c0 78       	rjmp	80018986 <_vfprintf_r+0x5ce>
8001897a:	f2 c8 ff f8 	sub	r8,r9,-8
8001897e:	72 1b       	ld.w	r11,r9[0x4]
80018980:	14 97       	mov	r7,r10
80018982:	51 08       	stdsp	sp[0x40],r8
80018984:	72 09       	ld.w	r9,r9[0x0]
80018986:	16 98       	mov	r8,r11
80018988:	fa e9 00 00 	st.d	sp[0],r8
8001898c:	ca e8       	rjmp	80018ae8 <_vfprintf_r+0x730>
8001898e:	ed b5 00 04 	bld	r5,0x4
80018992:	c1 71       	brne	800189c0 <_vfprintf_r+0x608>
80018994:	fa f8 06 b4 	ld.w	r8,sp[1716]
80018998:	40 3e       	lddsp	lr,sp[0xc]
8001899a:	58 0e       	cp.w	lr,0
8001899c:	c0 80       	breq	800189ac <_vfprintf_r+0x5f4>
8001899e:	10 36       	cp.w	r6,r8
800189a0:	c6 94       	brge	80018a72 <_vfprintf_r+0x6ba>
800189a2:	fa cc f9 44 	sub	r12,sp,-1724
800189a6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800189aa:	c8 28       	rjmp	80018aae <_vfprintf_r+0x6f6>
800189ac:	ee ca ff ff 	sub	r10,r7,-1
800189b0:	10 37       	cp.w	r7,r8
800189b2:	e0 84 00 81 	brge	80018ab4 <_vfprintf_r+0x6fc>
800189b6:	fa cb f9 44 	sub	r11,sp,-1724
800189ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800189be:	c7 78       	rjmp	80018aac <_vfprintf_r+0x6f4>
800189c0:	ed b5 00 06 	bld	r5,0x6
800189c4:	c4 b1       	brne	80018a5a <_vfprintf_r+0x6a2>
800189c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800189ca:	40 3c       	lddsp	r12,sp[0xc]
800189cc:	58 0c       	cp.w	r12,0
800189ce:	c1 d0       	breq	80018a08 <_vfprintf_r+0x650>
800189d0:	10 36       	cp.w	r6,r8
800189d2:	c0 64       	brge	800189de <_vfprintf_r+0x626>
800189d4:	fa cb f9 44 	sub	r11,sp,-1724
800189d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800189dc:	c1 f8       	rjmp	80018a1a <_vfprintf_r+0x662>
800189de:	fa c8 f9 50 	sub	r8,sp,-1712
800189e2:	1a d8       	st.w	--sp,r8
800189e4:	fa c8 fa b8 	sub	r8,sp,-1352
800189e8:	1a d8       	st.w	--sp,r8
800189ea:	fa c8 fb b4 	sub	r8,sp,-1100
800189ee:	1a d8       	st.w	--sp,r8
800189f0:	fa c8 f9 40 	sub	r8,sp,-1728
800189f4:	fa c9 ff b4 	sub	r9,sp,-76
800189f8:	04 9a       	mov	r10,r2
800189fa:	0c 9b       	mov	r11,r6
800189fc:	08 9c       	mov	r12,r4
800189fe:	fe b0 fb 3f 	rcall	8001807c <get_arg>
80018a02:	2f dd       	sub	sp,-12
80018a04:	98 18       	ld.sh	r8,r12[0x2]
80018a06:	c2 68       	rjmp	80018a52 <_vfprintf_r+0x69a>
80018a08:	ee ca ff ff 	sub	r10,r7,-1
80018a0c:	10 37       	cp.w	r7,r8
80018a0e:	c0 94       	brge	80018a20 <_vfprintf_r+0x668>
80018a10:	fa c9 f9 44 	sub	r9,sp,-1724
80018a14:	14 97       	mov	r7,r10
80018a16:	f2 06 00 36 	add	r6,r9,r6<<0x3
80018a1a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80018a1e:	c1 a8       	rjmp	80018a52 <_vfprintf_r+0x69a>
80018a20:	41 09       	lddsp	r9,sp[0x40]
80018a22:	59 f8       	cp.w	r8,31
80018a24:	e0 89 00 13 	brgt	80018a4a <_vfprintf_r+0x692>
80018a28:	f2 cb ff fc 	sub	r11,r9,-4
80018a2c:	51 0b       	stdsp	sp[0x40],r11
80018a2e:	72 09       	ld.w	r9,r9[0x0]
80018a30:	fa c6 f9 44 	sub	r6,sp,-1724
80018a34:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80018a38:	2f f8       	sub	r8,-1
80018a3a:	f7 49 fd 88 	st.w	r11[-632],r9
80018a3e:	fb 48 06 b4 	st.w	sp[1716],r8
80018a42:	14 97       	mov	r7,r10
80018a44:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80018a48:	c0 58       	rjmp	80018a52 <_vfprintf_r+0x69a>
80018a4a:	92 18       	ld.sh	r8,r9[0x2]
80018a4c:	14 97       	mov	r7,r10
80018a4e:	2f c9       	sub	r9,-4
80018a50:	51 09       	stdsp	sp[0x40],r9
80018a52:	50 18       	stdsp	sp[0x4],r8
80018a54:	bf 58       	asr	r8,0x1f
80018a56:	50 08       	stdsp	sp[0x0],r8
80018a58:	c4 88       	rjmp	80018ae8 <_vfprintf_r+0x730>
80018a5a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80018a5e:	40 3c       	lddsp	r12,sp[0xc]
80018a60:	58 0c       	cp.w	r12,0
80018a62:	c1 d0       	breq	80018a9c <_vfprintf_r+0x6e4>
80018a64:	10 36       	cp.w	r6,r8
80018a66:	c0 64       	brge	80018a72 <_vfprintf_r+0x6ba>
80018a68:	fa cb f9 44 	sub	r11,sp,-1724
80018a6c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80018a70:	c1 f8       	rjmp	80018aae <_vfprintf_r+0x6f6>
80018a72:	fa c8 f9 50 	sub	r8,sp,-1712
80018a76:	1a d8       	st.w	--sp,r8
80018a78:	fa c8 fa b8 	sub	r8,sp,-1352
80018a7c:	0c 9b       	mov	r11,r6
80018a7e:	1a d8       	st.w	--sp,r8
80018a80:	fa c8 fb b4 	sub	r8,sp,-1100
80018a84:	04 9a       	mov	r10,r2
80018a86:	1a d8       	st.w	--sp,r8
80018a88:	08 9c       	mov	r12,r4
80018a8a:	fa c8 f9 40 	sub	r8,sp,-1728
80018a8e:	fa c9 ff b4 	sub	r9,sp,-76
80018a92:	fe b0 fa f5 	rcall	8001807c <get_arg>
80018a96:	2f dd       	sub	sp,-12
80018a98:	78 0b       	ld.w	r11,r12[0x0]
80018a9a:	c2 48       	rjmp	80018ae2 <_vfprintf_r+0x72a>
80018a9c:	ee ca ff ff 	sub	r10,r7,-1
80018aa0:	10 37       	cp.w	r7,r8
80018aa2:	c0 94       	brge	80018ab4 <_vfprintf_r+0x6fc>
80018aa4:	fa c9 f9 44 	sub	r9,sp,-1724
80018aa8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80018aac:	14 97       	mov	r7,r10
80018aae:	ec fb fd 88 	ld.w	r11,r6[-632]
80018ab2:	c1 88       	rjmp	80018ae2 <_vfprintf_r+0x72a>
80018ab4:	41 09       	lddsp	r9,sp[0x40]
80018ab6:	59 f8       	cp.w	r8,31
80018ab8:	e0 89 00 11 	brgt	80018ada <_vfprintf_r+0x722>
80018abc:	f2 cb ff fc 	sub	r11,r9,-4
80018ac0:	51 0b       	stdsp	sp[0x40],r11
80018ac2:	fa c6 f9 44 	sub	r6,sp,-1724
80018ac6:	72 0b       	ld.w	r11,r9[0x0]
80018ac8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80018acc:	f3 4b fd 88 	st.w	r9[-632],r11
80018ad0:	2f f8       	sub	r8,-1
80018ad2:	14 97       	mov	r7,r10
80018ad4:	fb 48 06 b4 	st.w	sp[1716],r8
80018ad8:	c0 58       	rjmp	80018ae2 <_vfprintf_r+0x72a>
80018ada:	72 0b       	ld.w	r11,r9[0x0]
80018adc:	14 97       	mov	r7,r10
80018ade:	2f c9       	sub	r9,-4
80018ae0:	51 09       	stdsp	sp[0x40],r9
80018ae2:	50 1b       	stdsp	sp[0x4],r11
80018ae4:	bf 5b       	asr	r11,0x1f
80018ae6:	50 0b       	stdsp	sp[0x0],r11
80018ae8:	fa ea 00 00 	ld.d	r10,sp[0]
80018aec:	58 0a       	cp.w	r10,0
80018aee:	5c 2b       	cpc	r11
80018af0:	c0 e4       	brge	80018b0c <_vfprintf_r+0x754>
80018af2:	30 08       	mov	r8,0
80018af4:	fa ea 00 00 	ld.d	r10,sp[0]
80018af8:	30 09       	mov	r9,0
80018afa:	f0 0a 01 0a 	sub	r10,r8,r10
80018afe:	f2 0b 01 4b 	sbc	r11,r9,r11
80018b02:	32 d8       	mov	r8,45
80018b04:	fa eb 00 00 	st.d	sp[0],r10
80018b08:	fb 68 06 bb 	st.b	sp[1723],r8
80018b0c:	30 18       	mov	r8,1
80018b0e:	e0 8f 06 fe 	bral	8001990a <_vfprintf_r+0x1552>
80018b12:	50 a7       	stdsp	sp[0x28],r7
80018b14:	50 80       	stdsp	sp[0x20],r0
80018b16:	0c 97       	mov	r7,r6
80018b18:	04 94       	mov	r4,r2
80018b1a:	06 96       	mov	r6,r3
80018b1c:	02 92       	mov	r2,r1
80018b1e:	40 93       	lddsp	r3,sp[0x24]
80018b20:	10 90       	mov	r0,r8
80018b22:	40 41       	lddsp	r1,sp[0x10]
80018b24:	0e 99       	mov	r9,r7
80018b26:	ed b5 00 03 	bld	r5,0x3
80018b2a:	c4 11       	brne	80018bac <_vfprintf_r+0x7f4>
80018b2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80018b30:	40 3a       	lddsp	r10,sp[0xc]
80018b32:	58 0a       	cp.w	r10,0
80018b34:	c1 90       	breq	80018b66 <_vfprintf_r+0x7ae>
80018b36:	10 36       	cp.w	r6,r8
80018b38:	c6 45       	brlt	80018c00 <_vfprintf_r+0x848>
80018b3a:	fa c8 f9 50 	sub	r8,sp,-1712
80018b3e:	1a d8       	st.w	--sp,r8
80018b40:	fa c8 fa b8 	sub	r8,sp,-1352
80018b44:	1a d8       	st.w	--sp,r8
80018b46:	fa c8 fb b4 	sub	r8,sp,-1100
80018b4a:	0c 9b       	mov	r11,r6
80018b4c:	1a d8       	st.w	--sp,r8
80018b4e:	04 9a       	mov	r10,r2
80018b50:	fa c8 f9 40 	sub	r8,sp,-1728
80018b54:	fa c9 ff b4 	sub	r9,sp,-76
80018b58:	08 9c       	mov	r12,r4
80018b5a:	fe b0 fa 91 	rcall	8001807c <get_arg>
80018b5e:	2f dd       	sub	sp,-12
80018b60:	78 16       	ld.w	r6,r12[0x4]
80018b62:	50 76       	stdsp	sp[0x1c],r6
80018b64:	c4 88       	rjmp	80018bf4 <_vfprintf_r+0x83c>
80018b66:	2f f7       	sub	r7,-1
80018b68:	10 39       	cp.w	r9,r8
80018b6a:	c0 c4       	brge	80018b82 <_vfprintf_r+0x7ca>
80018b6c:	fa ce f9 44 	sub	lr,sp,-1724
80018b70:	fc 06 00 36 	add	r6,lr,r6<<0x3
80018b74:	ec fc fd 8c 	ld.w	r12,r6[-628]
80018b78:	50 7c       	stdsp	sp[0x1c],r12
80018b7a:	ec f6 fd 88 	ld.w	r6,r6[-632]
80018b7e:	50 56       	stdsp	sp[0x14],r6
80018b80:	c6 68       	rjmp	80018c4c <_vfprintf_r+0x894>
80018b82:	41 09       	lddsp	r9,sp[0x40]
80018b84:	59 f8       	cp.w	r8,31
80018b86:	e0 89 00 10 	brgt	80018ba6 <_vfprintf_r+0x7ee>
80018b8a:	f2 ca ff f8 	sub	r10,r9,-8
80018b8e:	72 1b       	ld.w	r11,r9[0x4]
80018b90:	51 0a       	stdsp	sp[0x40],r10
80018b92:	72 09       	ld.w	r9,r9[0x0]
80018b94:	fa ca f9 44 	sub	r10,sp,-1724
80018b98:	50 7b       	stdsp	sp[0x1c],r11
80018b9a:	50 59       	stdsp	sp[0x14],r9
80018b9c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80018ba0:	40 5b       	lddsp	r11,sp[0x14]
80018ba2:	40 7a       	lddsp	r10,sp[0x1c]
80018ba4:	c4 78       	rjmp	80018c32 <_vfprintf_r+0x87a>
80018ba6:	72 18       	ld.w	r8,r9[0x4]
80018ba8:	50 78       	stdsp	sp[0x1c],r8
80018baa:	c4 c8       	rjmp	80018c42 <_vfprintf_r+0x88a>
80018bac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80018bb0:	40 3e       	lddsp	lr,sp[0xc]
80018bb2:	58 0e       	cp.w	lr,0
80018bb4:	c2 30       	breq	80018bfa <_vfprintf_r+0x842>
80018bb6:	10 36       	cp.w	r6,r8
80018bb8:	c0 94       	brge	80018bca <_vfprintf_r+0x812>
80018bba:	fa cc f9 44 	sub	r12,sp,-1724
80018bbe:	f8 06 00 36 	add	r6,r12,r6<<0x3
80018bc2:	ec fb fd 8c 	ld.w	r11,r6[-628]
80018bc6:	50 7b       	stdsp	sp[0x1c],r11
80018bc8:	cd 9b       	rjmp	80018b7a <_vfprintf_r+0x7c2>
80018bca:	fa c8 f9 50 	sub	r8,sp,-1712
80018bce:	1a d8       	st.w	--sp,r8
80018bd0:	fa c8 fa b8 	sub	r8,sp,-1352
80018bd4:	04 9a       	mov	r10,r2
80018bd6:	1a d8       	st.w	--sp,r8
80018bd8:	fa c8 fb b4 	sub	r8,sp,-1100
80018bdc:	0c 9b       	mov	r11,r6
80018bde:	1a d8       	st.w	--sp,r8
80018be0:	08 9c       	mov	r12,r4
80018be2:	fa c8 f9 40 	sub	r8,sp,-1728
80018be6:	fa c9 ff b4 	sub	r9,sp,-76
80018bea:	fe b0 fa 49 	rcall	8001807c <get_arg>
80018bee:	2f dd       	sub	sp,-12
80018bf0:	78 1a       	ld.w	r10,r12[0x4]
80018bf2:	50 7a       	stdsp	sp[0x1c],r10
80018bf4:	78 0c       	ld.w	r12,r12[0x0]
80018bf6:	50 5c       	stdsp	sp[0x14],r12
80018bf8:	c2 a8       	rjmp	80018c4c <_vfprintf_r+0x894>
80018bfa:	2f f7       	sub	r7,-1
80018bfc:	10 39       	cp.w	r9,r8
80018bfe:	c0 94       	brge	80018c10 <_vfprintf_r+0x858>
80018c00:	fa c9 f9 44 	sub	r9,sp,-1724
80018c04:	f2 06 00 36 	add	r6,r9,r6<<0x3
80018c08:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80018c0c:	50 78       	stdsp	sp[0x1c],r8
80018c0e:	cb 6b       	rjmp	80018b7a <_vfprintf_r+0x7c2>
80018c10:	41 09       	lddsp	r9,sp[0x40]
80018c12:	59 f8       	cp.w	r8,31
80018c14:	e0 89 00 15 	brgt	80018c3e <_vfprintf_r+0x886>
80018c18:	f2 ca ff f8 	sub	r10,r9,-8
80018c1c:	72 16       	ld.w	r6,r9[0x4]
80018c1e:	72 09       	ld.w	r9,r9[0x0]
80018c20:	51 0a       	stdsp	sp[0x40],r10
80018c22:	50 59       	stdsp	sp[0x14],r9
80018c24:	fa ce f9 44 	sub	lr,sp,-1724
80018c28:	50 76       	stdsp	sp[0x1c],r6
80018c2a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80018c2e:	40 5b       	lddsp	r11,sp[0x14]
80018c30:	0c 9a       	mov	r10,r6
80018c32:	f2 eb fd 88 	st.d	r9[-632],r10
80018c36:	2f f8       	sub	r8,-1
80018c38:	fb 48 06 b4 	st.w	sp[1716],r8
80018c3c:	c0 88       	rjmp	80018c4c <_vfprintf_r+0x894>
80018c3e:	72 1c       	ld.w	r12,r9[0x4]
80018c40:	50 7c       	stdsp	sp[0x1c],r12
80018c42:	f2 c8 ff f8 	sub	r8,r9,-8
80018c46:	51 08       	stdsp	sp[0x40],r8
80018c48:	72 09       	ld.w	r9,r9[0x0]
80018c4a:	50 59       	stdsp	sp[0x14],r9
80018c4c:	40 5b       	lddsp	r11,sp[0x14]
80018c4e:	40 7a       	lddsp	r10,sp[0x1c]
80018c50:	e0 a0 18 e4 	rcall	8001be18 <__isinfd>
80018c54:	18 96       	mov	r6,r12
80018c56:	c1 50       	breq	80018c80 <_vfprintf_r+0x8c8>
80018c58:	30 08       	mov	r8,0
80018c5a:	30 09       	mov	r9,0
80018c5c:	40 5b       	lddsp	r11,sp[0x14]
80018c5e:	40 7a       	lddsp	r10,sp[0x1c]
80018c60:	e0 a0 1c 3e 	rcall	8001c4dc <__avr32_f64_cmp_lt>
80018c64:	c0 40       	breq	80018c6c <_vfprintf_r+0x8b4>
80018c66:	32 d8       	mov	r8,45
80018c68:	fb 68 06 bb 	st.b	sp[1723],r8
80018c6c:	4d 18       	lddpc	r8,80018db0 <_vfprintf_r+0x9f8>
80018c6e:	4d 26       	lddpc	r6,80018db4 <_vfprintf_r+0x9fc>
80018c70:	a7 d5       	cbr	r5,0x7
80018c72:	e0 40 00 47 	cp.w	r0,71
80018c76:	f0 06 17 a0 	movle	r6,r8
80018c7a:	30 32       	mov	r2,3
80018c7c:	e0 8f 06 d4 	bral	80019a24 <_vfprintf_r+0x166c>
80018c80:	40 5b       	lddsp	r11,sp[0x14]
80018c82:	40 7a       	lddsp	r10,sp[0x1c]
80018c84:	e0 a0 18 df 	rcall	8001be42 <__isnand>
80018c88:	c0 c0       	breq	80018ca0 <_vfprintf_r+0x8e8>
80018c8a:	50 26       	stdsp	sp[0x8],r6
80018c8c:	4c b8       	lddpc	r8,80018db8 <_vfprintf_r+0xa00>
80018c8e:	4c c6       	lddpc	r6,80018dbc <_vfprintf_r+0xa04>
80018c90:	a7 d5       	cbr	r5,0x7
80018c92:	e0 40 00 47 	cp.w	r0,71
80018c96:	f0 06 17 a0 	movle	r6,r8
80018c9a:	30 32       	mov	r2,3
80018c9c:	e0 8f 06 ca 	bral	80019a30 <_vfprintf_r+0x1678>
80018ca0:	40 2a       	lddsp	r10,sp[0x8]
80018ca2:	5b fa       	cp.w	r10,-1
80018ca4:	c0 41       	brne	80018cac <_vfprintf_r+0x8f4>
80018ca6:	30 69       	mov	r9,6
80018ca8:	50 29       	stdsp	sp[0x8],r9
80018caa:	c1 18       	rjmp	80018ccc <_vfprintf_r+0x914>
80018cac:	e0 40 00 47 	cp.w	r0,71
80018cb0:	5f 09       	sreq	r9
80018cb2:	e0 40 00 67 	cp.w	r0,103
80018cb6:	5f 08       	sreq	r8
80018cb8:	f3 e8 10 08 	or	r8,r9,r8
80018cbc:	f8 08 18 00 	cp.b	r8,r12
80018cc0:	c0 60       	breq	80018ccc <_vfprintf_r+0x914>
80018cc2:	40 28       	lddsp	r8,sp[0x8]
80018cc4:	58 08       	cp.w	r8,0
80018cc6:	f9 b8 00 01 	moveq	r8,1
80018cca:	50 28       	stdsp	sp[0x8],r8
80018ccc:	40 78       	lddsp	r8,sp[0x1c]
80018cce:	40 59       	lddsp	r9,sp[0x14]
80018cd0:	fa e9 06 94 	st.d	sp[1684],r8
80018cd4:	a9 a5       	sbr	r5,0x8
80018cd6:	fa f8 06 94 	ld.w	r8,sp[1684]
80018cda:	58 08       	cp.w	r8,0
80018cdc:	c0 65       	brlt	80018ce8 <_vfprintf_r+0x930>
80018cde:	40 5e       	lddsp	lr,sp[0x14]
80018ce0:	30 0c       	mov	r12,0
80018ce2:	50 6e       	stdsp	sp[0x18],lr
80018ce4:	50 9c       	stdsp	sp[0x24],r12
80018ce6:	c0 78       	rjmp	80018cf4 <_vfprintf_r+0x93c>
80018ce8:	40 5b       	lddsp	r11,sp[0x14]
80018cea:	32 da       	mov	r10,45
80018cec:	ee 1b 80 00 	eorh	r11,0x8000
80018cf0:	50 9a       	stdsp	sp[0x24],r10
80018cf2:	50 6b       	stdsp	sp[0x18],r11
80018cf4:	e0 40 00 46 	cp.w	r0,70
80018cf8:	5f 09       	sreq	r9
80018cfa:	e0 40 00 66 	cp.w	r0,102
80018cfe:	5f 08       	sreq	r8
80018d00:	f3 e8 10 08 	or	r8,r9,r8
80018d04:	50 48       	stdsp	sp[0x10],r8
80018d06:	c0 40       	breq	80018d0e <_vfprintf_r+0x956>
80018d08:	40 22       	lddsp	r2,sp[0x8]
80018d0a:	30 39       	mov	r9,3
80018d0c:	c1 08       	rjmp	80018d2c <_vfprintf_r+0x974>
80018d0e:	e0 40 00 45 	cp.w	r0,69
80018d12:	5f 09       	sreq	r9
80018d14:	e0 40 00 65 	cp.w	r0,101
80018d18:	5f 08       	sreq	r8
80018d1a:	40 22       	lddsp	r2,sp[0x8]
80018d1c:	10 49       	or	r9,r8
80018d1e:	2f f2       	sub	r2,-1
80018d20:	40 46       	lddsp	r6,sp[0x10]
80018d22:	ec 09 18 00 	cp.b	r9,r6
80018d26:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80018d2a:	30 29       	mov	r9,2
80018d2c:	fa c8 f9 5c 	sub	r8,sp,-1700
80018d30:	1a d8       	st.w	--sp,r8
80018d32:	fa c8 f9 54 	sub	r8,sp,-1708
80018d36:	1a d8       	st.w	--sp,r8
80018d38:	fa c8 f9 4c 	sub	r8,sp,-1716
80018d3c:	08 9c       	mov	r12,r4
80018d3e:	1a d8       	st.w	--sp,r8
80018d40:	04 98       	mov	r8,r2
80018d42:	40 9b       	lddsp	r11,sp[0x24]
80018d44:	40 aa       	lddsp	r10,sp[0x28]
80018d46:	e0 a0 0c 49 	rcall	8001a5d8 <_dtoa_r>
80018d4a:	e0 40 00 47 	cp.w	r0,71
80018d4e:	5f 19       	srne	r9
80018d50:	e0 40 00 67 	cp.w	r0,103
80018d54:	5f 18       	srne	r8
80018d56:	18 96       	mov	r6,r12
80018d58:	2f dd       	sub	sp,-12
80018d5a:	f3 e8 00 08 	and	r8,r9,r8
80018d5e:	c0 41       	brne	80018d66 <_vfprintf_r+0x9ae>
80018d60:	ed b5 00 00 	bld	r5,0x0
80018d64:	c3 81       	brne	80018dd4 <_vfprintf_r+0xa1c>
80018d66:	ec 02 00 0e 	add	lr,r6,r2
80018d6a:	50 3e       	stdsp	sp[0xc],lr
80018d6c:	40 4c       	lddsp	r12,sp[0x10]
80018d6e:	58 0c       	cp.w	r12,0
80018d70:	c1 50       	breq	80018d9a <_vfprintf_r+0x9e2>
80018d72:	0d 89       	ld.ub	r9,r6[0x0]
80018d74:	33 08       	mov	r8,48
80018d76:	f0 09 18 00 	cp.b	r9,r8
80018d7a:	c0 b1       	brne	80018d90 <_vfprintf_r+0x9d8>
80018d7c:	30 08       	mov	r8,0
80018d7e:	30 09       	mov	r9,0
80018d80:	40 6b       	lddsp	r11,sp[0x18]
80018d82:	40 7a       	lddsp	r10,sp[0x1c]
80018d84:	e0 a0 1b 65 	rcall	8001c44e <__avr32_f64_cmp_eq>
80018d88:	fb b2 00 01 	rsubeq	r2,1
80018d8c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80018d90:	40 3b       	lddsp	r11,sp[0xc]
80018d92:	fa f8 06 ac 	ld.w	r8,sp[1708]
80018d96:	10 0b       	add	r11,r8
80018d98:	50 3b       	stdsp	sp[0xc],r11
80018d9a:	40 6b       	lddsp	r11,sp[0x18]
80018d9c:	30 08       	mov	r8,0
80018d9e:	30 09       	mov	r9,0
80018da0:	40 7a       	lddsp	r10,sp[0x1c]
80018da2:	e0 a0 1b 56 	rcall	8001c44e <__avr32_f64_cmp_eq>
80018da6:	c1 10       	breq	80018dc8 <_vfprintf_r+0xa10>
80018da8:	40 3a       	lddsp	r10,sp[0xc]
80018daa:	fb 4a 06 a4 	st.w	sp[1700],r10
80018dae:	c0 d8       	rjmp	80018dc8 <_vfprintf_r+0xa10>
80018db0:	80 07       	ld.sh	r7,r0[0x0]
80018db2:	0d 1c       	ld.sh	r12,r6++
80018db4:	80 07       	ld.sh	r7,r0[0x0]
80018db6:	0d 20       	ld.uh	r0,r6++
80018db8:	80 07       	ld.sh	r7,r0[0x0]
80018dba:	0d 24       	ld.uh	r4,r6++
80018dbc:	80 07       	ld.sh	r7,r0[0x0]
80018dbe:	0d 28       	ld.uh	r8,r6++
80018dc0:	10 c9       	st.b	r8++,r9
80018dc2:	fb 48 06 a4 	st.w	sp[1700],r8
80018dc6:	c0 28       	rjmp	80018dca <_vfprintf_r+0xa12>
80018dc8:	33 09       	mov	r9,48
80018dca:	fa f8 06 a4 	ld.w	r8,sp[1700]
80018dce:	40 3e       	lddsp	lr,sp[0xc]
80018dd0:	1c 38       	cp.w	r8,lr
80018dd2:	cf 73       	brcs	80018dc0 <_vfprintf_r+0xa08>
80018dd4:	e0 40 00 47 	cp.w	r0,71
80018dd8:	5f 09       	sreq	r9
80018dda:	e0 40 00 67 	cp.w	r0,103
80018dde:	5f 08       	sreq	r8
80018de0:	f3 e8 10 08 	or	r8,r9,r8
80018de4:	fa f9 06 a4 	ld.w	r9,sp[1700]
80018de8:	0c 19       	sub	r9,r6
80018dea:	50 69       	stdsp	sp[0x18],r9
80018dec:	58 08       	cp.w	r8,0
80018dee:	c0 b0       	breq	80018e04 <_vfprintf_r+0xa4c>
80018df0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80018df4:	5b d8       	cp.w	r8,-3
80018df6:	c0 55       	brlt	80018e00 <_vfprintf_r+0xa48>
80018df8:	40 2c       	lddsp	r12,sp[0x8]
80018dfa:	18 38       	cp.w	r8,r12
80018dfc:	e0 8a 00 6a 	brle	80018ed0 <_vfprintf_r+0xb18>
80018e00:	20 20       	sub	r0,2
80018e02:	c0 58       	rjmp	80018e0c <_vfprintf_r+0xa54>
80018e04:	e0 40 00 65 	cp.w	r0,101
80018e08:	e0 89 00 46 	brgt	80018e94 <_vfprintf_r+0xadc>
80018e0c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80018e10:	fb 60 06 9c 	st.b	sp[1692],r0
80018e14:	20 1b       	sub	r11,1
80018e16:	fb 4b 06 ac 	st.w	sp[1708],r11
80018e1a:	c0 47       	brpl	80018e22 <_vfprintf_r+0xa6a>
80018e1c:	5c 3b       	neg	r11
80018e1e:	32 d8       	mov	r8,45
80018e20:	c0 28       	rjmp	80018e24 <_vfprintf_r+0xa6c>
80018e22:	32 b8       	mov	r8,43
80018e24:	fb 68 06 9d 	st.b	sp[1693],r8
80018e28:	58 9b       	cp.w	r11,9
80018e2a:	e0 8a 00 1d 	brle	80018e64 <_vfprintf_r+0xaac>
80018e2e:	fa c9 fa 35 	sub	r9,sp,-1483
80018e32:	30 aa       	mov	r10,10
80018e34:	12 98       	mov	r8,r9
80018e36:	0e 9c       	mov	r12,r7
80018e38:	0c 92       	mov	r2,r6
80018e3a:	f6 0a 0c 06 	divs	r6,r11,r10
80018e3e:	0e 9b       	mov	r11,r7
80018e40:	2d 0b       	sub	r11,-48
80018e42:	10 fb       	st.b	--r8,r11
80018e44:	0c 9b       	mov	r11,r6
80018e46:	58 96       	cp.w	r6,9
80018e48:	fe 99 ff f9 	brgt	80018e3a <_vfprintf_r+0xa82>
80018e4c:	2d 0b       	sub	r11,-48
80018e4e:	18 97       	mov	r7,r12
80018e50:	04 96       	mov	r6,r2
80018e52:	10 fb       	st.b	--r8,r11
80018e54:	fa ca f9 62 	sub	r10,sp,-1694
80018e58:	c0 38       	rjmp	80018e5e <_vfprintf_r+0xaa6>
80018e5a:	11 3b       	ld.ub	r11,r8++
80018e5c:	14 cb       	st.b	r10++,r11
80018e5e:	12 38       	cp.w	r8,r9
80018e60:	cf d3       	brcs	80018e5a <_vfprintf_r+0xaa2>
80018e62:	c0 98       	rjmp	80018e74 <_vfprintf_r+0xabc>
80018e64:	2d 0b       	sub	r11,-48
80018e66:	33 08       	mov	r8,48
80018e68:	fb 6b 06 9f 	st.b	sp[1695],r11
80018e6c:	fb 68 06 9e 	st.b	sp[1694],r8
80018e70:	fa ca f9 60 	sub	r10,sp,-1696
80018e74:	fa c8 f9 64 	sub	r8,sp,-1692
80018e78:	f4 08 01 08 	sub	r8,r10,r8
80018e7c:	50 e8       	stdsp	sp[0x38],r8
80018e7e:	10 92       	mov	r2,r8
80018e80:	40 6b       	lddsp	r11,sp[0x18]
80018e82:	16 02       	add	r2,r11
80018e84:	58 1b       	cp.w	r11,1
80018e86:	e0 89 00 05 	brgt	80018e90 <_vfprintf_r+0xad8>
80018e8a:	ed b5 00 00 	bld	r5,0x0
80018e8e:	c3 51       	brne	80018ef8 <_vfprintf_r+0xb40>
80018e90:	2f f2       	sub	r2,-1
80018e92:	c3 38       	rjmp	80018ef8 <_vfprintf_r+0xb40>
80018e94:	e0 40 00 66 	cp.w	r0,102
80018e98:	c1 c1       	brne	80018ed0 <_vfprintf_r+0xb18>
80018e9a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80018e9e:	58 02       	cp.w	r2,0
80018ea0:	e0 8a 00 0c 	brle	80018eb8 <_vfprintf_r+0xb00>
80018ea4:	40 2a       	lddsp	r10,sp[0x8]
80018ea6:	58 0a       	cp.w	r10,0
80018ea8:	c0 41       	brne	80018eb0 <_vfprintf_r+0xaf8>
80018eaa:	ed b5 00 00 	bld	r5,0x0
80018eae:	c2 51       	brne	80018ef8 <_vfprintf_r+0xb40>
80018eb0:	2f f2       	sub	r2,-1
80018eb2:	40 29       	lddsp	r9,sp[0x8]
80018eb4:	12 02       	add	r2,r9
80018eb6:	c0 b8       	rjmp	80018ecc <_vfprintf_r+0xb14>
80018eb8:	40 28       	lddsp	r8,sp[0x8]
80018eba:	58 08       	cp.w	r8,0
80018ebc:	c0 61       	brne	80018ec8 <_vfprintf_r+0xb10>
80018ebe:	ed b5 00 00 	bld	r5,0x0
80018ec2:	c0 30       	breq	80018ec8 <_vfprintf_r+0xb10>
80018ec4:	30 12       	mov	r2,1
80018ec6:	c1 98       	rjmp	80018ef8 <_vfprintf_r+0xb40>
80018ec8:	40 22       	lddsp	r2,sp[0x8]
80018eca:	2f e2       	sub	r2,-2
80018ecc:	36 60       	mov	r0,102
80018ece:	c1 58       	rjmp	80018ef8 <_vfprintf_r+0xb40>
80018ed0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80018ed4:	40 6e       	lddsp	lr,sp[0x18]
80018ed6:	1c 32       	cp.w	r2,lr
80018ed8:	c0 65       	brlt	80018ee4 <_vfprintf_r+0xb2c>
80018eda:	ed b5 00 00 	bld	r5,0x0
80018ede:	f7 b2 00 ff 	subeq	r2,-1
80018ee2:	c0 a8       	rjmp	80018ef6 <_vfprintf_r+0xb3e>
80018ee4:	e4 08 11 02 	rsub	r8,r2,2
80018ee8:	40 6c       	lddsp	r12,sp[0x18]
80018eea:	58 02       	cp.w	r2,0
80018eec:	f0 02 17 a0 	movle	r2,r8
80018ef0:	f9 b2 09 01 	movgt	r2,1
80018ef4:	18 02       	add	r2,r12
80018ef6:	36 70       	mov	r0,103
80018ef8:	40 9b       	lddsp	r11,sp[0x24]
80018efa:	58 0b       	cp.w	r11,0
80018efc:	e0 80 05 94 	breq	80019a24 <_vfprintf_r+0x166c>
80018f00:	32 d8       	mov	r8,45
80018f02:	fb 68 06 bb 	st.b	sp[1723],r8
80018f06:	e0 8f 05 93 	bral	80019a2c <_vfprintf_r+0x1674>
80018f0a:	50 a7       	stdsp	sp[0x28],r7
80018f0c:	04 94       	mov	r4,r2
80018f0e:	0c 97       	mov	r7,r6
80018f10:	02 92       	mov	r2,r1
80018f12:	06 96       	mov	r6,r3
80018f14:	40 41       	lddsp	r1,sp[0x10]
80018f16:	40 93       	lddsp	r3,sp[0x24]
80018f18:	0e 99       	mov	r9,r7
80018f1a:	ed b5 00 05 	bld	r5,0x5
80018f1e:	c4 81       	brne	80018fae <_vfprintf_r+0xbf6>
80018f20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80018f24:	40 3e       	lddsp	lr,sp[0xc]
80018f26:	58 0e       	cp.w	lr,0
80018f28:	c1 d0       	breq	80018f62 <_vfprintf_r+0xbaa>
80018f2a:	10 36       	cp.w	r6,r8
80018f2c:	c0 64       	brge	80018f38 <_vfprintf_r+0xb80>
80018f2e:	fa cc f9 44 	sub	r12,sp,-1724
80018f32:	f8 06 00 36 	add	r6,r12,r6<<0x3
80018f36:	c1 d8       	rjmp	80018f70 <_vfprintf_r+0xbb8>
80018f38:	fa c8 f9 50 	sub	r8,sp,-1712
80018f3c:	1a d8       	st.w	--sp,r8
80018f3e:	fa c8 fa b8 	sub	r8,sp,-1352
80018f42:	04 9a       	mov	r10,r2
80018f44:	1a d8       	st.w	--sp,r8
80018f46:	fa c8 fb b4 	sub	r8,sp,-1100
80018f4a:	0c 9b       	mov	r11,r6
80018f4c:	1a d8       	st.w	--sp,r8
80018f4e:	08 9c       	mov	r12,r4
80018f50:	fa c8 f9 40 	sub	r8,sp,-1728
80018f54:	fa c9 ff b4 	sub	r9,sp,-76
80018f58:	fe b0 f8 92 	rcall	8001807c <get_arg>
80018f5c:	2f dd       	sub	sp,-12
80018f5e:	78 0a       	ld.w	r10,r12[0x0]
80018f60:	c2 08       	rjmp	80018fa0 <_vfprintf_r+0xbe8>
80018f62:	2f f7       	sub	r7,-1
80018f64:	10 39       	cp.w	r9,r8
80018f66:	c0 84       	brge	80018f76 <_vfprintf_r+0xbbe>
80018f68:	fa cb f9 44 	sub	r11,sp,-1724
80018f6c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80018f70:	ec fa fd 88 	ld.w	r10,r6[-632]
80018f74:	c1 68       	rjmp	80018fa0 <_vfprintf_r+0xbe8>
80018f76:	41 09       	lddsp	r9,sp[0x40]
80018f78:	59 f8       	cp.w	r8,31
80018f7a:	e0 89 00 10 	brgt	80018f9a <_vfprintf_r+0xbe2>
80018f7e:	f2 ca ff fc 	sub	r10,r9,-4
80018f82:	51 0a       	stdsp	sp[0x40],r10
80018f84:	fa c6 f9 44 	sub	r6,sp,-1724
80018f88:	72 0a       	ld.w	r10,r9[0x0]
80018f8a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80018f8e:	f3 4a fd 88 	st.w	r9[-632],r10
80018f92:	2f f8       	sub	r8,-1
80018f94:	fb 48 06 b4 	st.w	sp[1716],r8
80018f98:	c0 48       	rjmp	80018fa0 <_vfprintf_r+0xbe8>
80018f9a:	72 0a       	ld.w	r10,r9[0x0]
80018f9c:	2f c9       	sub	r9,-4
80018f9e:	51 09       	stdsp	sp[0x40],r9
80018fa0:	40 be       	lddsp	lr,sp[0x2c]
80018fa2:	1c 98       	mov	r8,lr
80018fa4:	95 1e       	st.w	r10[0x4],lr
80018fa6:	bf 58       	asr	r8,0x1f
80018fa8:	95 08       	st.w	r10[0x0],r8
80018faa:	fe 9f fa 92 	bral	800184ce <_vfprintf_r+0x116>
80018fae:	ed b5 00 04 	bld	r5,0x4
80018fb2:	c4 80       	breq	80019042 <_vfprintf_r+0xc8a>
80018fb4:	e2 15 00 40 	andl	r5,0x40,COH
80018fb8:	c4 50       	breq	80019042 <_vfprintf_r+0xc8a>
80018fba:	fa f8 06 b4 	ld.w	r8,sp[1716]
80018fbe:	40 3c       	lddsp	r12,sp[0xc]
80018fc0:	58 0c       	cp.w	r12,0
80018fc2:	c1 d0       	breq	80018ffc <_vfprintf_r+0xc44>
80018fc4:	10 36       	cp.w	r6,r8
80018fc6:	c0 64       	brge	80018fd2 <_vfprintf_r+0xc1a>
80018fc8:	fa cb f9 44 	sub	r11,sp,-1724
80018fcc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80018fd0:	c1 d8       	rjmp	8001900a <_vfprintf_r+0xc52>
80018fd2:	fa c8 f9 50 	sub	r8,sp,-1712
80018fd6:	1a d8       	st.w	--sp,r8
80018fd8:	fa c8 fa b8 	sub	r8,sp,-1352
80018fdc:	04 9a       	mov	r10,r2
80018fde:	1a d8       	st.w	--sp,r8
80018fe0:	fa c8 fb b4 	sub	r8,sp,-1100
80018fe4:	0c 9b       	mov	r11,r6
80018fe6:	1a d8       	st.w	--sp,r8
80018fe8:	08 9c       	mov	r12,r4
80018fea:	fa c8 f9 40 	sub	r8,sp,-1728
80018fee:	fa c9 ff b4 	sub	r9,sp,-76
80018ff2:	fe b0 f8 45 	rcall	8001807c <get_arg>
80018ff6:	2f dd       	sub	sp,-12
80018ff8:	78 0a       	ld.w	r10,r12[0x0]
80018ffa:	c2 08       	rjmp	8001903a <_vfprintf_r+0xc82>
80018ffc:	2f f7       	sub	r7,-1
80018ffe:	10 39       	cp.w	r9,r8
80019000:	c0 84       	brge	80019010 <_vfprintf_r+0xc58>
80019002:	fa ca f9 44 	sub	r10,sp,-1724
80019006:	f4 06 00 36 	add	r6,r10,r6<<0x3
8001900a:	ec fa fd 88 	ld.w	r10,r6[-632]
8001900e:	c1 68       	rjmp	8001903a <_vfprintf_r+0xc82>
80019010:	41 09       	lddsp	r9,sp[0x40]
80019012:	59 f8       	cp.w	r8,31
80019014:	e0 89 00 10 	brgt	80019034 <_vfprintf_r+0xc7c>
80019018:	f2 ca ff fc 	sub	r10,r9,-4
8001901c:	51 0a       	stdsp	sp[0x40],r10
8001901e:	fa c6 f9 44 	sub	r6,sp,-1724
80019022:	72 0a       	ld.w	r10,r9[0x0]
80019024:	ec 08 00 39 	add	r9,r6,r8<<0x3
80019028:	f3 4a fd 88 	st.w	r9[-632],r10
8001902c:	2f f8       	sub	r8,-1
8001902e:	fb 48 06 b4 	st.w	sp[1716],r8
80019032:	c0 48       	rjmp	8001903a <_vfprintf_r+0xc82>
80019034:	72 0a       	ld.w	r10,r9[0x0]
80019036:	2f c9       	sub	r9,-4
80019038:	51 09       	stdsp	sp[0x40],r9
8001903a:	40 be       	lddsp	lr,sp[0x2c]
8001903c:	b4 0e       	st.h	r10[0x0],lr
8001903e:	fe 9f fa 48 	bral	800184ce <_vfprintf_r+0x116>
80019042:	fa f8 06 b4 	ld.w	r8,sp[1716]
80019046:	40 3c       	lddsp	r12,sp[0xc]
80019048:	58 0c       	cp.w	r12,0
8001904a:	c1 d0       	breq	80019084 <_vfprintf_r+0xccc>
8001904c:	10 36       	cp.w	r6,r8
8001904e:	c0 64       	brge	8001905a <_vfprintf_r+0xca2>
80019050:	fa cb f9 44 	sub	r11,sp,-1724
80019054:	f6 06 00 36 	add	r6,r11,r6<<0x3
80019058:	c1 d8       	rjmp	80019092 <_vfprintf_r+0xcda>
8001905a:	fa c8 f9 50 	sub	r8,sp,-1712
8001905e:	1a d8       	st.w	--sp,r8
80019060:	fa c8 fa b8 	sub	r8,sp,-1352
80019064:	04 9a       	mov	r10,r2
80019066:	1a d8       	st.w	--sp,r8
80019068:	fa c8 fb b4 	sub	r8,sp,-1100
8001906c:	0c 9b       	mov	r11,r6
8001906e:	1a d8       	st.w	--sp,r8
80019070:	08 9c       	mov	r12,r4
80019072:	fa c8 f9 40 	sub	r8,sp,-1728
80019076:	fa c9 ff b4 	sub	r9,sp,-76
8001907a:	fe b0 f8 01 	rcall	8001807c <get_arg>
8001907e:	2f dd       	sub	sp,-12
80019080:	78 0a       	ld.w	r10,r12[0x0]
80019082:	c2 08       	rjmp	800190c2 <_vfprintf_r+0xd0a>
80019084:	2f f7       	sub	r7,-1
80019086:	10 39       	cp.w	r9,r8
80019088:	c0 84       	brge	80019098 <_vfprintf_r+0xce0>
8001908a:	fa ca f9 44 	sub	r10,sp,-1724
8001908e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80019092:	ec fa fd 88 	ld.w	r10,r6[-632]
80019096:	c1 68       	rjmp	800190c2 <_vfprintf_r+0xd0a>
80019098:	41 09       	lddsp	r9,sp[0x40]
8001909a:	59 f8       	cp.w	r8,31
8001909c:	e0 89 00 10 	brgt	800190bc <_vfprintf_r+0xd04>
800190a0:	f2 ca ff fc 	sub	r10,r9,-4
800190a4:	51 0a       	stdsp	sp[0x40],r10
800190a6:	fa c6 f9 44 	sub	r6,sp,-1724
800190aa:	72 0a       	ld.w	r10,r9[0x0]
800190ac:	ec 08 00 39 	add	r9,r6,r8<<0x3
800190b0:	f3 4a fd 88 	st.w	r9[-632],r10
800190b4:	2f f8       	sub	r8,-1
800190b6:	fb 48 06 b4 	st.w	sp[1716],r8
800190ba:	c0 48       	rjmp	800190c2 <_vfprintf_r+0xd0a>
800190bc:	72 0a       	ld.w	r10,r9[0x0]
800190be:	2f c9       	sub	r9,-4
800190c0:	51 09       	stdsp	sp[0x40],r9
800190c2:	40 be       	lddsp	lr,sp[0x2c]
800190c4:	95 0e       	st.w	r10[0x0],lr
800190c6:	fe 9f fa 04 	bral	800184ce <_vfprintf_r+0x116>
800190ca:	50 a7       	stdsp	sp[0x28],r7
800190cc:	50 80       	stdsp	sp[0x20],r0
800190ce:	0c 97       	mov	r7,r6
800190d0:	04 94       	mov	r4,r2
800190d2:	06 96       	mov	r6,r3
800190d4:	02 92       	mov	r2,r1
800190d6:	40 93       	lddsp	r3,sp[0x24]
800190d8:	10 90       	mov	r0,r8
800190da:	40 41       	lddsp	r1,sp[0x10]
800190dc:	a5 a5       	sbr	r5,0x4
800190de:	c0 a8       	rjmp	800190f2 <_vfprintf_r+0xd3a>
800190e0:	50 a7       	stdsp	sp[0x28],r7
800190e2:	50 80       	stdsp	sp[0x20],r0
800190e4:	0c 97       	mov	r7,r6
800190e6:	04 94       	mov	r4,r2
800190e8:	06 96       	mov	r6,r3
800190ea:	02 92       	mov	r2,r1
800190ec:	40 93       	lddsp	r3,sp[0x24]
800190ee:	10 90       	mov	r0,r8
800190f0:	40 41       	lddsp	r1,sp[0x10]
800190f2:	ed b5 00 05 	bld	r5,0x5
800190f6:	c5 d1       	brne	800191b0 <_vfprintf_r+0xdf8>
800190f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800190fc:	40 3c       	lddsp	r12,sp[0xc]
800190fe:	58 0c       	cp.w	r12,0
80019100:	c2 60       	breq	8001914c <_vfprintf_r+0xd94>
80019102:	10 36       	cp.w	r6,r8
80019104:	c0 a4       	brge	80019118 <_vfprintf_r+0xd60>
80019106:	fa cb f9 44 	sub	r11,sp,-1724
8001910a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001910e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80019112:	fa e9 00 00 	st.d	sp[0],r8
80019116:	c1 88       	rjmp	80019146 <_vfprintf_r+0xd8e>
80019118:	fa c8 f9 50 	sub	r8,sp,-1712
8001911c:	1a d8       	st.w	--sp,r8
8001911e:	fa c8 fa b8 	sub	r8,sp,-1352
80019122:	04 9a       	mov	r10,r2
80019124:	1a d8       	st.w	--sp,r8
80019126:	0c 9b       	mov	r11,r6
80019128:	fa c8 fb b4 	sub	r8,sp,-1100
8001912c:	08 9c       	mov	r12,r4
8001912e:	1a d8       	st.w	--sp,r8
80019130:	fa c8 f9 40 	sub	r8,sp,-1728
80019134:	fa c9 ff b4 	sub	r9,sp,-76
80019138:	fe b0 f7 a2 	rcall	8001807c <get_arg>
8001913c:	2f dd       	sub	sp,-12
8001913e:	f8 ea 00 00 	ld.d	r10,r12[0]
80019142:	fa eb 00 00 	st.d	sp[0],r10
80019146:	30 08       	mov	r8,0
80019148:	e0 8f 03 de 	bral	80019904 <_vfprintf_r+0x154c>
8001914c:	ee ca ff ff 	sub	r10,r7,-1
80019150:	10 37       	cp.w	r7,r8
80019152:	c0 b4       	brge	80019168 <_vfprintf_r+0xdb0>
80019154:	fa c9 f9 44 	sub	r9,sp,-1724
80019158:	14 97       	mov	r7,r10
8001915a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001915e:	ec ea fd 88 	ld.d	r10,r6[-632]
80019162:	fa eb 00 00 	st.d	sp[0],r10
80019166:	c1 88       	rjmp	80019196 <_vfprintf_r+0xdde>
80019168:	41 09       	lddsp	r9,sp[0x40]
8001916a:	59 f8       	cp.w	r8,31
8001916c:	e0 89 00 18 	brgt	8001919c <_vfprintf_r+0xde4>
80019170:	f2 e6 00 00 	ld.d	r6,r9[0]
80019174:	f2 cb ff f8 	sub	r11,r9,-8
80019178:	fa e7 00 00 	st.d	sp[0],r6
8001917c:	51 0b       	stdsp	sp[0x40],r11
8001917e:	fa c6 f9 44 	sub	r6,sp,-1724
80019182:	ec 08 00 39 	add	r9,r6,r8<<0x3
80019186:	fa e6 00 00 	ld.d	r6,sp[0]
8001918a:	f2 e7 fd 88 	st.d	r9[-632],r6
8001918e:	2f f8       	sub	r8,-1
80019190:	14 97       	mov	r7,r10
80019192:	fb 48 06 b4 	st.w	sp[1716],r8
80019196:	40 38       	lddsp	r8,sp[0xc]
80019198:	e0 8f 03 b6 	bral	80019904 <_vfprintf_r+0x154c>
8001919c:	f2 e6 00 00 	ld.d	r6,r9[0]
800191a0:	40 38       	lddsp	r8,sp[0xc]
800191a2:	fa e7 00 00 	st.d	sp[0],r6
800191a6:	2f 89       	sub	r9,-8
800191a8:	14 97       	mov	r7,r10
800191aa:	51 09       	stdsp	sp[0x40],r9
800191ac:	e0 8f 03 ac 	bral	80019904 <_vfprintf_r+0x154c>
800191b0:	ed b5 00 04 	bld	r5,0x4
800191b4:	c1 61       	brne	800191e0 <_vfprintf_r+0xe28>
800191b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800191ba:	40 3e       	lddsp	lr,sp[0xc]
800191bc:	58 0e       	cp.w	lr,0
800191be:	c0 80       	breq	800191ce <_vfprintf_r+0xe16>
800191c0:	10 36       	cp.w	r6,r8
800191c2:	c6 74       	brge	80019290 <_vfprintf_r+0xed8>
800191c4:	fa cc f9 44 	sub	r12,sp,-1724
800191c8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800191cc:	c8 08       	rjmp	800192cc <_vfprintf_r+0xf14>
800191ce:	ee ca ff ff 	sub	r10,r7,-1
800191d2:	10 37       	cp.w	r7,r8
800191d4:	c7 f4       	brge	800192d2 <_vfprintf_r+0xf1a>
800191d6:	fa cb f9 44 	sub	r11,sp,-1724
800191da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800191de:	c7 68       	rjmp	800192ca <_vfprintf_r+0xf12>
800191e0:	ed b5 00 06 	bld	r5,0x6
800191e4:	c4 a1       	brne	80019278 <_vfprintf_r+0xec0>
800191e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800191ea:	40 3c       	lddsp	r12,sp[0xc]
800191ec:	58 0c       	cp.w	r12,0
800191ee:	c1 d0       	breq	80019228 <_vfprintf_r+0xe70>
800191f0:	10 36       	cp.w	r6,r8
800191f2:	c0 64       	brge	800191fe <_vfprintf_r+0xe46>
800191f4:	fa cb f9 44 	sub	r11,sp,-1724
800191f8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800191fc:	c1 f8       	rjmp	8001923a <_vfprintf_r+0xe82>
800191fe:	fa c8 f9 50 	sub	r8,sp,-1712
80019202:	1a d8       	st.w	--sp,r8
80019204:	fa c8 fa b8 	sub	r8,sp,-1352
80019208:	1a d8       	st.w	--sp,r8
8001920a:	fa c8 fb b4 	sub	r8,sp,-1100
8001920e:	1a d8       	st.w	--sp,r8
80019210:	fa c8 f9 40 	sub	r8,sp,-1728
80019214:	fa c9 ff b4 	sub	r9,sp,-76
80019218:	04 9a       	mov	r10,r2
8001921a:	0c 9b       	mov	r11,r6
8001921c:	08 9c       	mov	r12,r4
8001921e:	fe b0 f7 2f 	rcall	8001807c <get_arg>
80019222:	2f dd       	sub	sp,-12
80019224:	98 18       	ld.sh	r8,r12[0x2]
80019226:	c2 68       	rjmp	80019272 <_vfprintf_r+0xeba>
80019228:	ee ca ff ff 	sub	r10,r7,-1
8001922c:	10 37       	cp.w	r7,r8
8001922e:	c0 94       	brge	80019240 <_vfprintf_r+0xe88>
80019230:	fa c9 f9 44 	sub	r9,sp,-1724
80019234:	14 97       	mov	r7,r10
80019236:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001923a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8001923e:	c1 a8       	rjmp	80019272 <_vfprintf_r+0xeba>
80019240:	41 09       	lddsp	r9,sp[0x40]
80019242:	59 f8       	cp.w	r8,31
80019244:	e0 89 00 13 	brgt	8001926a <_vfprintf_r+0xeb2>
80019248:	f2 cb ff fc 	sub	r11,r9,-4
8001924c:	51 0b       	stdsp	sp[0x40],r11
8001924e:	72 09       	ld.w	r9,r9[0x0]
80019250:	fa c6 f9 44 	sub	r6,sp,-1724
80019254:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80019258:	2f f8       	sub	r8,-1
8001925a:	f7 49 fd 88 	st.w	r11[-632],r9
8001925e:	fb 48 06 b4 	st.w	sp[1716],r8
80019262:	14 97       	mov	r7,r10
80019264:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80019268:	c0 58       	rjmp	80019272 <_vfprintf_r+0xeba>
8001926a:	92 18       	ld.sh	r8,r9[0x2]
8001926c:	14 97       	mov	r7,r10
8001926e:	2f c9       	sub	r9,-4
80019270:	51 09       	stdsp	sp[0x40],r9
80019272:	5c 78       	castu.h	r8
80019274:	50 18       	stdsp	sp[0x4],r8
80019276:	c4 68       	rjmp	80019302 <_vfprintf_r+0xf4a>
80019278:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001927c:	40 3c       	lddsp	r12,sp[0xc]
8001927e:	58 0c       	cp.w	r12,0
80019280:	c1 d0       	breq	800192ba <_vfprintf_r+0xf02>
80019282:	10 36       	cp.w	r6,r8
80019284:	c0 64       	brge	80019290 <_vfprintf_r+0xed8>
80019286:	fa cb f9 44 	sub	r11,sp,-1724
8001928a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001928e:	c1 f8       	rjmp	800192cc <_vfprintf_r+0xf14>
80019290:	fa c8 f9 50 	sub	r8,sp,-1712
80019294:	1a d8       	st.w	--sp,r8
80019296:	fa c8 fa b8 	sub	r8,sp,-1352
8001929a:	0c 9b       	mov	r11,r6
8001929c:	1a d8       	st.w	--sp,r8
8001929e:	fa c8 fb b4 	sub	r8,sp,-1100
800192a2:	04 9a       	mov	r10,r2
800192a4:	1a d8       	st.w	--sp,r8
800192a6:	08 9c       	mov	r12,r4
800192a8:	fa c8 f9 40 	sub	r8,sp,-1728
800192ac:	fa c9 ff b4 	sub	r9,sp,-76
800192b0:	fe b0 f6 e6 	rcall	8001807c <get_arg>
800192b4:	2f dd       	sub	sp,-12
800192b6:	78 0b       	ld.w	r11,r12[0x0]
800192b8:	c2 48       	rjmp	80019300 <_vfprintf_r+0xf48>
800192ba:	ee ca ff ff 	sub	r10,r7,-1
800192be:	10 37       	cp.w	r7,r8
800192c0:	c0 94       	brge	800192d2 <_vfprintf_r+0xf1a>
800192c2:	fa c9 f9 44 	sub	r9,sp,-1724
800192c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800192ca:	14 97       	mov	r7,r10
800192cc:	ec fb fd 88 	ld.w	r11,r6[-632]
800192d0:	c1 88       	rjmp	80019300 <_vfprintf_r+0xf48>
800192d2:	41 09       	lddsp	r9,sp[0x40]
800192d4:	59 f8       	cp.w	r8,31
800192d6:	e0 89 00 11 	brgt	800192f8 <_vfprintf_r+0xf40>
800192da:	f2 cb ff fc 	sub	r11,r9,-4
800192de:	51 0b       	stdsp	sp[0x40],r11
800192e0:	fa c6 f9 44 	sub	r6,sp,-1724
800192e4:	72 0b       	ld.w	r11,r9[0x0]
800192e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800192ea:	f3 4b fd 88 	st.w	r9[-632],r11
800192ee:	2f f8       	sub	r8,-1
800192f0:	14 97       	mov	r7,r10
800192f2:	fb 48 06 b4 	st.w	sp[1716],r8
800192f6:	c0 58       	rjmp	80019300 <_vfprintf_r+0xf48>
800192f8:	72 0b       	ld.w	r11,r9[0x0]
800192fa:	14 97       	mov	r7,r10
800192fc:	2f c9       	sub	r9,-4
800192fe:	51 09       	stdsp	sp[0x40],r9
80019300:	50 1b       	stdsp	sp[0x4],r11
80019302:	30 0e       	mov	lr,0
80019304:	50 0e       	stdsp	sp[0x0],lr
80019306:	1c 98       	mov	r8,lr
80019308:	e0 8f 02 fe 	bral	80019904 <_vfprintf_r+0x154c>
8001930c:	50 a7       	stdsp	sp[0x28],r7
8001930e:	50 80       	stdsp	sp[0x20],r0
80019310:	0c 97       	mov	r7,r6
80019312:	04 94       	mov	r4,r2
80019314:	06 96       	mov	r6,r3
80019316:	02 92       	mov	r2,r1
80019318:	40 93       	lddsp	r3,sp[0x24]
8001931a:	40 41       	lddsp	r1,sp[0x10]
8001931c:	0e 99       	mov	r9,r7
8001931e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80019322:	40 3c       	lddsp	r12,sp[0xc]
80019324:	58 0c       	cp.w	r12,0
80019326:	c1 d0       	breq	80019360 <_vfprintf_r+0xfa8>
80019328:	10 36       	cp.w	r6,r8
8001932a:	c0 64       	brge	80019336 <_vfprintf_r+0xf7e>
8001932c:	fa cb f9 44 	sub	r11,sp,-1724
80019330:	f6 06 00 36 	add	r6,r11,r6<<0x3
80019334:	c1 d8       	rjmp	8001936e <_vfprintf_r+0xfb6>
80019336:	fa c8 f9 50 	sub	r8,sp,-1712
8001933a:	1a d8       	st.w	--sp,r8
8001933c:	fa c8 fa b8 	sub	r8,sp,-1352
80019340:	1a d8       	st.w	--sp,r8
80019342:	fa c8 fb b4 	sub	r8,sp,-1100
80019346:	1a d8       	st.w	--sp,r8
80019348:	fa c9 ff b4 	sub	r9,sp,-76
8001934c:	fa c8 f9 40 	sub	r8,sp,-1728
80019350:	04 9a       	mov	r10,r2
80019352:	0c 9b       	mov	r11,r6
80019354:	08 9c       	mov	r12,r4
80019356:	fe b0 f6 93 	rcall	8001807c <get_arg>
8001935a:	2f dd       	sub	sp,-12
8001935c:	78 09       	ld.w	r9,r12[0x0]
8001935e:	c2 18       	rjmp	800193a0 <_vfprintf_r+0xfe8>
80019360:	2f f7       	sub	r7,-1
80019362:	10 39       	cp.w	r9,r8
80019364:	c0 84       	brge	80019374 <_vfprintf_r+0xfbc>
80019366:	fa ca f9 44 	sub	r10,sp,-1724
8001936a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8001936e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80019372:	c1 78       	rjmp	800193a0 <_vfprintf_r+0xfe8>
80019374:	41 09       	lddsp	r9,sp[0x40]
80019376:	59 f8       	cp.w	r8,31
80019378:	e0 89 00 10 	brgt	80019398 <_vfprintf_r+0xfe0>
8001937c:	f2 ca ff fc 	sub	r10,r9,-4
80019380:	51 0a       	stdsp	sp[0x40],r10
80019382:	fa c6 f9 44 	sub	r6,sp,-1724
80019386:	72 09       	ld.w	r9,r9[0x0]
80019388:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8001938c:	f5 49 fd 88 	st.w	r10[-632],r9
80019390:	2f f8       	sub	r8,-1
80019392:	fb 48 06 b4 	st.w	sp[1716],r8
80019396:	c0 58       	rjmp	800193a0 <_vfprintf_r+0xfe8>
80019398:	f2 c8 ff fc 	sub	r8,r9,-4
8001939c:	51 08       	stdsp	sp[0x40],r8
8001939e:	72 09       	ld.w	r9,r9[0x0]
800193a0:	33 08       	mov	r8,48
800193a2:	fb 68 06 b8 	st.b	sp[1720],r8
800193a6:	37 88       	mov	r8,120
800193a8:	30 0e       	mov	lr,0
800193aa:	fb 68 06 b9 	st.b	sp[1721],r8
800193ae:	4c ac       	lddpc	r12,800194d4 <_vfprintf_r+0x111c>
800193b0:	50 19       	stdsp	sp[0x4],r9
800193b2:	a1 b5       	sbr	r5,0x1
800193b4:	50 0e       	stdsp	sp[0x0],lr
800193b6:	50 dc       	stdsp	sp[0x34],r12
800193b8:	30 28       	mov	r8,2
800193ba:	37 80       	mov	r0,120
800193bc:	e0 8f 02 a4 	bral	80019904 <_vfprintf_r+0x154c>
800193c0:	50 a7       	stdsp	sp[0x28],r7
800193c2:	50 80       	stdsp	sp[0x20],r0
800193c4:	10 90       	mov	r0,r8
800193c6:	30 08       	mov	r8,0
800193c8:	fb 68 06 bb 	st.b	sp[1723],r8
800193cc:	0c 97       	mov	r7,r6
800193ce:	04 94       	mov	r4,r2
800193d0:	06 96       	mov	r6,r3
800193d2:	02 92       	mov	r2,r1
800193d4:	40 93       	lddsp	r3,sp[0x24]
800193d6:	40 41       	lddsp	r1,sp[0x10]
800193d8:	0e 99       	mov	r9,r7
800193da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800193de:	40 3b       	lddsp	r11,sp[0xc]
800193e0:	58 0b       	cp.w	r11,0
800193e2:	c1 d0       	breq	8001941c <_vfprintf_r+0x1064>
800193e4:	10 36       	cp.w	r6,r8
800193e6:	c0 64       	brge	800193f2 <_vfprintf_r+0x103a>
800193e8:	fa ca f9 44 	sub	r10,sp,-1724
800193ec:	f4 06 00 36 	add	r6,r10,r6<<0x3
800193f0:	c1 d8       	rjmp	8001942a <_vfprintf_r+0x1072>
800193f2:	fa c8 f9 50 	sub	r8,sp,-1712
800193f6:	1a d8       	st.w	--sp,r8
800193f8:	fa c8 fa b8 	sub	r8,sp,-1352
800193fc:	1a d8       	st.w	--sp,r8
800193fe:	fa c8 fb b4 	sub	r8,sp,-1100
80019402:	0c 9b       	mov	r11,r6
80019404:	1a d8       	st.w	--sp,r8
80019406:	04 9a       	mov	r10,r2
80019408:	fa c8 f9 40 	sub	r8,sp,-1728
8001940c:	fa c9 ff b4 	sub	r9,sp,-76
80019410:	08 9c       	mov	r12,r4
80019412:	fe b0 f6 35 	rcall	8001807c <get_arg>
80019416:	2f dd       	sub	sp,-12
80019418:	78 06       	ld.w	r6,r12[0x0]
8001941a:	c2 08       	rjmp	8001945a <_vfprintf_r+0x10a2>
8001941c:	2f f7       	sub	r7,-1
8001941e:	10 39       	cp.w	r9,r8
80019420:	c0 84       	brge	80019430 <_vfprintf_r+0x1078>
80019422:	fa c9 f9 44 	sub	r9,sp,-1724
80019426:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001942a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8001942e:	c1 68       	rjmp	8001945a <_vfprintf_r+0x10a2>
80019430:	41 09       	lddsp	r9,sp[0x40]
80019432:	59 f8       	cp.w	r8,31
80019434:	e0 89 00 10 	brgt	80019454 <_vfprintf_r+0x109c>
80019438:	f2 ca ff fc 	sub	r10,r9,-4
8001943c:	51 0a       	stdsp	sp[0x40],r10
8001943e:	72 06       	ld.w	r6,r9[0x0]
80019440:	fa ce f9 44 	sub	lr,sp,-1724
80019444:	fc 08 00 39 	add	r9,lr,r8<<0x3
80019448:	f3 46 fd 88 	st.w	r9[-632],r6
8001944c:	2f f8       	sub	r8,-1
8001944e:	fb 48 06 b4 	st.w	sp[1716],r8
80019452:	c0 48       	rjmp	8001945a <_vfprintf_r+0x10a2>
80019454:	72 06       	ld.w	r6,r9[0x0]
80019456:	2f c9       	sub	r9,-4
80019458:	51 09       	stdsp	sp[0x40],r9
8001945a:	40 2c       	lddsp	r12,sp[0x8]
8001945c:	58 0c       	cp.w	r12,0
8001945e:	c1 05       	brlt	8001947e <_vfprintf_r+0x10c6>
80019460:	18 9a       	mov	r10,r12
80019462:	30 0b       	mov	r11,0
80019464:	0c 9c       	mov	r12,r6
80019466:	e0 a0 10 51 	rcall	8001b508 <memchr>
8001946a:	e0 80 02 e0 	breq	80019a2a <_vfprintf_r+0x1672>
8001946e:	f8 06 01 02 	sub	r2,r12,r6
80019472:	40 2b       	lddsp	r11,sp[0x8]
80019474:	16 32       	cp.w	r2,r11
80019476:	e0 89 02 da 	brgt	80019a2a <_vfprintf_r+0x1672>
8001947a:	e0 8f 02 d5 	bral	80019a24 <_vfprintf_r+0x166c>
8001947e:	30 0a       	mov	r10,0
80019480:	0c 9c       	mov	r12,r6
80019482:	50 2a       	stdsp	sp[0x8],r10
80019484:	fe b0 f5 70 	rcall	80017f64 <strlen>
80019488:	18 92       	mov	r2,r12
8001948a:	e0 8f 02 d3 	bral	80019a30 <_vfprintf_r+0x1678>
8001948e:	50 a7       	stdsp	sp[0x28],r7
80019490:	50 80       	stdsp	sp[0x20],r0
80019492:	0c 97       	mov	r7,r6
80019494:	04 94       	mov	r4,r2
80019496:	06 96       	mov	r6,r3
80019498:	02 92       	mov	r2,r1
8001949a:	40 93       	lddsp	r3,sp[0x24]
8001949c:	10 90       	mov	r0,r8
8001949e:	40 41       	lddsp	r1,sp[0x10]
800194a0:	a5 a5       	sbr	r5,0x4
800194a2:	c0 a8       	rjmp	800194b6 <_vfprintf_r+0x10fe>
800194a4:	50 a7       	stdsp	sp[0x28],r7
800194a6:	50 80       	stdsp	sp[0x20],r0
800194a8:	0c 97       	mov	r7,r6
800194aa:	04 94       	mov	r4,r2
800194ac:	06 96       	mov	r6,r3
800194ae:	02 92       	mov	r2,r1
800194b0:	40 93       	lddsp	r3,sp[0x24]
800194b2:	10 90       	mov	r0,r8
800194b4:	40 41       	lddsp	r1,sp[0x10]
800194b6:	ed b5 00 05 	bld	r5,0x5
800194ba:	c5 71       	brne	80019568 <_vfprintf_r+0x11b0>
800194bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800194c0:	40 39       	lddsp	r9,sp[0xc]
800194c2:	58 09       	cp.w	r9,0
800194c4:	c2 20       	breq	80019508 <_vfprintf_r+0x1150>
800194c6:	10 36       	cp.w	r6,r8
800194c8:	c0 84       	brge	800194d8 <_vfprintf_r+0x1120>
800194ca:	fa c8 f9 44 	sub	r8,sp,-1724
800194ce:	f0 06 00 36 	add	r6,r8,r6<<0x3
800194d2:	c2 48       	rjmp	8001951a <_vfprintf_r+0x1162>
800194d4:	80 07       	ld.sh	r7,r0[0x0]
800194d6:	0d 2c       	ld.uh	r12,r6++
800194d8:	fa c8 f9 50 	sub	r8,sp,-1712
800194dc:	1a d8       	st.w	--sp,r8
800194de:	fa c8 fa b8 	sub	r8,sp,-1352
800194e2:	1a d8       	st.w	--sp,r8
800194e4:	fa c8 fb b4 	sub	r8,sp,-1100
800194e8:	1a d8       	st.w	--sp,r8
800194ea:	fa c8 f9 40 	sub	r8,sp,-1728
800194ee:	fa c9 ff b4 	sub	r9,sp,-76
800194f2:	04 9a       	mov	r10,r2
800194f4:	0c 9b       	mov	r11,r6
800194f6:	08 9c       	mov	r12,r4
800194f8:	fe b0 f5 c2 	rcall	8001807c <get_arg>
800194fc:	2f dd       	sub	sp,-12
800194fe:	f8 e8 00 00 	ld.d	r8,r12[0]
80019502:	fa e9 00 00 	st.d	sp[0],r8
80019506:	c2 e8       	rjmp	80019562 <_vfprintf_r+0x11aa>
80019508:	ee ca ff ff 	sub	r10,r7,-1
8001950c:	10 37       	cp.w	r7,r8
8001950e:	c0 b4       	brge	80019524 <_vfprintf_r+0x116c>
80019510:	fa c8 f9 44 	sub	r8,sp,-1724
80019514:	14 97       	mov	r7,r10
80019516:	f0 06 00 36 	add	r6,r8,r6<<0x3
8001951a:	ec ea fd 88 	ld.d	r10,r6[-632]
8001951e:	fa eb 00 00 	st.d	sp[0],r10
80019522:	c2 08       	rjmp	80019562 <_vfprintf_r+0x11aa>
80019524:	41 09       	lddsp	r9,sp[0x40]
80019526:	59 f8       	cp.w	r8,31
80019528:	e0 89 00 16 	brgt	80019554 <_vfprintf_r+0x119c>
8001952c:	f2 e6 00 00 	ld.d	r6,r9[0]
80019530:	f2 cb ff f8 	sub	r11,r9,-8
80019534:	fa e7 00 00 	st.d	sp[0],r6
80019538:	51 0b       	stdsp	sp[0x40],r11
8001953a:	fa c6 f9 44 	sub	r6,sp,-1724
8001953e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80019542:	fa e6 00 00 	ld.d	r6,sp[0]
80019546:	f2 e7 fd 88 	st.d	r9[-632],r6
8001954a:	2f f8       	sub	r8,-1
8001954c:	14 97       	mov	r7,r10
8001954e:	fb 48 06 b4 	st.w	sp[1716],r8
80019552:	c0 88       	rjmp	80019562 <_vfprintf_r+0x11aa>
80019554:	f2 e6 00 00 	ld.d	r6,r9[0]
80019558:	2f 89       	sub	r9,-8
8001955a:	fa e7 00 00 	st.d	sp[0],r6
8001955e:	51 09       	stdsp	sp[0x40],r9
80019560:	14 97       	mov	r7,r10
80019562:	30 18       	mov	r8,1
80019564:	e0 8f 01 d0 	bral	80019904 <_vfprintf_r+0x154c>
80019568:	ed b5 00 04 	bld	r5,0x4
8001956c:	c1 61       	brne	80019598 <_vfprintf_r+0x11e0>
8001956e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80019572:	40 3e       	lddsp	lr,sp[0xc]
80019574:	58 0e       	cp.w	lr,0
80019576:	c0 80       	breq	80019586 <_vfprintf_r+0x11ce>
80019578:	10 36       	cp.w	r6,r8
8001957a:	c6 74       	brge	80019648 <_vfprintf_r+0x1290>
8001957c:	fa cc f9 44 	sub	r12,sp,-1724
80019580:	f8 06 00 36 	add	r6,r12,r6<<0x3
80019584:	c8 08       	rjmp	80019684 <_vfprintf_r+0x12cc>
80019586:	ee ca ff ff 	sub	r10,r7,-1
8001958a:	10 37       	cp.w	r7,r8
8001958c:	c7 f4       	brge	8001968a <_vfprintf_r+0x12d2>
8001958e:	fa cb f9 44 	sub	r11,sp,-1724
80019592:	f6 06 00 36 	add	r6,r11,r6<<0x3
80019596:	c7 68       	rjmp	80019682 <_vfprintf_r+0x12ca>
80019598:	ed b5 00 06 	bld	r5,0x6
8001959c:	c4 a1       	brne	80019630 <_vfprintf_r+0x1278>
8001959e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800195a2:	40 3c       	lddsp	r12,sp[0xc]
800195a4:	58 0c       	cp.w	r12,0
800195a6:	c1 d0       	breq	800195e0 <_vfprintf_r+0x1228>
800195a8:	10 36       	cp.w	r6,r8
800195aa:	c0 64       	brge	800195b6 <_vfprintf_r+0x11fe>
800195ac:	fa cb f9 44 	sub	r11,sp,-1724
800195b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800195b4:	c1 f8       	rjmp	800195f2 <_vfprintf_r+0x123a>
800195b6:	fa c8 f9 50 	sub	r8,sp,-1712
800195ba:	1a d8       	st.w	--sp,r8
800195bc:	fa c8 fa b8 	sub	r8,sp,-1352
800195c0:	1a d8       	st.w	--sp,r8
800195c2:	fa c8 fb b4 	sub	r8,sp,-1100
800195c6:	1a d8       	st.w	--sp,r8
800195c8:	fa c8 f9 40 	sub	r8,sp,-1728
800195cc:	fa c9 ff b4 	sub	r9,sp,-76
800195d0:	04 9a       	mov	r10,r2
800195d2:	0c 9b       	mov	r11,r6
800195d4:	08 9c       	mov	r12,r4
800195d6:	fe b0 f5 53 	rcall	8001807c <get_arg>
800195da:	2f dd       	sub	sp,-12
800195dc:	98 18       	ld.sh	r8,r12[0x2]
800195de:	c2 68       	rjmp	8001962a <_vfprintf_r+0x1272>
800195e0:	ee ca ff ff 	sub	r10,r7,-1
800195e4:	10 37       	cp.w	r7,r8
800195e6:	c0 94       	brge	800195f8 <_vfprintf_r+0x1240>
800195e8:	fa c9 f9 44 	sub	r9,sp,-1724
800195ec:	14 97       	mov	r7,r10
800195ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
800195f2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800195f6:	c1 a8       	rjmp	8001962a <_vfprintf_r+0x1272>
800195f8:	41 09       	lddsp	r9,sp[0x40]
800195fa:	59 f8       	cp.w	r8,31
800195fc:	e0 89 00 13 	brgt	80019622 <_vfprintf_r+0x126a>
80019600:	f2 cb ff fc 	sub	r11,r9,-4
80019604:	51 0b       	stdsp	sp[0x40],r11
80019606:	72 09       	ld.w	r9,r9[0x0]
80019608:	fa c6 f9 44 	sub	r6,sp,-1724
8001960c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80019610:	2f f8       	sub	r8,-1
80019612:	f7 49 fd 88 	st.w	r11[-632],r9
80019616:	fb 48 06 b4 	st.w	sp[1716],r8
8001961a:	14 97       	mov	r7,r10
8001961c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80019620:	c0 58       	rjmp	8001962a <_vfprintf_r+0x1272>
80019622:	92 18       	ld.sh	r8,r9[0x2]
80019624:	14 97       	mov	r7,r10
80019626:	2f c9       	sub	r9,-4
80019628:	51 09       	stdsp	sp[0x40],r9
8001962a:	5c 78       	castu.h	r8
8001962c:	50 18       	stdsp	sp[0x4],r8
8001962e:	c4 68       	rjmp	800196ba <_vfprintf_r+0x1302>
80019630:	fa f8 06 b4 	ld.w	r8,sp[1716]
80019634:	40 3c       	lddsp	r12,sp[0xc]
80019636:	58 0c       	cp.w	r12,0
80019638:	c1 d0       	breq	80019672 <_vfprintf_r+0x12ba>
8001963a:	10 36       	cp.w	r6,r8
8001963c:	c0 64       	brge	80019648 <_vfprintf_r+0x1290>
8001963e:	fa cb f9 44 	sub	r11,sp,-1724
80019642:	f6 06 00 36 	add	r6,r11,r6<<0x3
80019646:	c1 f8       	rjmp	80019684 <_vfprintf_r+0x12cc>
80019648:	fa c8 f9 50 	sub	r8,sp,-1712
8001964c:	1a d8       	st.w	--sp,r8
8001964e:	fa c8 fa b8 	sub	r8,sp,-1352
80019652:	0c 9b       	mov	r11,r6
80019654:	1a d8       	st.w	--sp,r8
80019656:	fa c8 fb b4 	sub	r8,sp,-1100
8001965a:	04 9a       	mov	r10,r2
8001965c:	1a d8       	st.w	--sp,r8
8001965e:	08 9c       	mov	r12,r4
80019660:	fa c8 f9 40 	sub	r8,sp,-1728
80019664:	fa c9 ff b4 	sub	r9,sp,-76
80019668:	fe b0 f5 0a 	rcall	8001807c <get_arg>
8001966c:	2f dd       	sub	sp,-12
8001966e:	78 0b       	ld.w	r11,r12[0x0]
80019670:	c2 48       	rjmp	800196b8 <_vfprintf_r+0x1300>
80019672:	ee ca ff ff 	sub	r10,r7,-1
80019676:	10 37       	cp.w	r7,r8
80019678:	c0 94       	brge	8001968a <_vfprintf_r+0x12d2>
8001967a:	fa c9 f9 44 	sub	r9,sp,-1724
8001967e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80019682:	14 97       	mov	r7,r10
80019684:	ec fb fd 88 	ld.w	r11,r6[-632]
80019688:	c1 88       	rjmp	800196b8 <_vfprintf_r+0x1300>
8001968a:	41 09       	lddsp	r9,sp[0x40]
8001968c:	59 f8       	cp.w	r8,31
8001968e:	e0 89 00 11 	brgt	800196b0 <_vfprintf_r+0x12f8>
80019692:	f2 cb ff fc 	sub	r11,r9,-4
80019696:	51 0b       	stdsp	sp[0x40],r11
80019698:	fa c6 f9 44 	sub	r6,sp,-1724
8001969c:	72 0b       	ld.w	r11,r9[0x0]
8001969e:	ec 08 00 39 	add	r9,r6,r8<<0x3
800196a2:	f3 4b fd 88 	st.w	r9[-632],r11
800196a6:	2f f8       	sub	r8,-1
800196a8:	14 97       	mov	r7,r10
800196aa:	fb 48 06 b4 	st.w	sp[1716],r8
800196ae:	c0 58       	rjmp	800196b8 <_vfprintf_r+0x1300>
800196b0:	72 0b       	ld.w	r11,r9[0x0]
800196b2:	14 97       	mov	r7,r10
800196b4:	2f c9       	sub	r9,-4
800196b6:	51 09       	stdsp	sp[0x40],r9
800196b8:	50 1b       	stdsp	sp[0x4],r11
800196ba:	30 0e       	mov	lr,0
800196bc:	30 18       	mov	r8,1
800196be:	50 0e       	stdsp	sp[0x0],lr
800196c0:	c2 29       	rjmp	80019904 <_vfprintf_r+0x154c>
800196c2:	50 a7       	stdsp	sp[0x28],r7
800196c4:	50 80       	stdsp	sp[0x20],r0
800196c6:	0c 97       	mov	r7,r6
800196c8:	04 94       	mov	r4,r2
800196ca:	06 96       	mov	r6,r3
800196cc:	02 92       	mov	r2,r1
800196ce:	4d 3c       	lddpc	r12,80019818 <_vfprintf_r+0x1460>
800196d0:	40 93       	lddsp	r3,sp[0x24]
800196d2:	10 90       	mov	r0,r8
800196d4:	40 41       	lddsp	r1,sp[0x10]
800196d6:	50 dc       	stdsp	sp[0x34],r12
800196d8:	ed b5 00 05 	bld	r5,0x5
800196dc:	c5 51       	brne	80019786 <_vfprintf_r+0x13ce>
800196de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800196e2:	40 3b       	lddsp	r11,sp[0xc]
800196e4:	58 0b       	cp.w	r11,0
800196e6:	c2 20       	breq	8001972a <_vfprintf_r+0x1372>
800196e8:	10 36       	cp.w	r6,r8
800196ea:	c0 a4       	brge	800196fe <_vfprintf_r+0x1346>
800196ec:	fa ca f9 44 	sub	r10,sp,-1724
800196f0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800196f4:	ec e8 fd 88 	ld.d	r8,r6[-632]
800196f8:	fa e9 00 00 	st.d	sp[0],r8
800196fc:	cf 38       	rjmp	800198e2 <_vfprintf_r+0x152a>
800196fe:	fa c8 f9 50 	sub	r8,sp,-1712
80019702:	1a d8       	st.w	--sp,r8
80019704:	fa c8 fa b8 	sub	r8,sp,-1352
80019708:	04 9a       	mov	r10,r2
8001970a:	1a d8       	st.w	--sp,r8
8001970c:	0c 9b       	mov	r11,r6
8001970e:	fa c8 fb b4 	sub	r8,sp,-1100
80019712:	08 9c       	mov	r12,r4
80019714:	1a d8       	st.w	--sp,r8
80019716:	fa c8 f9 40 	sub	r8,sp,-1728
8001971a:	fa c9 ff b4 	sub	r9,sp,-76
8001971e:	fe b0 f4 af 	rcall	8001807c <get_arg>
80019722:	2f dd       	sub	sp,-12
80019724:	f8 ea 00 00 	ld.d	r10,r12[0]
80019728:	c0 c8       	rjmp	80019740 <_vfprintf_r+0x1388>
8001972a:	ee ca ff ff 	sub	r10,r7,-1
8001972e:	10 37       	cp.w	r7,r8
80019730:	c0 b4       	brge	80019746 <_vfprintf_r+0x138e>
80019732:	fa c9 f9 44 	sub	r9,sp,-1724
80019736:	14 97       	mov	r7,r10
80019738:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001973c:	ec ea fd 88 	ld.d	r10,r6[-632]
80019740:	fa eb 00 00 	st.d	sp[0],r10
80019744:	cc f8       	rjmp	800198e2 <_vfprintf_r+0x152a>
80019746:	41 09       	lddsp	r9,sp[0x40]
80019748:	59 f8       	cp.w	r8,31
8001974a:	e0 89 00 16 	brgt	80019776 <_vfprintf_r+0x13be>
8001974e:	f2 e6 00 00 	ld.d	r6,r9[0]
80019752:	f2 cb ff f8 	sub	r11,r9,-8
80019756:	fa e7 00 00 	st.d	sp[0],r6
8001975a:	51 0b       	stdsp	sp[0x40],r11
8001975c:	fa c6 f9 44 	sub	r6,sp,-1724
80019760:	ec 08 00 39 	add	r9,r6,r8<<0x3
80019764:	fa e6 00 00 	ld.d	r6,sp[0]
80019768:	f2 e7 fd 88 	st.d	r9[-632],r6
8001976c:	2f f8       	sub	r8,-1
8001976e:	14 97       	mov	r7,r10
80019770:	fb 48 06 b4 	st.w	sp[1716],r8
80019774:	cb 78       	rjmp	800198e2 <_vfprintf_r+0x152a>
80019776:	f2 e6 00 00 	ld.d	r6,r9[0]
8001977a:	2f 89       	sub	r9,-8
8001977c:	fa e7 00 00 	st.d	sp[0],r6
80019780:	51 09       	stdsp	sp[0x40],r9
80019782:	14 97       	mov	r7,r10
80019784:	ca f8       	rjmp	800198e2 <_vfprintf_r+0x152a>
80019786:	ed b5 00 04 	bld	r5,0x4
8001978a:	c1 71       	brne	800197b8 <_vfprintf_r+0x1400>
8001978c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80019790:	40 3e       	lddsp	lr,sp[0xc]
80019792:	58 0e       	cp.w	lr,0
80019794:	c0 80       	breq	800197a4 <_vfprintf_r+0x13ec>
80019796:	10 36       	cp.w	r6,r8
80019798:	c6 a4       	brge	8001986c <_vfprintf_r+0x14b4>
8001979a:	fa cc f9 44 	sub	r12,sp,-1724
8001979e:	f8 06 00 36 	add	r6,r12,r6<<0x3
800197a2:	c8 38       	rjmp	800198a8 <_vfprintf_r+0x14f0>
800197a4:	ee ca ff ff 	sub	r10,r7,-1
800197a8:	10 37       	cp.w	r7,r8
800197aa:	e0 84 00 82 	brge	800198ae <_vfprintf_r+0x14f6>
800197ae:	fa cb f9 44 	sub	r11,sp,-1724
800197b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800197b6:	c7 88       	rjmp	800198a6 <_vfprintf_r+0x14ee>
800197b8:	ed b5 00 06 	bld	r5,0x6
800197bc:	c4 c1       	brne	80019854 <_vfprintf_r+0x149c>
800197be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800197c2:	40 3c       	lddsp	r12,sp[0xc]
800197c4:	58 0c       	cp.w	r12,0
800197c6:	c1 d0       	breq	80019800 <_vfprintf_r+0x1448>
800197c8:	10 36       	cp.w	r6,r8
800197ca:	c0 64       	brge	800197d6 <_vfprintf_r+0x141e>
800197cc:	fa cb f9 44 	sub	r11,sp,-1724
800197d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800197d4:	c1 f8       	rjmp	80019812 <_vfprintf_r+0x145a>
800197d6:	fa c8 f9 50 	sub	r8,sp,-1712
800197da:	1a d8       	st.w	--sp,r8
800197dc:	fa c8 fa b8 	sub	r8,sp,-1352
800197e0:	1a d8       	st.w	--sp,r8
800197e2:	fa c8 fb b4 	sub	r8,sp,-1100
800197e6:	1a d8       	st.w	--sp,r8
800197e8:	fa c8 f9 40 	sub	r8,sp,-1728
800197ec:	fa c9 ff b4 	sub	r9,sp,-76
800197f0:	04 9a       	mov	r10,r2
800197f2:	0c 9b       	mov	r11,r6
800197f4:	08 9c       	mov	r12,r4
800197f6:	fe b0 f4 43 	rcall	8001807c <get_arg>
800197fa:	2f dd       	sub	sp,-12
800197fc:	98 18       	ld.sh	r8,r12[0x2]
800197fe:	c2 88       	rjmp	8001984e <_vfprintf_r+0x1496>
80019800:	ee ca ff ff 	sub	r10,r7,-1
80019804:	10 37       	cp.w	r7,r8
80019806:	c0 b4       	brge	8001981c <_vfprintf_r+0x1464>
80019808:	fa c9 f9 44 	sub	r9,sp,-1724
8001980c:	14 97       	mov	r7,r10
8001980e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80019812:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80019816:	c1 c8       	rjmp	8001984e <_vfprintf_r+0x1496>
80019818:	80 07       	ld.sh	r7,r0[0x0]
8001981a:	0d 2c       	ld.uh	r12,r6++
8001981c:	41 09       	lddsp	r9,sp[0x40]
8001981e:	59 f8       	cp.w	r8,31
80019820:	e0 89 00 13 	brgt	80019846 <_vfprintf_r+0x148e>
80019824:	f2 cb ff fc 	sub	r11,r9,-4
80019828:	51 0b       	stdsp	sp[0x40],r11
8001982a:	72 09       	ld.w	r9,r9[0x0]
8001982c:	fa c6 f9 44 	sub	r6,sp,-1724
80019830:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80019834:	2f f8       	sub	r8,-1
80019836:	f7 49 fd 88 	st.w	r11[-632],r9
8001983a:	fb 48 06 b4 	st.w	sp[1716],r8
8001983e:	14 97       	mov	r7,r10
80019840:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80019844:	c0 58       	rjmp	8001984e <_vfprintf_r+0x1496>
80019846:	92 18       	ld.sh	r8,r9[0x2]
80019848:	14 97       	mov	r7,r10
8001984a:	2f c9       	sub	r9,-4
8001984c:	51 09       	stdsp	sp[0x40],r9
8001984e:	5c 78       	castu.h	r8
80019850:	50 18       	stdsp	sp[0x4],r8
80019852:	c4 68       	rjmp	800198de <_vfprintf_r+0x1526>
80019854:	fa f8 06 b4 	ld.w	r8,sp[1716]
80019858:	40 3c       	lddsp	r12,sp[0xc]
8001985a:	58 0c       	cp.w	r12,0
8001985c:	c1 d0       	breq	80019896 <_vfprintf_r+0x14de>
8001985e:	10 36       	cp.w	r6,r8
80019860:	c0 64       	brge	8001986c <_vfprintf_r+0x14b4>
80019862:	fa cb f9 44 	sub	r11,sp,-1724
80019866:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001986a:	c1 f8       	rjmp	800198a8 <_vfprintf_r+0x14f0>
8001986c:	fa c8 f9 50 	sub	r8,sp,-1712
80019870:	1a d8       	st.w	--sp,r8
80019872:	fa c8 fa b8 	sub	r8,sp,-1352
80019876:	0c 9b       	mov	r11,r6
80019878:	1a d8       	st.w	--sp,r8
8001987a:	fa c8 fb b4 	sub	r8,sp,-1100
8001987e:	04 9a       	mov	r10,r2
80019880:	1a d8       	st.w	--sp,r8
80019882:	08 9c       	mov	r12,r4
80019884:	fa c8 f9 40 	sub	r8,sp,-1728
80019888:	fa c9 ff b4 	sub	r9,sp,-76
8001988c:	fe b0 f3 f8 	rcall	8001807c <get_arg>
80019890:	2f dd       	sub	sp,-12
80019892:	78 0b       	ld.w	r11,r12[0x0]
80019894:	c2 48       	rjmp	800198dc <_vfprintf_r+0x1524>
80019896:	ee ca ff ff 	sub	r10,r7,-1
8001989a:	10 37       	cp.w	r7,r8
8001989c:	c0 94       	brge	800198ae <_vfprintf_r+0x14f6>
8001989e:	fa c9 f9 44 	sub	r9,sp,-1724
800198a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800198a6:	14 97       	mov	r7,r10
800198a8:	ec fb fd 88 	ld.w	r11,r6[-632]
800198ac:	c1 88       	rjmp	800198dc <_vfprintf_r+0x1524>
800198ae:	41 09       	lddsp	r9,sp[0x40]
800198b0:	59 f8       	cp.w	r8,31
800198b2:	e0 89 00 11 	brgt	800198d4 <_vfprintf_r+0x151c>
800198b6:	f2 cb ff fc 	sub	r11,r9,-4
800198ba:	51 0b       	stdsp	sp[0x40],r11
800198bc:	fa c6 f9 44 	sub	r6,sp,-1724
800198c0:	72 0b       	ld.w	r11,r9[0x0]
800198c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800198c6:	f3 4b fd 88 	st.w	r9[-632],r11
800198ca:	2f f8       	sub	r8,-1
800198cc:	14 97       	mov	r7,r10
800198ce:	fb 48 06 b4 	st.w	sp[1716],r8
800198d2:	c0 58       	rjmp	800198dc <_vfprintf_r+0x1524>
800198d4:	72 0b       	ld.w	r11,r9[0x0]
800198d6:	14 97       	mov	r7,r10
800198d8:	2f c9       	sub	r9,-4
800198da:	51 09       	stdsp	sp[0x40],r9
800198dc:	50 1b       	stdsp	sp[0x4],r11
800198de:	30 0e       	mov	lr,0
800198e0:	50 0e       	stdsp	sp[0x0],lr
800198e2:	40 08       	lddsp	r8,sp[0x0]
800198e4:	40 1c       	lddsp	r12,sp[0x4]
800198e6:	18 48       	or	r8,r12
800198e8:	5f 19       	srne	r9
800198ea:	0a 98       	mov	r8,r5
800198ec:	eb e9 00 09 	and	r9,r5,r9
800198f0:	a1 b8       	sbr	r8,0x1
800198f2:	58 09       	cp.w	r9,0
800198f4:	c0 70       	breq	80019902 <_vfprintf_r+0x154a>
800198f6:	10 95       	mov	r5,r8
800198f8:	fb 60 06 b9 	st.b	sp[1721],r0
800198fc:	33 08       	mov	r8,48
800198fe:	fb 68 06 b8 	st.b	sp[1720],r8
80019902:	30 28       	mov	r8,2
80019904:	30 09       	mov	r9,0
80019906:	fb 69 06 bb 	st.b	sp[1723],r9
8001990a:	0a 99       	mov	r9,r5
8001990c:	a7 d9       	cbr	r9,0x7
8001990e:	40 2b       	lddsp	r11,sp[0x8]
80019910:	40 16       	lddsp	r6,sp[0x4]
80019912:	58 0b       	cp.w	r11,0
80019914:	5f 1a       	srne	r10
80019916:	f2 05 17 40 	movge	r5,r9
8001991a:	fa c2 f9 78 	sub	r2,sp,-1672
8001991e:	40 09       	lddsp	r9,sp[0x0]
80019920:	0c 49       	or	r9,r6
80019922:	5f 19       	srne	r9
80019924:	f5 e9 10 09 	or	r9,r10,r9
80019928:	c5 c0       	breq	800199e0 <_vfprintf_r+0x1628>
8001992a:	30 19       	mov	r9,1
8001992c:	f2 08 18 00 	cp.b	r8,r9
80019930:	c0 60       	breq	8001993c <_vfprintf_r+0x1584>
80019932:	30 29       	mov	r9,2
80019934:	f2 08 18 00 	cp.b	r8,r9
80019938:	c0 41       	brne	80019940 <_vfprintf_r+0x1588>
8001993a:	c3 c8       	rjmp	800199b2 <_vfprintf_r+0x15fa>
8001993c:	04 96       	mov	r6,r2
8001993e:	c3 08       	rjmp	8001999e <_vfprintf_r+0x15e6>
80019940:	04 96       	mov	r6,r2
80019942:	fa e8 00 00 	ld.d	r8,sp[0]
80019946:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8001994a:	2d 0a       	sub	r10,-48
8001994c:	0c fa       	st.b	--r6,r10
8001994e:	f0 0b 16 03 	lsr	r11,r8,0x3
80019952:	f2 0c 16 03 	lsr	r12,r9,0x3
80019956:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8001995a:	18 99       	mov	r9,r12
8001995c:	16 98       	mov	r8,r11
8001995e:	58 08       	cp.w	r8,0
80019960:	5c 29       	cpc	r9
80019962:	cf 21       	brne	80019946 <_vfprintf_r+0x158e>
80019964:	fa e9 00 00 	st.d	sp[0],r8
80019968:	ed b5 00 00 	bld	r5,0x0
8001996c:	c4 51       	brne	800199f6 <_vfprintf_r+0x163e>
8001996e:	33 09       	mov	r9,48
80019970:	f2 0a 18 00 	cp.b	r10,r9
80019974:	c4 10       	breq	800199f6 <_vfprintf_r+0x163e>
80019976:	0c f9       	st.b	--r6,r9
80019978:	c3 f8       	rjmp	800199f6 <_vfprintf_r+0x163e>
8001997a:	fa ea 00 00 	ld.d	r10,sp[0]
8001997e:	30 a8       	mov	r8,10
80019980:	30 09       	mov	r9,0
80019982:	e0 a0 17 6d 	rcall	8001c85c <__avr32_umod64>
80019986:	30 a8       	mov	r8,10
80019988:	2d 0a       	sub	r10,-48
8001998a:	30 09       	mov	r9,0
8001998c:	ac 8a       	st.b	r6[0x0],r10
8001998e:	fa ea 00 00 	ld.d	r10,sp[0]
80019992:	fe b0 e6 fd 	rcall	8001678c <__avr32_udiv64>
80019996:	16 99       	mov	r9,r11
80019998:	14 98       	mov	r8,r10
8001999a:	fa e9 00 00 	st.d	sp[0],r8
8001999e:	20 16       	sub	r6,1
800199a0:	fa ea 00 00 	ld.d	r10,sp[0]
800199a4:	58 9a       	cp.w	r10,9
800199a6:	5c 2b       	cpc	r11
800199a8:	fe 9b ff e9 	brhi	8001997a <_vfprintf_r+0x15c2>
800199ac:	1b f8       	ld.ub	r8,sp[0x7]
800199ae:	2d 08       	sub	r8,-48
800199b0:	c2 08       	rjmp	800199f0 <_vfprintf_r+0x1638>
800199b2:	04 96       	mov	r6,r2
800199b4:	fa e8 00 00 	ld.d	r8,sp[0]
800199b8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800199bc:	40 de       	lddsp	lr,sp[0x34]
800199be:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800199c2:	0c fa       	st.b	--r6,r10
800199c4:	f2 0b 16 04 	lsr	r11,r9,0x4
800199c8:	f0 0a 16 04 	lsr	r10,r8,0x4
800199cc:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800199d0:	16 99       	mov	r9,r11
800199d2:	14 98       	mov	r8,r10
800199d4:	58 08       	cp.w	r8,0
800199d6:	5c 29       	cpc	r9
800199d8:	cf 01       	brne	800199b8 <_vfprintf_r+0x1600>
800199da:	fa e9 00 00 	st.d	sp[0],r8
800199de:	c0 c8       	rjmp	800199f6 <_vfprintf_r+0x163e>
800199e0:	58 08       	cp.w	r8,0
800199e2:	c0 91       	brne	800199f4 <_vfprintf_r+0x163c>
800199e4:	ed b5 00 00 	bld	r5,0x0
800199e8:	c0 61       	brne	800199f4 <_vfprintf_r+0x163c>
800199ea:	fa c6 f9 79 	sub	r6,sp,-1671
800199ee:	33 08       	mov	r8,48
800199f0:	ac 88       	st.b	r6[0x0],r8
800199f2:	c0 28       	rjmp	800199f6 <_vfprintf_r+0x163e>
800199f4:	04 96       	mov	r6,r2
800199f6:	0c 12       	sub	r2,r6
800199f8:	c1 c8       	rjmp	80019a30 <_vfprintf_r+0x1678>
800199fa:	50 a7       	stdsp	sp[0x28],r7
800199fc:	50 80       	stdsp	sp[0x20],r0
800199fe:	40 93       	lddsp	r3,sp[0x24]
80019a00:	0c 97       	mov	r7,r6
80019a02:	10 90       	mov	r0,r8
80019a04:	04 94       	mov	r4,r2
80019a06:	40 41       	lddsp	r1,sp[0x10]
80019a08:	58 08       	cp.w	r8,0
80019a0a:	e0 80 04 51 	breq	8001a2ac <_vfprintf_r+0x1ef4>
80019a0e:	fb 68 06 60 	st.b	sp[1632],r8
80019a12:	30 0c       	mov	r12,0
80019a14:	30 08       	mov	r8,0
80019a16:	30 12       	mov	r2,1
80019a18:	fb 68 06 bb 	st.b	sp[1723],r8
80019a1c:	50 2c       	stdsp	sp[0x8],r12
80019a1e:	fa c6 f9 a0 	sub	r6,sp,-1632
80019a22:	c0 78       	rjmp	80019a30 <_vfprintf_r+0x1678>
80019a24:	30 0b       	mov	r11,0
80019a26:	50 2b       	stdsp	sp[0x8],r11
80019a28:	c0 48       	rjmp	80019a30 <_vfprintf_r+0x1678>
80019a2a:	40 22       	lddsp	r2,sp[0x8]
80019a2c:	30 0a       	mov	r10,0
80019a2e:	50 2a       	stdsp	sp[0x8],r10
80019a30:	40 29       	lddsp	r9,sp[0x8]
80019a32:	e4 09 0c 49 	max	r9,r2,r9
80019a36:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80019a3a:	50 39       	stdsp	sp[0xc],r9
80019a3c:	0a 9e       	mov	lr,r5
80019a3e:	30 09       	mov	r9,0
80019a40:	e2 1e 00 02 	andl	lr,0x2,COH
80019a44:	f2 08 18 00 	cp.b	r8,r9
80019a48:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80019a4c:	f7 b8 01 ff 	subne	r8,-1
80019a50:	fb f8 1a 03 	st.wne	sp[0xc],r8
80019a54:	0a 9b       	mov	r11,r5
80019a56:	58 0e       	cp.w	lr,0
80019a58:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80019a5c:	f7 bc 01 fe 	subne	r12,-2
80019a60:	fb fc 1a 03 	st.wne	sp[0xc],r12
80019a64:	e2 1b 00 84 	andl	r11,0x84,COH
80019a68:	50 fe       	stdsp	sp[0x3c],lr
80019a6a:	50 9b       	stdsp	sp[0x24],r11
80019a6c:	c4 51       	brne	80019af6 <_vfprintf_r+0x173e>
80019a6e:	40 8a       	lddsp	r10,sp[0x20]
80019a70:	40 39       	lddsp	r9,sp[0xc]
80019a72:	12 1a       	sub	r10,r9
80019a74:	50 4a       	stdsp	sp[0x10],r10
80019a76:	58 0a       	cp.w	r10,0
80019a78:	e0 89 00 1f 	brgt	80019ab6 <_vfprintf_r+0x16fe>
80019a7c:	c3 d8       	rjmp	80019af6 <_vfprintf_r+0x173e>
80019a7e:	2f 09       	sub	r9,-16
80019a80:	2f f8       	sub	r8,-1
80019a82:	4c ee       	lddpc	lr,80019bb8 <_vfprintf_r+0x1800>
80019a84:	31 0c       	mov	r12,16
80019a86:	fb 49 06 90 	st.w	sp[1680],r9
80019a8a:	87 0e       	st.w	r3[0x0],lr
80019a8c:	87 1c       	st.w	r3[0x4],r12
80019a8e:	fb 48 06 8c 	st.w	sp[1676],r8
80019a92:	58 78       	cp.w	r8,7
80019a94:	e0 89 00 04 	brgt	80019a9c <_vfprintf_r+0x16e4>
80019a98:	2f 83       	sub	r3,-8
80019a9a:	c0 b8       	rjmp	80019ab0 <_vfprintf_r+0x16f8>
80019a9c:	fa ca f9 78 	sub	r10,sp,-1672
80019aa0:	02 9b       	mov	r11,r1
80019aa2:	08 9c       	mov	r12,r4
80019aa4:	fe b0 f4 7c 	rcall	8001839c <__sprint_r>
80019aa8:	e0 81 04 13 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019aac:	fa c3 f9 e0 	sub	r3,sp,-1568
80019ab0:	40 4b       	lddsp	r11,sp[0x10]
80019ab2:	21 0b       	sub	r11,16
80019ab4:	50 4b       	stdsp	sp[0x10],r11
80019ab6:	fa f9 06 90 	ld.w	r9,sp[1680]
80019aba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019abe:	4b fa       	lddpc	r10,80019bb8 <_vfprintf_r+0x1800>
80019ac0:	40 4e       	lddsp	lr,sp[0x10]
80019ac2:	59 0e       	cp.w	lr,16
80019ac4:	fe 99 ff dd 	brgt	80019a7e <_vfprintf_r+0x16c6>
80019ac8:	1c 09       	add	r9,lr
80019aca:	2f f8       	sub	r8,-1
80019acc:	87 0a       	st.w	r3[0x0],r10
80019ace:	fb 49 06 90 	st.w	sp[1680],r9
80019ad2:	87 1e       	st.w	r3[0x4],lr
80019ad4:	fb 48 06 8c 	st.w	sp[1676],r8
80019ad8:	58 78       	cp.w	r8,7
80019ada:	e0 89 00 04 	brgt	80019ae2 <_vfprintf_r+0x172a>
80019ade:	2f 83       	sub	r3,-8
80019ae0:	c0 b8       	rjmp	80019af6 <_vfprintf_r+0x173e>
80019ae2:	fa ca f9 78 	sub	r10,sp,-1672
80019ae6:	02 9b       	mov	r11,r1
80019ae8:	08 9c       	mov	r12,r4
80019aea:	fe b0 f4 59 	rcall	8001839c <__sprint_r>
80019aee:	e0 81 03 f0 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019af2:	fa c3 f9 e0 	sub	r3,sp,-1568
80019af6:	30 09       	mov	r9,0
80019af8:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80019afc:	f2 08 18 00 	cp.b	r8,r9
80019b00:	c1 f0       	breq	80019b3e <_vfprintf_r+0x1786>
80019b02:	fa f8 06 90 	ld.w	r8,sp[1680]
80019b06:	fa c9 f9 45 	sub	r9,sp,-1723
80019b0a:	2f f8       	sub	r8,-1
80019b0c:	87 09       	st.w	r3[0x0],r9
80019b0e:	fb 48 06 90 	st.w	sp[1680],r8
80019b12:	30 19       	mov	r9,1
80019b14:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019b18:	87 19       	st.w	r3[0x4],r9
80019b1a:	2f f8       	sub	r8,-1
80019b1c:	fb 48 06 8c 	st.w	sp[1676],r8
80019b20:	58 78       	cp.w	r8,7
80019b22:	e0 89 00 04 	brgt	80019b2a <_vfprintf_r+0x1772>
80019b26:	2f 83       	sub	r3,-8
80019b28:	c0 b8       	rjmp	80019b3e <_vfprintf_r+0x1786>
80019b2a:	fa ca f9 78 	sub	r10,sp,-1672
80019b2e:	02 9b       	mov	r11,r1
80019b30:	08 9c       	mov	r12,r4
80019b32:	fe b0 f4 35 	rcall	8001839c <__sprint_r>
80019b36:	e0 81 03 cc 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019b3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80019b3e:	40 fc       	lddsp	r12,sp[0x3c]
80019b40:	58 0c       	cp.w	r12,0
80019b42:	c1 f0       	breq	80019b80 <_vfprintf_r+0x17c8>
80019b44:	fa f8 06 90 	ld.w	r8,sp[1680]
80019b48:	fa c9 f9 48 	sub	r9,sp,-1720
80019b4c:	2f e8       	sub	r8,-2
80019b4e:	87 09       	st.w	r3[0x0],r9
80019b50:	fb 48 06 90 	st.w	sp[1680],r8
80019b54:	30 29       	mov	r9,2
80019b56:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019b5a:	87 19       	st.w	r3[0x4],r9
80019b5c:	2f f8       	sub	r8,-1
80019b5e:	fb 48 06 8c 	st.w	sp[1676],r8
80019b62:	58 78       	cp.w	r8,7
80019b64:	e0 89 00 04 	brgt	80019b6c <_vfprintf_r+0x17b4>
80019b68:	2f 83       	sub	r3,-8
80019b6a:	c0 b8       	rjmp	80019b80 <_vfprintf_r+0x17c8>
80019b6c:	fa ca f9 78 	sub	r10,sp,-1672
80019b70:	02 9b       	mov	r11,r1
80019b72:	08 9c       	mov	r12,r4
80019b74:	fe b0 f4 14 	rcall	8001839c <__sprint_r>
80019b78:	e0 81 03 ab 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019b7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80019b80:	40 9b       	lddsp	r11,sp[0x24]
80019b82:	e0 4b 00 80 	cp.w	r11,128
80019b86:	c4 a1       	brne	80019c1a <_vfprintf_r+0x1862>
80019b88:	40 8a       	lddsp	r10,sp[0x20]
80019b8a:	40 39       	lddsp	r9,sp[0xc]
80019b8c:	12 1a       	sub	r10,r9
80019b8e:	50 4a       	stdsp	sp[0x10],r10
80019b90:	58 0a       	cp.w	r10,0
80019b92:	e0 89 00 24 	brgt	80019bda <_vfprintf_r+0x1822>
80019b96:	c4 28       	rjmp	80019c1a <_vfprintf_r+0x1862>
80019b98:	2f 09       	sub	r9,-16
80019b9a:	2f f8       	sub	r8,-1
80019b9c:	48 8e       	lddpc	lr,80019bbc <_vfprintf_r+0x1804>
80019b9e:	31 0c       	mov	r12,16
80019ba0:	fb 49 06 90 	st.w	sp[1680],r9
80019ba4:	87 0e       	st.w	r3[0x0],lr
80019ba6:	87 1c       	st.w	r3[0x4],r12
80019ba8:	fb 48 06 8c 	st.w	sp[1676],r8
80019bac:	58 78       	cp.w	r8,7
80019bae:	e0 89 00 09 	brgt	80019bc0 <_vfprintf_r+0x1808>
80019bb2:	2f 83       	sub	r3,-8
80019bb4:	c1 08       	rjmp	80019bd4 <_vfprintf_r+0x181c>
80019bb6:	d7 03       	nop
80019bb8:	80 07       	ld.sh	r7,r0[0x0]
80019bba:	0d 40       	ld.w	r0,--r6
80019bbc:	80 07       	ld.sh	r7,r0[0x0]
80019bbe:	0d 50       	ld.sh	r0,--r6
80019bc0:	fa ca f9 78 	sub	r10,sp,-1672
80019bc4:	02 9b       	mov	r11,r1
80019bc6:	08 9c       	mov	r12,r4
80019bc8:	fe b0 f3 ea 	rcall	8001839c <__sprint_r>
80019bcc:	e0 81 03 81 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019bd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80019bd4:	40 4b       	lddsp	r11,sp[0x10]
80019bd6:	21 0b       	sub	r11,16
80019bd8:	50 4b       	stdsp	sp[0x10],r11
80019bda:	fa f9 06 90 	ld.w	r9,sp[1680]
80019bde:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019be2:	4c 6a       	lddpc	r10,80019cf8 <_vfprintf_r+0x1940>
80019be4:	40 4e       	lddsp	lr,sp[0x10]
80019be6:	59 0e       	cp.w	lr,16
80019be8:	fe 99 ff d8 	brgt	80019b98 <_vfprintf_r+0x17e0>
80019bec:	1c 09       	add	r9,lr
80019bee:	2f f8       	sub	r8,-1
80019bf0:	87 0a       	st.w	r3[0x0],r10
80019bf2:	fb 49 06 90 	st.w	sp[1680],r9
80019bf6:	87 1e       	st.w	r3[0x4],lr
80019bf8:	fb 48 06 8c 	st.w	sp[1676],r8
80019bfc:	58 78       	cp.w	r8,7
80019bfe:	e0 89 00 04 	brgt	80019c06 <_vfprintf_r+0x184e>
80019c02:	2f 83       	sub	r3,-8
80019c04:	c0 b8       	rjmp	80019c1a <_vfprintf_r+0x1862>
80019c06:	fa ca f9 78 	sub	r10,sp,-1672
80019c0a:	02 9b       	mov	r11,r1
80019c0c:	08 9c       	mov	r12,r4
80019c0e:	fe b0 f3 c7 	rcall	8001839c <__sprint_r>
80019c12:	e0 81 03 5e 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019c16:	fa c3 f9 e0 	sub	r3,sp,-1568
80019c1a:	40 2c       	lddsp	r12,sp[0x8]
80019c1c:	04 1c       	sub	r12,r2
80019c1e:	50 2c       	stdsp	sp[0x8],r12
80019c20:	58 0c       	cp.w	r12,0
80019c22:	e0 89 00 1f 	brgt	80019c60 <_vfprintf_r+0x18a8>
80019c26:	c3 d8       	rjmp	80019ca0 <_vfprintf_r+0x18e8>
80019c28:	2f 09       	sub	r9,-16
80019c2a:	2f f8       	sub	r8,-1
80019c2c:	4b 3b       	lddpc	r11,80019cf8 <_vfprintf_r+0x1940>
80019c2e:	31 0a       	mov	r10,16
80019c30:	fb 49 06 90 	st.w	sp[1680],r9
80019c34:	87 0b       	st.w	r3[0x0],r11
80019c36:	87 1a       	st.w	r3[0x4],r10
80019c38:	fb 48 06 8c 	st.w	sp[1676],r8
80019c3c:	58 78       	cp.w	r8,7
80019c3e:	e0 89 00 04 	brgt	80019c46 <_vfprintf_r+0x188e>
80019c42:	2f 83       	sub	r3,-8
80019c44:	c0 b8       	rjmp	80019c5a <_vfprintf_r+0x18a2>
80019c46:	fa ca f9 78 	sub	r10,sp,-1672
80019c4a:	02 9b       	mov	r11,r1
80019c4c:	08 9c       	mov	r12,r4
80019c4e:	fe b0 f3 a7 	rcall	8001839c <__sprint_r>
80019c52:	e0 81 03 3e 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019c56:	fa c3 f9 e0 	sub	r3,sp,-1568
80019c5a:	40 29       	lddsp	r9,sp[0x8]
80019c5c:	21 09       	sub	r9,16
80019c5e:	50 29       	stdsp	sp[0x8],r9
80019c60:	fa f9 06 90 	ld.w	r9,sp[1680]
80019c64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019c68:	4a 4a       	lddpc	r10,80019cf8 <_vfprintf_r+0x1940>
80019c6a:	40 2e       	lddsp	lr,sp[0x8]
80019c6c:	59 0e       	cp.w	lr,16
80019c6e:	fe 99 ff dd 	brgt	80019c28 <_vfprintf_r+0x1870>
80019c72:	1c 09       	add	r9,lr
80019c74:	2f f8       	sub	r8,-1
80019c76:	87 0a       	st.w	r3[0x0],r10
80019c78:	fb 49 06 90 	st.w	sp[1680],r9
80019c7c:	87 1e       	st.w	r3[0x4],lr
80019c7e:	fb 48 06 8c 	st.w	sp[1676],r8
80019c82:	58 78       	cp.w	r8,7
80019c84:	e0 89 00 04 	brgt	80019c8c <_vfprintf_r+0x18d4>
80019c88:	2f 83       	sub	r3,-8
80019c8a:	c0 b8       	rjmp	80019ca0 <_vfprintf_r+0x18e8>
80019c8c:	fa ca f9 78 	sub	r10,sp,-1672
80019c90:	02 9b       	mov	r11,r1
80019c92:	08 9c       	mov	r12,r4
80019c94:	fe b0 f3 84 	rcall	8001839c <__sprint_r>
80019c98:	e0 81 03 1b 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019c9c:	fa c3 f9 e0 	sub	r3,sp,-1568
80019ca0:	ed b5 00 08 	bld	r5,0x8
80019ca4:	c0 b0       	breq	80019cba <_vfprintf_r+0x1902>
80019ca6:	fa f8 06 90 	ld.w	r8,sp[1680]
80019caa:	87 12       	st.w	r3[0x4],r2
80019cac:	87 06       	st.w	r3[0x0],r6
80019cae:	f0 02 00 02 	add	r2,r8,r2
80019cb2:	fb 42 06 90 	st.w	sp[1680],r2
80019cb6:	e0 8f 01 d5 	bral	8001a060 <_vfprintf_r+0x1ca8>
80019cba:	e0 40 00 65 	cp.w	r0,101
80019cbe:	e0 8a 01 d7 	brle	8001a06c <_vfprintf_r+0x1cb4>
80019cc2:	30 08       	mov	r8,0
80019cc4:	30 09       	mov	r9,0
80019cc6:	40 5b       	lddsp	r11,sp[0x14]
80019cc8:	40 7a       	lddsp	r10,sp[0x1c]
80019cca:	e0 a0 13 c2 	rcall	8001c44e <__avr32_f64_cmp_eq>
80019cce:	c7 a0       	breq	80019dc2 <_vfprintf_r+0x1a0a>
80019cd0:	fa f8 06 90 	ld.w	r8,sp[1680]
80019cd4:	48 a9       	lddpc	r9,80019cfc <_vfprintf_r+0x1944>
80019cd6:	2f f8       	sub	r8,-1
80019cd8:	87 09       	st.w	r3[0x0],r9
80019cda:	fb 48 06 90 	st.w	sp[1680],r8
80019cde:	30 19       	mov	r9,1
80019ce0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019ce4:	87 19       	st.w	r3[0x4],r9
80019ce6:	2f f8       	sub	r8,-1
80019ce8:	fb 48 06 8c 	st.w	sp[1676],r8
80019cec:	58 78       	cp.w	r8,7
80019cee:	e0 89 00 09 	brgt	80019d00 <_vfprintf_r+0x1948>
80019cf2:	2f 83       	sub	r3,-8
80019cf4:	c1 08       	rjmp	80019d14 <_vfprintf_r+0x195c>
80019cf6:	d7 03       	nop
80019cf8:	80 07       	ld.sh	r7,r0[0x0]
80019cfa:	0d 50       	ld.sh	r0,--r6
80019cfc:	80 06       	ld.sh	r6,r0[0x0]
80019cfe:	d2 e0       	acall	0xb8
80019d00:	fa ca f9 78 	sub	r10,sp,-1672
80019d04:	02 9b       	mov	r11,r1
80019d06:	08 9c       	mov	r12,r4
80019d08:	fe b0 f3 4a 	rcall	8001839c <__sprint_r>
80019d0c:	e0 81 02 e1 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019d10:	fa c3 f9 e0 	sub	r3,sp,-1568
80019d14:	fa f8 06 ac 	ld.w	r8,sp[1708]
80019d18:	40 6c       	lddsp	r12,sp[0x18]
80019d1a:	18 38       	cp.w	r8,r12
80019d1c:	c0 55       	brlt	80019d26 <_vfprintf_r+0x196e>
80019d1e:	ed b5 00 00 	bld	r5,0x0
80019d22:	e0 81 02 69 	brne	8001a1f4 <_vfprintf_r+0x1e3c>
80019d26:	fa f8 06 90 	ld.w	r8,sp[1680]
80019d2a:	2f f8       	sub	r8,-1
80019d2c:	40 cb       	lddsp	r11,sp[0x30]
80019d2e:	fb 48 06 90 	st.w	sp[1680],r8
80019d32:	30 19       	mov	r9,1
80019d34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019d38:	87 0b       	st.w	r3[0x0],r11
80019d3a:	2f f8       	sub	r8,-1
80019d3c:	87 19       	st.w	r3[0x4],r9
80019d3e:	fb 48 06 8c 	st.w	sp[1676],r8
80019d42:	58 78       	cp.w	r8,7
80019d44:	e0 89 00 04 	brgt	80019d4c <_vfprintf_r+0x1994>
80019d48:	2f 83       	sub	r3,-8
80019d4a:	c0 b8       	rjmp	80019d60 <_vfprintf_r+0x19a8>
80019d4c:	fa ca f9 78 	sub	r10,sp,-1672
80019d50:	02 9b       	mov	r11,r1
80019d52:	08 9c       	mov	r12,r4
80019d54:	fe b0 f3 24 	rcall	8001839c <__sprint_r>
80019d58:	e0 81 02 bb 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019d5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80019d60:	40 66       	lddsp	r6,sp[0x18]
80019d62:	20 16       	sub	r6,1
80019d64:	58 06       	cp.w	r6,0
80019d66:	e0 89 00 1d 	brgt	80019da0 <_vfprintf_r+0x19e8>
80019d6a:	e0 8f 02 45 	bral	8001a1f4 <_vfprintf_r+0x1e3c>
80019d6e:	2f 09       	sub	r9,-16
80019d70:	2f f8       	sub	r8,-1
80019d72:	fb 49 06 90 	st.w	sp[1680],r9
80019d76:	87 02       	st.w	r3[0x0],r2
80019d78:	87 10       	st.w	r3[0x4],r0
80019d7a:	fb 48 06 8c 	st.w	sp[1676],r8
80019d7e:	58 78       	cp.w	r8,7
80019d80:	e0 89 00 04 	brgt	80019d88 <_vfprintf_r+0x19d0>
80019d84:	2f 83       	sub	r3,-8
80019d86:	c0 b8       	rjmp	80019d9c <_vfprintf_r+0x19e4>
80019d88:	fa ca f9 78 	sub	r10,sp,-1672
80019d8c:	02 9b       	mov	r11,r1
80019d8e:	08 9c       	mov	r12,r4
80019d90:	fe b0 f3 06 	rcall	8001839c <__sprint_r>
80019d94:	e0 81 02 9d 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019d98:	fa c3 f9 e0 	sub	r3,sp,-1568
80019d9c:	21 06       	sub	r6,16
80019d9e:	c0 38       	rjmp	80019da4 <_vfprintf_r+0x19ec>
80019da0:	4d 22       	lddpc	r2,80019ee8 <_vfprintf_r+0x1b30>
80019da2:	31 00       	mov	r0,16
80019da4:	fa f9 06 90 	ld.w	r9,sp[1680]
80019da8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019dac:	4c fa       	lddpc	r10,80019ee8 <_vfprintf_r+0x1b30>
80019dae:	59 06       	cp.w	r6,16
80019db0:	fe 99 ff df 	brgt	80019d6e <_vfprintf_r+0x19b6>
80019db4:	0c 09       	add	r9,r6
80019db6:	87 0a       	st.w	r3[0x0],r10
80019db8:	fb 49 06 90 	st.w	sp[1680],r9
80019dbc:	2f f8       	sub	r8,-1
80019dbe:	87 16       	st.w	r3[0x4],r6
80019dc0:	c5 39       	rjmp	8001a066 <_vfprintf_r+0x1cae>
80019dc2:	fa fa 06 ac 	ld.w	r10,sp[1708]
80019dc6:	58 0a       	cp.w	r10,0
80019dc8:	e0 89 00 94 	brgt	80019ef0 <_vfprintf_r+0x1b38>
80019dcc:	fa f8 06 90 	ld.w	r8,sp[1680]
80019dd0:	4c 79       	lddpc	r9,80019eec <_vfprintf_r+0x1b34>
80019dd2:	2f f8       	sub	r8,-1
80019dd4:	87 09       	st.w	r3[0x0],r9
80019dd6:	fb 48 06 90 	st.w	sp[1680],r8
80019dda:	30 19       	mov	r9,1
80019ddc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019de0:	87 19       	st.w	r3[0x4],r9
80019de2:	2f f8       	sub	r8,-1
80019de4:	fb 48 06 8c 	st.w	sp[1676],r8
80019de8:	58 78       	cp.w	r8,7
80019dea:	e0 89 00 04 	brgt	80019df2 <_vfprintf_r+0x1a3a>
80019dee:	2f 83       	sub	r3,-8
80019df0:	c0 b8       	rjmp	80019e06 <_vfprintf_r+0x1a4e>
80019df2:	fa ca f9 78 	sub	r10,sp,-1672
80019df6:	02 9b       	mov	r11,r1
80019df8:	08 9c       	mov	r12,r4
80019dfa:	fe b0 f2 d1 	rcall	8001839c <__sprint_r>
80019dfe:	e0 81 02 68 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019e02:	fa c3 f9 e0 	sub	r3,sp,-1568
80019e06:	fa f8 06 ac 	ld.w	r8,sp[1708]
80019e0a:	58 08       	cp.w	r8,0
80019e0c:	c0 81       	brne	80019e1c <_vfprintf_r+0x1a64>
80019e0e:	40 6a       	lddsp	r10,sp[0x18]
80019e10:	58 0a       	cp.w	r10,0
80019e12:	c0 51       	brne	80019e1c <_vfprintf_r+0x1a64>
80019e14:	ed b5 00 00 	bld	r5,0x0
80019e18:	e0 81 01 ee 	brne	8001a1f4 <_vfprintf_r+0x1e3c>
80019e1c:	40 c9       	lddsp	r9,sp[0x30]
80019e1e:	fa f8 06 90 	ld.w	r8,sp[1680]
80019e22:	2f f8       	sub	r8,-1
80019e24:	87 09       	st.w	r3[0x0],r9
80019e26:	fb 48 06 90 	st.w	sp[1680],r8
80019e2a:	30 19       	mov	r9,1
80019e2c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019e30:	87 19       	st.w	r3[0x4],r9
80019e32:	2f f8       	sub	r8,-1
80019e34:	fb 48 06 8c 	st.w	sp[1676],r8
80019e38:	58 78       	cp.w	r8,7
80019e3a:	e0 89 00 04 	brgt	80019e42 <_vfprintf_r+0x1a8a>
80019e3e:	2f 83       	sub	r3,-8
80019e40:	c0 b8       	rjmp	80019e56 <_vfprintf_r+0x1a9e>
80019e42:	fa ca f9 78 	sub	r10,sp,-1672
80019e46:	02 9b       	mov	r11,r1
80019e48:	08 9c       	mov	r12,r4
80019e4a:	fe b0 f2 a9 	rcall	8001839c <__sprint_r>
80019e4e:	e0 81 02 40 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019e52:	fa c3 f9 e0 	sub	r3,sp,-1568
80019e56:	fa f2 06 ac 	ld.w	r2,sp[1708]
80019e5a:	5c 32       	neg	r2
80019e5c:	58 02       	cp.w	r2,0
80019e5e:	e0 89 00 1d 	brgt	80019e98 <_vfprintf_r+0x1ae0>
80019e62:	c3 b8       	rjmp	80019ed8 <_vfprintf_r+0x1b20>
80019e64:	2f 09       	sub	r9,-16
80019e66:	2f f8       	sub	r8,-1
80019e68:	31 0e       	mov	lr,16
80019e6a:	fb 49 06 90 	st.w	sp[1680],r9
80019e6e:	87 00       	st.w	r3[0x0],r0
80019e70:	87 1e       	st.w	r3[0x4],lr
80019e72:	fb 48 06 8c 	st.w	sp[1676],r8
80019e76:	58 78       	cp.w	r8,7
80019e78:	e0 89 00 04 	brgt	80019e80 <_vfprintf_r+0x1ac8>
80019e7c:	2f 83       	sub	r3,-8
80019e7e:	c0 b8       	rjmp	80019e94 <_vfprintf_r+0x1adc>
80019e80:	fa ca f9 78 	sub	r10,sp,-1672
80019e84:	02 9b       	mov	r11,r1
80019e86:	08 9c       	mov	r12,r4
80019e88:	fe b0 f2 8a 	rcall	8001839c <__sprint_r>
80019e8c:	e0 81 02 21 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019e90:	fa c3 f9 e0 	sub	r3,sp,-1568
80019e94:	21 02       	sub	r2,16
80019e96:	c0 28       	rjmp	80019e9a <_vfprintf_r+0x1ae2>
80019e98:	49 40       	lddpc	r0,80019ee8 <_vfprintf_r+0x1b30>
80019e9a:	fa f9 06 90 	ld.w	r9,sp[1680]
80019e9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019ea2:	49 2a       	lddpc	r10,80019ee8 <_vfprintf_r+0x1b30>
80019ea4:	59 02       	cp.w	r2,16
80019ea6:	fe 99 ff df 	brgt	80019e64 <_vfprintf_r+0x1aac>
80019eaa:	04 09       	add	r9,r2
80019eac:	2f f8       	sub	r8,-1
80019eae:	87 0a       	st.w	r3[0x0],r10
80019eb0:	fb 49 06 90 	st.w	sp[1680],r9
80019eb4:	87 12       	st.w	r3[0x4],r2
80019eb6:	fb 48 06 8c 	st.w	sp[1676],r8
80019eba:	58 78       	cp.w	r8,7
80019ebc:	e0 89 00 04 	brgt	80019ec4 <_vfprintf_r+0x1b0c>
80019ec0:	2f 83       	sub	r3,-8
80019ec2:	c0 b8       	rjmp	80019ed8 <_vfprintf_r+0x1b20>
80019ec4:	fa ca f9 78 	sub	r10,sp,-1672
80019ec8:	02 9b       	mov	r11,r1
80019eca:	08 9c       	mov	r12,r4
80019ecc:	fe b0 f2 68 	rcall	8001839c <__sprint_r>
80019ed0:	e0 81 01 ff 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019ed4:	fa c3 f9 e0 	sub	r3,sp,-1568
80019ed8:	40 6c       	lddsp	r12,sp[0x18]
80019eda:	fa f8 06 90 	ld.w	r8,sp[1680]
80019ede:	87 06       	st.w	r3[0x0],r6
80019ee0:	87 1c       	st.w	r3[0x4],r12
80019ee2:	18 08       	add	r8,r12
80019ee4:	cb c8       	rjmp	8001a05c <_vfprintf_r+0x1ca4>
80019ee6:	d7 03       	nop
80019ee8:	80 07       	ld.sh	r7,r0[0x0]
80019eea:	0d 50       	ld.sh	r0,--r6
80019eec:	80 06       	ld.sh	r6,r0[0x0]
80019eee:	d2 e0       	acall	0xb8
80019ef0:	fa f9 06 90 	ld.w	r9,sp[1680]
80019ef4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019ef8:	40 6b       	lddsp	r11,sp[0x18]
80019efa:	16 3a       	cp.w	r10,r11
80019efc:	c6 d5       	brlt	80019fd6 <_vfprintf_r+0x1c1e>
80019efe:	16 09       	add	r9,r11
80019f00:	2f f8       	sub	r8,-1
80019f02:	87 06       	st.w	r3[0x0],r6
80019f04:	fb 49 06 90 	st.w	sp[1680],r9
80019f08:	87 1b       	st.w	r3[0x4],r11
80019f0a:	fb 48 06 8c 	st.w	sp[1676],r8
80019f0e:	58 78       	cp.w	r8,7
80019f10:	e0 89 00 04 	brgt	80019f18 <_vfprintf_r+0x1b60>
80019f14:	2f 83       	sub	r3,-8
80019f16:	c0 b8       	rjmp	80019f2c <_vfprintf_r+0x1b74>
80019f18:	fa ca f9 78 	sub	r10,sp,-1672
80019f1c:	02 9b       	mov	r11,r1
80019f1e:	08 9c       	mov	r12,r4
80019f20:	fe b0 f2 3e 	rcall	8001839c <__sprint_r>
80019f24:	e0 81 01 d5 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019f28:	fa c3 f9 e0 	sub	r3,sp,-1568
80019f2c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80019f30:	40 6a       	lddsp	r10,sp[0x18]
80019f32:	14 16       	sub	r6,r10
80019f34:	58 06       	cp.w	r6,0
80019f36:	e0 89 00 1c 	brgt	80019f6e <_vfprintf_r+0x1bb6>
80019f3a:	c3 b8       	rjmp	80019fb0 <_vfprintf_r+0x1bf8>
80019f3c:	2f 09       	sub	r9,-16
80019f3e:	2f f8       	sub	r8,-1
80019f40:	fb 49 06 90 	st.w	sp[1680],r9
80019f44:	87 02       	st.w	r3[0x0],r2
80019f46:	87 10       	st.w	r3[0x4],r0
80019f48:	fb 48 06 8c 	st.w	sp[1676],r8
80019f4c:	58 78       	cp.w	r8,7
80019f4e:	e0 89 00 04 	brgt	80019f56 <_vfprintf_r+0x1b9e>
80019f52:	2f 83       	sub	r3,-8
80019f54:	c0 b8       	rjmp	80019f6a <_vfprintf_r+0x1bb2>
80019f56:	fa ca f9 78 	sub	r10,sp,-1672
80019f5a:	02 9b       	mov	r11,r1
80019f5c:	08 9c       	mov	r12,r4
80019f5e:	fe b0 f2 1f 	rcall	8001839c <__sprint_r>
80019f62:	e0 81 01 b6 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019f66:	fa c3 f9 e0 	sub	r3,sp,-1568
80019f6a:	21 06       	sub	r6,16
80019f6c:	c0 38       	rjmp	80019f72 <_vfprintf_r+0x1bba>
80019f6e:	4d c2       	lddpc	r2,8001a0dc <_vfprintf_r+0x1d24>
80019f70:	31 00       	mov	r0,16
80019f72:	fa f9 06 90 	ld.w	r9,sp[1680]
80019f76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019f7a:	4d 9a       	lddpc	r10,8001a0dc <_vfprintf_r+0x1d24>
80019f7c:	59 06       	cp.w	r6,16
80019f7e:	fe 99 ff df 	brgt	80019f3c <_vfprintf_r+0x1b84>
80019f82:	0c 09       	add	r9,r6
80019f84:	2f f8       	sub	r8,-1
80019f86:	87 0a       	st.w	r3[0x0],r10
80019f88:	fb 49 06 90 	st.w	sp[1680],r9
80019f8c:	87 16       	st.w	r3[0x4],r6
80019f8e:	fb 48 06 8c 	st.w	sp[1676],r8
80019f92:	58 78       	cp.w	r8,7
80019f94:	e0 89 00 04 	brgt	80019f9c <_vfprintf_r+0x1be4>
80019f98:	2f 83       	sub	r3,-8
80019f9a:	c0 b8       	rjmp	80019fb0 <_vfprintf_r+0x1bf8>
80019f9c:	fa ca f9 78 	sub	r10,sp,-1672
80019fa0:	02 9b       	mov	r11,r1
80019fa2:	08 9c       	mov	r12,r4
80019fa4:	fe b0 f1 fc 	rcall	8001839c <__sprint_r>
80019fa8:	e0 81 01 93 	brne	8001a2ce <_vfprintf_r+0x1f16>
80019fac:	fa c3 f9 e0 	sub	r3,sp,-1568
80019fb0:	ed b5 00 00 	bld	r5,0x0
80019fb4:	e0 81 01 20 	brne	8001a1f4 <_vfprintf_r+0x1e3c>
80019fb8:	40 c9       	lddsp	r9,sp[0x30]
80019fba:	fa f8 06 90 	ld.w	r8,sp[1680]
80019fbe:	2f f8       	sub	r8,-1
80019fc0:	87 09       	st.w	r3[0x0],r9
80019fc2:	fb 48 06 90 	st.w	sp[1680],r8
80019fc6:	30 19       	mov	r9,1
80019fc8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80019fcc:	87 19       	st.w	r3[0x4],r9
80019fce:	2f f8       	sub	r8,-1
80019fd0:	fb 48 06 8c 	st.w	sp[1676],r8
80019fd4:	c0 29       	rjmp	8001a1d8 <_vfprintf_r+0x1e20>
80019fd6:	14 09       	add	r9,r10
80019fd8:	2f f8       	sub	r8,-1
80019fda:	fb 49 06 90 	st.w	sp[1680],r9
80019fde:	87 06       	st.w	r3[0x0],r6
80019fe0:	87 1a       	st.w	r3[0x4],r10
80019fe2:	fb 48 06 8c 	st.w	sp[1676],r8
80019fe6:	58 78       	cp.w	r8,7
80019fe8:	e0 89 00 04 	brgt	80019ff0 <_vfprintf_r+0x1c38>
80019fec:	2f 83       	sub	r3,-8
80019fee:	c0 b8       	rjmp	8001a004 <_vfprintf_r+0x1c4c>
80019ff0:	fa ca f9 78 	sub	r10,sp,-1672
80019ff4:	02 9b       	mov	r11,r1
80019ff6:	08 9c       	mov	r12,r4
80019ff8:	fe b0 f1 d2 	rcall	8001839c <__sprint_r>
80019ffc:	e0 81 01 69 	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a000:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a004:	40 c8       	lddsp	r8,sp[0x30]
8001a006:	87 08       	st.w	r3[0x0],r8
8001a008:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a00c:	2f f8       	sub	r8,-1
8001a00e:	30 19       	mov	r9,1
8001a010:	fb 48 06 90 	st.w	sp[1680],r8
8001a014:	87 19       	st.w	r3[0x4],r9
8001a016:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a01a:	2f f8       	sub	r8,-1
8001a01c:	fb 48 06 8c 	st.w	sp[1676],r8
8001a020:	fa f2 06 ac 	ld.w	r2,sp[1708]
8001a024:	58 78       	cp.w	r8,7
8001a026:	e0 89 00 04 	brgt	8001a02e <_vfprintf_r+0x1c76>
8001a02a:	2f 83       	sub	r3,-8
8001a02c:	c0 b8       	rjmp	8001a042 <_vfprintf_r+0x1c8a>
8001a02e:	fa ca f9 78 	sub	r10,sp,-1672
8001a032:	02 9b       	mov	r11,r1
8001a034:	08 9c       	mov	r12,r4
8001a036:	fe b0 f1 b3 	rcall	8001839c <__sprint_r>
8001a03a:	e0 81 01 4a 	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a03e:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a042:	04 06       	add	r6,r2
8001a044:	fa f8 06 ac 	ld.w	r8,sp[1708]
8001a048:	87 06       	st.w	r3[0x0],r6
8001a04a:	fa f9 06 90 	ld.w	r9,sp[1680]
8001a04e:	40 66       	lddsp	r6,sp[0x18]
8001a050:	40 6e       	lddsp	lr,sp[0x18]
8001a052:	10 16       	sub	r6,r8
8001a054:	f2 08 01 08 	sub	r8,r9,r8
8001a058:	87 16       	st.w	r3[0x4],r6
8001a05a:	1c 08       	add	r8,lr
8001a05c:	fb 48 06 90 	st.w	sp[1680],r8
8001a060:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a064:	2f f8       	sub	r8,-1
8001a066:	fb 48 06 8c 	st.w	sp[1676],r8
8001a06a:	cb 78       	rjmp	8001a1d8 <_vfprintf_r+0x1e20>
8001a06c:	40 6c       	lddsp	r12,sp[0x18]
8001a06e:	58 1c       	cp.w	r12,1
8001a070:	e0 89 00 06 	brgt	8001a07c <_vfprintf_r+0x1cc4>
8001a074:	ed b5 00 00 	bld	r5,0x0
8001a078:	e0 81 00 85 	brne	8001a182 <_vfprintf_r+0x1dca>
8001a07c:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a080:	2f f8       	sub	r8,-1
8001a082:	30 19       	mov	r9,1
8001a084:	fb 48 06 90 	st.w	sp[1680],r8
8001a088:	87 06       	st.w	r3[0x0],r6
8001a08a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a08e:	87 19       	st.w	r3[0x4],r9
8001a090:	2f f8       	sub	r8,-1
8001a092:	fb 48 06 8c 	st.w	sp[1676],r8
8001a096:	58 78       	cp.w	r8,7
8001a098:	e0 89 00 04 	brgt	8001a0a0 <_vfprintf_r+0x1ce8>
8001a09c:	2f 83       	sub	r3,-8
8001a09e:	c0 b8       	rjmp	8001a0b4 <_vfprintf_r+0x1cfc>
8001a0a0:	fa ca f9 78 	sub	r10,sp,-1672
8001a0a4:	02 9b       	mov	r11,r1
8001a0a6:	08 9c       	mov	r12,r4
8001a0a8:	fe b0 f1 7a 	rcall	8001839c <__sprint_r>
8001a0ac:	e0 81 01 11 	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a0b0:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a0b4:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a0b8:	2f f8       	sub	r8,-1
8001a0ba:	40 cb       	lddsp	r11,sp[0x30]
8001a0bc:	fb 48 06 90 	st.w	sp[1680],r8
8001a0c0:	30 19       	mov	r9,1
8001a0c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a0c6:	87 0b       	st.w	r3[0x0],r11
8001a0c8:	2f f8       	sub	r8,-1
8001a0ca:	87 19       	st.w	r3[0x4],r9
8001a0cc:	fb 48 06 8c 	st.w	sp[1676],r8
8001a0d0:	58 78       	cp.w	r8,7
8001a0d2:	e0 89 00 07 	brgt	8001a0e0 <_vfprintf_r+0x1d28>
8001a0d6:	2f 83       	sub	r3,-8
8001a0d8:	c0 e8       	rjmp	8001a0f4 <_vfprintf_r+0x1d3c>
8001a0da:	d7 03       	nop
8001a0dc:	80 07       	ld.sh	r7,r0[0x0]
8001a0de:	0d 50       	ld.sh	r0,--r6
8001a0e0:	fa ca f9 78 	sub	r10,sp,-1672
8001a0e4:	02 9b       	mov	r11,r1
8001a0e6:	08 9c       	mov	r12,r4
8001a0e8:	fe b0 f1 5a 	rcall	8001839c <__sprint_r>
8001a0ec:	e0 81 00 f1 	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a0f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a0f4:	30 08       	mov	r8,0
8001a0f6:	30 09       	mov	r9,0
8001a0f8:	40 5b       	lddsp	r11,sp[0x14]
8001a0fa:	40 7a       	lddsp	r10,sp[0x1c]
8001a0fc:	e0 a0 11 a9 	rcall	8001c44e <__avr32_f64_cmp_eq>
8001a100:	40 68       	lddsp	r8,sp[0x18]
8001a102:	20 18       	sub	r8,1
8001a104:	58 0c       	cp.w	r12,0
8001a106:	c0 d1       	brne	8001a120 <_vfprintf_r+0x1d68>
8001a108:	2f f6       	sub	r6,-1
8001a10a:	87 18       	st.w	r3[0x4],r8
8001a10c:	87 06       	st.w	r3[0x0],r6
8001a10e:	fa f6 06 90 	ld.w	r6,sp[1680]
8001a112:	10 06       	add	r6,r8
8001a114:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a118:	fb 46 06 90 	st.w	sp[1680],r6
8001a11c:	2f f8       	sub	r8,-1
8001a11e:	c2 f8       	rjmp	8001a17c <_vfprintf_r+0x1dc4>
8001a120:	10 96       	mov	r6,r8
8001a122:	58 08       	cp.w	r8,0
8001a124:	e0 89 00 1c 	brgt	8001a15c <_vfprintf_r+0x1da4>
8001a128:	c4 98       	rjmp	8001a1ba <_vfprintf_r+0x1e02>
8001a12a:	2f 09       	sub	r9,-16
8001a12c:	2f f8       	sub	r8,-1
8001a12e:	fb 49 06 90 	st.w	sp[1680],r9
8001a132:	87 02       	st.w	r3[0x0],r2
8001a134:	87 10       	st.w	r3[0x4],r0
8001a136:	fb 48 06 8c 	st.w	sp[1676],r8
8001a13a:	58 78       	cp.w	r8,7
8001a13c:	e0 89 00 04 	brgt	8001a144 <_vfprintf_r+0x1d8c>
8001a140:	2f 83       	sub	r3,-8
8001a142:	c0 b8       	rjmp	8001a158 <_vfprintf_r+0x1da0>
8001a144:	fa ca f9 78 	sub	r10,sp,-1672
8001a148:	02 9b       	mov	r11,r1
8001a14a:	08 9c       	mov	r12,r4
8001a14c:	fe b0 f1 28 	rcall	8001839c <__sprint_r>
8001a150:	e0 81 00 bf 	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a154:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a158:	21 06       	sub	r6,16
8001a15a:	c0 38       	rjmp	8001a160 <_vfprintf_r+0x1da8>
8001a15c:	4d 22       	lddpc	r2,8001a2a4 <_vfprintf_r+0x1eec>
8001a15e:	31 00       	mov	r0,16
8001a160:	fa f9 06 90 	ld.w	r9,sp[1680]
8001a164:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a168:	4c fa       	lddpc	r10,8001a2a4 <_vfprintf_r+0x1eec>
8001a16a:	59 06       	cp.w	r6,16
8001a16c:	fe 99 ff df 	brgt	8001a12a <_vfprintf_r+0x1d72>
8001a170:	0c 09       	add	r9,r6
8001a172:	87 0a       	st.w	r3[0x0],r10
8001a174:	fb 49 06 90 	st.w	sp[1680],r9
8001a178:	2f f8       	sub	r8,-1
8001a17a:	87 16       	st.w	r3[0x4],r6
8001a17c:	fb 48 06 8c 	st.w	sp[1676],r8
8001a180:	c0 e8       	rjmp	8001a19c <_vfprintf_r+0x1de4>
8001a182:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a186:	2f f8       	sub	r8,-1
8001a188:	30 19       	mov	r9,1
8001a18a:	fb 48 06 90 	st.w	sp[1680],r8
8001a18e:	87 06       	st.w	r3[0x0],r6
8001a190:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a194:	87 19       	st.w	r3[0x4],r9
8001a196:	2f f8       	sub	r8,-1
8001a198:	fb 48 06 8c 	st.w	sp[1676],r8
8001a19c:	58 78       	cp.w	r8,7
8001a19e:	e0 89 00 04 	brgt	8001a1a6 <_vfprintf_r+0x1dee>
8001a1a2:	2f 83       	sub	r3,-8
8001a1a4:	c0 b8       	rjmp	8001a1ba <_vfprintf_r+0x1e02>
8001a1a6:	fa ca f9 78 	sub	r10,sp,-1672
8001a1aa:	02 9b       	mov	r11,r1
8001a1ac:	08 9c       	mov	r12,r4
8001a1ae:	fe b0 f0 f7 	rcall	8001839c <__sprint_r>
8001a1b2:	e0 81 00 8e 	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a1b6:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a1ba:	40 ea       	lddsp	r10,sp[0x38]
8001a1bc:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a1c0:	14 08       	add	r8,r10
8001a1c2:	fa c9 f9 64 	sub	r9,sp,-1692
8001a1c6:	fb 48 06 90 	st.w	sp[1680],r8
8001a1ca:	87 1a       	st.w	r3[0x4],r10
8001a1cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a1d0:	87 09       	st.w	r3[0x0],r9
8001a1d2:	2f f8       	sub	r8,-1
8001a1d4:	fb 48 06 8c 	st.w	sp[1676],r8
8001a1d8:	58 78       	cp.w	r8,7
8001a1da:	e0 89 00 04 	brgt	8001a1e2 <_vfprintf_r+0x1e2a>
8001a1de:	2f 83       	sub	r3,-8
8001a1e0:	c0 a8       	rjmp	8001a1f4 <_vfprintf_r+0x1e3c>
8001a1e2:	fa ca f9 78 	sub	r10,sp,-1672
8001a1e6:	02 9b       	mov	r11,r1
8001a1e8:	08 9c       	mov	r12,r4
8001a1ea:	fe b0 f0 d9 	rcall	8001839c <__sprint_r>
8001a1ee:	c7 01       	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a1f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a1f4:	e2 15 00 04 	andl	r5,0x4,COH
8001a1f8:	c3 d0       	breq	8001a272 <_vfprintf_r+0x1eba>
8001a1fa:	40 86       	lddsp	r6,sp[0x20]
8001a1fc:	40 39       	lddsp	r9,sp[0xc]
8001a1fe:	12 16       	sub	r6,r9
8001a200:	58 06       	cp.w	r6,0
8001a202:	e0 89 00 1a 	brgt	8001a236 <_vfprintf_r+0x1e7e>
8001a206:	c3 68       	rjmp	8001a272 <_vfprintf_r+0x1eba>
8001a208:	2f 09       	sub	r9,-16
8001a20a:	2f f8       	sub	r8,-1
8001a20c:	fb 49 06 90 	st.w	sp[1680],r9
8001a210:	87 05       	st.w	r3[0x0],r5
8001a212:	87 12       	st.w	r3[0x4],r2
8001a214:	fb 48 06 8c 	st.w	sp[1676],r8
8001a218:	58 78       	cp.w	r8,7
8001a21a:	e0 89 00 04 	brgt	8001a222 <_vfprintf_r+0x1e6a>
8001a21e:	2f 83       	sub	r3,-8
8001a220:	c0 98       	rjmp	8001a232 <_vfprintf_r+0x1e7a>
8001a222:	00 9a       	mov	r10,r0
8001a224:	02 9b       	mov	r11,r1
8001a226:	08 9c       	mov	r12,r4
8001a228:	fe b0 f0 ba 	rcall	8001839c <__sprint_r>
8001a22c:	c5 11       	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a22e:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a232:	21 06       	sub	r6,16
8001a234:	c0 58       	rjmp	8001a23e <_vfprintf_r+0x1e86>
8001a236:	49 d5       	lddpc	r5,8001a2a8 <_vfprintf_r+0x1ef0>
8001a238:	31 02       	mov	r2,16
8001a23a:	fa c0 f9 78 	sub	r0,sp,-1672
8001a23e:	fa f9 06 90 	ld.w	r9,sp[1680]
8001a242:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001a246:	49 9a       	lddpc	r10,8001a2a8 <_vfprintf_r+0x1ef0>
8001a248:	59 06       	cp.w	r6,16
8001a24a:	fe 99 ff df 	brgt	8001a208 <_vfprintf_r+0x1e50>
8001a24e:	0c 09       	add	r9,r6
8001a250:	2f f8       	sub	r8,-1
8001a252:	87 0a       	st.w	r3[0x0],r10
8001a254:	87 16       	st.w	r3[0x4],r6
8001a256:	fb 49 06 90 	st.w	sp[1680],r9
8001a25a:	fb 48 06 8c 	st.w	sp[1676],r8
8001a25e:	58 78       	cp.w	r8,7
8001a260:	e0 8a 00 09 	brle	8001a272 <_vfprintf_r+0x1eba>
8001a264:	fa ca f9 78 	sub	r10,sp,-1672
8001a268:	02 9b       	mov	r11,r1
8001a26a:	08 9c       	mov	r12,r4
8001a26c:	fe b0 f0 98 	rcall	8001839c <__sprint_r>
8001a270:	c2 f1       	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a272:	40 bc       	lddsp	r12,sp[0x2c]
8001a274:	40 36       	lddsp	r6,sp[0xc]
8001a276:	40 8e       	lddsp	lr,sp[0x20]
8001a278:	ec 0e 0c 48 	max	r8,r6,lr
8001a27c:	10 0c       	add	r12,r8
8001a27e:	50 bc       	stdsp	sp[0x2c],r12
8001a280:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a284:	58 08       	cp.w	r8,0
8001a286:	c0 80       	breq	8001a296 <_vfprintf_r+0x1ede>
8001a288:	fa ca f9 78 	sub	r10,sp,-1672
8001a28c:	02 9b       	mov	r11,r1
8001a28e:	08 9c       	mov	r12,r4
8001a290:	fe b0 f0 86 	rcall	8001839c <__sprint_r>
8001a294:	c1 d1       	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a296:	30 0b       	mov	r11,0
8001a298:	fa c3 f9 e0 	sub	r3,sp,-1568
8001a29c:	fb 4b 06 8c 	st.w	sp[1676],r11
8001a2a0:	fe 9f f1 17 	bral	800184ce <_vfprintf_r+0x116>
8001a2a4:	80 07       	ld.sh	r7,r0[0x0]
8001a2a6:	0d 50       	ld.sh	r0,--r6
8001a2a8:	80 07       	ld.sh	r7,r0[0x0]
8001a2aa:	0d 40       	ld.w	r0,--r6
8001a2ac:	08 95       	mov	r5,r4
8001a2ae:	fa f8 06 90 	ld.w	r8,sp[1680]
8001a2b2:	58 08       	cp.w	r8,0
8001a2b4:	c0 80       	breq	8001a2c4 <_vfprintf_r+0x1f0c>
8001a2b6:	08 9c       	mov	r12,r4
8001a2b8:	fa ca f9 78 	sub	r10,sp,-1672
8001a2bc:	02 9b       	mov	r11,r1
8001a2be:	fe b0 f0 6f 	rcall	8001839c <__sprint_r>
8001a2c2:	c0 61       	brne	8001a2ce <_vfprintf_r+0x1f16>
8001a2c4:	30 08       	mov	r8,0
8001a2c6:	fb 48 06 8c 	st.w	sp[1676],r8
8001a2ca:	c0 28       	rjmp	8001a2ce <_vfprintf_r+0x1f16>
8001a2cc:	40 41       	lddsp	r1,sp[0x10]
8001a2ce:	82 68       	ld.sh	r8,r1[0xc]
8001a2d0:	ed b8 00 06 	bld	r8,0x6
8001a2d4:	c0 31       	brne	8001a2da <_vfprintf_r+0x1f22>
8001a2d6:	3f fa       	mov	r10,-1
8001a2d8:	50 ba       	stdsp	sp[0x2c],r10
8001a2da:	40 bc       	lddsp	r12,sp[0x2c]
8001a2dc:	fe 3d f9 44 	sub	sp,-1724
8001a2e0:	d8 32       	popm	r0-r7,pc
8001a2e2:	d7 03       	nop

8001a2e4 <__swbuf_r>:
8001a2e4:	d4 21       	pushm	r4-r7,lr
8001a2e6:	16 97       	mov	r7,r11
8001a2e8:	14 96       	mov	r6,r10
8001a2ea:	18 95       	mov	r5,r12
8001a2ec:	58 0c       	cp.w	r12,0
8001a2ee:	c0 60       	breq	8001a2fa <__swbuf_r+0x16>
8001a2f0:	78 68       	ld.w	r8,r12[0x18]
8001a2f2:	58 08       	cp.w	r8,0
8001a2f4:	c0 31       	brne	8001a2fa <__swbuf_r+0x16>
8001a2f6:	fe b0 e4 cf 	rcall	80016c94 <__sinit>
8001a2fa:	4a 38       	lddpc	r8,8001a384 <__swbuf_r+0xa0>
8001a2fc:	10 36       	cp.w	r6,r8
8001a2fe:	c0 31       	brne	8001a304 <__swbuf_r+0x20>
8001a300:	6a 06       	ld.w	r6,r5[0x0]
8001a302:	c0 a8       	rjmp	8001a316 <__swbuf_r+0x32>
8001a304:	4a 18       	lddpc	r8,8001a388 <__swbuf_r+0xa4>
8001a306:	10 36       	cp.w	r6,r8
8001a308:	c0 31       	brne	8001a30e <__swbuf_r+0x2a>
8001a30a:	6a 16       	ld.w	r6,r5[0x4]
8001a30c:	c0 58       	rjmp	8001a316 <__swbuf_r+0x32>
8001a30e:	4a 08       	lddpc	r8,8001a38c <__swbuf_r+0xa8>
8001a310:	10 36       	cp.w	r6,r8
8001a312:	eb f6 00 02 	ld.weq	r6,r5[0x8]
8001a316:	6c 68       	ld.w	r8,r6[0x18]
8001a318:	8d 28       	st.w	r6[0x8],r8
8001a31a:	8c 68       	ld.sh	r8,r6[0xc]
8001a31c:	ed b8 00 03 	bld	r8,0x3
8001a320:	c0 41       	brne	8001a328 <__swbuf_r+0x44>
8001a322:	6c 48       	ld.w	r8,r6[0x10]
8001a324:	58 08       	cp.w	r8,0
8001a326:	c0 b1       	brne	8001a33c <__swbuf_r+0x58>
8001a328:	0c 9b       	mov	r11,r6
8001a32a:	0a 9c       	mov	r12,r5
8001a32c:	c4 6c       	rcall	8001a3b8 <__swsetup_r>
8001a32e:	c0 70       	breq	8001a33c <__swbuf_r+0x58>
8001a330:	8c 68       	ld.sh	r8,r6[0xc]
8001a332:	a7 a8       	sbr	r8,0x6
8001a334:	ac 68       	st.h	r6[0xc],r8
8001a336:	30 98       	mov	r8,9
8001a338:	8b 38       	st.w	r5[0xc],r8
8001a33a:	c2 28       	rjmp	8001a37e <__swbuf_r+0x9a>
8001a33c:	6c 48       	ld.w	r8,r6[0x10]
8001a33e:	6c 0c       	ld.w	r12,r6[0x0]
8001a340:	10 1c       	sub	r12,r8
8001a342:	6c 58       	ld.w	r8,r6[0x14]
8001a344:	10 3c       	cp.w	r12,r8
8001a346:	c0 65       	brlt	8001a352 <__swbuf_r+0x6e>
8001a348:	0c 9b       	mov	r11,r6
8001a34a:	0a 9c       	mov	r12,r5
8001a34c:	fe b0 e3 b4 	rcall	80016ab4 <_fflush_r>
8001a350:	c1 71       	brne	8001a37e <__swbuf_r+0x9a>
8001a352:	6c 28       	ld.w	r8,r6[0x8]
8001a354:	20 18       	sub	r8,1
8001a356:	8d 28       	st.w	r6[0x8],r8
8001a358:	5c 57       	castu.b	r7
8001a35a:	6c 08       	ld.w	r8,r6[0x0]
8001a35c:	10 c7       	st.b	r8++,r7
8001a35e:	8d 08       	st.w	r6[0x0],r8
8001a360:	2f fc       	sub	r12,-1
8001a362:	6c 58       	ld.w	r8,r6[0x14]
8001a364:	10 3c       	cp.w	r12,r8
8001a366:	c0 70       	breq	8001a374 <__swbuf_r+0x90>
8001a368:	58 a7       	cp.w	r7,10
8001a36a:	5f 08       	sreq	r8
8001a36c:	8c 69       	ld.sh	r9,r6[0xc]
8001a36e:	f3 e8 00 08 	and	r8,r9,r8
8001a372:	c0 70       	breq	8001a380 <__swbuf_r+0x9c>
8001a374:	0c 9b       	mov	r11,r6
8001a376:	0a 9c       	mov	r12,r5
8001a378:	fe b0 e3 9e 	rcall	80016ab4 <_fflush_r>
8001a37c:	c0 20       	breq	8001a380 <__swbuf_r+0x9c>
8001a37e:	3f f7       	mov	r7,-1
8001a380:	0e 9c       	mov	r12,r7
8001a382:	d8 22       	popm	r4-r7,pc
8001a384:	80 07       	ld.sh	r7,r0[0x0]
8001a386:	0a 2c       	rsub	r12,r5
8001a388:	80 07       	ld.sh	r7,r0[0x0]
8001a38a:	0a 4c       	or	r12,r5
8001a38c:	80 07       	ld.sh	r7,r0[0x0]
8001a38e:	0a 6c       	and	r12,r5

8001a390 <_write_r>:
8001a390:	d4 21       	pushm	r4-r7,lr
8001a392:	16 98       	mov	r8,r11
8001a394:	18 97       	mov	r7,r12
8001a396:	10 9c       	mov	r12,r8
8001a398:	30 08       	mov	r8,0
8001a39a:	14 9b       	mov	r11,r10
8001a39c:	48 66       	lddpc	r6,8001a3b4 <_write_r+0x24>
8001a39e:	12 9a       	mov	r10,r9
8001a3a0:	8d 08       	st.w	r6[0x0],r8
8001a3a2:	fe b0 74 1d 	rcall	80008bdc <_write>
8001a3a6:	5b fc       	cp.w	r12,-1
8001a3a8:	c0 51       	brne	8001a3b2 <_write_r+0x22>
8001a3aa:	6c 08       	ld.w	r8,r6[0x0]
8001a3ac:	58 08       	cp.w	r8,0
8001a3ae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001a3b2:	d8 22       	popm	r4-r7,pc
8001a3b4:	00 00       	add	r0,r0
8001a3b6:	4f 74       	lddpc	r4,8001a590 <quorem+0xd8>

8001a3b8 <__swsetup_r>:
8001a3b8:	d4 21       	pushm	r4-r7,lr
8001a3ba:	4b 38       	lddpc	r8,8001a484 <__swsetup_r+0xcc>
8001a3bc:	18 96       	mov	r6,r12
8001a3be:	16 97       	mov	r7,r11
8001a3c0:	70 0c       	ld.w	r12,r8[0x0]
8001a3c2:	58 0c       	cp.w	r12,0
8001a3c4:	c0 60       	breq	8001a3d0 <__swsetup_r+0x18>
8001a3c6:	78 68       	ld.w	r8,r12[0x18]
8001a3c8:	58 08       	cp.w	r8,0
8001a3ca:	c0 31       	brne	8001a3d0 <__swsetup_r+0x18>
8001a3cc:	fe b0 e4 64 	rcall	80016c94 <__sinit>
8001a3d0:	4a e8       	lddpc	r8,8001a488 <__swsetup_r+0xd0>
8001a3d2:	10 37       	cp.w	r7,r8
8001a3d4:	c0 51       	brne	8001a3de <__swsetup_r+0x26>
8001a3d6:	4a c8       	lddpc	r8,8001a484 <__swsetup_r+0xcc>
8001a3d8:	70 08       	ld.w	r8,r8[0x0]
8001a3da:	70 07       	ld.w	r7,r8[0x0]
8001a3dc:	c0 e8       	rjmp	8001a3f8 <__swsetup_r+0x40>
8001a3de:	4a c8       	lddpc	r8,8001a48c <__swsetup_r+0xd4>
8001a3e0:	10 37       	cp.w	r7,r8
8001a3e2:	c0 51       	brne	8001a3ec <__swsetup_r+0x34>
8001a3e4:	4a 88       	lddpc	r8,8001a484 <__swsetup_r+0xcc>
8001a3e6:	70 08       	ld.w	r8,r8[0x0]
8001a3e8:	70 17       	ld.w	r7,r8[0x4]
8001a3ea:	c0 78       	rjmp	8001a3f8 <__swsetup_r+0x40>
8001a3ec:	4a 98       	lddpc	r8,8001a490 <__swsetup_r+0xd8>
8001a3ee:	10 37       	cp.w	r7,r8
8001a3f0:	c0 41       	brne	8001a3f8 <__swsetup_r+0x40>
8001a3f2:	4a 58       	lddpc	r8,8001a484 <__swsetup_r+0xcc>
8001a3f4:	70 08       	ld.w	r8,r8[0x0]
8001a3f6:	70 27       	ld.w	r7,r8[0x8]
8001a3f8:	8e 68       	ld.sh	r8,r7[0xc]
8001a3fa:	ed b8 00 03 	bld	r8,0x3
8001a3fe:	c1 e0       	breq	8001a43a <__swsetup_r+0x82>
8001a400:	ed b8 00 04 	bld	r8,0x4
8001a404:	c3 e1       	brne	8001a480 <__swsetup_r+0xc8>
8001a406:	ed b8 00 02 	bld	r8,0x2
8001a40a:	c1 51       	brne	8001a434 <__swsetup_r+0x7c>
8001a40c:	6e db       	ld.w	r11,r7[0x34]
8001a40e:	58 0b       	cp.w	r11,0
8001a410:	c0 a0       	breq	8001a424 <__swsetup_r+0x6c>
8001a412:	ee c8 ff bc 	sub	r8,r7,-68
8001a416:	10 3b       	cp.w	r11,r8
8001a418:	c0 40       	breq	8001a420 <__swsetup_r+0x68>
8001a41a:	0c 9c       	mov	r12,r6
8001a41c:	fe b0 e5 7c 	rcall	80016f14 <_free_r>
8001a420:	30 08       	mov	r8,0
8001a422:	8f d8       	st.w	r7[0x34],r8
8001a424:	8e 68       	ld.sh	r8,r7[0xc]
8001a426:	e0 18 ff db 	andl	r8,0xffdb
8001a42a:	ae 68       	st.h	r7[0xc],r8
8001a42c:	30 08       	mov	r8,0
8001a42e:	8f 18       	st.w	r7[0x4],r8
8001a430:	6e 48       	ld.w	r8,r7[0x10]
8001a432:	8f 08       	st.w	r7[0x0],r8
8001a434:	8e 68       	ld.sh	r8,r7[0xc]
8001a436:	a3 b8       	sbr	r8,0x3
8001a438:	ae 68       	st.h	r7[0xc],r8
8001a43a:	6e 48       	ld.w	r8,r7[0x10]
8001a43c:	58 08       	cp.w	r8,0
8001a43e:	c0 b1       	brne	8001a454 <__swsetup_r+0x9c>
8001a440:	8e 68       	ld.sh	r8,r7[0xc]
8001a442:	e2 18 02 80 	andl	r8,0x280,COH
8001a446:	e0 48 02 00 	cp.w	r8,512
8001a44a:	c0 50       	breq	8001a454 <__swsetup_r+0x9c>
8001a44c:	0c 9c       	mov	r12,r6
8001a44e:	0e 9b       	mov	r11,r7
8001a450:	fe b0 e8 16 	rcall	8001747c <__smakebuf_r>
8001a454:	8e 69       	ld.sh	r9,r7[0xc]
8001a456:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8001a45a:	c0 70       	breq	8001a468 <__swsetup_r+0xb0>
8001a45c:	30 08       	mov	r8,0
8001a45e:	8f 28       	st.w	r7[0x8],r8
8001a460:	6e 58       	ld.w	r8,r7[0x14]
8001a462:	5c 38       	neg	r8
8001a464:	8f 68       	st.w	r7[0x18],r8
8001a466:	c0 68       	rjmp	8001a472 <__swsetup_r+0xba>
8001a468:	ed b9 00 01 	bld	r9,0x1
8001a46c:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8001a470:	8f 28       	st.w	r7[0x8],r8
8001a472:	6e 48       	ld.w	r8,r7[0x10]
8001a474:	58 08       	cp.w	r8,0
8001a476:	c0 61       	brne	8001a482 <__swsetup_r+0xca>
8001a478:	8e 68       	ld.sh	r8,r7[0xc]
8001a47a:	ed b8 00 07 	bld	r8,0x7
8001a47e:	c0 21       	brne	8001a482 <__swsetup_r+0xca>
8001a480:	dc 2a       	popm	r4-r7,pc,r12=-1
8001a482:	d8 2a       	popm	r4-r7,pc,r12=0
8001a484:	00 00       	add	r0,r0
8001a486:	01 9c       	ld.ub	r12,r0[0x1]
8001a488:	80 07       	ld.sh	r7,r0[0x0]
8001a48a:	0a 2c       	rsub	r12,r5
8001a48c:	80 07       	ld.sh	r7,r0[0x0]
8001a48e:	0a 4c       	or	r12,r5
8001a490:	80 07       	ld.sh	r7,r0[0x0]
8001a492:	0a 6c       	and	r12,r5

8001a494 <_close_r>:
8001a494:	d4 21       	pushm	r4-r7,lr
8001a496:	30 08       	mov	r8,0
8001a498:	18 97       	mov	r7,r12
8001a49a:	48 76       	lddpc	r6,8001a4b4 <_close_r+0x20>
8001a49c:	16 9c       	mov	r12,r11
8001a49e:	8d 08       	st.w	r6[0x0],r8
8001a4a0:	fe b0 ed 7a 	rcall	80017f94 <_close>
8001a4a4:	5b fc       	cp.w	r12,-1
8001a4a6:	c0 51       	brne	8001a4b0 <_close_r+0x1c>
8001a4a8:	6c 08       	ld.w	r8,r6[0x0]
8001a4aa:	58 08       	cp.w	r8,0
8001a4ac:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001a4b0:	d8 22       	popm	r4-r7,pc
8001a4b2:	d7 03       	nop
8001a4b4:	00 00       	add	r0,r0
8001a4b6:	4f 74       	lddpc	r4,8001a690 <_dtoa_r+0xb8>

8001a4b8 <quorem>:
8001a4b8:	d4 31       	pushm	r0-r7,lr
8001a4ba:	20 2d       	sub	sp,8
8001a4bc:	18 97       	mov	r7,r12
8001a4be:	78 48       	ld.w	r8,r12[0x10]
8001a4c0:	76 46       	ld.w	r6,r11[0x10]
8001a4c2:	0c 38       	cp.w	r8,r6
8001a4c4:	c0 34       	brge	8001a4ca <quorem+0x12>
8001a4c6:	30 0c       	mov	r12,0
8001a4c8:	c8 58       	rjmp	8001a5d2 <quorem+0x11a>
8001a4ca:	ec c2 ff fc 	sub	r2,r6,-4
8001a4ce:	f6 c3 ff ec 	sub	r3,r11,-20
8001a4d2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8001a4d6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8001a4da:	2f f9       	sub	r9,-1
8001a4dc:	20 16       	sub	r6,1
8001a4de:	f8 09 0d 08 	divu	r8,r12,r9
8001a4e2:	f6 02 00 22 	add	r2,r11,r2<<0x2
8001a4e6:	ee c4 ff ec 	sub	r4,r7,-20
8001a4ea:	10 95       	mov	r5,r8
8001a4ec:	58 08       	cp.w	r8,0
8001a4ee:	c4 10       	breq	8001a570 <quorem+0xb8>
8001a4f0:	30 09       	mov	r9,0
8001a4f2:	06 9a       	mov	r10,r3
8001a4f4:	08 98       	mov	r8,r4
8001a4f6:	12 91       	mov	r1,r9
8001a4f8:	50 0b       	stdsp	sp[0x0],r11
8001a4fa:	70 0e       	ld.w	lr,r8[0x0]
8001a4fc:	b1 8e       	lsr	lr,0x10
8001a4fe:	50 1e       	stdsp	sp[0x4],lr
8001a500:	15 0e       	ld.w	lr,r10++
8001a502:	fc 00 16 10 	lsr	r0,lr,0x10
8001a506:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001a50a:	ea 0e 03 41 	mac	r1,r5,lr
8001a50e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8001a512:	b1 81       	lsr	r1,0x10
8001a514:	40 1b       	lddsp	r11,sp[0x4]
8001a516:	ea 00 02 40 	mul	r0,r5,r0
8001a51a:	e2 00 00 00 	add	r0,r1,r0
8001a51e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8001a522:	02 1b       	sub	r11,r1
8001a524:	50 1b       	stdsp	sp[0x4],r11
8001a526:	70 0b       	ld.w	r11,r8[0x0]
8001a528:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8001a52c:	02 09       	add	r9,r1
8001a52e:	f2 0e 01 0e 	sub	lr,r9,lr
8001a532:	b0 1e       	st.h	r8[0x2],lr
8001a534:	fc 09 14 10 	asr	r9,lr,0x10
8001a538:	40 1e       	lddsp	lr,sp[0x4]
8001a53a:	fc 09 00 09 	add	r9,lr,r9
8001a53e:	b0 09       	st.h	r8[0x0],r9
8001a540:	e0 01 16 10 	lsr	r1,r0,0x10
8001a544:	2f c8       	sub	r8,-4
8001a546:	b1 49       	asr	r9,0x10
8001a548:	04 3a       	cp.w	r10,r2
8001a54a:	fe 98 ff d8 	brls	8001a4fa <quorem+0x42>
8001a54e:	40 0b       	lddsp	r11,sp[0x0]
8001a550:	58 0c       	cp.w	r12,0
8001a552:	c0 f1       	brne	8001a570 <quorem+0xb8>
8001a554:	ec c8 ff fb 	sub	r8,r6,-5
8001a558:	ee 08 00 28 	add	r8,r7,r8<<0x2
8001a55c:	c0 28       	rjmp	8001a560 <quorem+0xa8>
8001a55e:	20 16       	sub	r6,1
8001a560:	20 48       	sub	r8,4
8001a562:	08 38       	cp.w	r8,r4
8001a564:	e0 88 00 05 	brls	8001a56e <quorem+0xb6>
8001a568:	70 09       	ld.w	r9,r8[0x0]
8001a56a:	58 09       	cp.w	r9,0
8001a56c:	cf 90       	breq	8001a55e <quorem+0xa6>
8001a56e:	8f 46       	st.w	r7[0x10],r6
8001a570:	0e 9c       	mov	r12,r7
8001a572:	e0 a0 08 6c 	rcall	8001b64a <__mcmp>
8001a576:	c2 d5       	brlt	8001a5d0 <quorem+0x118>
8001a578:	2f f5       	sub	r5,-1
8001a57a:	08 98       	mov	r8,r4
8001a57c:	30 09       	mov	r9,0
8001a57e:	07 0b       	ld.w	r11,r3++
8001a580:	f6 0a 16 10 	lsr	r10,r11,0x10
8001a584:	70 0c       	ld.w	r12,r8[0x0]
8001a586:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001a58a:	f8 0e 16 10 	lsr	lr,r12,0x10
8001a58e:	14 1e       	sub	lr,r10
8001a590:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8001a594:	16 1a       	sub	r10,r11
8001a596:	12 0a       	add	r10,r9
8001a598:	b0 1a       	st.h	r8[0x2],r10
8001a59a:	b1 4a       	asr	r10,0x10
8001a59c:	fc 0a 00 09 	add	r9,lr,r10
8001a5a0:	b0 09       	st.h	r8[0x0],r9
8001a5a2:	2f c8       	sub	r8,-4
8001a5a4:	b1 49       	asr	r9,0x10
8001a5a6:	04 33       	cp.w	r3,r2
8001a5a8:	fe 98 ff eb 	brls	8001a57e <quorem+0xc6>
8001a5ac:	ec c8 ff fb 	sub	r8,r6,-5
8001a5b0:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8001a5b4:	58 09       	cp.w	r9,0
8001a5b6:	c0 d1       	brne	8001a5d0 <quorem+0x118>
8001a5b8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8001a5bc:	c0 28       	rjmp	8001a5c0 <quorem+0x108>
8001a5be:	20 16       	sub	r6,1
8001a5c0:	20 48       	sub	r8,4
8001a5c2:	08 38       	cp.w	r8,r4
8001a5c4:	e0 88 00 05 	brls	8001a5ce <quorem+0x116>
8001a5c8:	70 09       	ld.w	r9,r8[0x0]
8001a5ca:	58 09       	cp.w	r9,0
8001a5cc:	cf 90       	breq	8001a5be <quorem+0x106>
8001a5ce:	8f 46       	st.w	r7[0x10],r6
8001a5d0:	0a 9c       	mov	r12,r5
8001a5d2:	2f ed       	sub	sp,-8
8001a5d4:	d8 32       	popm	r0-r7,pc
8001a5d6:	d7 03       	nop

8001a5d8 <_dtoa_r>:
8001a5d8:	d4 31       	pushm	r0-r7,lr
8001a5da:	21 ad       	sub	sp,104
8001a5dc:	fa c4 ff 74 	sub	r4,sp,-140
8001a5e0:	18 97       	mov	r7,r12
8001a5e2:	16 95       	mov	r5,r11
8001a5e4:	68 2c       	ld.w	r12,r4[0x8]
8001a5e6:	50 c9       	stdsp	sp[0x30],r9
8001a5e8:	68 16       	ld.w	r6,r4[0x4]
8001a5ea:	68 09       	ld.w	r9,r4[0x0]
8001a5ec:	50 e8       	stdsp	sp[0x38],r8
8001a5ee:	14 94       	mov	r4,r10
8001a5f0:	51 2c       	stdsp	sp[0x48],r12
8001a5f2:	fa e5 00 08 	st.d	sp[8],r4
8001a5f6:	51 59       	stdsp	sp[0x54],r9
8001a5f8:	6e 95       	ld.w	r5,r7[0x24]
8001a5fa:	58 05       	cp.w	r5,0
8001a5fc:	c0 91       	brne	8001a60e <_dtoa_r+0x36>
8001a5fe:	31 0c       	mov	r12,16
8001a600:	e0 a0 07 7a 	rcall	8001b4f4 <malloc>
8001a604:	99 35       	st.w	r12[0xc],r5
8001a606:	8f 9c       	st.w	r7[0x24],r12
8001a608:	99 15       	st.w	r12[0x4],r5
8001a60a:	99 25       	st.w	r12[0x8],r5
8001a60c:	99 05       	st.w	r12[0x0],r5
8001a60e:	6e 99       	ld.w	r9,r7[0x24]
8001a610:	72 08       	ld.w	r8,r9[0x0]
8001a612:	58 08       	cp.w	r8,0
8001a614:	c0 f0       	breq	8001a632 <_dtoa_r+0x5a>
8001a616:	72 1a       	ld.w	r10,r9[0x4]
8001a618:	91 1a       	st.w	r8[0x4],r10
8001a61a:	30 1a       	mov	r10,1
8001a61c:	72 19       	ld.w	r9,r9[0x4]
8001a61e:	f4 09 09 49 	lsl	r9,r10,r9
8001a622:	10 9b       	mov	r11,r8
8001a624:	91 29       	st.w	r8[0x8],r9
8001a626:	0e 9c       	mov	r12,r7
8001a628:	e0 a0 08 2a 	rcall	8001b67c <_Bfree>
8001a62c:	6e 98       	ld.w	r8,r7[0x24]
8001a62e:	30 09       	mov	r9,0
8001a630:	91 09       	st.w	r8[0x0],r9
8001a632:	40 28       	lddsp	r8,sp[0x8]
8001a634:	10 94       	mov	r4,r8
8001a636:	58 08       	cp.w	r8,0
8001a638:	c0 64       	brge	8001a644 <_dtoa_r+0x6c>
8001a63a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8001a63e:	50 28       	stdsp	sp[0x8],r8
8001a640:	30 18       	mov	r8,1
8001a642:	c0 28       	rjmp	8001a646 <_dtoa_r+0x6e>
8001a644:	30 08       	mov	r8,0
8001a646:	8d 08       	st.w	r6[0x0],r8
8001a648:	fc 1c 7f f0 	movh	r12,0x7ff0
8001a64c:	40 26       	lddsp	r6,sp[0x8]
8001a64e:	0c 98       	mov	r8,r6
8001a650:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001a654:	18 38       	cp.w	r8,r12
8001a656:	c1 e1       	brne	8001a692 <_dtoa_r+0xba>
8001a658:	e0 68 27 0f 	mov	r8,9999
8001a65c:	41 5b       	lddsp	r11,sp[0x54]
8001a65e:	97 08       	st.w	r11[0x0],r8
8001a660:	40 3a       	lddsp	r10,sp[0xc]
8001a662:	58 0a       	cp.w	r10,0
8001a664:	c0 61       	brne	8001a670 <_dtoa_r+0x98>
8001a666:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8001a66a:	c0 31       	brne	8001a670 <_dtoa_r+0x98>
8001a66c:	4a cc       	lddpc	r12,8001a71c <_dtoa_r+0x144>
8001a66e:	c0 28       	rjmp	8001a672 <_dtoa_r+0x9a>
8001a670:	4a cc       	lddpc	r12,8001a720 <_dtoa_r+0x148>
8001a672:	41 29       	lddsp	r9,sp[0x48]
8001a674:	58 09       	cp.w	r9,0
8001a676:	e0 80 05 9e 	breq	8001b1b2 <_dtoa_r+0xbda>
8001a67a:	f8 c8 ff fd 	sub	r8,r12,-3
8001a67e:	f8 c9 ff f8 	sub	r9,r12,-8
8001a682:	11 8b       	ld.ub	r11,r8[0x0]
8001a684:	30 0a       	mov	r10,0
8001a686:	41 25       	lddsp	r5,sp[0x48]
8001a688:	f4 0b 18 00 	cp.b	r11,r10
8001a68c:	f2 08 17 10 	movne	r8,r9
8001a690:	c1 58       	rjmp	8001a6ba <_dtoa_r+0xe2>
8001a692:	fa ea 00 08 	ld.d	r10,sp[8]
8001a696:	30 08       	mov	r8,0
8001a698:	fa eb 00 3c 	st.d	sp[60],r10
8001a69c:	30 09       	mov	r9,0
8001a69e:	e0 a0 0e d8 	rcall	8001c44e <__avr32_f64_cmp_eq>
8001a6a2:	c0 f0       	breq	8001a6c0 <_dtoa_r+0xe8>
8001a6a4:	30 18       	mov	r8,1
8001a6a6:	41 5a       	lddsp	r10,sp[0x54]
8001a6a8:	95 08       	st.w	r10[0x0],r8
8001a6aa:	49 fc       	lddpc	r12,8001a724 <_dtoa_r+0x14c>
8001a6ac:	41 29       	lddsp	r9,sp[0x48]
8001a6ae:	f8 08 00 08 	add	r8,r12,r8
8001a6b2:	58 09       	cp.w	r9,0
8001a6b4:	e0 80 05 7f 	breq	8001b1b2 <_dtoa_r+0xbda>
8001a6b8:	12 95       	mov	r5,r9
8001a6ba:	8b 08       	st.w	r5[0x0],r8
8001a6bc:	e0 8f 05 7b 	bral	8001b1b2 <_dtoa_r+0xbda>
8001a6c0:	fa c8 ff 9c 	sub	r8,sp,-100
8001a6c4:	fa c9 ff a0 	sub	r9,sp,-96
8001a6c8:	fa ea 00 3c 	ld.d	r10,sp[60]
8001a6cc:	0e 9c       	mov	r12,r7
8001a6ce:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8001a6d2:	e0 a0 08 23 	rcall	8001b718 <__d2b>
8001a6d6:	18 93       	mov	r3,r12
8001a6d8:	58 05       	cp.w	r5,0
8001a6da:	c0 d0       	breq	8001a6f4 <_dtoa_r+0x11c>
8001a6dc:	fa ea 00 3c 	ld.d	r10,sp[60]
8001a6e0:	30 04       	mov	r4,0
8001a6e2:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8001a6e6:	ea c5 03 ff 	sub	r5,r5,1023
8001a6ea:	10 9b       	mov	r11,r8
8001a6ec:	51 74       	stdsp	sp[0x5c],r4
8001a6ee:	ea 1b 3f f0 	orh	r11,0x3ff0
8001a6f2:	c2 a8       	rjmp	8001a746 <_dtoa_r+0x16e>
8001a6f4:	41 88       	lddsp	r8,sp[0x60]
8001a6f6:	41 9c       	lddsp	r12,sp[0x64]
8001a6f8:	10 0c       	add	r12,r8
8001a6fa:	f8 c5 fb ce 	sub	r5,r12,-1074
8001a6fe:	e0 45 00 20 	cp.w	r5,32
8001a702:	e0 8a 00 13 	brle	8001a728 <_dtoa_r+0x150>
8001a706:	f8 cc fb ee 	sub	r12,r12,-1042
8001a70a:	40 3b       	lddsp	r11,sp[0xc]
8001a70c:	ea 08 11 40 	rsub	r8,r5,64
8001a710:	f6 0c 0a 4c 	lsr	r12,r11,r12
8001a714:	ec 08 09 46 	lsl	r6,r6,r8
8001a718:	0c 4c       	or	r12,r6
8001a71a:	c0 c8       	rjmp	8001a732 <_dtoa_r+0x15a>
8001a71c:	80 07       	ld.sh	r7,r0[0x0]
8001a71e:	0e 60       	and	r0,r7
8001a720:	80 07       	ld.sh	r7,r0[0x0]
8001a722:	0e 6c       	and	r12,r7
8001a724:	80 06       	ld.sh	r6,r0[0x0]
8001a726:	d2 e0       	acall	0xb8
8001a728:	ea 0c 11 20 	rsub	r12,r5,32
8001a72c:	40 3a       	lddsp	r10,sp[0xc]
8001a72e:	f4 0c 09 4c 	lsl	r12,r10,r12
8001a732:	e0 a0 0e 1a 	rcall	8001c366 <__avr32_u32_to_f64>
8001a736:	fc 18 fe 10 	movh	r8,0xfe10
8001a73a:	30 19       	mov	r9,1
8001a73c:	ea c5 04 33 	sub	r5,r5,1075
8001a740:	f0 0b 00 0b 	add	r11,r8,r11
8001a744:	51 79       	stdsp	sp[0x5c],r9
8001a746:	30 08       	mov	r8,0
8001a748:	fc 19 3f f8 	movh	r9,0x3ff8
8001a74c:	e0 a0 0c a2 	rcall	8001c090 <__avr32_f64_sub>
8001a750:	e0 68 43 61 	mov	r8,17249
8001a754:	ea 18 63 6f 	orh	r8,0x636f
8001a758:	e0 69 87 a7 	mov	r9,34727
8001a75c:	ea 19 3f d2 	orh	r9,0x3fd2
8001a760:	e0 a0 0b ac 	rcall	8001beb8 <__avr32_f64_mul>
8001a764:	e0 68 c8 b3 	mov	r8,51379
8001a768:	ea 18 8b 60 	orh	r8,0x8b60
8001a76c:	e0 69 8a 28 	mov	r9,35368
8001a770:	ea 19 3f c6 	orh	r9,0x3fc6
8001a774:	e0 a0 0d 5c 	rcall	8001c22c <__avr32_f64_add>
8001a778:	0a 9c       	mov	r12,r5
8001a77a:	14 90       	mov	r0,r10
8001a77c:	16 91       	mov	r1,r11
8001a77e:	e0 a0 0d f8 	rcall	8001c36e <__avr32_s32_to_f64>
8001a782:	e0 68 79 fb 	mov	r8,31227
8001a786:	ea 18 50 9f 	orh	r8,0x509f
8001a78a:	e0 69 44 13 	mov	r9,17427
8001a78e:	ea 19 3f d3 	orh	r9,0x3fd3
8001a792:	e0 a0 0b 93 	rcall	8001beb8 <__avr32_f64_mul>
8001a796:	14 98       	mov	r8,r10
8001a798:	16 99       	mov	r9,r11
8001a79a:	00 9a       	mov	r10,r0
8001a79c:	02 9b       	mov	r11,r1
8001a79e:	e0 a0 0d 47 	rcall	8001c22c <__avr32_f64_add>
8001a7a2:	14 90       	mov	r0,r10
8001a7a4:	16 91       	mov	r1,r11
8001a7a6:	e0 a0 0d cd 	rcall	8001c340 <__avr32_f64_to_s32>
8001a7aa:	30 08       	mov	r8,0
8001a7ac:	18 96       	mov	r6,r12
8001a7ae:	30 09       	mov	r9,0
8001a7b0:	00 9a       	mov	r10,r0
8001a7b2:	02 9b       	mov	r11,r1
8001a7b4:	e0 a0 0e 94 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001a7b8:	c0 c0       	breq	8001a7d0 <_dtoa_r+0x1f8>
8001a7ba:	0c 9c       	mov	r12,r6
8001a7bc:	e0 a0 0d d9 	rcall	8001c36e <__avr32_s32_to_f64>
8001a7c0:	14 98       	mov	r8,r10
8001a7c2:	16 99       	mov	r9,r11
8001a7c4:	00 9a       	mov	r10,r0
8001a7c6:	02 9b       	mov	r11,r1
8001a7c8:	e0 a0 0e 43 	rcall	8001c44e <__avr32_f64_cmp_eq>
8001a7cc:	f7 b6 00 01 	subeq	r6,1
8001a7d0:	59 66       	cp.w	r6,22
8001a7d2:	e0 88 00 05 	brls	8001a7dc <_dtoa_r+0x204>
8001a7d6:	30 18       	mov	r8,1
8001a7d8:	51 48       	stdsp	sp[0x50],r8
8001a7da:	c1 28       	rjmp	8001a7fe <_dtoa_r+0x226>
8001a7dc:	4c 08       	lddpc	r8,8001a8dc <_dtoa_r+0x304>
8001a7de:	fa ea 00 3c 	ld.d	r10,sp[60]
8001a7e2:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8001a7e6:	e0 a0 0e 7b 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001a7ea:	f9 b4 00 00 	moveq	r4,0
8001a7ee:	fb f4 0a 14 	st.weq	sp[0x50],r4
8001a7f2:	f7 b6 01 01 	subne	r6,1
8001a7f6:	f9 bc 01 00 	movne	r12,0
8001a7fa:	fb fc 1a 14 	st.wne	sp[0x50],r12
8001a7fe:	41 90       	lddsp	r0,sp[0x64]
8001a800:	20 10       	sub	r0,1
8001a802:	0a 10       	sub	r0,r5
8001a804:	c0 46       	brmi	8001a80c <_dtoa_r+0x234>
8001a806:	50 40       	stdsp	sp[0x10],r0
8001a808:	30 00       	mov	r0,0
8001a80a:	c0 48       	rjmp	8001a812 <_dtoa_r+0x23a>
8001a80c:	30 0b       	mov	r11,0
8001a80e:	5c 30       	neg	r0
8001a810:	50 4b       	stdsp	sp[0x10],r11
8001a812:	ec 02 11 00 	rsub	r2,r6,0
8001a816:	58 06       	cp.w	r6,0
8001a818:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8001a81c:	f5 d6 e4 0a 	addge	r10,r10,r6
8001a820:	fb fa 4a 04 	st.wge	sp[0x10],r10
8001a824:	fb f6 4a 11 	st.wge	sp[0x44],r6
8001a828:	f9 b2 04 00 	movge	r2,0
8001a82c:	e1 d6 e5 10 	sublt	r0,r0,r6
8001a830:	f9 b9 05 00 	movlt	r9,0
8001a834:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8001a838:	40 c8       	lddsp	r8,sp[0x30]
8001a83a:	58 98       	cp.w	r8,9
8001a83c:	e0 8b 00 20 	brhi	8001a87c <_dtoa_r+0x2a4>
8001a840:	58 58       	cp.w	r8,5
8001a842:	f9 b4 0a 01 	movle	r4,1
8001a846:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8001a84a:	f7 b5 09 04 	subgt	r5,4
8001a84e:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8001a852:	f9 b4 09 00 	movgt	r4,0
8001a856:	40 cc       	lddsp	r12,sp[0x30]
8001a858:	58 3c       	cp.w	r12,3
8001a85a:	c2 d0       	breq	8001a8b4 <_dtoa_r+0x2dc>
8001a85c:	e0 89 00 05 	brgt	8001a866 <_dtoa_r+0x28e>
8001a860:	58 2c       	cp.w	r12,2
8001a862:	c1 01       	brne	8001a882 <_dtoa_r+0x2aa>
8001a864:	c1 88       	rjmp	8001a894 <_dtoa_r+0x2bc>
8001a866:	40 cb       	lddsp	r11,sp[0x30]
8001a868:	58 4b       	cp.w	r11,4
8001a86a:	c0 60       	breq	8001a876 <_dtoa_r+0x29e>
8001a86c:	58 5b       	cp.w	r11,5
8001a86e:	c0 a1       	brne	8001a882 <_dtoa_r+0x2aa>
8001a870:	30 1a       	mov	r10,1
8001a872:	50 da       	stdsp	sp[0x34],r10
8001a874:	c2 28       	rjmp	8001a8b8 <_dtoa_r+0x2e0>
8001a876:	30 19       	mov	r9,1
8001a878:	50 d9       	stdsp	sp[0x34],r9
8001a87a:	c0 f8       	rjmp	8001a898 <_dtoa_r+0x2c0>
8001a87c:	30 08       	mov	r8,0
8001a87e:	30 14       	mov	r4,1
8001a880:	50 c8       	stdsp	sp[0x30],r8
8001a882:	3f f5       	mov	r5,-1
8001a884:	30 1c       	mov	r12,1
8001a886:	30 0b       	mov	r11,0
8001a888:	50 95       	stdsp	sp[0x24],r5
8001a88a:	50 dc       	stdsp	sp[0x34],r12
8001a88c:	0a 91       	mov	r1,r5
8001a88e:	31 28       	mov	r8,18
8001a890:	50 eb       	stdsp	sp[0x38],r11
8001a892:	c2 08       	rjmp	8001a8d2 <_dtoa_r+0x2fa>
8001a894:	30 0a       	mov	r10,0
8001a896:	50 da       	stdsp	sp[0x34],r10
8001a898:	40 e9       	lddsp	r9,sp[0x38]
8001a89a:	58 09       	cp.w	r9,0
8001a89c:	e0 89 00 07 	brgt	8001a8aa <_dtoa_r+0x2d2>
8001a8a0:	30 18       	mov	r8,1
8001a8a2:	50 98       	stdsp	sp[0x24],r8
8001a8a4:	10 91       	mov	r1,r8
8001a8a6:	50 e8       	stdsp	sp[0x38],r8
8001a8a8:	c1 58       	rjmp	8001a8d2 <_dtoa_r+0x2fa>
8001a8aa:	40 e5       	lddsp	r5,sp[0x38]
8001a8ac:	50 95       	stdsp	sp[0x24],r5
8001a8ae:	0a 91       	mov	r1,r5
8001a8b0:	0a 98       	mov	r8,r5
8001a8b2:	c1 08       	rjmp	8001a8d2 <_dtoa_r+0x2fa>
8001a8b4:	30 0c       	mov	r12,0
8001a8b6:	50 dc       	stdsp	sp[0x34],r12
8001a8b8:	40 eb       	lddsp	r11,sp[0x38]
8001a8ba:	ec 0b 00 0b 	add	r11,r6,r11
8001a8be:	50 9b       	stdsp	sp[0x24],r11
8001a8c0:	16 98       	mov	r8,r11
8001a8c2:	2f f8       	sub	r8,-1
8001a8c4:	58 08       	cp.w	r8,0
8001a8c6:	e0 89 00 05 	brgt	8001a8d0 <_dtoa_r+0x2f8>
8001a8ca:	10 91       	mov	r1,r8
8001a8cc:	30 18       	mov	r8,1
8001a8ce:	c0 28       	rjmp	8001a8d2 <_dtoa_r+0x2fa>
8001a8d0:	10 91       	mov	r1,r8
8001a8d2:	30 09       	mov	r9,0
8001a8d4:	6e 9a       	ld.w	r10,r7[0x24]
8001a8d6:	95 19       	st.w	r10[0x4],r9
8001a8d8:	30 49       	mov	r9,4
8001a8da:	c0 78       	rjmp	8001a8e8 <_dtoa_r+0x310>
8001a8dc:	80 07       	ld.sh	r7,r0[0x0]
8001a8de:	0e b8       	st.h	r7++,r8
8001a8e0:	6a 1a       	ld.w	r10,r5[0x4]
8001a8e2:	a1 79       	lsl	r9,0x1
8001a8e4:	2f fa       	sub	r10,-1
8001a8e6:	8b 1a       	st.w	r5[0x4],r10
8001a8e8:	6e 95       	ld.w	r5,r7[0x24]
8001a8ea:	f2 ca ff ec 	sub	r10,r9,-20
8001a8ee:	10 3a       	cp.w	r10,r8
8001a8f0:	fe 98 ff f8 	brls	8001a8e0 <_dtoa_r+0x308>
8001a8f4:	6a 1b       	ld.w	r11,r5[0x4]
8001a8f6:	0e 9c       	mov	r12,r7
8001a8f8:	e0 a0 06 da 	rcall	8001b6ac <_Balloc>
8001a8fc:	58 e1       	cp.w	r1,14
8001a8fe:	5f 88       	srls	r8
8001a900:	8b 0c       	st.w	r5[0x0],r12
8001a902:	f1 e4 00 04 	and	r4,r8,r4
8001a906:	6e 98       	ld.w	r8,r7[0x24]
8001a908:	70 08       	ld.w	r8,r8[0x0]
8001a90a:	50 88       	stdsp	sp[0x20],r8
8001a90c:	e0 80 01 82 	breq	8001ac10 <_dtoa_r+0x638>
8001a910:	58 06       	cp.w	r6,0
8001a912:	e0 8a 00 40 	brle	8001a992 <_dtoa_r+0x3ba>
8001a916:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8001a91a:	4c b8       	lddpc	r8,8001aa44 <_dtoa_r+0x46c>
8001a91c:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8001a920:	fa e5 00 18 	st.d	sp[24],r4
8001a924:	ec 04 14 04 	asr	r4,r6,0x4
8001a928:	ed b4 00 04 	bld	r4,0x4
8001a92c:	c0 30       	breq	8001a932 <_dtoa_r+0x35a>
8001a92e:	30 25       	mov	r5,2
8001a930:	c0 f8       	rjmp	8001a94e <_dtoa_r+0x376>
8001a932:	4c 68       	lddpc	r8,8001aa48 <_dtoa_r+0x470>
8001a934:	f0 e8 00 20 	ld.d	r8,r8[32]
8001a938:	fa ea 00 3c 	ld.d	r10,sp[60]
8001a93c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8001a940:	e0 a0 0e 02 	rcall	8001c544 <__avr32_f64_div>
8001a944:	30 35       	mov	r5,3
8001a946:	14 98       	mov	r8,r10
8001a948:	16 99       	mov	r9,r11
8001a94a:	fa e9 00 08 	st.d	sp[8],r8
8001a94e:	4b fc       	lddpc	r12,8001aa48 <_dtoa_r+0x470>
8001a950:	50 a3       	stdsp	sp[0x28],r3
8001a952:	0c 93       	mov	r3,r6
8001a954:	18 96       	mov	r6,r12
8001a956:	c0 f8       	rjmp	8001a974 <_dtoa_r+0x39c>
8001a958:	fa ea 00 18 	ld.d	r10,sp[24]
8001a95c:	ed b4 00 00 	bld	r4,0x0
8001a960:	c0 81       	brne	8001a970 <_dtoa_r+0x398>
8001a962:	ec e8 00 00 	ld.d	r8,r6[0]
8001a966:	2f f5       	sub	r5,-1
8001a968:	e0 a0 0a a8 	rcall	8001beb8 <__avr32_f64_mul>
8001a96c:	fa eb 00 18 	st.d	sp[24],r10
8001a970:	a1 54       	asr	r4,0x1
8001a972:	2f 86       	sub	r6,-8
8001a974:	58 04       	cp.w	r4,0
8001a976:	cf 11       	brne	8001a958 <_dtoa_r+0x380>
8001a978:	fa e8 00 18 	ld.d	r8,sp[24]
8001a97c:	fa ea 00 08 	ld.d	r10,sp[8]
8001a980:	06 96       	mov	r6,r3
8001a982:	e0 a0 0d e1 	rcall	8001c544 <__avr32_f64_div>
8001a986:	40 a3       	lddsp	r3,sp[0x28]
8001a988:	14 98       	mov	r8,r10
8001a98a:	16 99       	mov	r9,r11
8001a98c:	fa e9 00 08 	st.d	sp[8],r8
8001a990:	c2 d8       	rjmp	8001a9ea <_dtoa_r+0x412>
8001a992:	ec 08 11 00 	rsub	r8,r6,0
8001a996:	c0 31       	brne	8001a99c <_dtoa_r+0x3c4>
8001a998:	30 25       	mov	r5,2
8001a99a:	c2 88       	rjmp	8001a9ea <_dtoa_r+0x412>
8001a99c:	4a bc       	lddpc	r12,8001aa48 <_dtoa_r+0x470>
8001a99e:	f0 04 14 04 	asr	r4,r8,0x4
8001a9a2:	50 1c       	stdsp	sp[0x4],r12
8001a9a4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8001a9a8:	4a 79       	lddpc	r9,8001aa44 <_dtoa_r+0x46c>
8001a9aa:	fa ea 00 3c 	ld.d	r10,sp[60]
8001a9ae:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8001a9b2:	e0 a0 0a 83 	rcall	8001beb8 <__avr32_f64_mul>
8001a9b6:	40 1c       	lddsp	r12,sp[0x4]
8001a9b8:	50 63       	stdsp	sp[0x18],r3
8001a9ba:	30 25       	mov	r5,2
8001a9bc:	0c 93       	mov	r3,r6
8001a9be:	fa eb 00 08 	st.d	sp[8],r10
8001a9c2:	18 96       	mov	r6,r12
8001a9c4:	c0 f8       	rjmp	8001a9e2 <_dtoa_r+0x40a>
8001a9c6:	fa ea 00 08 	ld.d	r10,sp[8]
8001a9ca:	ed b4 00 00 	bld	r4,0x0
8001a9ce:	c0 81       	brne	8001a9de <_dtoa_r+0x406>
8001a9d0:	ec e8 00 00 	ld.d	r8,r6[0]
8001a9d4:	2f f5       	sub	r5,-1
8001a9d6:	e0 a0 0a 71 	rcall	8001beb8 <__avr32_f64_mul>
8001a9da:	fa eb 00 08 	st.d	sp[8],r10
8001a9de:	a1 54       	asr	r4,0x1
8001a9e0:	2f 86       	sub	r6,-8
8001a9e2:	58 04       	cp.w	r4,0
8001a9e4:	cf 11       	brne	8001a9c6 <_dtoa_r+0x3ee>
8001a9e6:	06 96       	mov	r6,r3
8001a9e8:	40 63       	lddsp	r3,sp[0x18]
8001a9ea:	41 4a       	lddsp	r10,sp[0x50]
8001a9ec:	58 0a       	cp.w	r10,0
8001a9ee:	c2 f0       	breq	8001aa4c <_dtoa_r+0x474>
8001a9f0:	fa e8 00 08 	ld.d	r8,sp[8]
8001a9f4:	58 01       	cp.w	r1,0
8001a9f6:	5f 94       	srgt	r4
8001a9f8:	fa e9 00 18 	st.d	sp[24],r8
8001a9fc:	30 08       	mov	r8,0
8001a9fe:	fc 19 3f f0 	movh	r9,0x3ff0
8001aa02:	fa ea 00 18 	ld.d	r10,sp[24]
8001aa06:	e0 a0 0d 6b 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001aa0a:	f9 bc 00 00 	moveq	r12,0
8001aa0e:	f9 bc 01 01 	movne	r12,1
8001aa12:	e9 ec 00 0c 	and	r12,r4,r12
8001aa16:	c1 b0       	breq	8001aa4c <_dtoa_r+0x474>
8001aa18:	40 98       	lddsp	r8,sp[0x24]
8001aa1a:	58 08       	cp.w	r8,0
8001aa1c:	e0 8a 00 f6 	brle	8001ac08 <_dtoa_r+0x630>
8001aa20:	30 08       	mov	r8,0
8001aa22:	fc 19 40 24 	movh	r9,0x4024
8001aa26:	ec c4 00 01 	sub	r4,r6,1
8001aa2a:	fa ea 00 18 	ld.d	r10,sp[24]
8001aa2e:	2f f5       	sub	r5,-1
8001aa30:	50 64       	stdsp	sp[0x18],r4
8001aa32:	e0 a0 0a 43 	rcall	8001beb8 <__avr32_f64_mul>
8001aa36:	40 94       	lddsp	r4,sp[0x24]
8001aa38:	14 98       	mov	r8,r10
8001aa3a:	16 99       	mov	r9,r11
8001aa3c:	fa e9 00 08 	st.d	sp[8],r8
8001aa40:	c0 88       	rjmp	8001aa50 <_dtoa_r+0x478>
8001aa42:	d7 03       	nop
8001aa44:	80 07       	ld.sh	r7,r0[0x0]
8001aa46:	0e b8       	st.h	r7++,r8
8001aa48:	80 07       	ld.sh	r7,r0[0x0]
8001aa4a:	0f 80       	ld.ub	r0,r7[0x0]
8001aa4c:	50 66       	stdsp	sp[0x18],r6
8001aa4e:	02 94       	mov	r4,r1
8001aa50:	0a 9c       	mov	r12,r5
8001aa52:	e0 a0 0c 8e 	rcall	8001c36e <__avr32_s32_to_f64>
8001aa56:	fa e8 00 08 	ld.d	r8,sp[8]
8001aa5a:	e0 a0 0a 2f 	rcall	8001beb8 <__avr32_f64_mul>
8001aa5e:	30 08       	mov	r8,0
8001aa60:	fc 19 40 1c 	movh	r9,0x401c
8001aa64:	e0 a0 0b e4 	rcall	8001c22c <__avr32_f64_add>
8001aa68:	14 98       	mov	r8,r10
8001aa6a:	16 99       	mov	r9,r11
8001aa6c:	fa e9 00 28 	st.d	sp[40],r8
8001aa70:	fc 18 fc c0 	movh	r8,0xfcc0
8001aa74:	40 a5       	lddsp	r5,sp[0x28]
8001aa76:	10 05       	add	r5,r8
8001aa78:	50 a5       	stdsp	sp[0x28],r5
8001aa7a:	58 04       	cp.w	r4,0
8001aa7c:	c2 11       	brne	8001aabe <_dtoa_r+0x4e6>
8001aa7e:	fa ea 00 08 	ld.d	r10,sp[8]
8001aa82:	30 08       	mov	r8,0
8001aa84:	fc 19 40 14 	movh	r9,0x4014
8001aa88:	e0 a0 0b 04 	rcall	8001c090 <__avr32_f64_sub>
8001aa8c:	40 bc       	lddsp	r12,sp[0x2c]
8001aa8e:	fa eb 00 08 	st.d	sp[8],r10
8001aa92:	14 98       	mov	r8,r10
8001aa94:	16 99       	mov	r9,r11
8001aa96:	18 9a       	mov	r10,r12
8001aa98:	0a 9b       	mov	r11,r5
8001aa9a:	e0 a0 0d 21 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001aa9e:	e0 81 02 54 	brne	8001af46 <_dtoa_r+0x96e>
8001aaa2:	0a 98       	mov	r8,r5
8001aaa4:	40 b9       	lddsp	r9,sp[0x2c]
8001aaa6:	ee 18 80 00 	eorh	r8,0x8000
8001aaaa:	fa ea 00 08 	ld.d	r10,sp[8]
8001aaae:	10 95       	mov	r5,r8
8001aab0:	12 98       	mov	r8,r9
8001aab2:	0a 99       	mov	r9,r5
8001aab4:	e0 a0 0d 14 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001aab8:	e0 81 02 3e 	brne	8001af34 <_dtoa_r+0x95c>
8001aabc:	ca 68       	rjmp	8001ac08 <_dtoa_r+0x630>
8001aabe:	4c e9       	lddpc	r9,8001abf4 <_dtoa_r+0x61c>
8001aac0:	e8 c8 00 01 	sub	r8,r4,1
8001aac4:	40 d5       	lddsp	r5,sp[0x34]
8001aac6:	58 05       	cp.w	r5,0
8001aac8:	c4 f0       	breq	8001ab66 <_dtoa_r+0x58e>
8001aaca:	30 0c       	mov	r12,0
8001aacc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8001aad0:	51 3c       	stdsp	sp[0x4c],r12
8001aad2:	30 0a       	mov	r10,0
8001aad4:	fc 1b 3f e0 	movh	r11,0x3fe0
8001aad8:	e0 a0 0d 36 	rcall	8001c544 <__avr32_f64_div>
8001aadc:	fa e8 00 28 	ld.d	r8,sp[40]
8001aae0:	40 85       	lddsp	r5,sp[0x20]
8001aae2:	e0 a0 0a d7 	rcall	8001c090 <__avr32_f64_sub>
8001aae6:	fa eb 00 28 	st.d	sp[40],r10
8001aaea:	fa ea 00 08 	ld.d	r10,sp[8]
8001aaee:	e0 a0 0c 29 	rcall	8001c340 <__avr32_f64_to_s32>
8001aaf2:	51 6c       	stdsp	sp[0x58],r12
8001aaf4:	e0 a0 0c 3d 	rcall	8001c36e <__avr32_s32_to_f64>
8001aaf8:	14 98       	mov	r8,r10
8001aafa:	16 99       	mov	r9,r11
8001aafc:	fa ea 00 08 	ld.d	r10,sp[8]
8001ab00:	e0 a0 0a c8 	rcall	8001c090 <__avr32_f64_sub>
8001ab04:	fa eb 00 08 	st.d	sp[8],r10
8001ab08:	41 68       	lddsp	r8,sp[0x58]
8001ab0a:	2d 08       	sub	r8,-48
8001ab0c:	0a c8       	st.b	r5++,r8
8001ab0e:	41 39       	lddsp	r9,sp[0x4c]
8001ab10:	2f f9       	sub	r9,-1
8001ab12:	51 39       	stdsp	sp[0x4c],r9
8001ab14:	fa e8 00 28 	ld.d	r8,sp[40]
8001ab18:	e0 a0 0c e2 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001ab1c:	e0 81 03 3a 	brne	8001b190 <_dtoa_r+0xbb8>
8001ab20:	fa e8 00 08 	ld.d	r8,sp[8]
8001ab24:	30 0a       	mov	r10,0
8001ab26:	fc 1b 3f f0 	movh	r11,0x3ff0
8001ab2a:	e0 a0 0a b3 	rcall	8001c090 <__avr32_f64_sub>
8001ab2e:	fa e8 00 28 	ld.d	r8,sp[40]
8001ab32:	e0 a0 0c d5 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001ab36:	fa ea 00 28 	ld.d	r10,sp[40]
8001ab3a:	30 08       	mov	r8,0
8001ab3c:	fc 19 40 24 	movh	r9,0x4024
8001ab40:	e0 81 00 da 	brne	8001acf4 <_dtoa_r+0x71c>
8001ab44:	41 3c       	lddsp	r12,sp[0x4c]
8001ab46:	08 3c       	cp.w	r12,r4
8001ab48:	c6 04       	brge	8001ac08 <_dtoa_r+0x630>
8001ab4a:	e0 a0 09 b7 	rcall	8001beb8 <__avr32_f64_mul>
8001ab4e:	30 08       	mov	r8,0
8001ab50:	fa eb 00 28 	st.d	sp[40],r10
8001ab54:	fc 19 40 24 	movh	r9,0x4024
8001ab58:	fa ea 00 08 	ld.d	r10,sp[8]
8001ab5c:	e0 a0 09 ae 	rcall	8001beb8 <__avr32_f64_mul>
8001ab60:	fa eb 00 08 	st.d	sp[8],r10
8001ab64:	cc 3b       	rjmp	8001aaea <_dtoa_r+0x512>
8001ab66:	40 85       	lddsp	r5,sp[0x20]
8001ab68:	08 05       	add	r5,r4
8001ab6a:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8001ab6e:	51 35       	stdsp	sp[0x4c],r5
8001ab70:	fa e8 00 28 	ld.d	r8,sp[40]
8001ab74:	40 85       	lddsp	r5,sp[0x20]
8001ab76:	e0 a0 09 a1 	rcall	8001beb8 <__avr32_f64_mul>
8001ab7a:	fa eb 00 28 	st.d	sp[40],r10
8001ab7e:	fa ea 00 08 	ld.d	r10,sp[8]
8001ab82:	e0 a0 0b df 	rcall	8001c340 <__avr32_f64_to_s32>
8001ab86:	51 6c       	stdsp	sp[0x58],r12
8001ab88:	e0 a0 0b f3 	rcall	8001c36e <__avr32_s32_to_f64>
8001ab8c:	14 98       	mov	r8,r10
8001ab8e:	16 99       	mov	r9,r11
8001ab90:	fa ea 00 08 	ld.d	r10,sp[8]
8001ab94:	e0 a0 0a 7e 	rcall	8001c090 <__avr32_f64_sub>
8001ab98:	fa eb 00 08 	st.d	sp[8],r10
8001ab9c:	41 68       	lddsp	r8,sp[0x58]
8001ab9e:	2d 08       	sub	r8,-48
8001aba0:	0a c8       	st.b	r5++,r8
8001aba2:	41 3c       	lddsp	r12,sp[0x4c]
8001aba4:	18 35       	cp.w	r5,r12
8001aba6:	c2 91       	brne	8001abf8 <_dtoa_r+0x620>
8001aba8:	30 08       	mov	r8,0
8001abaa:	fc 19 3f e0 	movh	r9,0x3fe0
8001abae:	fa ea 00 28 	ld.d	r10,sp[40]
8001abb2:	e0 a0 0b 3d 	rcall	8001c22c <__avr32_f64_add>
8001abb6:	40 85       	lddsp	r5,sp[0x20]
8001abb8:	fa e8 00 08 	ld.d	r8,sp[8]
8001abbc:	08 05       	add	r5,r4
8001abbe:	e0 a0 0c 8f 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001abc2:	e0 81 00 99 	brne	8001acf4 <_dtoa_r+0x71c>
8001abc6:	fa e8 00 28 	ld.d	r8,sp[40]
8001abca:	30 0a       	mov	r10,0
8001abcc:	fc 1b 3f e0 	movh	r11,0x3fe0
8001abd0:	e0 a0 0a 60 	rcall	8001c090 <__avr32_f64_sub>
8001abd4:	14 98       	mov	r8,r10
8001abd6:	16 99       	mov	r9,r11
8001abd8:	fa ea 00 08 	ld.d	r10,sp[8]
8001abdc:	e0 a0 0c 80 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001abe0:	c1 40       	breq	8001ac08 <_dtoa_r+0x630>
8001abe2:	33 09       	mov	r9,48
8001abe4:	0a 98       	mov	r8,r5
8001abe6:	11 7a       	ld.ub	r10,--r8
8001abe8:	f2 0a 18 00 	cp.b	r10,r9
8001abec:	e0 81 02 d2 	brne	8001b190 <_dtoa_r+0xbb8>
8001abf0:	10 95       	mov	r5,r8
8001abf2:	cf 9b       	rjmp	8001abe4 <_dtoa_r+0x60c>
8001abf4:	80 07       	ld.sh	r7,r0[0x0]
8001abf6:	0e b8       	st.h	r7++,r8
8001abf8:	30 08       	mov	r8,0
8001abfa:	fc 19 40 24 	movh	r9,0x4024
8001abfe:	e0 a0 09 5d 	rcall	8001beb8 <__avr32_f64_mul>
8001ac02:	fa eb 00 08 	st.d	sp[8],r10
8001ac06:	cb cb       	rjmp	8001ab7e <_dtoa_r+0x5a6>
8001ac08:	fa ea 00 3c 	ld.d	r10,sp[60]
8001ac0c:	fa eb 00 08 	st.d	sp[8],r10
8001ac10:	58 e6       	cp.w	r6,14
8001ac12:	5f ab       	srle	r11
8001ac14:	41 8a       	lddsp	r10,sp[0x60]
8001ac16:	30 08       	mov	r8,0
8001ac18:	f4 09 11 ff 	rsub	r9,r10,-1
8001ac1c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8001ac20:	f0 09 18 00 	cp.b	r9,r8
8001ac24:	e0 80 00 81 	breq	8001ad26 <_dtoa_r+0x74e>
8001ac28:	40 ea       	lddsp	r10,sp[0x38]
8001ac2a:	58 01       	cp.w	r1,0
8001ac2c:	5f a9       	srle	r9
8001ac2e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8001ac32:	4c 9a       	lddpc	r10,8001ad54 <_dtoa_r+0x77c>
8001ac34:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8001ac38:	fa e5 00 10 	st.d	sp[16],r4
8001ac3c:	f0 09 18 00 	cp.b	r9,r8
8001ac40:	c1 40       	breq	8001ac68 <_dtoa_r+0x690>
8001ac42:	58 01       	cp.w	r1,0
8001ac44:	e0 81 01 78 	brne	8001af34 <_dtoa_r+0x95c>
8001ac48:	30 08       	mov	r8,0
8001ac4a:	fc 19 40 14 	movh	r9,0x4014
8001ac4e:	08 9a       	mov	r10,r4
8001ac50:	0a 9b       	mov	r11,r5
8001ac52:	e0 a0 09 33 	rcall	8001beb8 <__avr32_f64_mul>
8001ac56:	fa e8 00 08 	ld.d	r8,sp[8]
8001ac5a:	e0 a0 0c 0d 	rcall	8001c474 <__avr32_f64_cmp_ge>
8001ac5e:	e0 81 01 6b 	brne	8001af34 <_dtoa_r+0x95c>
8001ac62:	02 92       	mov	r2,r1
8001ac64:	e0 8f 01 73 	bral	8001af4a <_dtoa_r+0x972>
8001ac68:	40 85       	lddsp	r5,sp[0x20]
8001ac6a:	30 14       	mov	r4,1
8001ac6c:	fa e8 00 10 	ld.d	r8,sp[16]
8001ac70:	fa ea 00 08 	ld.d	r10,sp[8]
8001ac74:	e0 a0 0c 68 	rcall	8001c544 <__avr32_f64_div>
8001ac78:	e0 a0 0b 64 	rcall	8001c340 <__avr32_f64_to_s32>
8001ac7c:	18 92       	mov	r2,r12
8001ac7e:	e0 a0 0b 78 	rcall	8001c36e <__avr32_s32_to_f64>
8001ac82:	fa e8 00 10 	ld.d	r8,sp[16]
8001ac86:	e0 a0 09 19 	rcall	8001beb8 <__avr32_f64_mul>
8001ac8a:	14 98       	mov	r8,r10
8001ac8c:	16 99       	mov	r9,r11
8001ac8e:	fa ea 00 08 	ld.d	r10,sp[8]
8001ac92:	e0 a0 09 ff 	rcall	8001c090 <__avr32_f64_sub>
8001ac96:	fa eb 00 08 	st.d	sp[8],r10
8001ac9a:	e4 c8 ff d0 	sub	r8,r2,-48
8001ac9e:	0a c8       	st.b	r5++,r8
8001aca0:	fc 19 40 24 	movh	r9,0x4024
8001aca4:	30 08       	mov	r8,0
8001aca6:	02 34       	cp.w	r4,r1
8001aca8:	c3 31       	brne	8001ad0e <_dtoa_r+0x736>
8001acaa:	fa e8 00 08 	ld.d	r8,sp[8]
8001acae:	e0 a0 0a bf 	rcall	8001c22c <__avr32_f64_add>
8001acb2:	16 91       	mov	r1,r11
8001acb4:	14 90       	mov	r0,r10
8001acb6:	14 98       	mov	r8,r10
8001acb8:	02 99       	mov	r9,r1
8001acba:	fa ea 00 10 	ld.d	r10,sp[16]
8001acbe:	e0 a0 0c 0f 	rcall	8001c4dc <__avr32_f64_cmp_lt>
8001acc2:	c1 a1       	brne	8001acf6 <_dtoa_r+0x71e>
8001acc4:	fa e8 00 10 	ld.d	r8,sp[16]
8001acc8:	00 9a       	mov	r10,r0
8001acca:	02 9b       	mov	r11,r1
8001accc:	e0 a0 0b c1 	rcall	8001c44e <__avr32_f64_cmp_eq>
8001acd0:	e0 80 02 5f 	breq	8001b18e <_dtoa_r+0xbb6>
8001acd4:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8001acd8:	c0 f1       	brne	8001acf6 <_dtoa_r+0x71e>
8001acda:	e0 8f 02 5a 	bral	8001b18e <_dtoa_r+0xbb6>
8001acde:	40 8a       	lddsp	r10,sp[0x20]
8001ace0:	14 38       	cp.w	r8,r10
8001ace2:	c0 30       	breq	8001ace8 <_dtoa_r+0x710>
8001ace4:	10 95       	mov	r5,r8
8001ace6:	c0 98       	rjmp	8001acf8 <_dtoa_r+0x720>
8001ace8:	33 08       	mov	r8,48
8001acea:	40 89       	lddsp	r9,sp[0x20]
8001acec:	2f f6       	sub	r6,-1
8001acee:	b2 88       	st.b	r9[0x0],r8
8001acf0:	40 88       	lddsp	r8,sp[0x20]
8001acf2:	c0 88       	rjmp	8001ad02 <_dtoa_r+0x72a>
8001acf4:	40 66       	lddsp	r6,sp[0x18]
8001acf6:	33 99       	mov	r9,57
8001acf8:	0a 98       	mov	r8,r5
8001acfa:	11 7a       	ld.ub	r10,--r8
8001acfc:	f2 0a 18 00 	cp.b	r10,r9
8001ad00:	ce f0       	breq	8001acde <_dtoa_r+0x706>
8001ad02:	50 66       	stdsp	sp[0x18],r6
8001ad04:	11 89       	ld.ub	r9,r8[0x0]
8001ad06:	2f f9       	sub	r9,-1
8001ad08:	b0 89       	st.b	r8[0x0],r9
8001ad0a:	e0 8f 02 43 	bral	8001b190 <_dtoa_r+0xbb8>
8001ad0e:	e0 a0 08 d5 	rcall	8001beb8 <__avr32_f64_mul>
8001ad12:	2f f4       	sub	r4,-1
8001ad14:	fa eb 00 08 	st.d	sp[8],r10
8001ad18:	30 08       	mov	r8,0
8001ad1a:	30 09       	mov	r9,0
8001ad1c:	e0 a0 0b 99 	rcall	8001c44e <__avr32_f64_cmp_eq>
8001ad20:	ca 60       	breq	8001ac6c <_dtoa_r+0x694>
8001ad22:	e0 8f 02 36 	bral	8001b18e <_dtoa_r+0xbb6>
8001ad26:	40 d8       	lddsp	r8,sp[0x34]
8001ad28:	58 08       	cp.w	r8,0
8001ad2a:	c0 51       	brne	8001ad34 <_dtoa_r+0x75c>
8001ad2c:	04 98       	mov	r8,r2
8001ad2e:	00 95       	mov	r5,r0
8001ad30:	40 d4       	lddsp	r4,sp[0x34]
8001ad32:	c3 88       	rjmp	8001ada2 <_dtoa_r+0x7ca>
8001ad34:	40 c5       	lddsp	r5,sp[0x30]
8001ad36:	58 15       	cp.w	r5,1
8001ad38:	e0 89 00 10 	brgt	8001ad58 <_dtoa_r+0x780>
8001ad3c:	41 74       	lddsp	r4,sp[0x5c]
8001ad3e:	58 04       	cp.w	r4,0
8001ad40:	c0 40       	breq	8001ad48 <_dtoa_r+0x770>
8001ad42:	f4 c9 fb cd 	sub	r9,r10,-1075
8001ad46:	c0 48       	rjmp	8001ad4e <_dtoa_r+0x776>
8001ad48:	41 99       	lddsp	r9,sp[0x64]
8001ad4a:	f2 09 11 36 	rsub	r9,r9,54
8001ad4e:	04 98       	mov	r8,r2
8001ad50:	00 95       	mov	r5,r0
8001ad52:	c1 d8       	rjmp	8001ad8c <_dtoa_r+0x7b4>
8001ad54:	80 07       	ld.sh	r7,r0[0x0]
8001ad56:	0e b8       	st.h	r7++,r8
8001ad58:	e2 c8 00 01 	sub	r8,r1,1
8001ad5c:	58 01       	cp.w	r1,0
8001ad5e:	e0 05 17 40 	movge	r5,r0
8001ad62:	e2 09 17 40 	movge	r9,r1
8001ad66:	e1 d1 e5 15 	sublt	r5,r0,r1
8001ad6a:	f9 b9 05 00 	movlt	r9,0
8001ad6e:	10 32       	cp.w	r2,r8
8001ad70:	e5 d8 e4 18 	subge	r8,r2,r8
8001ad74:	f1 d2 e5 18 	sublt	r8,r8,r2
8001ad78:	e5 d8 e5 02 	addlt	r2,r2,r8
8001ad7c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8001ad80:	f9 d8 e5 0c 	addlt	r12,r12,r8
8001ad84:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8001ad88:	f9 b8 05 00 	movlt	r8,0
8001ad8c:	40 4b       	lddsp	r11,sp[0x10]
8001ad8e:	12 0b       	add	r11,r9
8001ad90:	50 08       	stdsp	sp[0x0],r8
8001ad92:	50 4b       	stdsp	sp[0x10],r11
8001ad94:	12 00       	add	r0,r9
8001ad96:	30 1b       	mov	r11,1
8001ad98:	0e 9c       	mov	r12,r7
8001ad9a:	e0 a0 06 3b 	rcall	8001ba10 <__i2b>
8001ad9e:	40 08       	lddsp	r8,sp[0x0]
8001ada0:	18 94       	mov	r4,r12
8001ada2:	40 4a       	lddsp	r10,sp[0x10]
8001ada4:	58 05       	cp.w	r5,0
8001ada6:	5f 99       	srgt	r9
8001ada8:	58 0a       	cp.w	r10,0
8001adaa:	5f 9a       	srgt	r10
8001adac:	f5 e9 00 09 	and	r9,r10,r9
8001adb0:	c0 80       	breq	8001adc0 <_dtoa_r+0x7e8>
8001adb2:	40 4c       	lddsp	r12,sp[0x10]
8001adb4:	f8 05 0d 49 	min	r9,r12,r5
8001adb8:	12 1c       	sub	r12,r9
8001adba:	12 10       	sub	r0,r9
8001adbc:	50 4c       	stdsp	sp[0x10],r12
8001adbe:	12 15       	sub	r5,r9
8001adc0:	58 02       	cp.w	r2,0
8001adc2:	e0 8a 00 27 	brle	8001ae10 <_dtoa_r+0x838>
8001adc6:	40 db       	lddsp	r11,sp[0x34]
8001adc8:	58 0b       	cp.w	r11,0
8001adca:	c1 d0       	breq	8001ae04 <_dtoa_r+0x82c>
8001adcc:	58 08       	cp.w	r8,0
8001adce:	e0 8a 00 17 	brle	8001adfc <_dtoa_r+0x824>
8001add2:	10 9a       	mov	r10,r8
8001add4:	50 08       	stdsp	sp[0x0],r8
8001add6:	08 9b       	mov	r11,r4
8001add8:	0e 9c       	mov	r12,r7
8001adda:	e0 a0 06 61 	rcall	8001ba9c <__pow5mult>
8001adde:	06 9a       	mov	r10,r3
8001ade0:	18 9b       	mov	r11,r12
8001ade2:	18 94       	mov	r4,r12
8001ade4:	0e 9c       	mov	r12,r7
8001ade6:	e0 a0 05 95 	rcall	8001b910 <__multiply>
8001adea:	18 99       	mov	r9,r12
8001adec:	06 9b       	mov	r11,r3
8001adee:	50 19       	stdsp	sp[0x4],r9
8001adf0:	0e 9c       	mov	r12,r7
8001adf2:	e0 a0 04 45 	rcall	8001b67c <_Bfree>
8001adf6:	40 19       	lddsp	r9,sp[0x4]
8001adf8:	40 08       	lddsp	r8,sp[0x0]
8001adfa:	12 93       	mov	r3,r9
8001adfc:	e4 08 01 0a 	sub	r10,r2,r8
8001ae00:	c0 80       	breq	8001ae10 <_dtoa_r+0x838>
8001ae02:	c0 28       	rjmp	8001ae06 <_dtoa_r+0x82e>
8001ae04:	04 9a       	mov	r10,r2
8001ae06:	06 9b       	mov	r11,r3
8001ae08:	0e 9c       	mov	r12,r7
8001ae0a:	e0 a0 06 49 	rcall	8001ba9c <__pow5mult>
8001ae0e:	18 93       	mov	r3,r12
8001ae10:	30 1b       	mov	r11,1
8001ae12:	0e 9c       	mov	r12,r7
8001ae14:	e0 a0 05 fe 	rcall	8001ba10 <__i2b>
8001ae18:	41 1a       	lddsp	r10,sp[0x44]
8001ae1a:	18 92       	mov	r2,r12
8001ae1c:	58 0a       	cp.w	r10,0
8001ae1e:	e0 8a 00 07 	brle	8001ae2c <_dtoa_r+0x854>
8001ae22:	18 9b       	mov	r11,r12
8001ae24:	0e 9c       	mov	r12,r7
8001ae26:	e0 a0 06 3b 	rcall	8001ba9c <__pow5mult>
8001ae2a:	18 92       	mov	r2,r12
8001ae2c:	40 c9       	lddsp	r9,sp[0x30]
8001ae2e:	58 19       	cp.w	r9,1
8001ae30:	e0 89 00 14 	brgt	8001ae58 <_dtoa_r+0x880>
8001ae34:	40 38       	lddsp	r8,sp[0xc]
8001ae36:	58 08       	cp.w	r8,0
8001ae38:	c1 01       	brne	8001ae58 <_dtoa_r+0x880>
8001ae3a:	40 29       	lddsp	r9,sp[0x8]
8001ae3c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8001ae40:	c0 c1       	brne	8001ae58 <_dtoa_r+0x880>
8001ae42:	12 98       	mov	r8,r9
8001ae44:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001ae48:	c0 80       	breq	8001ae58 <_dtoa_r+0x880>
8001ae4a:	40 4c       	lddsp	r12,sp[0x10]
8001ae4c:	30 1b       	mov	r11,1
8001ae4e:	2f fc       	sub	r12,-1
8001ae50:	2f f0       	sub	r0,-1
8001ae52:	50 4c       	stdsp	sp[0x10],r12
8001ae54:	50 6b       	stdsp	sp[0x18],r11
8001ae56:	c0 38       	rjmp	8001ae5c <_dtoa_r+0x884>
8001ae58:	30 0a       	mov	r10,0
8001ae5a:	50 6a       	stdsp	sp[0x18],r10
8001ae5c:	41 19       	lddsp	r9,sp[0x44]
8001ae5e:	58 09       	cp.w	r9,0
8001ae60:	c0 31       	brne	8001ae66 <_dtoa_r+0x88e>
8001ae62:	30 1c       	mov	r12,1
8001ae64:	c0 98       	rjmp	8001ae76 <_dtoa_r+0x89e>
8001ae66:	64 48       	ld.w	r8,r2[0x10]
8001ae68:	2f c8       	sub	r8,-4
8001ae6a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8001ae6e:	e0 a0 03 77 	rcall	8001b55c <__hi0bits>
8001ae72:	f8 0c 11 20 	rsub	r12,r12,32
8001ae76:	40 4b       	lddsp	r11,sp[0x10]
8001ae78:	f8 0b 00 08 	add	r8,r12,r11
8001ae7c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8001ae80:	c0 c0       	breq	8001ae98 <_dtoa_r+0x8c0>
8001ae82:	f0 08 11 20 	rsub	r8,r8,32
8001ae86:	58 48       	cp.w	r8,4
8001ae88:	e0 8a 00 06 	brle	8001ae94 <_dtoa_r+0x8bc>
8001ae8c:	20 48       	sub	r8,4
8001ae8e:	10 0b       	add	r11,r8
8001ae90:	50 4b       	stdsp	sp[0x10],r11
8001ae92:	c0 78       	rjmp	8001aea0 <_dtoa_r+0x8c8>
8001ae94:	58 48       	cp.w	r8,4
8001ae96:	c0 70       	breq	8001aea4 <_dtoa_r+0x8cc>
8001ae98:	40 4a       	lddsp	r10,sp[0x10]
8001ae9a:	2e 48       	sub	r8,-28
8001ae9c:	10 0a       	add	r10,r8
8001ae9e:	50 4a       	stdsp	sp[0x10],r10
8001aea0:	10 00       	add	r0,r8
8001aea2:	10 05       	add	r5,r8
8001aea4:	58 00       	cp.w	r0,0
8001aea6:	e0 8a 00 08 	brle	8001aeb6 <_dtoa_r+0x8de>
8001aeaa:	06 9b       	mov	r11,r3
8001aeac:	00 9a       	mov	r10,r0
8001aeae:	0e 9c       	mov	r12,r7
8001aeb0:	e0 a0 04 ec 	rcall	8001b888 <__lshift>
8001aeb4:	18 93       	mov	r3,r12
8001aeb6:	40 49       	lddsp	r9,sp[0x10]
8001aeb8:	58 09       	cp.w	r9,0
8001aeba:	e0 8a 00 08 	brle	8001aeca <_dtoa_r+0x8f2>
8001aebe:	04 9b       	mov	r11,r2
8001aec0:	12 9a       	mov	r10,r9
8001aec2:	0e 9c       	mov	r12,r7
8001aec4:	e0 a0 04 e2 	rcall	8001b888 <__lshift>
8001aec8:	18 92       	mov	r2,r12
8001aeca:	41 48       	lddsp	r8,sp[0x50]
8001aecc:	58 08       	cp.w	r8,0
8001aece:	c1 b0       	breq	8001af04 <_dtoa_r+0x92c>
8001aed0:	04 9b       	mov	r11,r2
8001aed2:	06 9c       	mov	r12,r3
8001aed4:	e0 a0 03 bb 	rcall	8001b64a <__mcmp>
8001aed8:	c1 64       	brge	8001af04 <_dtoa_r+0x92c>
8001aeda:	06 9b       	mov	r11,r3
8001aedc:	30 09       	mov	r9,0
8001aede:	30 aa       	mov	r10,10
8001aee0:	0e 9c       	mov	r12,r7
8001aee2:	e0 a0 05 9f 	rcall	8001ba20 <__multadd>
8001aee6:	20 16       	sub	r6,1
8001aee8:	18 93       	mov	r3,r12
8001aeea:	40 dc       	lddsp	r12,sp[0x34]
8001aeec:	58 0c       	cp.w	r12,0
8001aeee:	c0 31       	brne	8001aef4 <_dtoa_r+0x91c>
8001aef0:	40 91       	lddsp	r1,sp[0x24]
8001aef2:	c0 98       	rjmp	8001af04 <_dtoa_r+0x92c>
8001aef4:	08 9b       	mov	r11,r4
8001aef6:	40 91       	lddsp	r1,sp[0x24]
8001aef8:	30 09       	mov	r9,0
8001aefa:	30 aa       	mov	r10,10
8001aefc:	0e 9c       	mov	r12,r7
8001aefe:	e0 a0 05 91 	rcall	8001ba20 <__multadd>
8001af02:	18 94       	mov	r4,r12
8001af04:	58 01       	cp.w	r1,0
8001af06:	5f a9       	srle	r9
8001af08:	40 cb       	lddsp	r11,sp[0x30]
8001af0a:	58 2b       	cp.w	r11,2
8001af0c:	5f 98       	srgt	r8
8001af0e:	f3 e8 00 08 	and	r8,r9,r8
8001af12:	c2 50       	breq	8001af5c <_dtoa_r+0x984>
8001af14:	58 01       	cp.w	r1,0
8001af16:	c1 11       	brne	8001af38 <_dtoa_r+0x960>
8001af18:	04 9b       	mov	r11,r2
8001af1a:	02 99       	mov	r9,r1
8001af1c:	30 5a       	mov	r10,5
8001af1e:	0e 9c       	mov	r12,r7
8001af20:	e0 a0 05 80 	rcall	8001ba20 <__multadd>
8001af24:	18 92       	mov	r2,r12
8001af26:	18 9b       	mov	r11,r12
8001af28:	06 9c       	mov	r12,r3
8001af2a:	e0 a0 03 90 	rcall	8001b64a <__mcmp>
8001af2e:	e0 89 00 0f 	brgt	8001af4c <_dtoa_r+0x974>
8001af32:	c0 38       	rjmp	8001af38 <_dtoa_r+0x960>
8001af34:	30 02       	mov	r2,0
8001af36:	04 94       	mov	r4,r2
8001af38:	40 ea       	lddsp	r10,sp[0x38]
8001af3a:	30 09       	mov	r9,0
8001af3c:	5c da       	com	r10
8001af3e:	40 85       	lddsp	r5,sp[0x20]
8001af40:	50 6a       	stdsp	sp[0x18],r10
8001af42:	50 49       	stdsp	sp[0x10],r9
8001af44:	c0 f9       	rjmp	8001b162 <_dtoa_r+0xb8a>
8001af46:	08 92       	mov	r2,r4
8001af48:	40 66       	lddsp	r6,sp[0x18]
8001af4a:	04 94       	mov	r4,r2
8001af4c:	2f f6       	sub	r6,-1
8001af4e:	50 66       	stdsp	sp[0x18],r6
8001af50:	33 18       	mov	r8,49
8001af52:	40 85       	lddsp	r5,sp[0x20]
8001af54:	0a c8       	st.b	r5++,r8
8001af56:	30 08       	mov	r8,0
8001af58:	50 48       	stdsp	sp[0x10],r8
8001af5a:	c0 49       	rjmp	8001b162 <_dtoa_r+0xb8a>
8001af5c:	40 dc       	lddsp	r12,sp[0x34]
8001af5e:	58 0c       	cp.w	r12,0
8001af60:	e0 80 00 b5 	breq	8001b0ca <_dtoa_r+0xaf2>
8001af64:	58 05       	cp.w	r5,0
8001af66:	e0 8a 00 08 	brle	8001af76 <_dtoa_r+0x99e>
8001af6a:	08 9b       	mov	r11,r4
8001af6c:	0a 9a       	mov	r10,r5
8001af6e:	0e 9c       	mov	r12,r7
8001af70:	e0 a0 04 8c 	rcall	8001b888 <__lshift>
8001af74:	18 94       	mov	r4,r12
8001af76:	40 6b       	lddsp	r11,sp[0x18]
8001af78:	58 0b       	cp.w	r11,0
8001af7a:	c0 31       	brne	8001af80 <_dtoa_r+0x9a8>
8001af7c:	08 9c       	mov	r12,r4
8001af7e:	c1 38       	rjmp	8001afa4 <_dtoa_r+0x9cc>
8001af80:	68 1b       	ld.w	r11,r4[0x4]
8001af82:	0e 9c       	mov	r12,r7
8001af84:	e0 a0 03 94 	rcall	8001b6ac <_Balloc>
8001af88:	68 4a       	ld.w	r10,r4[0x10]
8001af8a:	18 95       	mov	r5,r12
8001af8c:	e8 cb ff f4 	sub	r11,r4,-12
8001af90:	2f ea       	sub	r10,-2
8001af92:	2f 4c       	sub	r12,-12
8001af94:	a3 6a       	lsl	r10,0x2
8001af96:	fe b0 e4 e5 	rcall	80017960 <memcpy>
8001af9a:	0a 9b       	mov	r11,r5
8001af9c:	30 1a       	mov	r10,1
8001af9e:	0e 9c       	mov	r12,r7
8001afa0:	e0 a0 04 74 	rcall	8001b888 <__lshift>
8001afa4:	50 44       	stdsp	sp[0x10],r4
8001afa6:	40 3a       	lddsp	r10,sp[0xc]
8001afa8:	30 19       	mov	r9,1
8001afaa:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001afae:	18 94       	mov	r4,r12
8001afb0:	50 da       	stdsp	sp[0x34],r10
8001afb2:	40 85       	lddsp	r5,sp[0x20]
8001afb4:	50 99       	stdsp	sp[0x24],r9
8001afb6:	50 26       	stdsp	sp[0x8],r6
8001afb8:	50 e1       	stdsp	sp[0x38],r1
8001afba:	04 9b       	mov	r11,r2
8001afbc:	06 9c       	mov	r12,r3
8001afbe:	fe b0 fa 7d 	rcall	8001a4b8 <quorem>
8001afc2:	40 4b       	lddsp	r11,sp[0x10]
8001afc4:	f8 c0 ff d0 	sub	r0,r12,-48
8001afc8:	06 9c       	mov	r12,r3
8001afca:	e0 a0 03 40 	rcall	8001b64a <__mcmp>
8001afce:	08 9a       	mov	r10,r4
8001afd0:	50 6c       	stdsp	sp[0x18],r12
8001afd2:	04 9b       	mov	r11,r2
8001afd4:	0e 9c       	mov	r12,r7
8001afd6:	e0 a0 03 f1 	rcall	8001b7b8 <__mdiff>
8001afda:	18 91       	mov	r1,r12
8001afdc:	78 38       	ld.w	r8,r12[0xc]
8001afde:	58 08       	cp.w	r8,0
8001afe0:	c0 30       	breq	8001afe6 <_dtoa_r+0xa0e>
8001afe2:	30 16       	mov	r6,1
8001afe4:	c0 68       	rjmp	8001aff0 <_dtoa_r+0xa18>
8001afe6:	18 9b       	mov	r11,r12
8001afe8:	06 9c       	mov	r12,r3
8001afea:	e0 a0 03 30 	rcall	8001b64a <__mcmp>
8001afee:	18 96       	mov	r6,r12
8001aff0:	0e 9c       	mov	r12,r7
8001aff2:	02 9b       	mov	r11,r1
8001aff4:	e0 a0 03 44 	rcall	8001b67c <_Bfree>
8001aff8:	40 cc       	lddsp	r12,sp[0x30]
8001affa:	ed ec 10 08 	or	r8,r6,r12
8001affe:	c0 d1       	brne	8001b018 <_dtoa_r+0xa40>
8001b000:	40 db       	lddsp	r11,sp[0x34]
8001b002:	58 0b       	cp.w	r11,0
8001b004:	c0 a1       	brne	8001b018 <_dtoa_r+0xa40>
8001b006:	40 26       	lddsp	r6,sp[0x8]
8001b008:	e0 40 00 39 	cp.w	r0,57
8001b00c:	c3 00       	breq	8001b06c <_dtoa_r+0xa94>
8001b00e:	40 6a       	lddsp	r10,sp[0x18]
8001b010:	58 0a       	cp.w	r10,0
8001b012:	e0 89 00 24 	brgt	8001b05a <_dtoa_r+0xa82>
8001b016:	c2 f8       	rjmp	8001b074 <_dtoa_r+0xa9c>
8001b018:	40 69       	lddsp	r9,sp[0x18]
8001b01a:	58 09       	cp.w	r9,0
8001b01c:	c0 85       	brlt	8001b02c <_dtoa_r+0xa54>
8001b01e:	12 98       	mov	r8,r9
8001b020:	40 cc       	lddsp	r12,sp[0x30]
8001b022:	18 48       	or	r8,r12
8001b024:	c1 d1       	brne	8001b05e <_dtoa_r+0xa86>
8001b026:	40 db       	lddsp	r11,sp[0x34]
8001b028:	58 0b       	cp.w	r11,0
8001b02a:	c1 a1       	brne	8001b05e <_dtoa_r+0xa86>
8001b02c:	0c 99       	mov	r9,r6
8001b02e:	40 26       	lddsp	r6,sp[0x8]
8001b030:	58 09       	cp.w	r9,0
8001b032:	e0 8a 00 21 	brle	8001b074 <_dtoa_r+0xa9c>
8001b036:	06 9b       	mov	r11,r3
8001b038:	30 1a       	mov	r10,1
8001b03a:	0e 9c       	mov	r12,r7
8001b03c:	e0 a0 04 26 	rcall	8001b888 <__lshift>
8001b040:	04 9b       	mov	r11,r2
8001b042:	18 93       	mov	r3,r12
8001b044:	e0 a0 03 03 	rcall	8001b64a <__mcmp>
8001b048:	e0 89 00 06 	brgt	8001b054 <_dtoa_r+0xa7c>
8001b04c:	c1 41       	brne	8001b074 <_dtoa_r+0xa9c>
8001b04e:	ed b0 00 00 	bld	r0,0x0
8001b052:	c1 11       	brne	8001b074 <_dtoa_r+0xa9c>
8001b054:	e0 40 00 39 	cp.w	r0,57
8001b058:	c0 a0       	breq	8001b06c <_dtoa_r+0xa94>
8001b05a:	2f f0       	sub	r0,-1
8001b05c:	c0 c8       	rjmp	8001b074 <_dtoa_r+0xa9c>
8001b05e:	58 06       	cp.w	r6,0
8001b060:	e0 8a 00 0c 	brle	8001b078 <_dtoa_r+0xaa0>
8001b064:	40 26       	lddsp	r6,sp[0x8]
8001b066:	e0 40 00 39 	cp.w	r0,57
8001b06a:	c0 41       	brne	8001b072 <_dtoa_r+0xa9a>
8001b06c:	33 98       	mov	r8,57
8001b06e:	0a c8       	st.b	r5++,r8
8001b070:	c6 78       	rjmp	8001b13e <_dtoa_r+0xb66>
8001b072:	2f f0       	sub	r0,-1
8001b074:	0a c0       	st.b	r5++,r0
8001b076:	c7 58       	rjmp	8001b160 <_dtoa_r+0xb88>
8001b078:	0a c0       	st.b	r5++,r0
8001b07a:	40 9a       	lddsp	r10,sp[0x24]
8001b07c:	40 e9       	lddsp	r9,sp[0x38]
8001b07e:	12 3a       	cp.w	r10,r9
8001b080:	c4 30       	breq	8001b106 <_dtoa_r+0xb2e>
8001b082:	06 9b       	mov	r11,r3
8001b084:	30 09       	mov	r9,0
8001b086:	30 aa       	mov	r10,10
8001b088:	0e 9c       	mov	r12,r7
8001b08a:	e0 a0 04 cb 	rcall	8001ba20 <__multadd>
8001b08e:	40 48       	lddsp	r8,sp[0x10]
8001b090:	18 93       	mov	r3,r12
8001b092:	08 38       	cp.w	r8,r4
8001b094:	c0 91       	brne	8001b0a6 <_dtoa_r+0xace>
8001b096:	10 9b       	mov	r11,r8
8001b098:	30 09       	mov	r9,0
8001b09a:	30 aa       	mov	r10,10
8001b09c:	0e 9c       	mov	r12,r7
8001b09e:	e0 a0 04 c1 	rcall	8001ba20 <__multadd>
8001b0a2:	50 4c       	stdsp	sp[0x10],r12
8001b0a4:	c0 e8       	rjmp	8001b0c0 <_dtoa_r+0xae8>
8001b0a6:	40 4b       	lddsp	r11,sp[0x10]
8001b0a8:	30 09       	mov	r9,0
8001b0aa:	30 aa       	mov	r10,10
8001b0ac:	0e 9c       	mov	r12,r7
8001b0ae:	e0 a0 04 b9 	rcall	8001ba20 <__multadd>
8001b0b2:	08 9b       	mov	r11,r4
8001b0b4:	50 4c       	stdsp	sp[0x10],r12
8001b0b6:	30 09       	mov	r9,0
8001b0b8:	30 aa       	mov	r10,10
8001b0ba:	0e 9c       	mov	r12,r7
8001b0bc:	e0 a0 04 b2 	rcall	8001ba20 <__multadd>
8001b0c0:	18 94       	mov	r4,r12
8001b0c2:	40 9c       	lddsp	r12,sp[0x24]
8001b0c4:	2f fc       	sub	r12,-1
8001b0c6:	50 9c       	stdsp	sp[0x24],r12
8001b0c8:	c7 9b       	rjmp	8001afba <_dtoa_r+0x9e2>
8001b0ca:	30 18       	mov	r8,1
8001b0cc:	06 90       	mov	r0,r3
8001b0ce:	40 85       	lddsp	r5,sp[0x20]
8001b0d0:	08 93       	mov	r3,r4
8001b0d2:	0c 94       	mov	r4,r6
8001b0d4:	10 96       	mov	r6,r8
8001b0d6:	04 9b       	mov	r11,r2
8001b0d8:	00 9c       	mov	r12,r0
8001b0da:	fe b0 f9 ef 	rcall	8001a4b8 <quorem>
8001b0de:	2d 0c       	sub	r12,-48
8001b0e0:	0a cc       	st.b	r5++,r12
8001b0e2:	02 36       	cp.w	r6,r1
8001b0e4:	c0 a4       	brge	8001b0f8 <_dtoa_r+0xb20>
8001b0e6:	00 9b       	mov	r11,r0
8001b0e8:	30 09       	mov	r9,0
8001b0ea:	30 aa       	mov	r10,10
8001b0ec:	0e 9c       	mov	r12,r7
8001b0ee:	2f f6       	sub	r6,-1
8001b0f0:	e0 a0 04 98 	rcall	8001ba20 <__multadd>
8001b0f4:	18 90       	mov	r0,r12
8001b0f6:	cf 0b       	rjmp	8001b0d6 <_dtoa_r+0xafe>
8001b0f8:	08 96       	mov	r6,r4
8001b0fa:	30 0b       	mov	r11,0
8001b0fc:	06 94       	mov	r4,r3
8001b0fe:	50 4b       	stdsp	sp[0x10],r11
8001b100:	00 93       	mov	r3,r0
8001b102:	18 90       	mov	r0,r12
8001b104:	c0 28       	rjmp	8001b108 <_dtoa_r+0xb30>
8001b106:	40 26       	lddsp	r6,sp[0x8]
8001b108:	06 9b       	mov	r11,r3
8001b10a:	30 1a       	mov	r10,1
8001b10c:	0e 9c       	mov	r12,r7
8001b10e:	e0 a0 03 bd 	rcall	8001b888 <__lshift>
8001b112:	04 9b       	mov	r11,r2
8001b114:	18 93       	mov	r3,r12
8001b116:	e0 a0 02 9a 	rcall	8001b64a <__mcmp>
8001b11a:	e0 89 00 12 	brgt	8001b13e <_dtoa_r+0xb66>
8001b11e:	c1 b1       	brne	8001b154 <_dtoa_r+0xb7c>
8001b120:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8001b124:	c0 d1       	brne	8001b13e <_dtoa_r+0xb66>
8001b126:	c1 78       	rjmp	8001b154 <_dtoa_r+0xb7c>
8001b128:	40 89       	lddsp	r9,sp[0x20]
8001b12a:	12 38       	cp.w	r8,r9
8001b12c:	c0 30       	breq	8001b132 <_dtoa_r+0xb5a>
8001b12e:	10 95       	mov	r5,r8
8001b130:	c0 88       	rjmp	8001b140 <_dtoa_r+0xb68>
8001b132:	2f f6       	sub	r6,-1
8001b134:	50 66       	stdsp	sp[0x18],r6
8001b136:	33 18       	mov	r8,49
8001b138:	40 8c       	lddsp	r12,sp[0x20]
8001b13a:	b8 88       	st.b	r12[0x0],r8
8001b13c:	c1 38       	rjmp	8001b162 <_dtoa_r+0xb8a>
8001b13e:	33 9a       	mov	r10,57
8001b140:	0a 98       	mov	r8,r5
8001b142:	11 79       	ld.ub	r9,--r8
8001b144:	f4 09 18 00 	cp.b	r9,r10
8001b148:	cf 00       	breq	8001b128 <_dtoa_r+0xb50>
8001b14a:	2f f9       	sub	r9,-1
8001b14c:	b0 89       	st.b	r8[0x0],r9
8001b14e:	c0 98       	rjmp	8001b160 <_dtoa_r+0xb88>
8001b150:	10 95       	mov	r5,r8
8001b152:	c0 28       	rjmp	8001b156 <_dtoa_r+0xb7e>
8001b154:	33 09       	mov	r9,48
8001b156:	0a 98       	mov	r8,r5
8001b158:	11 7a       	ld.ub	r10,--r8
8001b15a:	f2 0a 18 00 	cp.b	r10,r9
8001b15e:	cf 90       	breq	8001b150 <_dtoa_r+0xb78>
8001b160:	50 66       	stdsp	sp[0x18],r6
8001b162:	04 9b       	mov	r11,r2
8001b164:	0e 9c       	mov	r12,r7
8001b166:	e0 a0 02 8b 	rcall	8001b67c <_Bfree>
8001b16a:	58 04       	cp.w	r4,0
8001b16c:	c1 20       	breq	8001b190 <_dtoa_r+0xbb8>
8001b16e:	40 4b       	lddsp	r11,sp[0x10]
8001b170:	08 3b       	cp.w	r11,r4
8001b172:	5f 19       	srne	r9
8001b174:	58 0b       	cp.w	r11,0
8001b176:	5f 18       	srne	r8
8001b178:	f3 e8 00 08 	and	r8,r9,r8
8001b17c:	c0 40       	breq	8001b184 <_dtoa_r+0xbac>
8001b17e:	0e 9c       	mov	r12,r7
8001b180:	e0 a0 02 7e 	rcall	8001b67c <_Bfree>
8001b184:	08 9b       	mov	r11,r4
8001b186:	0e 9c       	mov	r12,r7
8001b188:	e0 a0 02 7a 	rcall	8001b67c <_Bfree>
8001b18c:	c0 28       	rjmp	8001b190 <_dtoa_r+0xbb8>
8001b18e:	50 66       	stdsp	sp[0x18],r6
8001b190:	0e 9c       	mov	r12,r7
8001b192:	06 9b       	mov	r11,r3
8001b194:	e0 a0 02 74 	rcall	8001b67c <_Bfree>
8001b198:	30 08       	mov	r8,0
8001b19a:	aa 88       	st.b	r5[0x0],r8
8001b19c:	40 68       	lddsp	r8,sp[0x18]
8001b19e:	41 5a       	lddsp	r10,sp[0x54]
8001b1a0:	2f f8       	sub	r8,-1
8001b1a2:	41 29       	lddsp	r9,sp[0x48]
8001b1a4:	95 08       	st.w	r10[0x0],r8
8001b1a6:	40 8c       	lddsp	r12,sp[0x20]
8001b1a8:	58 09       	cp.w	r9,0
8001b1aa:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8001b1ae:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8001b1b2:	2e 6d       	sub	sp,-104
8001b1b4:	d8 32       	popm	r0-r7,pc
8001b1b6:	d7 03       	nop

8001b1b8 <__errno>:
8001b1b8:	48 28       	lddpc	r8,8001b1c0 <__errno+0x8>
8001b1ba:	70 0c       	ld.w	r12,r8[0x0]
8001b1bc:	2f 4c       	sub	r12,-12
8001b1be:	5e fc       	retal	r12
8001b1c0:	00 00       	add	r0,r0
8001b1c2:	01 9c       	ld.ub	r12,r0[0x1]

8001b1c4 <__sflags>:
8001b1c4:	d4 21       	pushm	r4-r7,lr
8001b1c6:	37 29       	mov	r9,114
8001b1c8:	17 88       	ld.ub	r8,r11[0x0]
8001b1ca:	f2 08 18 00 	cp.b	r8,r9
8001b1ce:	c1 80       	breq	8001b1fe <__sflags+0x3a>
8001b1d0:	37 79       	mov	r9,119
8001b1d2:	f2 08 18 00 	cp.b	r8,r9
8001b1d6:	c0 60       	breq	8001b1e2 <__sflags+0x1e>
8001b1d8:	36 19       	mov	r9,97
8001b1da:	f2 08 18 00 	cp.b	r8,r9
8001b1de:	c0 d1       	brne	8001b1f8 <__sflags+0x34>
8001b1e0:	c0 68       	rjmp	8001b1ec <__sflags+0x28>
8001b1e2:	e0 68 06 00 	mov	r8,1536
8001b1e6:	30 19       	mov	r9,1
8001b1e8:	30 8c       	mov	r12,8
8001b1ea:	c0 d8       	rjmp	8001b204 <__sflags+0x40>
8001b1ec:	e0 68 02 08 	mov	r8,520
8001b1f0:	30 19       	mov	r9,1
8001b1f2:	e0 6c 01 08 	mov	r12,264
8001b1f6:	c0 78       	rjmp	8001b204 <__sflags+0x40>
8001b1f8:	31 68       	mov	r8,22
8001b1fa:	99 38       	st.w	r12[0xc],r8
8001b1fc:	d8 2a       	popm	r4-r7,pc,r12=0
8001b1fe:	30 08       	mov	r8,0
8001b200:	30 4c       	mov	r12,4
8001b202:	10 99       	mov	r9,r8
8001b204:	17 97       	ld.ub	r7,r11[0x1]
8001b206:	58 07       	cp.w	r7,0
8001b208:	c0 d0       	breq	8001b222 <__sflags+0x5e>
8001b20a:	32 be       	mov	lr,43
8001b20c:	fc 07 18 00 	cp.b	r7,lr
8001b210:	c0 50       	breq	8001b21a <__sflags+0x56>
8001b212:	17 ab       	ld.ub	r11,r11[0x2]
8001b214:	fc 0b 18 00 	cp.b	r11,lr
8001b218:	c0 51       	brne	8001b222 <__sflags+0x5e>
8001b21a:	e0 1c ff e3 	andl	r12,0xffe3
8001b21e:	30 29       	mov	r9,2
8001b220:	a5 ac       	sbr	r12,0x4
8001b222:	f3 e8 10 08 	or	r8,r9,r8
8001b226:	95 08       	st.w	r10[0x0],r8
8001b228:	d8 22       	popm	r4-r7,pc
8001b22a:	d7 03       	nop

8001b22c <__sfvwrite_r>:
8001b22c:	d4 31       	pushm	r0-r7,lr
8001b22e:	20 3d       	sub	sp,12
8001b230:	14 94       	mov	r4,r10
8001b232:	18 95       	mov	r5,r12
8001b234:	16 97       	mov	r7,r11
8001b236:	74 28       	ld.w	r8,r10[0x8]
8001b238:	58 08       	cp.w	r8,0
8001b23a:	e0 80 01 41 	breq	8001b4bc <__sfvwrite_r+0x290>
8001b23e:	96 68       	ld.sh	r8,r11[0xc]
8001b240:	ed b8 00 03 	bld	r8,0x3
8001b244:	c0 41       	brne	8001b24c <__sfvwrite_r+0x20>
8001b246:	76 48       	ld.w	r8,r11[0x10]
8001b248:	58 08       	cp.w	r8,0
8001b24a:	c0 c1       	brne	8001b262 <__sfvwrite_r+0x36>
8001b24c:	0e 9b       	mov	r11,r7
8001b24e:	0a 9c       	mov	r12,r5
8001b250:	fe b0 f8 b4 	rcall	8001a3b8 <__swsetup_r>
8001b254:	c0 70       	breq	8001b262 <__sfvwrite_r+0x36>
8001b256:	8e 68       	ld.sh	r8,r7[0xc]
8001b258:	a7 a8       	sbr	r8,0x6
8001b25a:	ae 68       	st.h	r7[0xc],r8
8001b25c:	30 98       	mov	r8,9
8001b25e:	8b 38       	st.w	r5[0xc],r8
8001b260:	c2 c9       	rjmp	8001b4b8 <__sfvwrite_r+0x28c>
8001b262:	8e 63       	ld.sh	r3,r7[0xc]
8001b264:	68 00       	ld.w	r0,r4[0x0]
8001b266:	06 96       	mov	r6,r3
8001b268:	e2 16 00 02 	andl	r6,0x2,COH
8001b26c:	c2 10       	breq	8001b2ae <__sfvwrite_r+0x82>
8001b26e:	30 03       	mov	r3,0
8001b270:	e0 62 04 00 	mov	r2,1024
8001b274:	06 96       	mov	r6,r3
8001b276:	c0 48       	rjmp	8001b27e <__sfvwrite_r+0x52>
8001b278:	60 03       	ld.w	r3,r0[0x0]
8001b27a:	60 16       	ld.w	r6,r0[0x4]
8001b27c:	2f 80       	sub	r0,-8
8001b27e:	58 06       	cp.w	r6,0
8001b280:	cf c0       	breq	8001b278 <__sfvwrite_r+0x4c>
8001b282:	e0 46 04 00 	cp.w	r6,1024
8001b286:	ec 09 17 80 	movls	r9,r6
8001b28a:	e4 09 17 b0 	movhi	r9,r2
8001b28e:	06 9a       	mov	r10,r3
8001b290:	6e a8       	ld.w	r8,r7[0x28]
8001b292:	6e 8b       	ld.w	r11,r7[0x20]
8001b294:	0a 9c       	mov	r12,r5
8001b296:	5d 18       	icall	r8
8001b298:	18 16       	sub	r6,r12
8001b29a:	58 0c       	cp.w	r12,0
8001b29c:	e0 8a 01 0b 	brle	8001b4b2 <__sfvwrite_r+0x286>
8001b2a0:	68 28       	ld.w	r8,r4[0x8]
8001b2a2:	18 18       	sub	r8,r12
8001b2a4:	89 28       	st.w	r4[0x8],r8
8001b2a6:	e0 80 01 0b 	breq	8001b4bc <__sfvwrite_r+0x290>
8001b2aa:	18 03       	add	r3,r12
8001b2ac:	ce 9b       	rjmp	8001b27e <__sfvwrite_r+0x52>
8001b2ae:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8001b2b2:	c0 70       	breq	8001b2c0 <__sfvwrite_r+0x94>
8001b2b4:	50 06       	stdsp	sp[0x0],r6
8001b2b6:	0c 93       	mov	r3,r6
8001b2b8:	0c 91       	mov	r1,r6
8001b2ba:	50 15       	stdsp	sp[0x4],r5
8001b2bc:	08 92       	mov	r2,r4
8001b2be:	c9 d8       	rjmp	8001b3f8 <__sfvwrite_r+0x1cc>
8001b2c0:	06 96       	mov	r6,r3
8001b2c2:	08 91       	mov	r1,r4
8001b2c4:	c0 48       	rjmp	8001b2cc <__sfvwrite_r+0xa0>
8001b2c6:	60 03       	ld.w	r3,r0[0x0]
8001b2c8:	60 16       	ld.w	r6,r0[0x4]
8001b2ca:	2f 80       	sub	r0,-8
8001b2cc:	58 06       	cp.w	r6,0
8001b2ce:	cf c0       	breq	8001b2c6 <__sfvwrite_r+0x9a>
8001b2d0:	8e 68       	ld.sh	r8,r7[0xc]
8001b2d2:	6e 24       	ld.w	r4,r7[0x8]
8001b2d4:	10 99       	mov	r9,r8
8001b2d6:	e2 19 02 00 	andl	r9,0x200,COH
8001b2da:	c5 60       	breq	8001b386 <__sfvwrite_r+0x15a>
8001b2dc:	08 36       	cp.w	r6,r4
8001b2de:	c4 53       	brcs	8001b368 <__sfvwrite_r+0x13c>
8001b2e0:	10 99       	mov	r9,r8
8001b2e2:	e2 19 04 80 	andl	r9,0x480,COH
8001b2e6:	c4 10       	breq	8001b368 <__sfvwrite_r+0x13c>
8001b2e8:	6e 4b       	ld.w	r11,r7[0x10]
8001b2ea:	6e 09       	ld.w	r9,r7[0x0]
8001b2ec:	16 19       	sub	r9,r11
8001b2ee:	50 09       	stdsp	sp[0x0],r9
8001b2f0:	6e 59       	ld.w	r9,r7[0x14]
8001b2f2:	10 9c       	mov	r12,r8
8001b2f4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8001b2f8:	30 28       	mov	r8,2
8001b2fa:	f4 08 0c 08 	divs	r8,r10,r8
8001b2fe:	fa e9 00 04 	st.d	sp[4],r8
8001b302:	10 94       	mov	r4,r8
8001b304:	40 09       	lddsp	r9,sp[0x0]
8001b306:	e2 1c 04 00 	andl	r12,0x400,COH
8001b30a:	2f f9       	sub	r9,-1
8001b30c:	0c 09       	add	r9,r6
8001b30e:	12 38       	cp.w	r8,r9
8001b310:	f2 04 17 30 	movlo	r4,r9
8001b314:	58 0c       	cp.w	r12,0
8001b316:	c1 10       	breq	8001b338 <__sfvwrite_r+0x10c>
8001b318:	08 9b       	mov	r11,r4
8001b31a:	0a 9c       	mov	r12,r5
8001b31c:	fe b0 e1 0c 	rcall	80017534 <_malloc_r>
8001b320:	18 92       	mov	r2,r12
8001b322:	c1 50       	breq	8001b34c <__sfvwrite_r+0x120>
8001b324:	40 0a       	lddsp	r10,sp[0x0]
8001b326:	6e 4b       	ld.w	r11,r7[0x10]
8001b328:	fe b0 e3 1c 	rcall	80017960 <memcpy>
8001b32c:	8e 68       	ld.sh	r8,r7[0xc]
8001b32e:	e0 18 fb 7f 	andl	r8,0xfb7f
8001b332:	a7 b8       	sbr	r8,0x7
8001b334:	ae 68       	st.h	r7[0xc],r8
8001b336:	c0 e8       	rjmp	8001b352 <__sfvwrite_r+0x126>
8001b338:	08 9a       	mov	r10,r4
8001b33a:	0a 9c       	mov	r12,r5
8001b33c:	e0 a0 04 0c 	rcall	8001bb54 <_realloc_r>
8001b340:	18 92       	mov	r2,r12
8001b342:	c0 81       	brne	8001b352 <__sfvwrite_r+0x126>
8001b344:	6e 4b       	ld.w	r11,r7[0x10]
8001b346:	0a 9c       	mov	r12,r5
8001b348:	fe b0 dd e6 	rcall	80016f14 <_free_r>
8001b34c:	30 c8       	mov	r8,12
8001b34e:	8b 38       	st.w	r5[0xc],r8
8001b350:	cb 18       	rjmp	8001b4b2 <__sfvwrite_r+0x286>
8001b352:	40 0a       	lddsp	r10,sp[0x0]
8001b354:	40 09       	lddsp	r9,sp[0x0]
8001b356:	e8 0a 01 0a 	sub	r10,r4,r10
8001b35a:	e4 09 00 08 	add	r8,r2,r9
8001b35e:	8f 54       	st.w	r7[0x14],r4
8001b360:	8f 2a       	st.w	r7[0x8],r10
8001b362:	8f 08       	st.w	r7[0x0],r8
8001b364:	8f 42       	st.w	r7[0x10],r2
8001b366:	0c 94       	mov	r4,r6
8001b368:	08 36       	cp.w	r6,r4
8001b36a:	ec 04 17 30 	movlo	r4,r6
8001b36e:	06 9b       	mov	r11,r3
8001b370:	08 9a       	mov	r10,r4
8001b372:	6e 0c       	ld.w	r12,r7[0x0]
8001b374:	cd 5c       	rcall	8001b51e <memmove>
8001b376:	6e 08       	ld.w	r8,r7[0x0]
8001b378:	08 08       	add	r8,r4
8001b37a:	8f 08       	st.w	r7[0x0],r8
8001b37c:	6e 28       	ld.w	r8,r7[0x8]
8001b37e:	08 18       	sub	r8,r4
8001b380:	0c 94       	mov	r4,r6
8001b382:	8f 28       	st.w	r7[0x8],r8
8001b384:	c2 e8       	rjmp	8001b3e0 <__sfvwrite_r+0x1b4>
8001b386:	08 36       	cp.w	r6,r4
8001b388:	5f ba       	srhi	r10
8001b38a:	6e 0c       	ld.w	r12,r7[0x0]
8001b38c:	6e 48       	ld.w	r8,r7[0x10]
8001b38e:	10 3c       	cp.w	r12,r8
8001b390:	5f b8       	srhi	r8
8001b392:	f5 e8 00 08 	and	r8,r10,r8
8001b396:	f2 08 18 00 	cp.b	r8,r9
8001b39a:	c0 d0       	breq	8001b3b4 <__sfvwrite_r+0x188>
8001b39c:	06 9b       	mov	r11,r3
8001b39e:	08 9a       	mov	r10,r4
8001b3a0:	cb fc       	rcall	8001b51e <memmove>
8001b3a2:	6e 08       	ld.w	r8,r7[0x0]
8001b3a4:	08 08       	add	r8,r4
8001b3a6:	0e 9b       	mov	r11,r7
8001b3a8:	8f 08       	st.w	r7[0x0],r8
8001b3aa:	0a 9c       	mov	r12,r5
8001b3ac:	fe b0 db 84 	rcall	80016ab4 <_fflush_r>
8001b3b0:	c1 80       	breq	8001b3e0 <__sfvwrite_r+0x1b4>
8001b3b2:	c8 08       	rjmp	8001b4b2 <__sfvwrite_r+0x286>
8001b3b4:	6e 59       	ld.w	r9,r7[0x14]
8001b3b6:	12 36       	cp.w	r6,r9
8001b3b8:	c0 a3       	brcs	8001b3cc <__sfvwrite_r+0x1a0>
8001b3ba:	6e a8       	ld.w	r8,r7[0x28]
8001b3bc:	06 9a       	mov	r10,r3
8001b3be:	6e 8b       	ld.w	r11,r7[0x20]
8001b3c0:	0a 9c       	mov	r12,r5
8001b3c2:	5d 18       	icall	r8
8001b3c4:	18 94       	mov	r4,r12
8001b3c6:	e0 89 00 0d 	brgt	8001b3e0 <__sfvwrite_r+0x1b4>
8001b3ca:	c7 48       	rjmp	8001b4b2 <__sfvwrite_r+0x286>
8001b3cc:	0c 9a       	mov	r10,r6
8001b3ce:	06 9b       	mov	r11,r3
8001b3d0:	ca 7c       	rcall	8001b51e <memmove>
8001b3d2:	6e 08       	ld.w	r8,r7[0x0]
8001b3d4:	0c 08       	add	r8,r6
8001b3d6:	0c 94       	mov	r4,r6
8001b3d8:	8f 08       	st.w	r7[0x0],r8
8001b3da:	6e 28       	ld.w	r8,r7[0x8]
8001b3dc:	0c 18       	sub	r8,r6
8001b3de:	8f 28       	st.w	r7[0x8],r8
8001b3e0:	62 28       	ld.w	r8,r1[0x8]
8001b3e2:	08 18       	sub	r8,r4
8001b3e4:	83 28       	st.w	r1[0x8],r8
8001b3e6:	c6 b0       	breq	8001b4bc <__sfvwrite_r+0x290>
8001b3e8:	08 16       	sub	r6,r4
8001b3ea:	08 03       	add	r3,r4
8001b3ec:	c7 0b       	rjmp	8001b2cc <__sfvwrite_r+0xa0>
8001b3ee:	60 03       	ld.w	r3,r0[0x0]
8001b3f0:	60 11       	ld.w	r1,r0[0x4]
8001b3f2:	30 08       	mov	r8,0
8001b3f4:	2f 80       	sub	r0,-8
8001b3f6:	50 08       	stdsp	sp[0x0],r8
8001b3f8:	58 01       	cp.w	r1,0
8001b3fa:	cf a0       	breq	8001b3ee <__sfvwrite_r+0x1c2>
8001b3fc:	40 0a       	lddsp	r10,sp[0x0]
8001b3fe:	58 0a       	cp.w	r10,0
8001b400:	c1 41       	brne	8001b428 <__sfvwrite_r+0x1fc>
8001b402:	e2 c6 ff ff 	sub	r6,r1,-1
8001b406:	02 9a       	mov	r10,r1
8001b408:	30 ab       	mov	r11,10
8001b40a:	06 9c       	mov	r12,r3
8001b40c:	c7 ec       	rcall	8001b508 <memchr>
8001b40e:	f8 c8 ff ff 	sub	r8,r12,-1
8001b412:	58 0c       	cp.w	r12,0
8001b414:	f1 d3 e1 16 	subne	r6,r8,r3
8001b418:	f9 b9 01 01 	movne	r9,1
8001b41c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8001b420:	f9 b8 00 01 	moveq	r8,1
8001b424:	fb f8 0a 00 	st.weq	sp[0x0],r8
8001b428:	02 36       	cp.w	r6,r1
8001b42a:	ec 04 17 80 	movls	r4,r6
8001b42e:	e2 04 17 b0 	movhi	r4,r1
8001b432:	6e 59       	ld.w	r9,r7[0x14]
8001b434:	6e 25       	ld.w	r5,r7[0x8]
8001b436:	f2 05 00 05 	add	r5,r9,r5
8001b43a:	0a 34       	cp.w	r4,r5
8001b43c:	5f 9a       	srgt	r10
8001b43e:	6e 0c       	ld.w	r12,r7[0x0]
8001b440:	6e 48       	ld.w	r8,r7[0x10]
8001b442:	10 3c       	cp.w	r12,r8
8001b444:	5f b8       	srhi	r8
8001b446:	f5 e8 00 08 	and	r8,r10,r8
8001b44a:	30 0a       	mov	r10,0
8001b44c:	f4 08 18 00 	cp.b	r8,r10
8001b450:	c0 d0       	breq	8001b46a <__sfvwrite_r+0x23e>
8001b452:	06 9b       	mov	r11,r3
8001b454:	0a 9a       	mov	r10,r5
8001b456:	c6 4c       	rcall	8001b51e <memmove>
8001b458:	6e 08       	ld.w	r8,r7[0x0]
8001b45a:	0a 08       	add	r8,r5
8001b45c:	0e 9b       	mov	r11,r7
8001b45e:	8f 08       	st.w	r7[0x0],r8
8001b460:	40 1c       	lddsp	r12,sp[0x4]
8001b462:	fe b0 db 29 	rcall	80016ab4 <_fflush_r>
8001b466:	c1 70       	breq	8001b494 <__sfvwrite_r+0x268>
8001b468:	c2 58       	rjmp	8001b4b2 <__sfvwrite_r+0x286>
8001b46a:	12 34       	cp.w	r4,r9
8001b46c:	c0 a5       	brlt	8001b480 <__sfvwrite_r+0x254>
8001b46e:	6e a8       	ld.w	r8,r7[0x28]
8001b470:	06 9a       	mov	r10,r3
8001b472:	6e 8b       	ld.w	r11,r7[0x20]
8001b474:	40 1c       	lddsp	r12,sp[0x4]
8001b476:	5d 18       	icall	r8
8001b478:	18 95       	mov	r5,r12
8001b47a:	e0 89 00 0d 	brgt	8001b494 <__sfvwrite_r+0x268>
8001b47e:	c1 a8       	rjmp	8001b4b2 <__sfvwrite_r+0x286>
8001b480:	08 9a       	mov	r10,r4
8001b482:	06 9b       	mov	r11,r3
8001b484:	c4 dc       	rcall	8001b51e <memmove>
8001b486:	6e 08       	ld.w	r8,r7[0x0]
8001b488:	08 08       	add	r8,r4
8001b48a:	08 95       	mov	r5,r4
8001b48c:	8f 08       	st.w	r7[0x0],r8
8001b48e:	6e 28       	ld.w	r8,r7[0x8]
8001b490:	08 18       	sub	r8,r4
8001b492:	8f 28       	st.w	r7[0x8],r8
8001b494:	0a 16       	sub	r6,r5
8001b496:	c0 71       	brne	8001b4a4 <__sfvwrite_r+0x278>
8001b498:	0e 9b       	mov	r11,r7
8001b49a:	40 1c       	lddsp	r12,sp[0x4]
8001b49c:	fe b0 db 0c 	rcall	80016ab4 <_fflush_r>
8001b4a0:	c0 91       	brne	8001b4b2 <__sfvwrite_r+0x286>
8001b4a2:	50 06       	stdsp	sp[0x0],r6
8001b4a4:	64 28       	ld.w	r8,r2[0x8]
8001b4a6:	0a 18       	sub	r8,r5
8001b4a8:	85 28       	st.w	r2[0x8],r8
8001b4aa:	c0 90       	breq	8001b4bc <__sfvwrite_r+0x290>
8001b4ac:	0a 11       	sub	r1,r5
8001b4ae:	0a 03       	add	r3,r5
8001b4b0:	ca 4b       	rjmp	8001b3f8 <__sfvwrite_r+0x1cc>
8001b4b2:	8e 68       	ld.sh	r8,r7[0xc]
8001b4b4:	a7 a8       	sbr	r8,0x6
8001b4b6:	ae 68       	st.h	r7[0xc],r8
8001b4b8:	3f fc       	mov	r12,-1
8001b4ba:	c0 28       	rjmp	8001b4be <__sfvwrite_r+0x292>
8001b4bc:	30 0c       	mov	r12,0
8001b4be:	2f dd       	sub	sp,-12
8001b4c0:	d8 32       	popm	r0-r7,pc
8001b4c2:	d7 03       	nop

8001b4c4 <_localeconv_r>:
8001b4c4:	48 1c       	lddpc	r12,8001b4c8 <_localeconv_r+0x4>
8001b4c6:	5e fc       	retal	r12
8001b4c8:	80 07       	ld.sh	r7,r0[0x0]
8001b4ca:	0e 70       	tst	r0,r7

8001b4cc <_lseek_r>:
8001b4cc:	d4 21       	pushm	r4-r7,lr
8001b4ce:	16 98       	mov	r8,r11
8001b4d0:	18 97       	mov	r7,r12
8001b4d2:	10 9c       	mov	r12,r8
8001b4d4:	30 08       	mov	r8,0
8001b4d6:	14 9b       	mov	r11,r10
8001b4d8:	48 66       	lddpc	r6,8001b4f0 <_lseek_r+0x24>
8001b4da:	12 9a       	mov	r10,r9
8001b4dc:	8d 08       	st.w	r6[0x0],r8
8001b4de:	fe b0 e5 67 	rcall	80017fac <_lseek>
8001b4e2:	5b fc       	cp.w	r12,-1
8001b4e4:	c0 51       	brne	8001b4ee <_lseek_r+0x22>
8001b4e6:	6c 08       	ld.w	r8,r6[0x0]
8001b4e8:	58 08       	cp.w	r8,0
8001b4ea:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001b4ee:	d8 22       	popm	r4-r7,pc
8001b4f0:	00 00       	add	r0,r0
8001b4f2:	4f 74       	lddpc	r4,8001b6cc <_Balloc+0x20>

8001b4f4 <malloc>:
8001b4f4:	d4 01       	pushm	lr
8001b4f6:	48 48       	lddpc	r8,8001b504 <malloc+0x10>
8001b4f8:	18 9b       	mov	r11,r12
8001b4fa:	70 0c       	ld.w	r12,r8[0x0]
8001b4fc:	fe b0 e0 1c 	rcall	80017534 <_malloc_r>
8001b500:	d8 02       	popm	pc
8001b502:	d7 03       	nop
8001b504:	00 00       	add	r0,r0
8001b506:	01 9c       	ld.ub	r12,r0[0x1]

8001b508 <memchr>:
8001b508:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8001b50c:	c0 68       	rjmp	8001b518 <memchr+0x10>
8001b50e:	20 1a       	sub	r10,1
8001b510:	19 88       	ld.ub	r8,r12[0x0]
8001b512:	16 38       	cp.w	r8,r11
8001b514:	5e 0c       	reteq	r12
8001b516:	2f fc       	sub	r12,-1
8001b518:	58 0a       	cp.w	r10,0
8001b51a:	cf a1       	brne	8001b50e <memchr+0x6>
8001b51c:	5e fa       	retal	r10

8001b51e <memmove>:
8001b51e:	d4 01       	pushm	lr
8001b520:	18 3b       	cp.w	r11,r12
8001b522:	c1 92       	brcc	8001b554 <memmove+0x36>
8001b524:	f6 0a 00 09 	add	r9,r11,r10
8001b528:	12 3c       	cp.w	r12,r9
8001b52a:	c1 52       	brcc	8001b554 <memmove+0x36>
8001b52c:	f8 0a 00 0b 	add	r11,r12,r10
8001b530:	30 08       	mov	r8,0
8001b532:	c0 68       	rjmp	8001b53e <memmove+0x20>
8001b534:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8001b538:	20 1a       	sub	r10,1
8001b53a:	f6 08 0b 0e 	st.b	r11[r8],lr
8001b53e:	20 18       	sub	r8,1
8001b540:	58 0a       	cp.w	r10,0
8001b542:	cf 91       	brne	8001b534 <memmove+0x16>
8001b544:	d8 02       	popm	pc
8001b546:	f6 08 07 09 	ld.ub	r9,r11[r8]
8001b54a:	20 1a       	sub	r10,1
8001b54c:	f8 08 0b 09 	st.b	r12[r8],r9
8001b550:	2f f8       	sub	r8,-1
8001b552:	c0 28       	rjmp	8001b556 <memmove+0x38>
8001b554:	30 08       	mov	r8,0
8001b556:	58 0a       	cp.w	r10,0
8001b558:	cf 71       	brne	8001b546 <memmove+0x28>
8001b55a:	d8 02       	popm	pc

8001b55c <__hi0bits>:
8001b55c:	18 98       	mov	r8,r12
8001b55e:	e0 1c 00 00 	andl	r12,0x0
8001b562:	f0 09 15 10 	lsl	r9,r8,0x10
8001b566:	58 0c       	cp.w	r12,0
8001b568:	f2 08 17 00 	moveq	r8,r9
8001b56c:	f9 bc 00 10 	moveq	r12,16
8001b570:	f9 bc 01 00 	movne	r12,0
8001b574:	10 9a       	mov	r10,r8
8001b576:	f0 09 15 08 	lsl	r9,r8,0x8
8001b57a:	e6 1a ff 00 	andh	r10,0xff00,COH
8001b57e:	f7 bc 00 f8 	subeq	r12,-8
8001b582:	f2 08 17 00 	moveq	r8,r9
8001b586:	10 9a       	mov	r10,r8
8001b588:	f0 09 15 04 	lsl	r9,r8,0x4
8001b58c:	e6 1a f0 00 	andh	r10,0xf000,COH
8001b590:	f7 bc 00 fc 	subeq	r12,-4
8001b594:	f2 08 17 00 	moveq	r8,r9
8001b598:	10 9a       	mov	r10,r8
8001b59a:	f0 09 15 02 	lsl	r9,r8,0x2
8001b59e:	e6 1a c0 00 	andh	r10,0xc000,COH
8001b5a2:	f7 bc 00 fe 	subeq	r12,-2
8001b5a6:	f2 08 17 00 	moveq	r8,r9
8001b5aa:	58 08       	cp.w	r8,0
8001b5ac:	5e 5c       	retlt	r12
8001b5ae:	ed b8 00 1e 	bld	r8,0x1e
8001b5b2:	f9 bc 01 20 	movne	r12,32
8001b5b6:	f7 bc 00 ff 	subeq	r12,-1
8001b5ba:	5e fc       	retal	r12

8001b5bc <__lo0bits>:
8001b5bc:	18 99       	mov	r9,r12
8001b5be:	78 08       	ld.w	r8,r12[0x0]
8001b5c0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8001b5c4:	c1 50       	breq	8001b5ee <__lo0bits+0x32>
8001b5c6:	ed b8 00 00 	bld	r8,0x0
8001b5ca:	c0 21       	brne	8001b5ce <__lo0bits+0x12>
8001b5cc:	5e fd       	retal	0
8001b5ce:	10 9b       	mov	r11,r8
8001b5d0:	f0 0a 16 01 	lsr	r10,r8,0x1
8001b5d4:	e2 1b 00 02 	andl	r11,0x2,COH
8001b5d8:	a3 88       	lsr	r8,0x2
8001b5da:	58 0b       	cp.w	r11,0
8001b5dc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8001b5e0:	f9 bc 01 01 	movne	r12,1
8001b5e4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8001b5e8:	f9 bc 00 02 	moveq	r12,2
8001b5ec:	5e fc       	retal	r12
8001b5ee:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8001b5f2:	f0 0b 16 10 	lsr	r11,r8,0x10
8001b5f6:	58 0a       	cp.w	r10,0
8001b5f8:	f6 08 17 00 	moveq	r8,r11
8001b5fc:	f9 bc 00 10 	moveq	r12,16
8001b600:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8001b604:	f0 0a 16 08 	lsr	r10,r8,0x8
8001b608:	58 0b       	cp.w	r11,0
8001b60a:	f7 bc 00 f8 	subeq	r12,-8
8001b60e:	f4 08 17 00 	moveq	r8,r10
8001b612:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8001b616:	f0 0a 16 04 	lsr	r10,r8,0x4
8001b61a:	58 0b       	cp.w	r11,0
8001b61c:	f7 bc 00 fc 	subeq	r12,-4
8001b620:	f4 08 17 00 	moveq	r8,r10
8001b624:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8001b628:	f0 0a 16 02 	lsr	r10,r8,0x2
8001b62c:	58 0b       	cp.w	r11,0
8001b62e:	f7 bc 00 fe 	subeq	r12,-2
8001b632:	f4 08 17 00 	moveq	r8,r10
8001b636:	ed b8 00 00 	bld	r8,0x0
8001b63a:	c0 60       	breq	8001b646 <__lo0bits+0x8a>
8001b63c:	a1 98       	lsr	r8,0x1
8001b63e:	c0 31       	brne	8001b644 <__lo0bits+0x88>
8001b640:	32 0c       	mov	r12,32
8001b642:	5e fc       	retal	r12
8001b644:	2f fc       	sub	r12,-1
8001b646:	93 08       	st.w	r9[0x0],r8
8001b648:	5e fc       	retal	r12

8001b64a <__mcmp>:
8001b64a:	d4 01       	pushm	lr
8001b64c:	18 98       	mov	r8,r12
8001b64e:	76 49       	ld.w	r9,r11[0x10]
8001b650:	78 4c       	ld.w	r12,r12[0x10]
8001b652:	12 1c       	sub	r12,r9
8001b654:	c1 31       	brne	8001b67a <__mcmp+0x30>
8001b656:	2f b9       	sub	r9,-5
8001b658:	a3 69       	lsl	r9,0x2
8001b65a:	12 0b       	add	r11,r9
8001b65c:	f0 09 00 09 	add	r9,r8,r9
8001b660:	2e c8       	sub	r8,-20
8001b662:	13 4e       	ld.w	lr,--r9
8001b664:	17 4a       	ld.w	r10,--r11
8001b666:	14 3e       	cp.w	lr,r10
8001b668:	c0 60       	breq	8001b674 <__mcmp+0x2a>
8001b66a:	f9 bc 03 ff 	movlo	r12,-1
8001b66e:	f9 bc 02 01 	movhs	r12,1
8001b672:	d8 02       	popm	pc
8001b674:	10 39       	cp.w	r9,r8
8001b676:	fe 9b ff f6 	brhi	8001b662 <__mcmp+0x18>
8001b67a:	d8 02       	popm	pc

8001b67c <_Bfree>:
8001b67c:	d4 21       	pushm	r4-r7,lr
8001b67e:	18 97       	mov	r7,r12
8001b680:	16 95       	mov	r5,r11
8001b682:	78 96       	ld.w	r6,r12[0x24]
8001b684:	58 06       	cp.w	r6,0
8001b686:	c0 81       	brne	8001b696 <_Bfree+0x1a>
8001b688:	31 0c       	mov	r12,16
8001b68a:	c3 5f       	rcall	8001b4f4 <malloc>
8001b68c:	99 36       	st.w	r12[0xc],r6
8001b68e:	8f 9c       	st.w	r7[0x24],r12
8001b690:	99 16       	st.w	r12[0x4],r6
8001b692:	99 26       	st.w	r12[0x8],r6
8001b694:	99 06       	st.w	r12[0x0],r6
8001b696:	58 05       	cp.w	r5,0
8001b698:	c0 90       	breq	8001b6aa <_Bfree+0x2e>
8001b69a:	6a 19       	ld.w	r9,r5[0x4]
8001b69c:	6e 98       	ld.w	r8,r7[0x24]
8001b69e:	70 38       	ld.w	r8,r8[0xc]
8001b6a0:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8001b6a4:	8b 0a       	st.w	r5[0x0],r10
8001b6a6:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8001b6aa:	d8 22       	popm	r4-r7,pc

8001b6ac <_Balloc>:
8001b6ac:	d4 21       	pushm	r4-r7,lr
8001b6ae:	18 97       	mov	r7,r12
8001b6b0:	16 96       	mov	r6,r11
8001b6b2:	78 95       	ld.w	r5,r12[0x24]
8001b6b4:	58 05       	cp.w	r5,0
8001b6b6:	c0 81       	brne	8001b6c6 <_Balloc+0x1a>
8001b6b8:	31 0c       	mov	r12,16
8001b6ba:	c1 df       	rcall	8001b4f4 <malloc>
8001b6bc:	99 35       	st.w	r12[0xc],r5
8001b6be:	8f 9c       	st.w	r7[0x24],r12
8001b6c0:	99 15       	st.w	r12[0x4],r5
8001b6c2:	99 25       	st.w	r12[0x8],r5
8001b6c4:	99 05       	st.w	r12[0x0],r5
8001b6c6:	6e 95       	ld.w	r5,r7[0x24]
8001b6c8:	6a 38       	ld.w	r8,r5[0xc]
8001b6ca:	58 08       	cp.w	r8,0
8001b6cc:	c0 b1       	brne	8001b6e2 <_Balloc+0x36>
8001b6ce:	31 0a       	mov	r10,16
8001b6d0:	30 4b       	mov	r11,4
8001b6d2:	0e 9c       	mov	r12,r7
8001b6d4:	e0 a0 03 c6 	rcall	8001be60 <_calloc_r>
8001b6d8:	8b 3c       	st.w	r5[0xc],r12
8001b6da:	6e 98       	ld.w	r8,r7[0x24]
8001b6dc:	70 3c       	ld.w	r12,r8[0xc]
8001b6de:	58 0c       	cp.w	r12,0
8001b6e0:	c1 b0       	breq	8001b716 <_Balloc+0x6a>
8001b6e2:	6e 98       	ld.w	r8,r7[0x24]
8001b6e4:	70 38       	ld.w	r8,r8[0xc]
8001b6e6:	f0 06 00 28 	add	r8,r8,r6<<0x2
8001b6ea:	70 0c       	ld.w	r12,r8[0x0]
8001b6ec:	58 0c       	cp.w	r12,0
8001b6ee:	c0 40       	breq	8001b6f6 <_Balloc+0x4a>
8001b6f0:	78 09       	ld.w	r9,r12[0x0]
8001b6f2:	91 09       	st.w	r8[0x0],r9
8001b6f4:	c0 e8       	rjmp	8001b710 <_Balloc+0x64>
8001b6f6:	0e 9c       	mov	r12,r7
8001b6f8:	30 17       	mov	r7,1
8001b6fa:	0e 9b       	mov	r11,r7
8001b6fc:	ee 06 09 47 	lsl	r7,r7,r6
8001b700:	ee ca ff fb 	sub	r10,r7,-5
8001b704:	a3 6a       	lsl	r10,0x2
8001b706:	e0 a0 03 ad 	rcall	8001be60 <_calloc_r>
8001b70a:	c0 60       	breq	8001b716 <_Balloc+0x6a>
8001b70c:	99 16       	st.w	r12[0x4],r6
8001b70e:	99 27       	st.w	r12[0x8],r7
8001b710:	30 08       	mov	r8,0
8001b712:	99 38       	st.w	r12[0xc],r8
8001b714:	99 48       	st.w	r12[0x10],r8
8001b716:	d8 22       	popm	r4-r7,pc

8001b718 <__d2b>:
8001b718:	d4 31       	pushm	r0-r7,lr
8001b71a:	20 2d       	sub	sp,8
8001b71c:	16 93       	mov	r3,r11
8001b71e:	12 96       	mov	r6,r9
8001b720:	10 95       	mov	r5,r8
8001b722:	14 92       	mov	r2,r10
8001b724:	30 1b       	mov	r11,1
8001b726:	cc 3f       	rcall	8001b6ac <_Balloc>
8001b728:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8001b72c:	50 09       	stdsp	sp[0x0],r9
8001b72e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8001b732:	b5 a9       	sbr	r9,0x14
8001b734:	f0 01 16 14 	lsr	r1,r8,0x14
8001b738:	fb f9 1a 00 	st.wne	sp[0x0],r9
8001b73c:	18 94       	mov	r4,r12
8001b73e:	58 02       	cp.w	r2,0
8001b740:	c1 d0       	breq	8001b77a <__d2b+0x62>
8001b742:	fa cc ff f8 	sub	r12,sp,-8
8001b746:	18 d2       	st.w	--r12,r2
8001b748:	c3 af       	rcall	8001b5bc <__lo0bits>
8001b74a:	40 18       	lddsp	r8,sp[0x4]
8001b74c:	c0 d0       	breq	8001b766 <__d2b+0x4e>
8001b74e:	40 09       	lddsp	r9,sp[0x0]
8001b750:	f8 0a 11 20 	rsub	r10,r12,32
8001b754:	f2 0a 09 4a 	lsl	r10,r9,r10
8001b758:	f5 e8 10 08 	or	r8,r10,r8
8001b75c:	89 58       	st.w	r4[0x14],r8
8001b75e:	f2 0c 0a 49 	lsr	r9,r9,r12
8001b762:	50 09       	stdsp	sp[0x0],r9
8001b764:	c0 28       	rjmp	8001b768 <__d2b+0x50>
8001b766:	89 58       	st.w	r4[0x14],r8
8001b768:	40 08       	lddsp	r8,sp[0x0]
8001b76a:	58 08       	cp.w	r8,0
8001b76c:	f9 b3 01 02 	movne	r3,2
8001b770:	f9 b3 00 01 	moveq	r3,1
8001b774:	89 68       	st.w	r4[0x18],r8
8001b776:	89 43       	st.w	r4[0x10],r3
8001b778:	c0 88       	rjmp	8001b788 <__d2b+0x70>
8001b77a:	1a 9c       	mov	r12,sp
8001b77c:	c2 0f       	rcall	8001b5bc <__lo0bits>
8001b77e:	30 13       	mov	r3,1
8001b780:	40 08       	lddsp	r8,sp[0x0]
8001b782:	2e 0c       	sub	r12,-32
8001b784:	89 43       	st.w	r4[0x10],r3
8001b786:	89 58       	st.w	r4[0x14],r8
8001b788:	58 01       	cp.w	r1,0
8001b78a:	c0 90       	breq	8001b79c <__d2b+0x84>
8001b78c:	e2 c1 04 33 	sub	r1,r1,1075
8001b790:	18 01       	add	r1,r12
8001b792:	8d 01       	st.w	r6[0x0],r1
8001b794:	f8 0c 11 35 	rsub	r12,r12,53
8001b798:	8b 0c       	st.w	r5[0x0],r12
8001b79a:	c0 c8       	rjmp	8001b7b2 <__d2b+0x9a>
8001b79c:	e6 c8 ff fc 	sub	r8,r3,-4
8001b7a0:	f8 cc 04 32 	sub	r12,r12,1074
8001b7a4:	a5 73       	lsl	r3,0x5
8001b7a6:	8d 0c       	st.w	r6[0x0],r12
8001b7a8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8001b7ac:	cd 8e       	rcall	8001b55c <__hi0bits>
8001b7ae:	18 13       	sub	r3,r12
8001b7b0:	8b 03       	st.w	r5[0x0],r3
8001b7b2:	08 9c       	mov	r12,r4
8001b7b4:	2f ed       	sub	sp,-8
8001b7b6:	d8 32       	popm	r0-r7,pc

8001b7b8 <__mdiff>:
8001b7b8:	d4 31       	pushm	r0-r7,lr
8001b7ba:	74 48       	ld.w	r8,r10[0x10]
8001b7bc:	76 45       	ld.w	r5,r11[0x10]
8001b7be:	16 97       	mov	r7,r11
8001b7c0:	14 96       	mov	r6,r10
8001b7c2:	10 15       	sub	r5,r8
8001b7c4:	c1 31       	brne	8001b7ea <__mdiff+0x32>
8001b7c6:	2f b8       	sub	r8,-5
8001b7c8:	ee ce ff ec 	sub	lr,r7,-20
8001b7cc:	a3 68       	lsl	r8,0x2
8001b7ce:	f4 08 00 0b 	add	r11,r10,r8
8001b7d2:	ee 08 00 08 	add	r8,r7,r8
8001b7d6:	11 4a       	ld.w	r10,--r8
8001b7d8:	17 49       	ld.w	r9,--r11
8001b7da:	12 3a       	cp.w	r10,r9
8001b7dc:	c0 30       	breq	8001b7e2 <__mdiff+0x2a>
8001b7de:	c0 e2       	brcc	8001b7fa <__mdiff+0x42>
8001b7e0:	c0 78       	rjmp	8001b7ee <__mdiff+0x36>
8001b7e2:	1c 38       	cp.w	r8,lr
8001b7e4:	fe 9b ff f9 	brhi	8001b7d6 <__mdiff+0x1e>
8001b7e8:	c4 98       	rjmp	8001b87a <__mdiff+0xc2>
8001b7ea:	58 05       	cp.w	r5,0
8001b7ec:	c0 64       	brge	8001b7f8 <__mdiff+0x40>
8001b7ee:	0e 98       	mov	r8,r7
8001b7f0:	30 15       	mov	r5,1
8001b7f2:	0c 97       	mov	r7,r6
8001b7f4:	10 96       	mov	r6,r8
8001b7f6:	c0 28       	rjmp	8001b7fa <__mdiff+0x42>
8001b7f8:	30 05       	mov	r5,0
8001b7fa:	6e 1b       	ld.w	r11,r7[0x4]
8001b7fc:	c5 8f       	rcall	8001b6ac <_Balloc>
8001b7fe:	6e 49       	ld.w	r9,r7[0x10]
8001b800:	6c 44       	ld.w	r4,r6[0x10]
8001b802:	99 35       	st.w	r12[0xc],r5
8001b804:	2f b4       	sub	r4,-5
8001b806:	f2 c5 ff fb 	sub	r5,r9,-5
8001b80a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8001b80e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8001b812:	2e c6       	sub	r6,-20
8001b814:	2e c7       	sub	r7,-20
8001b816:	f8 c8 ff ec 	sub	r8,r12,-20
8001b81a:	30 0a       	mov	r10,0
8001b81c:	0f 0e       	ld.w	lr,r7++
8001b81e:	0d 0b       	ld.w	r11,r6++
8001b820:	fc 02 16 10 	lsr	r2,lr,0x10
8001b824:	f6 03 16 10 	lsr	r3,r11,0x10
8001b828:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001b82c:	e4 03 01 03 	sub	r3,r2,r3
8001b830:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001b834:	fc 0b 01 0b 	sub	r11,lr,r11
8001b838:	f6 0a 00 0a 	add	r10,r11,r10
8001b83c:	b0 1a       	st.h	r8[0x2],r10
8001b83e:	b1 4a       	asr	r10,0x10
8001b840:	e6 0a 00 0a 	add	r10,r3,r10
8001b844:	b0 0a       	st.h	r8[0x0],r10
8001b846:	2f c8       	sub	r8,-4
8001b848:	b1 4a       	asr	r10,0x10
8001b84a:	08 36       	cp.w	r6,r4
8001b84c:	ce 83       	brcs	8001b81c <__mdiff+0x64>
8001b84e:	c0 d8       	rjmp	8001b868 <__mdiff+0xb0>
8001b850:	0f 0b       	ld.w	r11,r7++
8001b852:	f6 0e 16 10 	lsr	lr,r11,0x10
8001b856:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001b85a:	16 0a       	add	r10,r11
8001b85c:	b0 1a       	st.h	r8[0x2],r10
8001b85e:	b1 4a       	asr	r10,0x10
8001b860:	1c 0a       	add	r10,lr
8001b862:	b0 0a       	st.h	r8[0x0],r10
8001b864:	2f c8       	sub	r8,-4
8001b866:	b1 4a       	asr	r10,0x10
8001b868:	0a 37       	cp.w	r7,r5
8001b86a:	cf 33       	brcs	8001b850 <__mdiff+0x98>
8001b86c:	c0 28       	rjmp	8001b870 <__mdiff+0xb8>
8001b86e:	20 19       	sub	r9,1
8001b870:	11 4a       	ld.w	r10,--r8
8001b872:	58 0a       	cp.w	r10,0
8001b874:	cf d0       	breq	8001b86e <__mdiff+0xb6>
8001b876:	99 49       	st.w	r12[0x10],r9
8001b878:	d8 32       	popm	r0-r7,pc
8001b87a:	30 0b       	mov	r11,0
8001b87c:	c1 8f       	rcall	8001b6ac <_Balloc>
8001b87e:	30 18       	mov	r8,1
8001b880:	99 48       	st.w	r12[0x10],r8
8001b882:	30 08       	mov	r8,0
8001b884:	99 58       	st.w	r12[0x14],r8
8001b886:	d8 32       	popm	r0-r7,pc

8001b888 <__lshift>:
8001b888:	d4 31       	pushm	r0-r7,lr
8001b88a:	16 97       	mov	r7,r11
8001b88c:	76 46       	ld.w	r6,r11[0x10]
8001b88e:	f4 02 14 05 	asr	r2,r10,0x5
8001b892:	2f f6       	sub	r6,-1
8001b894:	14 93       	mov	r3,r10
8001b896:	18 94       	mov	r4,r12
8001b898:	04 06       	add	r6,r2
8001b89a:	76 1b       	ld.w	r11,r11[0x4]
8001b89c:	6e 28       	ld.w	r8,r7[0x8]
8001b89e:	c0 38       	rjmp	8001b8a4 <__lshift+0x1c>
8001b8a0:	2f fb       	sub	r11,-1
8001b8a2:	a1 78       	lsl	r8,0x1
8001b8a4:	10 36       	cp.w	r6,r8
8001b8a6:	fe 99 ff fd 	brgt	8001b8a0 <__lshift+0x18>
8001b8aa:	08 9c       	mov	r12,r4
8001b8ac:	c0 0f       	rcall	8001b6ac <_Balloc>
8001b8ae:	30 09       	mov	r9,0
8001b8b0:	18 95       	mov	r5,r12
8001b8b2:	f8 c8 ff ec 	sub	r8,r12,-20
8001b8b6:	12 9a       	mov	r10,r9
8001b8b8:	c0 38       	rjmp	8001b8be <__lshift+0x36>
8001b8ba:	10 aa       	st.w	r8++,r10
8001b8bc:	2f f9       	sub	r9,-1
8001b8be:	04 39       	cp.w	r9,r2
8001b8c0:	cf d5       	brlt	8001b8ba <__lshift+0x32>
8001b8c2:	6e 4b       	ld.w	r11,r7[0x10]
8001b8c4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8001b8c8:	2f bb       	sub	r11,-5
8001b8ca:	ee c9 ff ec 	sub	r9,r7,-20
8001b8ce:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8001b8d2:	58 03       	cp.w	r3,0
8001b8d4:	c1 30       	breq	8001b8fa <__lshift+0x72>
8001b8d6:	e6 0c 11 20 	rsub	r12,r3,32
8001b8da:	30 0a       	mov	r10,0
8001b8dc:	72 02       	ld.w	r2,r9[0x0]
8001b8de:	e4 03 09 42 	lsl	r2,r2,r3
8001b8e2:	04 4a       	or	r10,r2
8001b8e4:	10 aa       	st.w	r8++,r10
8001b8e6:	13 0a       	ld.w	r10,r9++
8001b8e8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8001b8ec:	16 39       	cp.w	r9,r11
8001b8ee:	cf 73       	brcs	8001b8dc <__lshift+0x54>
8001b8f0:	91 0a       	st.w	r8[0x0],r10
8001b8f2:	58 0a       	cp.w	r10,0
8001b8f4:	c0 70       	breq	8001b902 <__lshift+0x7a>
8001b8f6:	2f f6       	sub	r6,-1
8001b8f8:	c0 58       	rjmp	8001b902 <__lshift+0x7a>
8001b8fa:	13 0a       	ld.w	r10,r9++
8001b8fc:	10 aa       	st.w	r8++,r10
8001b8fe:	16 39       	cp.w	r9,r11
8001b900:	cf d3       	brcs	8001b8fa <__lshift+0x72>
8001b902:	08 9c       	mov	r12,r4
8001b904:	20 16       	sub	r6,1
8001b906:	0e 9b       	mov	r11,r7
8001b908:	8b 46       	st.w	r5[0x10],r6
8001b90a:	cb 9e       	rcall	8001b67c <_Bfree>
8001b90c:	0a 9c       	mov	r12,r5
8001b90e:	d8 32       	popm	r0-r7,pc

8001b910 <__multiply>:
8001b910:	d4 31       	pushm	r0-r7,lr
8001b912:	20 2d       	sub	sp,8
8001b914:	76 49       	ld.w	r9,r11[0x10]
8001b916:	74 48       	ld.w	r8,r10[0x10]
8001b918:	16 96       	mov	r6,r11
8001b91a:	14 95       	mov	r5,r10
8001b91c:	10 39       	cp.w	r9,r8
8001b91e:	ec 08 17 50 	movlt	r8,r6
8001b922:	ea 06 17 50 	movlt	r6,r5
8001b926:	f0 05 17 50 	movlt	r5,r8
8001b92a:	6c 28       	ld.w	r8,r6[0x8]
8001b92c:	76 43       	ld.w	r3,r11[0x10]
8001b92e:	74 42       	ld.w	r2,r10[0x10]
8001b930:	76 1b       	ld.w	r11,r11[0x4]
8001b932:	e4 03 00 07 	add	r7,r2,r3
8001b936:	10 37       	cp.w	r7,r8
8001b938:	f7 bb 09 ff 	subgt	r11,-1
8001b93c:	cb 8e       	rcall	8001b6ac <_Balloc>
8001b93e:	ee c4 ff fb 	sub	r4,r7,-5
8001b942:	f8 c9 ff ec 	sub	r9,r12,-20
8001b946:	f8 04 00 24 	add	r4,r12,r4<<0x2
8001b94a:	30 0a       	mov	r10,0
8001b94c:	12 98       	mov	r8,r9
8001b94e:	c0 28       	rjmp	8001b952 <__multiply+0x42>
8001b950:	10 aa       	st.w	r8++,r10
8001b952:	08 38       	cp.w	r8,r4
8001b954:	cf e3       	brcs	8001b950 <__multiply+0x40>
8001b956:	2f b3       	sub	r3,-5
8001b958:	2f b2       	sub	r2,-5
8001b95a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8001b95e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8001b962:	ec cb ff ec 	sub	r11,r6,-20
8001b966:	50 12       	stdsp	sp[0x4],r2
8001b968:	ea ca ff ec 	sub	r10,r5,-20
8001b96c:	c4 48       	rjmp	8001b9f4 <__multiply+0xe4>
8001b96e:	94 95       	ld.uh	r5,r10[0x2]
8001b970:	58 05       	cp.w	r5,0
8001b972:	c2 00       	breq	8001b9b2 <__multiply+0xa2>
8001b974:	12 98       	mov	r8,r9
8001b976:	16 96       	mov	r6,r11
8001b978:	30 0e       	mov	lr,0
8001b97a:	50 09       	stdsp	sp[0x0],r9
8001b97c:	0d 02       	ld.w	r2,r6++
8001b97e:	e4 00 16 10 	lsr	r0,r2,0x10
8001b982:	70 01       	ld.w	r1,r8[0x0]
8001b984:	70 09       	ld.w	r9,r8[0x0]
8001b986:	b1 81       	lsr	r1,0x10
8001b988:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8001b98c:	e0 05 03 41 	mac	r1,r0,r5
8001b990:	ab 32       	mul	r2,r5
8001b992:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8001b996:	00 02       	add	r2,r0
8001b998:	e4 0e 00 0e 	add	lr,r2,lr
8001b99c:	b0 1e       	st.h	r8[0x2],lr
8001b99e:	b1 8e       	lsr	lr,0x10
8001b9a0:	1c 01       	add	r1,lr
8001b9a2:	b0 01       	st.h	r8[0x0],r1
8001b9a4:	e2 0e 16 10 	lsr	lr,r1,0x10
8001b9a8:	2f c8       	sub	r8,-4
8001b9aa:	06 36       	cp.w	r6,r3
8001b9ac:	ce 83       	brcs	8001b97c <__multiply+0x6c>
8001b9ae:	40 09       	lddsp	r9,sp[0x0]
8001b9b0:	91 0e       	st.w	r8[0x0],lr
8001b9b2:	94 86       	ld.uh	r6,r10[0x0]
8001b9b4:	58 06       	cp.w	r6,0
8001b9b6:	c1 d0       	breq	8001b9f0 <__multiply+0xe0>
8001b9b8:	72 02       	ld.w	r2,r9[0x0]
8001b9ba:	12 98       	mov	r8,r9
8001b9bc:	16 9e       	mov	lr,r11
8001b9be:	30 05       	mov	r5,0
8001b9c0:	b0 12       	st.h	r8[0x2],r2
8001b9c2:	1d 01       	ld.w	r1,lr++
8001b9c4:	90 82       	ld.uh	r2,r8[0x0]
8001b9c6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8001b9ca:	ad 30       	mul	r0,r6
8001b9cc:	e0 02 00 02 	add	r2,r0,r2
8001b9d0:	e4 05 00 05 	add	r5,r2,r5
8001b9d4:	b0 05       	st.h	r8[0x0],r5
8001b9d6:	b1 85       	lsr	r5,0x10
8001b9d8:	b1 81       	lsr	r1,0x10
8001b9da:	2f c8       	sub	r8,-4
8001b9dc:	ad 31       	mul	r1,r6
8001b9de:	90 92       	ld.uh	r2,r8[0x2]
8001b9e0:	e2 02 00 02 	add	r2,r1,r2
8001b9e4:	0a 02       	add	r2,r5
8001b9e6:	e4 05 16 10 	lsr	r5,r2,0x10
8001b9ea:	06 3e       	cp.w	lr,r3
8001b9ec:	ce a3       	brcs	8001b9c0 <__multiply+0xb0>
8001b9ee:	91 02       	st.w	r8[0x0],r2
8001b9f0:	2f ca       	sub	r10,-4
8001b9f2:	2f c9       	sub	r9,-4
8001b9f4:	40 18       	lddsp	r8,sp[0x4]
8001b9f6:	10 3a       	cp.w	r10,r8
8001b9f8:	cb b3       	brcs	8001b96e <__multiply+0x5e>
8001b9fa:	c0 28       	rjmp	8001b9fe <__multiply+0xee>
8001b9fc:	20 17       	sub	r7,1
8001b9fe:	58 07       	cp.w	r7,0
8001ba00:	e0 8a 00 05 	brle	8001ba0a <__multiply+0xfa>
8001ba04:	09 48       	ld.w	r8,--r4
8001ba06:	58 08       	cp.w	r8,0
8001ba08:	cf a0       	breq	8001b9fc <__multiply+0xec>
8001ba0a:	99 47       	st.w	r12[0x10],r7
8001ba0c:	2f ed       	sub	sp,-8
8001ba0e:	d8 32       	popm	r0-r7,pc

8001ba10 <__i2b>:
8001ba10:	d4 21       	pushm	r4-r7,lr
8001ba12:	16 97       	mov	r7,r11
8001ba14:	30 1b       	mov	r11,1
8001ba16:	c4 be       	rcall	8001b6ac <_Balloc>
8001ba18:	30 19       	mov	r9,1
8001ba1a:	99 57       	st.w	r12[0x14],r7
8001ba1c:	99 49       	st.w	r12[0x10],r9
8001ba1e:	d8 22       	popm	r4-r7,pc

8001ba20 <__multadd>:
8001ba20:	d4 31       	pushm	r0-r7,lr
8001ba22:	30 08       	mov	r8,0
8001ba24:	12 95       	mov	r5,r9
8001ba26:	16 97       	mov	r7,r11
8001ba28:	18 96       	mov	r6,r12
8001ba2a:	76 44       	ld.w	r4,r11[0x10]
8001ba2c:	f6 c9 ff ec 	sub	r9,r11,-20
8001ba30:	72 0b       	ld.w	r11,r9[0x0]
8001ba32:	f6 0c 16 10 	lsr	r12,r11,0x10
8001ba36:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001ba3a:	f4 0c 02 4c 	mul	r12,r10,r12
8001ba3e:	f4 0b 03 45 	mac	r5,r10,r11
8001ba42:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8001ba46:	b1 85       	lsr	r5,0x10
8001ba48:	18 05       	add	r5,r12
8001ba4a:	ea 0c 15 10 	lsl	r12,r5,0x10
8001ba4e:	f8 0b 00 0b 	add	r11,r12,r11
8001ba52:	12 ab       	st.w	r9++,r11
8001ba54:	2f f8       	sub	r8,-1
8001ba56:	b1 85       	lsr	r5,0x10
8001ba58:	08 38       	cp.w	r8,r4
8001ba5a:	ce b5       	brlt	8001ba30 <__multadd+0x10>
8001ba5c:	58 05       	cp.w	r5,0
8001ba5e:	c1 c0       	breq	8001ba96 <__multadd+0x76>
8001ba60:	6e 28       	ld.w	r8,r7[0x8]
8001ba62:	10 34       	cp.w	r4,r8
8001ba64:	c1 35       	brlt	8001ba8a <__multadd+0x6a>
8001ba66:	6e 1b       	ld.w	r11,r7[0x4]
8001ba68:	0c 9c       	mov	r12,r6
8001ba6a:	2f fb       	sub	r11,-1
8001ba6c:	c2 0e       	rcall	8001b6ac <_Balloc>
8001ba6e:	6e 4a       	ld.w	r10,r7[0x10]
8001ba70:	ee cb ff f4 	sub	r11,r7,-12
8001ba74:	18 93       	mov	r3,r12
8001ba76:	2f ea       	sub	r10,-2
8001ba78:	2f 4c       	sub	r12,-12
8001ba7a:	a3 6a       	lsl	r10,0x2
8001ba7c:	fe b0 df 72 	rcall	80017960 <memcpy>
8001ba80:	0e 9b       	mov	r11,r7
8001ba82:	0c 9c       	mov	r12,r6
8001ba84:	fe b0 fd fc 	rcall	8001b67c <_Bfree>
8001ba88:	06 97       	mov	r7,r3
8001ba8a:	e8 c8 ff ff 	sub	r8,r4,-1
8001ba8e:	2f b4       	sub	r4,-5
8001ba90:	8f 48       	st.w	r7[0x10],r8
8001ba92:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8001ba96:	0e 9c       	mov	r12,r7
8001ba98:	d8 32       	popm	r0-r7,pc
8001ba9a:	d7 03       	nop

8001ba9c <__pow5mult>:
8001ba9c:	d4 31       	pushm	r0-r7,lr
8001ba9e:	14 96       	mov	r6,r10
8001baa0:	18 97       	mov	r7,r12
8001baa2:	16 94       	mov	r4,r11
8001baa4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8001baa8:	c0 80       	breq	8001bab8 <__pow5mult+0x1c>
8001baaa:	20 18       	sub	r8,1
8001baac:	49 f9       	lddpc	r9,8001bb28 <__pow5mult+0x8c>
8001baae:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8001bab2:	30 09       	mov	r9,0
8001bab4:	cb 6f       	rcall	8001ba20 <__multadd>
8001bab6:	18 94       	mov	r4,r12
8001bab8:	a3 46       	asr	r6,0x2
8001baba:	c3 40       	breq	8001bb22 <__pow5mult+0x86>
8001babc:	6e 95       	ld.w	r5,r7[0x24]
8001babe:	58 05       	cp.w	r5,0
8001bac0:	c0 91       	brne	8001bad2 <__pow5mult+0x36>
8001bac2:	31 0c       	mov	r12,16
8001bac4:	fe b0 fd 18 	rcall	8001b4f4 <malloc>
8001bac8:	99 35       	st.w	r12[0xc],r5
8001baca:	8f 9c       	st.w	r7[0x24],r12
8001bacc:	99 15       	st.w	r12[0x4],r5
8001bace:	99 25       	st.w	r12[0x8],r5
8001bad0:	99 05       	st.w	r12[0x0],r5
8001bad2:	6e 93       	ld.w	r3,r7[0x24]
8001bad4:	66 25       	ld.w	r5,r3[0x8]
8001bad6:	58 05       	cp.w	r5,0
8001bad8:	c0 c1       	brne	8001baf0 <__pow5mult+0x54>
8001bada:	e0 6b 02 71 	mov	r11,625
8001bade:	0e 9c       	mov	r12,r7
8001bae0:	c9 8f       	rcall	8001ba10 <__i2b>
8001bae2:	87 2c       	st.w	r3[0x8],r12
8001bae4:	30 08       	mov	r8,0
8001bae6:	18 95       	mov	r5,r12
8001bae8:	99 08       	st.w	r12[0x0],r8
8001baea:	c0 38       	rjmp	8001baf0 <__pow5mult+0x54>
8001baec:	06 9c       	mov	r12,r3
8001baee:	18 95       	mov	r5,r12
8001baf0:	ed b6 00 00 	bld	r6,0x0
8001baf4:	c0 b1       	brne	8001bb0a <__pow5mult+0x6e>
8001baf6:	08 9b       	mov	r11,r4
8001baf8:	0a 9a       	mov	r10,r5
8001bafa:	0e 9c       	mov	r12,r7
8001bafc:	c0 af       	rcall	8001b910 <__multiply>
8001bafe:	08 9b       	mov	r11,r4
8001bb00:	18 93       	mov	r3,r12
8001bb02:	0e 9c       	mov	r12,r7
8001bb04:	06 94       	mov	r4,r3
8001bb06:	fe b0 fd bb 	rcall	8001b67c <_Bfree>
8001bb0a:	a1 56       	asr	r6,0x1
8001bb0c:	c0 b0       	breq	8001bb22 <__pow5mult+0x86>
8001bb0e:	6a 03       	ld.w	r3,r5[0x0]
8001bb10:	58 03       	cp.w	r3,0
8001bb12:	ce d1       	brne	8001baec <__pow5mult+0x50>
8001bb14:	0a 9a       	mov	r10,r5
8001bb16:	0a 9b       	mov	r11,r5
8001bb18:	0e 9c       	mov	r12,r7
8001bb1a:	cf be       	rcall	8001b910 <__multiply>
8001bb1c:	8b 0c       	st.w	r5[0x0],r12
8001bb1e:	99 03       	st.w	r12[0x0],r3
8001bb20:	ce 7b       	rjmp	8001baee <__pow5mult+0x52>
8001bb22:	08 9c       	mov	r12,r4
8001bb24:	d8 32       	popm	r0-r7,pc
8001bb26:	d7 03       	nop
8001bb28:	80 07       	ld.sh	r7,r0[0x0]
8001bb2a:	0e ac       	st.w	r7++,r12

8001bb2c <_read_r>:
8001bb2c:	d4 21       	pushm	r4-r7,lr
8001bb2e:	16 98       	mov	r8,r11
8001bb30:	18 97       	mov	r7,r12
8001bb32:	10 9c       	mov	r12,r8
8001bb34:	30 08       	mov	r8,0
8001bb36:	14 9b       	mov	r11,r10
8001bb38:	48 66       	lddpc	r6,8001bb50 <_read_r+0x24>
8001bb3a:	12 9a       	mov	r10,r9
8001bb3c:	8d 08       	st.w	r6[0x0],r8
8001bb3e:	fe b0 68 2f 	rcall	80008b9c <_read>
8001bb42:	5b fc       	cp.w	r12,-1
8001bb44:	c0 51       	brne	8001bb4e <_read_r+0x22>
8001bb46:	6c 08       	ld.w	r8,r6[0x0]
8001bb48:	58 08       	cp.w	r8,0
8001bb4a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001bb4e:	d8 22       	popm	r4-r7,pc
8001bb50:	00 00       	add	r0,r0
8001bb52:	4f 74       	lddpc	r4,8001bd2c <_realloc_r+0x1d8>

8001bb54 <_realloc_r>:
8001bb54:	d4 31       	pushm	r0-r7,lr
8001bb56:	20 1d       	sub	sp,4
8001bb58:	16 94       	mov	r4,r11
8001bb5a:	18 92       	mov	r2,r12
8001bb5c:	14 9b       	mov	r11,r10
8001bb5e:	58 04       	cp.w	r4,0
8001bb60:	c0 51       	brne	8001bb6a <_realloc_r+0x16>
8001bb62:	fe b0 dc e9 	rcall	80017534 <_malloc_r>
8001bb66:	18 95       	mov	r5,r12
8001bb68:	c5 59       	rjmp	8001be12 <_realloc_r+0x2be>
8001bb6a:	50 0a       	stdsp	sp[0x0],r10
8001bb6c:	fe b0 df a5 	rcall	80017ab6 <__malloc_lock>
8001bb70:	40 0b       	lddsp	r11,sp[0x0]
8001bb72:	f6 c8 ff f5 	sub	r8,r11,-11
8001bb76:	e8 c1 00 08 	sub	r1,r4,8
8001bb7a:	10 96       	mov	r6,r8
8001bb7c:	62 1c       	ld.w	r12,r1[0x4]
8001bb7e:	e0 16 ff f8 	andl	r6,0xfff8
8001bb82:	59 68       	cp.w	r8,22
8001bb84:	f9 b6 08 10 	movls	r6,16
8001bb88:	16 36       	cp.w	r6,r11
8001bb8a:	5f 38       	srlo	r8
8001bb8c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8001bb90:	c0 50       	breq	8001bb9a <_realloc_r+0x46>
8001bb92:	30 c8       	mov	r8,12
8001bb94:	30 05       	mov	r5,0
8001bb96:	85 38       	st.w	r2[0xc],r8
8001bb98:	c3 d9       	rjmp	8001be12 <_realloc_r+0x2be>
8001bb9a:	18 90       	mov	r0,r12
8001bb9c:	e0 10 ff fc 	andl	r0,0xfffc
8001bba0:	0c 30       	cp.w	r0,r6
8001bba2:	e0 84 01 0d 	brge	8001bdbc <_realloc_r+0x268>
8001bba6:	4c a8       	lddpc	r8,8001bccc <_realloc_r+0x178>
8001bba8:	e2 00 00 09 	add	r9,r1,r0
8001bbac:	70 25       	ld.w	r5,r8[0x8]
8001bbae:	0a 39       	cp.w	r9,r5
8001bbb0:	c0 90       	breq	8001bbc2 <_realloc_r+0x6e>
8001bbb2:	72 1a       	ld.w	r10,r9[0x4]
8001bbb4:	a1 ca       	cbr	r10,0x0
8001bbb6:	f2 0a 00 0a 	add	r10,r9,r10
8001bbba:	74 1a       	ld.w	r10,r10[0x4]
8001bbbc:	ed ba 00 00 	bld	r10,0x0
8001bbc0:	c2 20       	breq	8001bc04 <_realloc_r+0xb0>
8001bbc2:	72 1a       	ld.w	r10,r9[0x4]
8001bbc4:	e0 1a ff fc 	andl	r10,0xfffc
8001bbc8:	f4 00 00 03 	add	r3,r10,r0
8001bbcc:	0a 39       	cp.w	r9,r5
8001bbce:	c1 31       	brne	8001bbf4 <_realloc_r+0xa0>
8001bbd0:	ec c7 ff f0 	sub	r7,r6,-16
8001bbd4:	0e 33       	cp.w	r3,r7
8001bbd6:	c1 95       	brlt	8001bc08 <_realloc_r+0xb4>
8001bbd8:	e2 06 00 09 	add	r9,r1,r6
8001bbdc:	0c 13       	sub	r3,r6
8001bbde:	a1 a3       	sbr	r3,0x0
8001bbe0:	93 13       	st.w	r9[0x4],r3
8001bbe2:	91 29       	st.w	r8[0x8],r9
8001bbe4:	04 9c       	mov	r12,r2
8001bbe6:	62 18       	ld.w	r8,r1[0x4]
8001bbe8:	08 95       	mov	r5,r4
8001bbea:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001bbee:	10 46       	or	r6,r8
8001bbf0:	83 16       	st.w	r1[0x4],r6
8001bbf2:	c0 e9       	rjmp	8001be0e <_realloc_r+0x2ba>
8001bbf4:	0c 33       	cp.w	r3,r6
8001bbf6:	c0 95       	brlt	8001bc08 <_realloc_r+0xb4>
8001bbf8:	72 28       	ld.w	r8,r9[0x8]
8001bbfa:	02 97       	mov	r7,r1
8001bbfc:	72 39       	ld.w	r9,r9[0xc]
8001bbfe:	93 28       	st.w	r9[0x8],r8
8001bc00:	91 39       	st.w	r8[0xc],r9
8001bc02:	cd f8       	rjmp	8001bdc0 <_realloc_r+0x26c>
8001bc04:	30 0a       	mov	r10,0
8001bc06:	14 99       	mov	r9,r10
8001bc08:	ed bc 00 00 	bld	r12,0x0
8001bc0c:	e0 80 00 98 	breq	8001bd3c <_realloc_r+0x1e8>
8001bc10:	62 07       	ld.w	r7,r1[0x0]
8001bc12:	e2 07 01 07 	sub	r7,r1,r7
8001bc16:	6e 1c       	ld.w	r12,r7[0x4]
8001bc18:	e0 1c ff fc 	andl	r12,0xfffc
8001bc1c:	58 09       	cp.w	r9,0
8001bc1e:	c5 90       	breq	8001bcd0 <_realloc_r+0x17c>
8001bc20:	f8 00 00 03 	add	r3,r12,r0
8001bc24:	0a 39       	cp.w	r9,r5
8001bc26:	c4 81       	brne	8001bcb6 <_realloc_r+0x162>
8001bc28:	14 03       	add	r3,r10
8001bc2a:	ec c9 ff f0 	sub	r9,r6,-16
8001bc2e:	12 33       	cp.w	r3,r9
8001bc30:	c5 05       	brlt	8001bcd0 <_realloc_r+0x17c>
8001bc32:	6e 3a       	ld.w	r10,r7[0xc]
8001bc34:	6e 29       	ld.w	r9,r7[0x8]
8001bc36:	95 29       	st.w	r10[0x8],r9
8001bc38:	93 3a       	st.w	r9[0xc],r10
8001bc3a:	ee c5 ff f8 	sub	r5,r7,-8
8001bc3e:	e0 ca 00 04 	sub	r10,r0,4
8001bc42:	e0 4a 00 24 	cp.w	r10,36
8001bc46:	e0 8b 00 25 	brhi	8001bc90 <_realloc_r+0x13c>
8001bc4a:	0a 99       	mov	r9,r5
8001bc4c:	59 3a       	cp.w	r10,19
8001bc4e:	e0 88 00 1a 	brls	8001bc82 <_realloc_r+0x12e>
8001bc52:	09 09       	ld.w	r9,r4++
8001bc54:	8b 09       	st.w	r5[0x0],r9
8001bc56:	09 09       	ld.w	r9,r4++
8001bc58:	8f 39       	st.w	r7[0xc],r9
8001bc5a:	ee c9 ff f0 	sub	r9,r7,-16
8001bc5e:	59 ba       	cp.w	r10,27
8001bc60:	e0 88 00 11 	brls	8001bc82 <_realloc_r+0x12e>
8001bc64:	09 0b       	ld.w	r11,r4++
8001bc66:	93 0b       	st.w	r9[0x0],r11
8001bc68:	09 09       	ld.w	r9,r4++
8001bc6a:	8f 59       	st.w	r7[0x14],r9
8001bc6c:	ee c9 ff e8 	sub	r9,r7,-24
8001bc70:	e0 4a 00 24 	cp.w	r10,36
8001bc74:	c0 71       	brne	8001bc82 <_realloc_r+0x12e>
8001bc76:	09 0a       	ld.w	r10,r4++
8001bc78:	93 0a       	st.w	r9[0x0],r10
8001bc7a:	ee c9 ff e0 	sub	r9,r7,-32
8001bc7e:	09 0a       	ld.w	r10,r4++
8001bc80:	8f 7a       	st.w	r7[0x1c],r10
8001bc82:	09 0a       	ld.w	r10,r4++
8001bc84:	12 aa       	st.w	r9++,r10
8001bc86:	68 0a       	ld.w	r10,r4[0x0]
8001bc88:	93 0a       	st.w	r9[0x0],r10
8001bc8a:	68 1a       	ld.w	r10,r4[0x4]
8001bc8c:	93 1a       	st.w	r9[0x4],r10
8001bc8e:	c0 78       	rjmp	8001bc9c <_realloc_r+0x148>
8001bc90:	50 08       	stdsp	sp[0x0],r8
8001bc92:	08 9b       	mov	r11,r4
8001bc94:	0a 9c       	mov	r12,r5
8001bc96:	fe b0 fc 44 	rcall	8001b51e <memmove>
8001bc9a:	40 08       	lddsp	r8,sp[0x0]
8001bc9c:	ee 06 00 09 	add	r9,r7,r6
8001bca0:	0c 13       	sub	r3,r6
8001bca2:	a1 a3       	sbr	r3,0x0
8001bca4:	93 13       	st.w	r9[0x4],r3
8001bca6:	91 29       	st.w	r8[0x8],r9
8001bca8:	04 9c       	mov	r12,r2
8001bcaa:	6e 18       	ld.w	r8,r7[0x4]
8001bcac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001bcb0:	10 46       	or	r6,r8
8001bcb2:	8f 16       	st.w	r7[0x4],r6
8001bcb4:	ca d8       	rjmp	8001be0e <_realloc_r+0x2ba>
8001bcb6:	14 03       	add	r3,r10
8001bcb8:	0c 33       	cp.w	r3,r6
8001bcba:	c0 b5       	brlt	8001bcd0 <_realloc_r+0x17c>
8001bcbc:	72 28       	ld.w	r8,r9[0x8]
8001bcbe:	72 39       	ld.w	r9,r9[0xc]
8001bcc0:	93 28       	st.w	r9[0x8],r8
8001bcc2:	91 39       	st.w	r8[0xc],r9
8001bcc4:	6e 28       	ld.w	r8,r7[0x8]
8001bcc6:	6e 39       	ld.w	r9,r7[0xc]
8001bcc8:	c0 a8       	rjmp	8001bcdc <_realloc_r+0x188>
8001bcca:	d7 03       	nop
8001bccc:	00 00       	add	r0,r0
8001bcce:	01 a0       	ld.ub	r0,r0[0x2]
8001bcd0:	f8 00 00 03 	add	r3,r12,r0
8001bcd4:	0c 33       	cp.w	r3,r6
8001bcd6:	c3 35       	brlt	8001bd3c <_realloc_r+0x1e8>
8001bcd8:	6e 39       	ld.w	r9,r7[0xc]
8001bcda:	6e 28       	ld.w	r8,r7[0x8]
8001bcdc:	93 28       	st.w	r9[0x8],r8
8001bcde:	91 39       	st.w	r8[0xc],r9
8001bce0:	e0 ca 00 04 	sub	r10,r0,4
8001bce4:	ee cc ff f8 	sub	r12,r7,-8
8001bce8:	e0 4a 00 24 	cp.w	r10,36
8001bcec:	e0 8b 00 24 	brhi	8001bd34 <_realloc_r+0x1e0>
8001bcf0:	59 3a       	cp.w	r10,19
8001bcf2:	e0 88 00 1a 	brls	8001bd26 <_realloc_r+0x1d2>
8001bcf6:	09 08       	ld.w	r8,r4++
8001bcf8:	99 08       	st.w	r12[0x0],r8
8001bcfa:	09 08       	ld.w	r8,r4++
8001bcfc:	8f 38       	st.w	r7[0xc],r8
8001bcfe:	ee cc ff f0 	sub	r12,r7,-16
8001bd02:	59 ba       	cp.w	r10,27
8001bd04:	e0 88 00 11 	brls	8001bd26 <_realloc_r+0x1d2>
8001bd08:	09 08       	ld.w	r8,r4++
8001bd0a:	99 08       	st.w	r12[0x0],r8
8001bd0c:	09 08       	ld.w	r8,r4++
8001bd0e:	8f 58       	st.w	r7[0x14],r8
8001bd10:	ee cc ff e8 	sub	r12,r7,-24
8001bd14:	e0 4a 00 24 	cp.w	r10,36
8001bd18:	c0 71       	brne	8001bd26 <_realloc_r+0x1d2>
8001bd1a:	09 08       	ld.w	r8,r4++
8001bd1c:	99 08       	st.w	r12[0x0],r8
8001bd1e:	ee cc ff e0 	sub	r12,r7,-32
8001bd22:	09 08       	ld.w	r8,r4++
8001bd24:	8f 78       	st.w	r7[0x1c],r8
8001bd26:	09 08       	ld.w	r8,r4++
8001bd28:	18 a8       	st.w	r12++,r8
8001bd2a:	68 08       	ld.w	r8,r4[0x0]
8001bd2c:	99 08       	st.w	r12[0x0],r8
8001bd2e:	68 18       	ld.w	r8,r4[0x4]
8001bd30:	99 18       	st.w	r12[0x4],r8
8001bd32:	c4 78       	rjmp	8001bdc0 <_realloc_r+0x26c>
8001bd34:	08 9b       	mov	r11,r4
8001bd36:	fe b0 fb f4 	rcall	8001b51e <memmove>
8001bd3a:	c4 38       	rjmp	8001bdc0 <_realloc_r+0x26c>
8001bd3c:	04 9c       	mov	r12,r2
8001bd3e:	fe b0 db fb 	rcall	80017534 <_malloc_r>
8001bd42:	18 95       	mov	r5,r12
8001bd44:	c3 a0       	breq	8001bdb8 <_realloc_r+0x264>
8001bd46:	62 18       	ld.w	r8,r1[0x4]
8001bd48:	f8 c9 00 08 	sub	r9,r12,8
8001bd4c:	a1 c8       	cbr	r8,0x0
8001bd4e:	e2 08 00 08 	add	r8,r1,r8
8001bd52:	10 39       	cp.w	r9,r8
8001bd54:	c0 71       	brne	8001bd62 <_realloc_r+0x20e>
8001bd56:	72 13       	ld.w	r3,r9[0x4]
8001bd58:	02 97       	mov	r7,r1
8001bd5a:	e0 13 ff fc 	andl	r3,0xfffc
8001bd5e:	00 03       	add	r3,r0
8001bd60:	c3 08       	rjmp	8001bdc0 <_realloc_r+0x26c>
8001bd62:	e0 ca 00 04 	sub	r10,r0,4
8001bd66:	e0 4a 00 24 	cp.w	r10,36
8001bd6a:	e0 8b 00 20 	brhi	8001bdaa <_realloc_r+0x256>
8001bd6e:	08 99       	mov	r9,r4
8001bd70:	18 98       	mov	r8,r12
8001bd72:	59 3a       	cp.w	r10,19
8001bd74:	e0 88 00 14 	brls	8001bd9c <_realloc_r+0x248>
8001bd78:	13 0b       	ld.w	r11,r9++
8001bd7a:	10 ab       	st.w	r8++,r11
8001bd7c:	13 0b       	ld.w	r11,r9++
8001bd7e:	10 ab       	st.w	r8++,r11
8001bd80:	59 ba       	cp.w	r10,27
8001bd82:	e0 88 00 0d 	brls	8001bd9c <_realloc_r+0x248>
8001bd86:	13 0b       	ld.w	r11,r9++
8001bd88:	10 ab       	st.w	r8++,r11
8001bd8a:	13 0b       	ld.w	r11,r9++
8001bd8c:	10 ab       	st.w	r8++,r11
8001bd8e:	e0 4a 00 24 	cp.w	r10,36
8001bd92:	c0 51       	brne	8001bd9c <_realloc_r+0x248>
8001bd94:	13 0a       	ld.w	r10,r9++
8001bd96:	10 aa       	st.w	r8++,r10
8001bd98:	13 0a       	ld.w	r10,r9++
8001bd9a:	10 aa       	st.w	r8++,r10
8001bd9c:	13 0a       	ld.w	r10,r9++
8001bd9e:	10 aa       	st.w	r8++,r10
8001bda0:	72 0a       	ld.w	r10,r9[0x0]
8001bda2:	91 0a       	st.w	r8[0x0],r10
8001bda4:	72 19       	ld.w	r9,r9[0x4]
8001bda6:	91 19       	st.w	r8[0x4],r9
8001bda8:	c0 48       	rjmp	8001bdb0 <_realloc_r+0x25c>
8001bdaa:	08 9b       	mov	r11,r4
8001bdac:	fe b0 fb b9 	rcall	8001b51e <memmove>
8001bdb0:	08 9b       	mov	r11,r4
8001bdb2:	04 9c       	mov	r12,r2
8001bdb4:	fe b0 d8 b0 	rcall	80016f14 <_free_r>
8001bdb8:	04 9c       	mov	r12,r2
8001bdba:	c2 a8       	rjmp	8001be0e <_realloc_r+0x2ba>
8001bdbc:	00 93       	mov	r3,r0
8001bdbe:	02 97       	mov	r7,r1
8001bdc0:	e6 06 01 09 	sub	r9,r3,r6
8001bdc4:	6e 18       	ld.w	r8,r7[0x4]
8001bdc6:	58 f9       	cp.w	r9,15
8001bdc8:	e0 88 00 16 	brls	8001bdf4 <_realloc_r+0x2a0>
8001bdcc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001bdd0:	ed e8 10 08 	or	r8,r6,r8
8001bdd4:	8f 18       	st.w	r7[0x4],r8
8001bdd6:	12 98       	mov	r8,r9
8001bdd8:	a1 a8       	sbr	r8,0x0
8001bdda:	ee 06 00 0b 	add	r11,r7,r6
8001bdde:	f6 09 00 09 	add	r9,r11,r9
8001bde2:	97 18       	st.w	r11[0x4],r8
8001bde4:	72 18       	ld.w	r8,r9[0x4]
8001bde6:	a1 a8       	sbr	r8,0x0
8001bde8:	2f 8b       	sub	r11,-8
8001bdea:	93 18       	st.w	r9[0x4],r8
8001bdec:	04 9c       	mov	r12,r2
8001bdee:	fe b0 d8 93 	rcall	80016f14 <_free_r>
8001bdf2:	c0 b8       	rjmp	8001be08 <_realloc_r+0x2b4>
8001bdf4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001bdf8:	e7 e8 10 08 	or	r8,r3,r8
8001bdfc:	8f 18       	st.w	r7[0x4],r8
8001bdfe:	ee 03 00 03 	add	r3,r7,r3
8001be02:	66 18       	ld.w	r8,r3[0x4]
8001be04:	a1 a8       	sbr	r8,0x0
8001be06:	87 18       	st.w	r3[0x4],r8
8001be08:	04 9c       	mov	r12,r2
8001be0a:	ee c5 ff f8 	sub	r5,r7,-8
8001be0e:	fe b0 de 55 	rcall	80017ab8 <__malloc_unlock>
8001be12:	0a 9c       	mov	r12,r5
8001be14:	2f fd       	sub	sp,-4
8001be16:	d8 32       	popm	r0-r7,pc

8001be18 <__isinfd>:
8001be18:	14 98       	mov	r8,r10
8001be1a:	fc 19 7f f0 	movh	r9,0x7ff0
8001be1e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8001be22:	f0 0b 11 00 	rsub	r11,r8,0
8001be26:	f7 e8 10 08 	or	r8,r11,r8
8001be2a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8001be2e:	f2 08 01 08 	sub	r8,r9,r8
8001be32:	f0 0c 11 00 	rsub	r12,r8,0
8001be36:	f9 e8 10 08 	or	r8,r12,r8
8001be3a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8001be3e:	2f fc       	sub	r12,-1
8001be40:	5e fc       	retal	r12

8001be42 <__isnand>:
8001be42:	14 98       	mov	r8,r10
8001be44:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8001be48:	f0 0c 11 00 	rsub	r12,r8,0
8001be4c:	10 4c       	or	r12,r8
8001be4e:	fc 18 7f f0 	movh	r8,0x7ff0
8001be52:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8001be56:	f0 0c 01 0c 	sub	r12,r8,r12
8001be5a:	bf 9c       	lsr	r12,0x1f
8001be5c:	5e fc       	retal	r12
8001be5e:	d7 03       	nop

8001be60 <_calloc_r>:
8001be60:	d4 21       	pushm	r4-r7,lr
8001be62:	f4 0b 02 4b 	mul	r11,r10,r11
8001be66:	fe b0 db 67 	rcall	80017534 <_malloc_r>
8001be6a:	18 97       	mov	r7,r12
8001be6c:	c2 30       	breq	8001beb2 <_calloc_r+0x52>
8001be6e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8001be72:	e0 1a ff fc 	andl	r10,0xfffc
8001be76:	20 4a       	sub	r10,4
8001be78:	e0 4a 00 24 	cp.w	r10,36
8001be7c:	e0 8b 00 18 	brhi	8001beac <_calloc_r+0x4c>
8001be80:	18 98       	mov	r8,r12
8001be82:	59 3a       	cp.w	r10,19
8001be84:	e0 88 00 0f 	brls	8001bea2 <_calloc_r+0x42>
8001be88:	30 09       	mov	r9,0
8001be8a:	10 a9       	st.w	r8++,r9
8001be8c:	10 a9       	st.w	r8++,r9
8001be8e:	59 ba       	cp.w	r10,27
8001be90:	e0 88 00 09 	brls	8001bea2 <_calloc_r+0x42>
8001be94:	10 a9       	st.w	r8++,r9
8001be96:	10 a9       	st.w	r8++,r9
8001be98:	e0 4a 00 24 	cp.w	r10,36
8001be9c:	c0 31       	brne	8001bea2 <_calloc_r+0x42>
8001be9e:	10 a9       	st.w	r8++,r9
8001bea0:	10 a9       	st.w	r8++,r9
8001bea2:	30 09       	mov	r9,0
8001bea4:	10 a9       	st.w	r8++,r9
8001bea6:	91 19       	st.w	r8[0x4],r9
8001bea8:	91 09       	st.w	r8[0x0],r9
8001beaa:	c0 48       	rjmp	8001beb2 <_calloc_r+0x52>
8001beac:	30 0b       	mov	r11,0
8001beae:	fe b0 dd fd 	rcall	80017aa8 <memset>
8001beb2:	0e 9c       	mov	r12,r7
8001beb4:	d8 22       	popm	r4-r7,pc
8001beb6:	d7 03       	nop

8001beb8 <__avr32_f64_mul>:
8001beb8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8001bebc:	e0 80 00 dc 	breq	8001c074 <__avr32_f64_mul_op1_zero>
8001bec0:	d4 21       	pushm	r4-r7,lr
8001bec2:	f7 e9 20 0e 	eor	lr,r11,r9
8001bec6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8001beca:	30 15       	mov	r5,1
8001becc:	c4 30       	breq	8001bf52 <__avr32_f64_mul_op1_subnormal>
8001bece:	ab 6b       	lsl	r11,0xa
8001bed0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8001bed4:	ab 6a       	lsl	r10,0xa
8001bed6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8001beda:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8001bede:	c5 c0       	breq	8001bf96 <__avr32_f64_mul_op2_subnormal>
8001bee0:	a1 78       	lsl	r8,0x1
8001bee2:	5c f9       	rol	r9
8001bee4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8001bee8:	e0 47 07 ff 	cp.w	r7,2047
8001beec:	c7 70       	breq	8001bfda <__avr32_f64_mul_op_nan_or_inf>
8001beee:	e0 46 07 ff 	cp.w	r6,2047
8001bef2:	c7 40       	breq	8001bfda <__avr32_f64_mul_op_nan_or_inf>
8001bef4:	ee 06 00 0c 	add	r12,r7,r6
8001bef8:	e0 2c 03 fe 	sub	r12,1022
8001befc:	f6 08 06 44 	mulu.d	r4,r11,r8
8001bf00:	f4 09 07 44 	macu.d	r4,r10,r9
8001bf04:	f4 08 06 46 	mulu.d	r6,r10,r8
8001bf08:	f6 09 06 4a 	mulu.d	r10,r11,r9
8001bf0c:	08 07       	add	r7,r4
8001bf0e:	f4 05 00 4a 	adc	r10,r10,r5
8001bf12:	5c 0b       	acr	r11
8001bf14:	ed bb 00 14 	bld	r11,0x14
8001bf18:	c0 50       	breq	8001bf22 <__avr32_f64_mul+0x6a>
8001bf1a:	a1 77       	lsl	r7,0x1
8001bf1c:	5c fa       	rol	r10
8001bf1e:	5c fb       	rol	r11
8001bf20:	20 1c       	sub	r12,1
8001bf22:	58 0c       	cp.w	r12,0
8001bf24:	e0 8a 00 6f 	brle	8001c002 <__avr32_f64_mul_res_subnormal>
8001bf28:	e0 4c 07 ff 	cp.w	r12,2047
8001bf2c:	e0 84 00 9c 	brge	8001c064 <__avr32_f64_mul_res_inf>
8001bf30:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8001bf34:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8001bf38:	ef e6 12 17 	or	r7,r7,r6>>0x1
8001bf3c:	ee 17 80 00 	eorh	r7,0x8000
8001bf40:	f1 b7 04 20 	satu	r7,0x1
8001bf44:	0e 0a       	add	r10,r7
8001bf46:	5c 0b       	acr	r11
8001bf48:	ed be 00 1f 	bld	lr,0x1f
8001bf4c:	ef bb 00 1f 	bst	r11,0x1f
8001bf50:	d8 22       	popm	r4-r7,pc

8001bf52 <__avr32_f64_mul_op1_subnormal>:
8001bf52:	e4 1b 00 0f 	andh	r11,0xf
8001bf56:	f4 0c 12 00 	clz	r12,r10
8001bf5a:	f6 06 12 00 	clz	r6,r11
8001bf5e:	f7 bc 03 e1 	sublo	r12,-31
8001bf62:	f8 06 17 30 	movlo	r6,r12
8001bf66:	f7 b6 02 01 	subhs	r6,1
8001bf6a:	e0 46 00 20 	cp.w	r6,32
8001bf6e:	c0 d4       	brge	8001bf88 <__avr32_f64_mul_op1_subnormal+0x36>
8001bf70:	ec 0c 11 20 	rsub	r12,r6,32
8001bf74:	f6 06 09 4b 	lsl	r11,r11,r6
8001bf78:	f4 0c 0a 4c 	lsr	r12,r10,r12
8001bf7c:	18 4b       	or	r11,r12
8001bf7e:	f4 06 09 4a 	lsl	r10,r10,r6
8001bf82:	20 b6       	sub	r6,11
8001bf84:	0c 17       	sub	r7,r6
8001bf86:	ca ab       	rjmp	8001beda <__avr32_f64_mul+0x22>
8001bf88:	f4 06 09 4b 	lsl	r11,r10,r6
8001bf8c:	c6 40       	breq	8001c054 <__avr32_f64_mul_res_zero>
8001bf8e:	30 0a       	mov	r10,0
8001bf90:	20 b6       	sub	r6,11
8001bf92:	0c 17       	sub	r7,r6
8001bf94:	ca 3b       	rjmp	8001beda <__avr32_f64_mul+0x22>

8001bf96 <__avr32_f64_mul_op2_subnormal>:
8001bf96:	e4 19 00 0f 	andh	r9,0xf
8001bf9a:	f0 0c 12 00 	clz	r12,r8
8001bf9e:	f2 05 12 00 	clz	r5,r9
8001bfa2:	f7 bc 03 ea 	sublo	r12,-22
8001bfa6:	f8 05 17 30 	movlo	r5,r12
8001bfaa:	f7 b5 02 0a 	subhs	r5,10
8001bfae:	e0 45 00 20 	cp.w	r5,32
8001bfb2:	c0 d4       	brge	8001bfcc <__avr32_f64_mul_op2_subnormal+0x36>
8001bfb4:	ea 0c 11 20 	rsub	r12,r5,32
8001bfb8:	f2 05 09 49 	lsl	r9,r9,r5
8001bfbc:	f0 0c 0a 4c 	lsr	r12,r8,r12
8001bfc0:	18 49       	or	r9,r12
8001bfc2:	f0 05 09 48 	lsl	r8,r8,r5
8001bfc6:	20 25       	sub	r5,2
8001bfc8:	0a 16       	sub	r6,r5
8001bfca:	c8 fb       	rjmp	8001bee8 <__avr32_f64_mul+0x30>
8001bfcc:	f0 05 09 49 	lsl	r9,r8,r5
8001bfd0:	c4 20       	breq	8001c054 <__avr32_f64_mul_res_zero>
8001bfd2:	30 08       	mov	r8,0
8001bfd4:	20 25       	sub	r5,2
8001bfd6:	0a 16       	sub	r6,r5
8001bfd8:	c8 8b       	rjmp	8001bee8 <__avr32_f64_mul+0x30>

8001bfda <__avr32_f64_mul_op_nan_or_inf>:
8001bfda:	e4 19 00 0f 	andh	r9,0xf
8001bfde:	e4 1b 00 0f 	andh	r11,0xf
8001bfe2:	14 4b       	or	r11,r10
8001bfe4:	10 49       	or	r9,r8
8001bfe6:	e0 47 07 ff 	cp.w	r7,2047
8001bfea:	c0 91       	brne	8001bffc <__avr32_f64_mul_op1_not_naninf>
8001bfec:	58 0b       	cp.w	r11,0
8001bfee:	c3 81       	brne	8001c05e <__avr32_f64_mul_res_nan>
8001bff0:	e0 46 07 ff 	cp.w	r6,2047
8001bff4:	c3 81       	brne	8001c064 <__avr32_f64_mul_res_inf>
8001bff6:	58 09       	cp.w	r9,0
8001bff8:	c3 60       	breq	8001c064 <__avr32_f64_mul_res_inf>
8001bffa:	c3 28       	rjmp	8001c05e <__avr32_f64_mul_res_nan>

8001bffc <__avr32_f64_mul_op1_not_naninf>:
8001bffc:	58 09       	cp.w	r9,0
8001bffe:	c3 30       	breq	8001c064 <__avr32_f64_mul_res_inf>
8001c000:	c2 f8       	rjmp	8001c05e <__avr32_f64_mul_res_nan>

8001c002 <__avr32_f64_mul_res_subnormal>:
8001c002:	5c 3c       	neg	r12
8001c004:	2f fc       	sub	r12,-1
8001c006:	f1 bc 04 c0 	satu	r12,0x6
8001c00a:	e0 4c 00 20 	cp.w	r12,32
8001c00e:	c1 14       	brge	8001c030 <__avr32_f64_mul_res_subnormal+0x2e>
8001c010:	f8 08 11 20 	rsub	r8,r12,32
8001c014:	0e 46       	or	r6,r7
8001c016:	ee 0c 0a 47 	lsr	r7,r7,r12
8001c01a:	f4 08 09 49 	lsl	r9,r10,r8
8001c01e:	12 47       	or	r7,r9
8001c020:	f4 0c 0a 4a 	lsr	r10,r10,r12
8001c024:	f6 08 09 49 	lsl	r9,r11,r8
8001c028:	12 4a       	or	r10,r9
8001c02a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8001c02e:	c8 3b       	rjmp	8001bf34 <__avr32_f64_mul+0x7c>
8001c030:	f8 08 11 20 	rsub	r8,r12,32
8001c034:	f9 b9 00 00 	moveq	r9,0
8001c038:	c0 30       	breq	8001c03e <__avr32_f64_mul_res_subnormal+0x3c>
8001c03a:	f6 08 09 49 	lsl	r9,r11,r8
8001c03e:	0e 46       	or	r6,r7
8001c040:	ed ea 10 16 	or	r6,r6,r10<<0x1
8001c044:	f4 0c 0a 4a 	lsr	r10,r10,r12
8001c048:	f3 ea 10 07 	or	r7,r9,r10
8001c04c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8001c050:	30 0b       	mov	r11,0
8001c052:	c7 1b       	rjmp	8001bf34 <__avr32_f64_mul+0x7c>

8001c054 <__avr32_f64_mul_res_zero>:
8001c054:	1c 9b       	mov	r11,lr
8001c056:	e6 1b 80 00 	andh	r11,0x8000,COH
8001c05a:	30 0a       	mov	r10,0
8001c05c:	d8 22       	popm	r4-r7,pc

8001c05e <__avr32_f64_mul_res_nan>:
8001c05e:	3f fb       	mov	r11,-1
8001c060:	3f fa       	mov	r10,-1
8001c062:	d8 22       	popm	r4-r7,pc

8001c064 <__avr32_f64_mul_res_inf>:
8001c064:	f0 6b 00 00 	mov	r11,-1048576
8001c068:	ed be 00 1f 	bld	lr,0x1f
8001c06c:	ef bb 00 1f 	bst	r11,0x1f
8001c070:	30 0a       	mov	r10,0
8001c072:	d8 22       	popm	r4-r7,pc

8001c074 <__avr32_f64_mul_op1_zero>:
8001c074:	f7 e9 20 0b 	eor	r11,r11,r9
8001c078:	e6 1b 80 00 	andh	r11,0x8000,COH
8001c07c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8001c080:	e0 4c 07 ff 	cp.w	r12,2047
8001c084:	5e 1c       	retne	r12
8001c086:	3f fa       	mov	r10,-1
8001c088:	3f fb       	mov	r11,-1
8001c08a:	5e fc       	retal	r12

8001c08c <__avr32_f64_sub_from_add>:
8001c08c:	ee 19 80 00 	eorh	r9,0x8000

8001c090 <__avr32_f64_sub>:
8001c090:	f7 e9 20 0c 	eor	r12,r11,r9
8001c094:	e0 86 00 ca 	brmi	8001c228 <__avr32_f64_add_from_sub>
8001c098:	eb cd 40 e0 	pushm	r5-r7,lr
8001c09c:	16 9c       	mov	r12,r11
8001c09e:	e6 1c 80 00 	andh	r12,0x8000,COH
8001c0a2:	bf db       	cbr	r11,0x1f
8001c0a4:	bf d9       	cbr	r9,0x1f
8001c0a6:	10 3a       	cp.w	r10,r8
8001c0a8:	f2 0b 13 00 	cpc	r11,r9
8001c0ac:	c0 92       	brcc	8001c0be <__avr32_f64_sub+0x2e>
8001c0ae:	16 97       	mov	r7,r11
8001c0b0:	12 9b       	mov	r11,r9
8001c0b2:	0e 99       	mov	r9,r7
8001c0b4:	14 97       	mov	r7,r10
8001c0b6:	10 9a       	mov	r10,r8
8001c0b8:	0e 98       	mov	r8,r7
8001c0ba:	ee 1c 80 00 	eorh	r12,0x8000
8001c0be:	f6 07 16 14 	lsr	r7,r11,0x14
8001c0c2:	ab 7b       	lsl	r11,0xb
8001c0c4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8001c0c8:	ab 7a       	lsl	r10,0xb
8001c0ca:	bf bb       	sbr	r11,0x1f
8001c0cc:	f2 06 16 14 	lsr	r6,r9,0x14
8001c0d0:	c4 40       	breq	8001c158 <__avr32_f64_sub_opL_subnormal>
8001c0d2:	ab 79       	lsl	r9,0xb
8001c0d4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8001c0d8:	ab 78       	lsl	r8,0xb
8001c0da:	bf b9       	sbr	r9,0x1f

8001c0dc <__avr32_f64_sub_opL_subnormal_done>:
8001c0dc:	e0 47 07 ff 	cp.w	r7,2047
8001c0e0:	c4 f0       	breq	8001c17e <__avr32_f64_sub_opH_nan_or_inf>
8001c0e2:	0e 26       	rsub	r6,r7
8001c0e4:	c1 20       	breq	8001c108 <__avr32_f64_sub_shift_done>
8001c0e6:	ec 05 11 20 	rsub	r5,r6,32
8001c0ea:	e0 46 00 20 	cp.w	r6,32
8001c0ee:	c7 c2       	brcc	8001c1e6 <__avr32_f64_sub_longshift>
8001c0f0:	f0 05 09 4e 	lsl	lr,r8,r5
8001c0f4:	f2 05 09 45 	lsl	r5,r9,r5
8001c0f8:	f0 06 0a 48 	lsr	r8,r8,r6
8001c0fc:	f2 06 0a 49 	lsr	r9,r9,r6
8001c100:	0a 48       	or	r8,r5
8001c102:	58 0e       	cp.w	lr,0
8001c104:	5f 1e       	srne	lr
8001c106:	1c 48       	or	r8,lr

8001c108 <__avr32_f64_sub_shift_done>:
8001c108:	10 1a       	sub	r10,r8
8001c10a:	f6 09 01 4b 	sbc	r11,r11,r9
8001c10e:	f6 06 12 00 	clz	r6,r11
8001c112:	c0 e0       	breq	8001c12e <__avr32_f64_sub_longnormalize_done>
8001c114:	c7 83       	brcs	8001c204 <__avr32_f64_sub_longnormalize>
8001c116:	ec 0e 11 20 	rsub	lr,r6,32
8001c11a:	f6 06 09 4b 	lsl	r11,r11,r6
8001c11e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8001c122:	1c 4b       	or	r11,lr
8001c124:	f4 06 09 4a 	lsl	r10,r10,r6
8001c128:	0c 17       	sub	r7,r6
8001c12a:	e0 8a 00 39 	brle	8001c19c <__avr32_f64_sub_subnormal_result>

8001c12e <__avr32_f64_sub_longnormalize_done>:
8001c12e:	f4 09 15 15 	lsl	r9,r10,0x15
8001c132:	ab 9a       	lsr	r10,0xb
8001c134:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8001c138:	ab 9b       	lsr	r11,0xb
8001c13a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8001c13e:	18 4b       	or	r11,r12

8001c140 <__avr32_f64_sub_round>:
8001c140:	fc 17 80 00 	movh	r7,0x8000
8001c144:	ed ba 00 00 	bld	r10,0x0
8001c148:	f7 b7 01 ff 	subne	r7,-1
8001c14c:	0e 39       	cp.w	r9,r7
8001c14e:	5f 29       	srhs	r9
8001c150:	12 0a       	add	r10,r9
8001c152:	5c 0b       	acr	r11
8001c154:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c158 <__avr32_f64_sub_opL_subnormal>:
8001c158:	ab 79       	lsl	r9,0xb
8001c15a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8001c15e:	ab 78       	lsl	r8,0xb
8001c160:	f3 e8 10 0e 	or	lr,r9,r8
8001c164:	f9 b6 01 01 	movne	r6,1
8001c168:	ee 0e 11 00 	rsub	lr,r7,0
8001c16c:	f9 b7 00 01 	moveq	r7,1
8001c170:	ef bb 00 1f 	bst	r11,0x1f
8001c174:	f7 ea 10 0e 	or	lr,r11,r10
8001c178:	f9 b7 00 00 	moveq	r7,0
8001c17c:	cb 0b       	rjmp	8001c0dc <__avr32_f64_sub_opL_subnormal_done>

8001c17e <__avr32_f64_sub_opH_nan_or_inf>:
8001c17e:	bf db       	cbr	r11,0x1f
8001c180:	f7 ea 10 0e 	or	lr,r11,r10
8001c184:	c0 81       	brne	8001c194 <__avr32_f64_sub_return_nan>
8001c186:	e0 46 07 ff 	cp.w	r6,2047
8001c18a:	c0 50       	breq	8001c194 <__avr32_f64_sub_return_nan>
8001c18c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8001c190:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c194 <__avr32_f64_sub_return_nan>:
8001c194:	3f fa       	mov	r10,-1
8001c196:	3f fb       	mov	r11,-1
8001c198:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c19c <__avr32_f64_sub_subnormal_result>:
8001c19c:	5c 37       	neg	r7
8001c19e:	2f f7       	sub	r7,-1
8001c1a0:	f1 b7 04 c0 	satu	r7,0x6
8001c1a4:	e0 47 00 20 	cp.w	r7,32
8001c1a8:	c1 14       	brge	8001c1ca <__avr32_f64_sub_subnormal_result+0x2e>
8001c1aa:	ee 08 11 20 	rsub	r8,r7,32
8001c1ae:	f4 08 09 49 	lsl	r9,r10,r8
8001c1b2:	5f 16       	srne	r6
8001c1b4:	f4 07 0a 4a 	lsr	r10,r10,r7
8001c1b8:	0c 4a       	or	r10,r6
8001c1ba:	f6 08 09 49 	lsl	r9,r11,r8
8001c1be:	f5 e9 10 0a 	or	r10,r10,r9
8001c1c2:	f4 07 0a 4b 	lsr	r11,r10,r7
8001c1c6:	30 07       	mov	r7,0
8001c1c8:	cb 3b       	rjmp	8001c12e <__avr32_f64_sub_longnormalize_done>
8001c1ca:	ee 08 11 40 	rsub	r8,r7,64
8001c1ce:	f6 08 09 49 	lsl	r9,r11,r8
8001c1d2:	14 49       	or	r9,r10
8001c1d4:	5f 16       	srne	r6
8001c1d6:	f6 07 0a 4a 	lsr	r10,r11,r7
8001c1da:	0c 4a       	or	r10,r6
8001c1dc:	30 0b       	mov	r11,0
8001c1de:	30 07       	mov	r7,0
8001c1e0:	ca 7b       	rjmp	8001c12e <__avr32_f64_sub_longnormalize_done>
8001c1e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c1e6 <__avr32_f64_sub_longshift>:
8001c1e6:	f1 b6 04 c0 	satu	r6,0x6
8001c1ea:	f0 0e 17 00 	moveq	lr,r8
8001c1ee:	c0 40       	breq	8001c1f6 <__avr32_f64_sub_longshift+0x10>
8001c1f0:	f2 05 09 4e 	lsl	lr,r9,r5
8001c1f4:	10 4e       	or	lr,r8
8001c1f6:	f2 06 0a 48 	lsr	r8,r9,r6
8001c1fa:	30 09       	mov	r9,0
8001c1fc:	58 0e       	cp.w	lr,0
8001c1fe:	5f 1e       	srne	lr
8001c200:	1c 48       	or	r8,lr
8001c202:	c8 3b       	rjmp	8001c108 <__avr32_f64_sub_shift_done>

8001c204 <__avr32_f64_sub_longnormalize>:
8001c204:	f4 06 12 00 	clz	r6,r10
8001c208:	f9 b7 03 00 	movlo	r7,0
8001c20c:	f9 b6 03 00 	movlo	r6,0
8001c210:	f9 bc 03 00 	movlo	r12,0
8001c214:	f7 b6 02 e0 	subhs	r6,-32
8001c218:	f4 06 09 4b 	lsl	r11,r10,r6
8001c21c:	30 0a       	mov	r10,0
8001c21e:	0c 17       	sub	r7,r6
8001c220:	fe 9a ff be 	brle	8001c19c <__avr32_f64_sub_subnormal_result>
8001c224:	c8 5b       	rjmp	8001c12e <__avr32_f64_sub_longnormalize_done>
8001c226:	d7 03       	nop

8001c228 <__avr32_f64_add_from_sub>:
8001c228:	ee 19 80 00 	eorh	r9,0x8000

8001c22c <__avr32_f64_add>:
8001c22c:	f7 e9 20 0c 	eor	r12,r11,r9
8001c230:	fe 96 ff 2e 	brmi	8001c08c <__avr32_f64_sub_from_add>
8001c234:	eb cd 40 e0 	pushm	r5-r7,lr
8001c238:	16 9c       	mov	r12,r11
8001c23a:	e6 1c 80 00 	andh	r12,0x8000,COH
8001c23e:	bf db       	cbr	r11,0x1f
8001c240:	bf d9       	cbr	r9,0x1f
8001c242:	12 3b       	cp.w	r11,r9
8001c244:	c0 72       	brcc	8001c252 <__avr32_f64_add+0x26>
8001c246:	16 97       	mov	r7,r11
8001c248:	12 9b       	mov	r11,r9
8001c24a:	0e 99       	mov	r9,r7
8001c24c:	14 97       	mov	r7,r10
8001c24e:	10 9a       	mov	r10,r8
8001c250:	0e 98       	mov	r8,r7
8001c252:	30 0e       	mov	lr,0
8001c254:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8001c258:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8001c25c:	b5 ab       	sbr	r11,0x14
8001c25e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8001c262:	c6 20       	breq	8001c326 <__avr32_f64_add_op2_subnormal>
8001c264:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8001c268:	b5 a9       	sbr	r9,0x14
8001c26a:	e0 47 07 ff 	cp.w	r7,2047
8001c26e:	c2 80       	breq	8001c2be <__avr32_f64_add_opH_nan_or_inf>
8001c270:	0e 26       	rsub	r6,r7
8001c272:	c1 20       	breq	8001c296 <__avr32_f64_add_shift_done>
8001c274:	e0 46 00 36 	cp.w	r6,54
8001c278:	c1 52       	brcc	8001c2a2 <__avr32_f64_add_res_of_done>
8001c27a:	ec 05 11 20 	rsub	r5,r6,32
8001c27e:	e0 46 00 20 	cp.w	r6,32
8001c282:	c3 52       	brcc	8001c2ec <__avr32_f64_add_longshift>
8001c284:	f0 05 09 4e 	lsl	lr,r8,r5
8001c288:	f2 05 09 45 	lsl	r5,r9,r5
8001c28c:	f0 06 0a 48 	lsr	r8,r8,r6
8001c290:	f2 06 0a 49 	lsr	r9,r9,r6
8001c294:	0a 48       	or	r8,r5

8001c296 <__avr32_f64_add_shift_done>:
8001c296:	10 0a       	add	r10,r8
8001c298:	f6 09 00 4b 	adc	r11,r11,r9
8001c29c:	ed bb 00 15 	bld	r11,0x15
8001c2a0:	c3 40       	breq	8001c308 <__avr32_f64_add_res_of>

8001c2a2 <__avr32_f64_add_res_of_done>:
8001c2a2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8001c2a6:	18 4b       	or	r11,r12

8001c2a8 <__avr32_f64_add_round>:
8001c2a8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8001c2ac:	18 4e       	or	lr,r12
8001c2ae:	ee 1e 80 00 	eorh	lr,0x8000
8001c2b2:	f1 be 04 20 	satu	lr,0x1
8001c2b6:	1c 0a       	add	r10,lr
8001c2b8:	5c 0b       	acr	r11
8001c2ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c2be <__avr32_f64_add_opH_nan_or_inf>:
8001c2be:	b5 cb       	cbr	r11,0x14
8001c2c0:	f7 ea 10 0e 	or	lr,r11,r10
8001c2c4:	c1 01       	brne	8001c2e4 <__avr32_f64_add_return_nan>
8001c2c6:	e0 46 07 ff 	cp.w	r6,2047
8001c2ca:	c0 30       	breq	8001c2d0 <__avr32_f64_add_opL_nan_or_inf>
8001c2cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c2d0 <__avr32_f64_add_opL_nan_or_inf>:
8001c2d0:	b5 c9       	cbr	r9,0x14
8001c2d2:	f3 e8 10 0e 	or	lr,r9,r8
8001c2d6:	c0 71       	brne	8001c2e4 <__avr32_f64_add_return_nan>
8001c2d8:	30 0a       	mov	r10,0
8001c2da:	fc 1b 7f f0 	movh	r11,0x7ff0
8001c2de:	18 4b       	or	r11,r12
8001c2e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c2e4 <__avr32_f64_add_return_nan>:
8001c2e4:	3f fa       	mov	r10,-1
8001c2e6:	3f fb       	mov	r11,-1
8001c2e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001c2ec <__avr32_f64_add_longshift>:
8001c2ec:	f1 b6 04 c0 	satu	r6,0x6
8001c2f0:	f0 0e 17 00 	moveq	lr,r8
8001c2f4:	c0 60       	breq	8001c300 <__avr32_f64_add_longshift+0x14>
8001c2f6:	f2 05 09 4e 	lsl	lr,r9,r5
8001c2fa:	58 08       	cp.w	r8,0
8001c2fc:	5f 18       	srne	r8
8001c2fe:	10 4e       	or	lr,r8
8001c300:	f2 06 0a 48 	lsr	r8,r9,r6
8001c304:	30 09       	mov	r9,0
8001c306:	cc 8b       	rjmp	8001c296 <__avr32_f64_add_shift_done>

8001c308 <__avr32_f64_add_res_of>:
8001c308:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8001c30c:	a1 9b       	lsr	r11,0x1
8001c30e:	5d 0a       	ror	r10
8001c310:	5d 0e       	ror	lr
8001c312:	2f f7       	sub	r7,-1
8001c314:	e0 47 07 ff 	cp.w	r7,2047
8001c318:	f9 ba 00 00 	moveq	r10,0
8001c31c:	f9 bb 00 00 	moveq	r11,0
8001c320:	f9 be 00 00 	moveq	lr,0
8001c324:	cb fb       	rjmp	8001c2a2 <__avr32_f64_add_res_of_done>

8001c326 <__avr32_f64_add_op2_subnormal>:
8001c326:	30 16       	mov	r6,1
8001c328:	58 07       	cp.w	r7,0
8001c32a:	ca 01       	brne	8001c26a <__avr32_f64_add+0x3e>
8001c32c:	b5 cb       	cbr	r11,0x14
8001c32e:	10 0a       	add	r10,r8
8001c330:	f6 09 00 4b 	adc	r11,r11,r9
8001c334:	18 4b       	or	r11,r12
8001c336:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001c33a:	d7 03       	nop

8001c33c <__avr32_f64_to_u32>:
8001c33c:	58 0b       	cp.w	r11,0
8001c33e:	5e 6d       	retmi	0

8001c340 <__avr32_f64_to_s32>:
8001c340:	f6 0c 15 01 	lsl	r12,r11,0x1
8001c344:	b5 9c       	lsr	r12,0x15
8001c346:	e0 2c 03 ff 	sub	r12,1023
8001c34a:	5e 3d       	retlo	0
8001c34c:	f8 0c 11 1f 	rsub	r12,r12,31
8001c350:	16 99       	mov	r9,r11
8001c352:	ab 7b       	lsl	r11,0xb
8001c354:	bf bb       	sbr	r11,0x1f
8001c356:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8001c35a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8001c35e:	a1 79       	lsl	r9,0x1
8001c360:	5e 2b       	reths	r11
8001c362:	5c 3b       	neg	r11
8001c364:	5e fb       	retal	r11

8001c366 <__avr32_u32_to_f64>:
8001c366:	f8 cb 00 00 	sub	r11,r12,0
8001c36a:	30 0c       	mov	r12,0
8001c36c:	c0 38       	rjmp	8001c372 <__avr32_s32_to_f64+0x4>

8001c36e <__avr32_s32_to_f64>:
8001c36e:	18 9b       	mov	r11,r12
8001c370:	5c 4b       	abs	r11
8001c372:	30 0a       	mov	r10,0
8001c374:	5e 0b       	reteq	r11
8001c376:	d4 01       	pushm	lr
8001c378:	e0 69 04 1e 	mov	r9,1054
8001c37c:	f6 08 12 00 	clz	r8,r11
8001c380:	c1 70       	breq	8001c3ae <__avr32_s32_to_f64+0x40>
8001c382:	c0 c3       	brcs	8001c39a <__avr32_s32_to_f64+0x2c>
8001c384:	f0 0e 11 20 	rsub	lr,r8,32
8001c388:	f6 08 09 4b 	lsl	r11,r11,r8
8001c38c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8001c390:	1c 4b       	or	r11,lr
8001c392:	f4 08 09 4a 	lsl	r10,r10,r8
8001c396:	10 19       	sub	r9,r8
8001c398:	c0 b8       	rjmp	8001c3ae <__avr32_s32_to_f64+0x40>
8001c39a:	f4 08 12 00 	clz	r8,r10
8001c39e:	f9 b8 03 00 	movlo	r8,0
8001c3a2:	f7 b8 02 e0 	subhs	r8,-32
8001c3a6:	f4 08 09 4b 	lsl	r11,r10,r8
8001c3aa:	30 0a       	mov	r10,0
8001c3ac:	10 19       	sub	r9,r8
8001c3ae:	58 09       	cp.w	r9,0
8001c3b0:	e0 89 00 30 	brgt	8001c410 <__avr32_s32_to_f64+0xa2>
8001c3b4:	5c 39       	neg	r9
8001c3b6:	2f f9       	sub	r9,-1
8001c3b8:	e0 49 00 36 	cp.w	r9,54
8001c3bc:	c0 43       	brcs	8001c3c4 <__avr32_s32_to_f64+0x56>
8001c3be:	30 0b       	mov	r11,0
8001c3c0:	30 0a       	mov	r10,0
8001c3c2:	c2 68       	rjmp	8001c40e <__avr32_s32_to_f64+0xa0>
8001c3c4:	2f 69       	sub	r9,-10
8001c3c6:	f2 08 11 20 	rsub	r8,r9,32
8001c3ca:	e0 49 00 20 	cp.w	r9,32
8001c3ce:	c0 b2       	brcc	8001c3e4 <__avr32_s32_to_f64+0x76>
8001c3d0:	f4 08 09 4e 	lsl	lr,r10,r8
8001c3d4:	f6 08 09 48 	lsl	r8,r11,r8
8001c3d8:	f4 09 0a 4a 	lsr	r10,r10,r9
8001c3dc:	f6 09 0a 4b 	lsr	r11,r11,r9
8001c3e0:	10 4b       	or	r11,r8
8001c3e2:	c0 88       	rjmp	8001c3f2 <__avr32_s32_to_f64+0x84>
8001c3e4:	f6 08 09 4e 	lsl	lr,r11,r8
8001c3e8:	14 4e       	or	lr,r10
8001c3ea:	16 9a       	mov	r10,r11
8001c3ec:	30 0b       	mov	r11,0
8001c3ee:	f4 09 0a 4a 	lsr	r10,r10,r9
8001c3f2:	ed ba 00 00 	bld	r10,0x0
8001c3f6:	c0 92       	brcc	8001c408 <__avr32_s32_to_f64+0x9a>
8001c3f8:	1c 7e       	tst	lr,lr
8001c3fa:	c0 41       	brne	8001c402 <__avr32_s32_to_f64+0x94>
8001c3fc:	ed ba 00 01 	bld	r10,0x1
8001c400:	c0 42       	brcc	8001c408 <__avr32_s32_to_f64+0x9a>
8001c402:	2f fa       	sub	r10,-1
8001c404:	f7 bb 02 ff 	subhs	r11,-1
8001c408:	5c fc       	rol	r12
8001c40a:	5d 0b       	ror	r11
8001c40c:	5d 0a       	ror	r10
8001c40e:	d8 02       	popm	pc
8001c410:	e0 68 03 ff 	mov	r8,1023
8001c414:	ed ba 00 0b 	bld	r10,0xb
8001c418:	f7 b8 00 ff 	subeq	r8,-1
8001c41c:	10 0a       	add	r10,r8
8001c41e:	5c 0b       	acr	r11
8001c420:	f7 b9 03 fe 	sublo	r9,-2
8001c424:	e0 49 07 ff 	cp.w	r9,2047
8001c428:	c0 55       	brlt	8001c432 <__avr32_s32_to_f64+0xc4>
8001c42a:	30 0a       	mov	r10,0
8001c42c:	fc 1b ff e0 	movh	r11,0xffe0
8001c430:	c0 c8       	rjmp	8001c448 <__floatsidf_return_op1>
8001c432:	ed bb 00 1f 	bld	r11,0x1f
8001c436:	f7 b9 01 01 	subne	r9,1
8001c43a:	ab 9a       	lsr	r10,0xb
8001c43c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8001c440:	a1 7b       	lsl	r11,0x1
8001c442:	ab 9b       	lsr	r11,0xb
8001c444:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8001c448 <__floatsidf_return_op1>:
8001c448:	a1 7c       	lsl	r12,0x1
8001c44a:	5d 0b       	ror	r11
8001c44c:	d8 02       	popm	pc

8001c44e <__avr32_f64_cmp_eq>:
8001c44e:	10 3a       	cp.w	r10,r8
8001c450:	f2 0b 13 00 	cpc	r11,r9
8001c454:	c0 80       	breq	8001c464 <__avr32_f64_cmp_eq+0x16>
8001c456:	a1 7b       	lsl	r11,0x1
8001c458:	a1 79       	lsl	r9,0x1
8001c45a:	14 4b       	or	r11,r10
8001c45c:	12 4b       	or	r11,r9
8001c45e:	10 4b       	or	r11,r8
8001c460:	5e 0f       	reteq	1
8001c462:	5e fd       	retal	0
8001c464:	a1 7b       	lsl	r11,0x1
8001c466:	fc 1c ff e0 	movh	r12,0xffe0
8001c46a:	58 0a       	cp.w	r10,0
8001c46c:	f8 0b 13 00 	cpc	r11,r12
8001c470:	5e 8f       	retls	1
8001c472:	5e fd       	retal	0

8001c474 <__avr32_f64_cmp_ge>:
8001c474:	1a de       	st.w	--sp,lr
8001c476:	1a d7       	st.w	--sp,r7
8001c478:	a1 7b       	lsl	r11,0x1
8001c47a:	5f 3c       	srlo	r12
8001c47c:	a1 79       	lsl	r9,0x1
8001c47e:	5f 37       	srlo	r7
8001c480:	5c fc       	rol	r12
8001c482:	fc 1e ff e0 	movh	lr,0xffe0
8001c486:	58 0a       	cp.w	r10,0
8001c488:	fc 0b 13 00 	cpc	r11,lr
8001c48c:	e0 8b 00 1d 	brhi	8001c4c6 <__avr32_f64_cmp_ge+0x52>
8001c490:	58 08       	cp.w	r8,0
8001c492:	fc 09 13 00 	cpc	r9,lr
8001c496:	e0 8b 00 18 	brhi	8001c4c6 <__avr32_f64_cmp_ge+0x52>
8001c49a:	58 0b       	cp.w	r11,0
8001c49c:	f5 ba 00 00 	subfeq	r10,0
8001c4a0:	c1 50       	breq	8001c4ca <__avr32_f64_cmp_ge+0x56>
8001c4a2:	1b 07       	ld.w	r7,sp++
8001c4a4:	1b 0e       	ld.w	lr,sp++
8001c4a6:	58 3c       	cp.w	r12,3
8001c4a8:	c0 a0       	breq	8001c4bc <__avr32_f64_cmp_ge+0x48>
8001c4aa:	58 1c       	cp.w	r12,1
8001c4ac:	c0 33       	brcs	8001c4b2 <__avr32_f64_cmp_ge+0x3e>
8001c4ae:	5e 0f       	reteq	1
8001c4b0:	5e 1d       	retne	0
8001c4b2:	10 3a       	cp.w	r10,r8
8001c4b4:	f2 0b 13 00 	cpc	r11,r9
8001c4b8:	5e 2f       	reths	1
8001c4ba:	5e 3d       	retlo	0
8001c4bc:	14 38       	cp.w	r8,r10
8001c4be:	f6 09 13 00 	cpc	r9,r11
8001c4c2:	5e 2f       	reths	1
8001c4c4:	5e 3d       	retlo	0
8001c4c6:	1b 07       	ld.w	r7,sp++
8001c4c8:	d8 0a       	popm	pc,r12=0
8001c4ca:	58 17       	cp.w	r7,1
8001c4cc:	5f 0c       	sreq	r12
8001c4ce:	58 09       	cp.w	r9,0
8001c4d0:	f5 b8 00 00 	subfeq	r8,0
8001c4d4:	1b 07       	ld.w	r7,sp++
8001c4d6:	1b 0e       	ld.w	lr,sp++
8001c4d8:	5e 0f       	reteq	1
8001c4da:	5e fc       	retal	r12

8001c4dc <__avr32_f64_cmp_lt>:
8001c4dc:	1a de       	st.w	--sp,lr
8001c4de:	1a d7       	st.w	--sp,r7
8001c4e0:	a1 7b       	lsl	r11,0x1
8001c4e2:	5f 3c       	srlo	r12
8001c4e4:	a1 79       	lsl	r9,0x1
8001c4e6:	5f 37       	srlo	r7
8001c4e8:	5c fc       	rol	r12
8001c4ea:	fc 1e ff e0 	movh	lr,0xffe0
8001c4ee:	58 0a       	cp.w	r10,0
8001c4f0:	fc 0b 13 00 	cpc	r11,lr
8001c4f4:	e0 8b 00 1d 	brhi	8001c52e <__avr32_f64_cmp_lt+0x52>
8001c4f8:	58 08       	cp.w	r8,0
8001c4fa:	fc 09 13 00 	cpc	r9,lr
8001c4fe:	e0 8b 00 18 	brhi	8001c52e <__avr32_f64_cmp_lt+0x52>
8001c502:	58 0b       	cp.w	r11,0
8001c504:	f5 ba 00 00 	subfeq	r10,0
8001c508:	c1 50       	breq	8001c532 <__avr32_f64_cmp_lt+0x56>
8001c50a:	1b 07       	ld.w	r7,sp++
8001c50c:	1b 0e       	ld.w	lr,sp++
8001c50e:	58 3c       	cp.w	r12,3
8001c510:	c0 a0       	breq	8001c524 <__avr32_f64_cmp_lt+0x48>
8001c512:	58 1c       	cp.w	r12,1
8001c514:	c0 33       	brcs	8001c51a <__avr32_f64_cmp_lt+0x3e>
8001c516:	5e 0d       	reteq	0
8001c518:	5e 1f       	retne	1
8001c51a:	10 3a       	cp.w	r10,r8
8001c51c:	f2 0b 13 00 	cpc	r11,r9
8001c520:	5e 2d       	reths	0
8001c522:	5e 3f       	retlo	1
8001c524:	14 38       	cp.w	r8,r10
8001c526:	f6 09 13 00 	cpc	r9,r11
8001c52a:	5e 2d       	reths	0
8001c52c:	5e 3f       	retlo	1
8001c52e:	1b 07       	ld.w	r7,sp++
8001c530:	d8 0a       	popm	pc,r12=0
8001c532:	58 17       	cp.w	r7,1
8001c534:	5f 1c       	srne	r12
8001c536:	58 09       	cp.w	r9,0
8001c538:	f5 b8 00 00 	subfeq	r8,0
8001c53c:	1b 07       	ld.w	r7,sp++
8001c53e:	1b 0e       	ld.w	lr,sp++
8001c540:	5e 0d       	reteq	0
8001c542:	5e fc       	retal	r12

8001c544 <__avr32_f64_div>:
8001c544:	eb cd 40 ff 	pushm	r0-r7,lr
8001c548:	f7 e9 20 0e 	eor	lr,r11,r9
8001c54c:	f6 07 16 14 	lsr	r7,r11,0x14
8001c550:	a9 7b       	lsl	r11,0x9
8001c552:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8001c556:	a9 7a       	lsl	r10,0x9
8001c558:	bd bb       	sbr	r11,0x1d
8001c55a:	e4 1b 3f ff 	andh	r11,0x3fff
8001c55e:	ab d7       	cbr	r7,0xb
8001c560:	e0 80 00 cc 	breq	8001c6f8 <__avr32_f64_div_round_subnormal+0x54>
8001c564:	e0 47 07 ff 	cp.w	r7,2047
8001c568:	e0 84 00 b5 	brge	8001c6d2 <__avr32_f64_div_round_subnormal+0x2e>
8001c56c:	f2 06 16 14 	lsr	r6,r9,0x14
8001c570:	a9 79       	lsl	r9,0x9
8001c572:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8001c576:	a9 78       	lsl	r8,0x9
8001c578:	bd b9       	sbr	r9,0x1d
8001c57a:	e4 19 3f ff 	andh	r9,0x3fff
8001c57e:	ab d6       	cbr	r6,0xb
8001c580:	e0 80 00 e2 	breq	8001c744 <__avr32_f64_div_round_subnormal+0xa0>
8001c584:	e0 46 07 ff 	cp.w	r6,2047
8001c588:	e0 84 00 b2 	brge	8001c6ec <__avr32_f64_div_round_subnormal+0x48>
8001c58c:	0c 17       	sub	r7,r6
8001c58e:	fe 37 fc 01 	sub	r7,-1023
8001c592:	fc 1c 80 00 	movh	r12,0x8000
8001c596:	f8 03 16 01 	lsr	r3,r12,0x1
8001c59a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8001c59e:	5c d4       	com	r4
8001c5a0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8001c5a4:	e6 09 06 44 	mulu.d	r4,r3,r9
8001c5a8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001c5ac:	e6 05 06 44 	mulu.d	r4,r3,r5
8001c5b0:	ea 03 15 02 	lsl	r3,r5,0x2
8001c5b4:	e6 09 06 44 	mulu.d	r4,r3,r9
8001c5b8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001c5bc:	e6 05 06 44 	mulu.d	r4,r3,r5
8001c5c0:	ea 03 15 02 	lsl	r3,r5,0x2
8001c5c4:	e6 09 06 44 	mulu.d	r4,r3,r9
8001c5c8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001c5cc:	e6 05 06 44 	mulu.d	r4,r3,r5
8001c5d0:	ea 03 15 02 	lsl	r3,r5,0x2
8001c5d4:	e6 08 06 40 	mulu.d	r0,r3,r8
8001c5d8:	e4 09 07 40 	macu.d	r0,r2,r9
8001c5dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8001c5e0:	02 04       	add	r4,r1
8001c5e2:	5c 05       	acr	r5
8001c5e4:	a3 65       	lsl	r5,0x2
8001c5e6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001c5ea:	a3 64       	lsl	r4,0x2
8001c5ec:	5c 34       	neg	r4
8001c5ee:	f8 05 01 45 	sbc	r5,r12,r5
8001c5f2:	e6 04 06 40 	mulu.d	r0,r3,r4
8001c5f6:	e4 05 07 40 	macu.d	r0,r2,r5
8001c5fa:	e6 05 06 44 	mulu.d	r4,r3,r5
8001c5fe:	02 04       	add	r4,r1
8001c600:	5c 05       	acr	r5
8001c602:	ea 03 15 02 	lsl	r3,r5,0x2
8001c606:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001c60a:	e8 02 15 02 	lsl	r2,r4,0x2
8001c60e:	e6 08 06 40 	mulu.d	r0,r3,r8
8001c612:	e4 09 07 40 	macu.d	r0,r2,r9
8001c616:	e6 09 06 44 	mulu.d	r4,r3,r9
8001c61a:	02 04       	add	r4,r1
8001c61c:	5c 05       	acr	r5
8001c61e:	a3 65       	lsl	r5,0x2
8001c620:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001c624:	a3 64       	lsl	r4,0x2
8001c626:	5c 34       	neg	r4
8001c628:	f8 05 01 45 	sbc	r5,r12,r5
8001c62c:	e6 04 06 40 	mulu.d	r0,r3,r4
8001c630:	e4 05 07 40 	macu.d	r0,r2,r5
8001c634:	e6 05 06 44 	mulu.d	r4,r3,r5
8001c638:	02 04       	add	r4,r1
8001c63a:	5c 05       	acr	r5
8001c63c:	ea 03 15 02 	lsl	r3,r5,0x2
8001c640:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001c644:	e8 02 15 02 	lsl	r2,r4,0x2
8001c648:	e6 0a 06 40 	mulu.d	r0,r3,r10
8001c64c:	e4 0b 07 40 	macu.d	r0,r2,r11
8001c650:	e6 0b 06 42 	mulu.d	r2,r3,r11
8001c654:	02 02       	add	r2,r1
8001c656:	5c 03       	acr	r3
8001c658:	ed b3 00 1c 	bld	r3,0x1c
8001c65c:	c0 90       	breq	8001c66e <__avr32_f64_div+0x12a>
8001c65e:	a1 72       	lsl	r2,0x1
8001c660:	5c f3       	rol	r3
8001c662:	20 17       	sub	r7,1
8001c664:	a3 9a       	lsr	r10,0x3
8001c666:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8001c66a:	a3 9b       	lsr	r11,0x3
8001c66c:	c0 58       	rjmp	8001c676 <__avr32_f64_div+0x132>
8001c66e:	a5 8a       	lsr	r10,0x4
8001c670:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8001c674:	a5 8b       	lsr	r11,0x4
8001c676:	58 07       	cp.w	r7,0
8001c678:	e0 8a 00 8b 	brle	8001c78e <__avr32_f64_div_res_subnormal>
8001c67c:	e0 12 ff 00 	andl	r2,0xff00
8001c680:	e8 12 00 80 	orl	r2,0x80
8001c684:	e6 08 06 40 	mulu.d	r0,r3,r8
8001c688:	e4 09 07 40 	macu.d	r0,r2,r9
8001c68c:	e4 08 06 44 	mulu.d	r4,r2,r8
8001c690:	e6 09 06 48 	mulu.d	r8,r3,r9
8001c694:	00 05       	add	r5,r0
8001c696:	f0 01 00 48 	adc	r8,r8,r1
8001c69a:	5c 09       	acr	r9
8001c69c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8001c6a0:	58 04       	cp.w	r4,0
8001c6a2:	5c 25       	cpc	r5

8001c6a4 <__avr32_f64_div_round_subnormal>:
8001c6a4:	f4 08 13 00 	cpc	r8,r10
8001c6a8:	f6 09 13 00 	cpc	r9,r11
8001c6ac:	5f 36       	srlo	r6
8001c6ae:	f8 06 17 00 	moveq	r6,r12
8001c6b2:	e4 0a 16 08 	lsr	r10,r2,0x8
8001c6b6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8001c6ba:	e6 0b 16 08 	lsr	r11,r3,0x8
8001c6be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8001c6c2:	ed be 00 1f 	bld	lr,0x1f
8001c6c6:	ef bb 00 1f 	bst	r11,0x1f
8001c6ca:	0c 0a       	add	r10,r6
8001c6cc:	5c 0b       	acr	r11
8001c6ce:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001c6d2:	e4 1b 00 0f 	andh	r11,0xf
8001c6d6:	14 4b       	or	r11,r10
8001c6d8:	e0 81 00 a7 	brne	8001c826 <__avr32_f64_div_res_subnormal+0x98>
8001c6dc:	f2 06 16 14 	lsr	r6,r9,0x14
8001c6e0:	ab d6       	cbr	r6,0xb
8001c6e2:	e0 46 07 ff 	cp.w	r6,2047
8001c6e6:	e0 81 00 a4 	brne	8001c82e <__avr32_f64_div_res_subnormal+0xa0>
8001c6ea:	c9 e8       	rjmp	8001c826 <__avr32_f64_div_res_subnormal+0x98>
8001c6ec:	e4 19 00 0f 	andh	r9,0xf
8001c6f0:	10 49       	or	r9,r8
8001c6f2:	e0 81 00 9a 	brne	8001c826 <__avr32_f64_div_res_subnormal+0x98>
8001c6f6:	c9 28       	rjmp	8001c81a <__avr32_f64_div_res_subnormal+0x8c>
8001c6f8:	a3 7b       	lsl	r11,0x3
8001c6fa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8001c6fe:	a3 7a       	lsl	r10,0x3
8001c700:	f5 eb 10 04 	or	r4,r10,r11
8001c704:	e0 80 00 a0 	breq	8001c844 <__avr32_f64_div_op1_zero>
8001c708:	f6 04 12 00 	clz	r4,r11
8001c70c:	c1 70       	breq	8001c73a <__avr32_f64_div_round_subnormal+0x96>
8001c70e:	c0 c3       	brcs	8001c726 <__avr32_f64_div_round_subnormal+0x82>
8001c710:	e8 05 11 20 	rsub	r5,r4,32
8001c714:	f6 04 09 4b 	lsl	r11,r11,r4
8001c718:	f4 05 0a 45 	lsr	r5,r10,r5
8001c71c:	0a 4b       	or	r11,r5
8001c71e:	f4 04 09 4a 	lsl	r10,r10,r4
8001c722:	08 17       	sub	r7,r4
8001c724:	c0 b8       	rjmp	8001c73a <__avr32_f64_div_round_subnormal+0x96>
8001c726:	f4 04 12 00 	clz	r4,r10
8001c72a:	f9 b4 03 00 	movlo	r4,0
8001c72e:	f7 b4 02 e0 	subhs	r4,-32
8001c732:	f4 04 09 4b 	lsl	r11,r10,r4
8001c736:	30 0a       	mov	r10,0
8001c738:	08 17       	sub	r7,r4
8001c73a:	a3 8a       	lsr	r10,0x2
8001c73c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8001c740:	a3 8b       	lsr	r11,0x2
8001c742:	c1 1b       	rjmp	8001c564 <__avr32_f64_div+0x20>
8001c744:	a3 79       	lsl	r9,0x3
8001c746:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8001c74a:	a3 78       	lsl	r8,0x3
8001c74c:	f3 e8 10 04 	or	r4,r9,r8
8001c750:	c6 f0       	breq	8001c82e <__avr32_f64_div_res_subnormal+0xa0>
8001c752:	f2 04 12 00 	clz	r4,r9
8001c756:	c1 70       	breq	8001c784 <__avr32_f64_div_round_subnormal+0xe0>
8001c758:	c0 c3       	brcs	8001c770 <__avr32_f64_div_round_subnormal+0xcc>
8001c75a:	e8 05 11 20 	rsub	r5,r4,32
8001c75e:	f2 04 09 49 	lsl	r9,r9,r4
8001c762:	f0 05 0a 45 	lsr	r5,r8,r5
8001c766:	0a 49       	or	r9,r5
8001c768:	f0 04 09 48 	lsl	r8,r8,r4
8001c76c:	08 16       	sub	r6,r4
8001c76e:	c0 b8       	rjmp	8001c784 <__avr32_f64_div_round_subnormal+0xe0>
8001c770:	f0 04 12 00 	clz	r4,r8
8001c774:	f9 b4 03 00 	movlo	r4,0
8001c778:	f7 b4 02 e0 	subhs	r4,-32
8001c77c:	f0 04 09 49 	lsl	r9,r8,r4
8001c780:	30 08       	mov	r8,0
8001c782:	08 16       	sub	r6,r4
8001c784:	a3 88       	lsr	r8,0x2
8001c786:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8001c78a:	a3 89       	lsr	r9,0x2
8001c78c:	cf ca       	rjmp	8001c584 <__avr32_f64_div+0x40>

8001c78e <__avr32_f64_div_res_subnormal>:
8001c78e:	5c 37       	neg	r7
8001c790:	2f f7       	sub	r7,-1
8001c792:	f1 b7 04 c0 	satu	r7,0x6
8001c796:	e0 47 00 20 	cp.w	r7,32
8001c79a:	c1 54       	brge	8001c7c4 <__avr32_f64_div_res_subnormal+0x36>
8001c79c:	ee 06 11 20 	rsub	r6,r7,32
8001c7a0:	e4 07 0a 42 	lsr	r2,r2,r7
8001c7a4:	e6 06 09 4c 	lsl	r12,r3,r6
8001c7a8:	18 42       	or	r2,r12
8001c7aa:	e6 07 0a 43 	lsr	r3,r3,r7
8001c7ae:	f4 06 09 41 	lsl	r1,r10,r6
8001c7b2:	f4 07 0a 4a 	lsr	r10,r10,r7
8001c7b6:	f6 06 09 4c 	lsl	r12,r11,r6
8001c7ba:	18 4a       	or	r10,r12
8001c7bc:	f6 07 0a 4b 	lsr	r11,r11,r7
8001c7c0:	30 00       	mov	r0,0
8001c7c2:	c1 58       	rjmp	8001c7ec <__avr32_f64_div_res_subnormal+0x5e>
8001c7c4:	ee 06 11 20 	rsub	r6,r7,32
8001c7c8:	f9 b0 00 00 	moveq	r0,0
8001c7cc:	f9 bc 00 00 	moveq	r12,0
8001c7d0:	c0 50       	breq	8001c7da <__avr32_f64_div_res_subnormal+0x4c>
8001c7d2:	f4 06 09 40 	lsl	r0,r10,r6
8001c7d6:	f6 06 09 4c 	lsl	r12,r11,r6
8001c7da:	e6 07 0a 42 	lsr	r2,r3,r7
8001c7de:	30 03       	mov	r3,0
8001c7e0:	f4 07 0a 41 	lsr	r1,r10,r7
8001c7e4:	18 41       	or	r1,r12
8001c7e6:	f6 07 0a 4a 	lsr	r10,r11,r7
8001c7ea:	30 0b       	mov	r11,0
8001c7ec:	e0 12 ff 00 	andl	r2,0xff00
8001c7f0:	e8 12 00 80 	orl	r2,0x80
8001c7f4:	e6 08 06 46 	mulu.d	r6,r3,r8
8001c7f8:	e4 09 07 46 	macu.d	r6,r2,r9
8001c7fc:	e4 08 06 44 	mulu.d	r4,r2,r8
8001c800:	e6 09 06 48 	mulu.d	r8,r3,r9
8001c804:	0c 05       	add	r5,r6
8001c806:	f0 07 00 48 	adc	r8,r8,r7
8001c80a:	5c 09       	acr	r9
8001c80c:	30 07       	mov	r7,0
8001c80e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8001c812:	00 34       	cp.w	r4,r0
8001c814:	e2 05 13 00 	cpc	r5,r1
8001c818:	c4 6b       	rjmp	8001c6a4 <__avr32_f64_div_round_subnormal>
8001c81a:	1c 9b       	mov	r11,lr
8001c81c:	e6 1b 80 00 	andh	r11,0x8000,COH
8001c820:	30 0a       	mov	r10,0
8001c822:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001c826:	3f fb       	mov	r11,-1
8001c828:	30 0a       	mov	r10,0
8001c82a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001c82e:	f5 eb 10 04 	or	r4,r10,r11
8001c832:	c0 90       	breq	8001c844 <__avr32_f64_div_op1_zero>
8001c834:	1c 9b       	mov	r11,lr
8001c836:	e6 1b 80 00 	andh	r11,0x8000,COH
8001c83a:	ea 1b 7f f0 	orh	r11,0x7ff0
8001c83e:	30 0a       	mov	r10,0
8001c840:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8001c844 <__avr32_f64_div_op1_zero>:
8001c844:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8001c848:	ce f0       	breq	8001c826 <__avr32_f64_div_res_subnormal+0x98>
8001c84a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8001c84e:	e0 44 07 ff 	cp.w	r4,2047
8001c852:	ce 41       	brne	8001c81a <__avr32_f64_div_res_subnormal+0x8c>
8001c854:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8001c858:	ce 10       	breq	8001c81a <__avr32_f64_div_res_subnormal+0x8c>
8001c85a:	ce 6b       	rjmp	8001c826 <__avr32_f64_div_res_subnormal+0x98>

8001c85c <__avr32_umod64>:
8001c85c:	d4 31       	pushm	r0-r7,lr
8001c85e:	1a 97       	mov	r7,sp
8001c860:	20 3d       	sub	sp,12
8001c862:	10 9c       	mov	r12,r8
8001c864:	12 95       	mov	r5,r9
8001c866:	14 9e       	mov	lr,r10
8001c868:	16 91       	mov	r1,r11
8001c86a:	16 96       	mov	r6,r11
8001c86c:	58 09       	cp.w	r9,0
8001c86e:	e0 81 00 81 	brne	8001c970 <__avr32_umod64+0x114>
8001c872:	16 38       	cp.w	r8,r11
8001c874:	e0 88 00 12 	brls	8001c898 <__avr32_umod64+0x3c>
8001c878:	f0 08 12 00 	clz	r8,r8
8001c87c:	c4 e0       	breq	8001c918 <__avr32_umod64+0xbc>
8001c87e:	f6 08 09 46 	lsl	r6,r11,r8
8001c882:	f8 08 09 4c 	lsl	r12,r12,r8
8001c886:	f0 0b 11 20 	rsub	r11,r8,32
8001c88a:	f4 08 09 4e 	lsl	lr,r10,r8
8001c88e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8001c892:	f7 e6 10 06 	or	r6,r11,r6
8001c896:	c4 18       	rjmp	8001c918 <__avr32_umod64+0xbc>
8001c898:	58 08       	cp.w	r8,0
8001c89a:	c0 51       	brne	8001c8a4 <__avr32_umod64+0x48>
8001c89c:	30 19       	mov	r9,1
8001c89e:	f2 08 0d 08 	divu	r8,r9,r8
8001c8a2:	10 9c       	mov	r12,r8
8001c8a4:	f8 08 12 00 	clz	r8,r12
8001c8a8:	c0 31       	brne	8001c8ae <__avr32_umod64+0x52>
8001c8aa:	18 16       	sub	r6,r12
8001c8ac:	c3 68       	rjmp	8001c918 <__avr32_umod64+0xbc>
8001c8ae:	f0 03 11 20 	rsub	r3,r8,32
8001c8b2:	f4 03 0a 4b 	lsr	r11,r10,r3
8001c8b6:	f8 08 09 4c 	lsl	r12,r12,r8
8001c8ba:	ec 08 09 49 	lsl	r9,r6,r8
8001c8be:	ec 03 0a 43 	lsr	r3,r6,r3
8001c8c2:	f7 e9 10 09 	or	r9,r11,r9
8001c8c6:	f8 05 16 10 	lsr	r5,r12,0x10
8001c8ca:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8001c8ce:	e6 05 0d 02 	divu	r2,r3,r5
8001c8d2:	f2 0e 16 10 	lsr	lr,r9,0x10
8001c8d6:	ec 02 02 4b 	mul	r11,r6,r2
8001c8da:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8001c8de:	16 3e       	cp.w	lr,r11
8001c8e0:	c0 72       	brcc	8001c8ee <__avr32_umod64+0x92>
8001c8e2:	18 0e       	add	lr,r12
8001c8e4:	18 3e       	cp.w	lr,r12
8001c8e6:	c0 43       	brcs	8001c8ee <__avr32_umod64+0x92>
8001c8e8:	16 3e       	cp.w	lr,r11
8001c8ea:	fd dc e3 0e 	addcs	lr,lr,r12
8001c8ee:	fc 0b 01 03 	sub	r3,lr,r11
8001c8f2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8001c8f6:	e6 05 0d 02 	divu	r2,r3,r5
8001c8fa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8001c8fe:	a5 36       	mul	r6,r2
8001c900:	0c 39       	cp.w	r9,r6
8001c902:	c0 72       	brcc	8001c910 <__avr32_umod64+0xb4>
8001c904:	18 09       	add	r9,r12
8001c906:	18 39       	cp.w	r9,r12
8001c908:	c0 43       	brcs	8001c910 <__avr32_umod64+0xb4>
8001c90a:	0c 39       	cp.w	r9,r6
8001c90c:	f3 dc e3 09 	addcs	r9,r9,r12
8001c910:	f2 06 01 06 	sub	r6,r9,r6
8001c914:	f4 08 09 4e 	lsl	lr,r10,r8
8001c918:	f8 0a 16 10 	lsr	r10,r12,0x10
8001c91c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8001c920:	ec 0a 0d 02 	divu	r2,r6,r10
8001c924:	fc 09 16 10 	lsr	r9,lr,0x10
8001c928:	ea 02 02 4b 	mul	r11,r5,r2
8001c92c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8001c930:	16 39       	cp.w	r9,r11
8001c932:	c0 72       	brcc	8001c940 <__avr32_umod64+0xe4>
8001c934:	18 09       	add	r9,r12
8001c936:	18 39       	cp.w	r9,r12
8001c938:	c0 43       	brcs	8001c940 <__avr32_umod64+0xe4>
8001c93a:	16 39       	cp.w	r9,r11
8001c93c:	f3 dc e3 09 	addcs	r9,r9,r12
8001c940:	f2 0b 01 0b 	sub	r11,r9,r11
8001c944:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001c948:	f6 0a 0d 0a 	divu	r10,r11,r10
8001c94c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8001c950:	ea 0a 02 4a 	mul	r10,r5,r10
8001c954:	14 3e       	cp.w	lr,r10
8001c956:	c0 72       	brcc	8001c964 <__avr32_umod64+0x108>
8001c958:	18 0e       	add	lr,r12
8001c95a:	18 3e       	cp.w	lr,r12
8001c95c:	c0 43       	brcs	8001c964 <__avr32_umod64+0x108>
8001c95e:	14 3e       	cp.w	lr,r10
8001c960:	fd dc e3 0e 	addcs	lr,lr,r12
8001c964:	fc 0a 01 0a 	sub	r10,lr,r10
8001c968:	30 0b       	mov	r11,0
8001c96a:	f4 08 0a 4a 	lsr	r10,r10,r8
8001c96e:	c7 b8       	rjmp	8001ca64 <__avr32_umod64+0x208>
8001c970:	16 39       	cp.w	r9,r11
8001c972:	e0 8b 00 79 	brhi	8001ca64 <__avr32_umod64+0x208>
8001c976:	f2 09 12 00 	clz	r9,r9
8001c97a:	c1 21       	brne	8001c99e <__avr32_umod64+0x142>
8001c97c:	10 3a       	cp.w	r10,r8
8001c97e:	5f 2b       	srhs	r11
8001c980:	0a 31       	cp.w	r1,r5
8001c982:	5f ba       	srhi	r10
8001c984:	f7 ea 10 0a 	or	r10,r11,r10
8001c988:	f2 0a 18 00 	cp.b	r10,r9
8001c98c:	c0 60       	breq	8001c998 <__avr32_umod64+0x13c>
8001c98e:	fc 08 01 0c 	sub	r12,lr,r8
8001c992:	e2 05 01 46 	sbc	r6,r1,r5
8001c996:	18 9e       	mov	lr,r12
8001c998:	0c 9b       	mov	r11,r6
8001c99a:	1c 9a       	mov	r10,lr
8001c99c:	c6 48       	rjmp	8001ca64 <__avr32_umod64+0x208>
8001c99e:	ea 09 09 4c 	lsl	r12,r5,r9
8001c9a2:	f2 06 11 20 	rsub	r6,r9,32
8001c9a6:	f6 09 09 4b 	lsl	r11,r11,r9
8001c9aa:	f0 09 09 42 	lsl	r2,r8,r9
8001c9ae:	ef 46 ff f4 	st.w	r7[-12],r6
8001c9b2:	f0 06 0a 48 	lsr	r8,r8,r6
8001c9b6:	18 48       	or	r8,r12
8001c9b8:	e2 06 0a 4c 	lsr	r12,r1,r6
8001c9bc:	f4 09 09 43 	lsl	r3,r10,r9
8001c9c0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8001c9c4:	f4 06 0a 4a 	lsr	r10,r10,r6
8001c9c8:	16 4a       	or	r10,r11
8001c9ca:	f0 0b 16 10 	lsr	r11,r8,0x10
8001c9ce:	f8 0b 0d 04 	divu	r4,r12,r11
8001c9d2:	f4 0c 16 10 	lsr	r12,r10,0x10
8001c9d6:	08 91       	mov	r1,r4
8001c9d8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8001c9dc:	e8 0e 02 46 	mul	r6,r4,lr
8001c9e0:	0c 3c       	cp.w	r12,r6
8001c9e2:	c0 a2       	brcc	8001c9f6 <__avr32_umod64+0x19a>
8001c9e4:	20 11       	sub	r1,1
8001c9e6:	10 0c       	add	r12,r8
8001c9e8:	10 3c       	cp.w	r12,r8
8001c9ea:	c0 63       	brcs	8001c9f6 <__avr32_umod64+0x19a>
8001c9ec:	0c 3c       	cp.w	r12,r6
8001c9ee:	f7 b1 03 01 	sublo	r1,1
8001c9f2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8001c9f6:	0c 1c       	sub	r12,r6
8001c9f8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8001c9fc:	f8 0b 0d 04 	divu	r4,r12,r11
8001ca00:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8001ca04:	08 96       	mov	r6,r4
8001ca06:	e8 0e 02 4e 	mul	lr,r4,lr
8001ca0a:	1c 3b       	cp.w	r11,lr
8001ca0c:	c0 a2       	brcc	8001ca20 <__avr32_umod64+0x1c4>
8001ca0e:	20 16       	sub	r6,1
8001ca10:	10 0b       	add	r11,r8
8001ca12:	10 3b       	cp.w	r11,r8
8001ca14:	c0 63       	brcs	8001ca20 <__avr32_umod64+0x1c4>
8001ca16:	1c 3b       	cp.w	r11,lr
8001ca18:	f7 b6 03 01 	sublo	r6,1
8001ca1c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8001ca20:	ed e1 11 01 	or	r1,r6,r1<<0x10
8001ca24:	1c 1b       	sub	r11,lr
8001ca26:	e2 02 06 40 	mulu.d	r0,r1,r2
8001ca2a:	00 9e       	mov	lr,r0
8001ca2c:	02 9c       	mov	r12,r1
8001ca2e:	16 3c       	cp.w	r12,r11
8001ca30:	e0 8b 00 08 	brhi	8001ca40 <__avr32_umod64+0x1e4>
8001ca34:	5f 06       	sreq	r6
8001ca36:	06 30       	cp.w	r0,r3
8001ca38:	5f ba       	srhi	r10
8001ca3a:	ed ea 00 0a 	and	r10,r6,r10
8001ca3e:	c0 60       	breq	8001ca4a <__avr32_umod64+0x1ee>
8001ca40:	fc 02 01 04 	sub	r4,lr,r2
8001ca44:	f8 08 01 4c 	sbc	r12,r12,r8
8001ca48:	08 9e       	mov	lr,r4
8001ca4a:	e6 0e 01 0a 	sub	r10,r3,lr
8001ca4e:	f6 0c 01 4c 	sbc	r12,r11,r12
8001ca52:	ee f1 ff f4 	ld.w	r1,r7[-12]
8001ca56:	f8 09 0a 4b 	lsr	r11,r12,r9
8001ca5a:	f4 09 0a 4a 	lsr	r10,r10,r9
8001ca5e:	f8 01 09 4c 	lsl	r12,r12,r1
8001ca62:	18 4a       	or	r10,r12
8001ca64:	2f dd       	sub	sp,-12
8001ca66:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8001cc00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8001cc00:	c0 08       	rjmp	8001cc00 <_evba>
	...

8001cc04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8001cc04:	c0 08       	rjmp	8001cc04 <_handle_TLB_Multiple_Hit>
	...

8001cc08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8001cc08:	c0 08       	rjmp	8001cc08 <_handle_Bus_Error_Data_Fetch>
	...

8001cc0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8001cc0c:	c0 08       	rjmp	8001cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8001cc10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8001cc10:	c0 08       	rjmp	8001cc10 <_handle_NMI>
	...

8001cc14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8001cc14:	c0 08       	rjmp	8001cc14 <_handle_Instruction_Address>
	...

8001cc18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8001cc18:	c0 08       	rjmp	8001cc18 <_handle_ITLB_Protection>
	...

8001cc1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8001cc1c:	c0 08       	rjmp	8001cc1c <_handle_Breakpoint>
	...

8001cc20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8001cc20:	c0 08       	rjmp	8001cc20 <_handle_Illegal_Opcode>
	...

8001cc24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8001cc24:	c0 08       	rjmp	8001cc24 <_handle_Unimplemented_Instruction>
	...

8001cc28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8001cc28:	c0 08       	rjmp	8001cc28 <_handle_Privilege_Violation>
	...

8001cc2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
8001cc2c:	c0 08       	rjmp	8001cc2c <_handle_Floating_Point>
	...

8001cc30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
8001cc30:	c0 08       	rjmp	8001cc30 <_handle_Coprocessor_Absent>
	...

8001cc34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8001cc34:	c0 08       	rjmp	8001cc34 <_handle_Data_Address_Read>
	...

8001cc38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8001cc38:	c0 08       	rjmp	8001cc38 <_handle_Data_Address_Write>
	...

8001cc3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8001cc3c:	c0 08       	rjmp	8001cc3c <_handle_DTLB_Protection_Read>
	...

8001cc40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8001cc40:	c0 08       	rjmp	8001cc40 <_handle_DTLB_Protection_Write>
	...

8001cc44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8001cc44:	c0 08       	rjmp	8001cc44 <_handle_DTLB_Modified>
	...

8001cc50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8001cc50:	c0 08       	rjmp	8001cc50 <_handle_ITLB_Miss>
	...

8001cc60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8001cc60:	c0 08       	rjmp	8001cc60 <_handle_DTLB_Miss_Read>
	...

8001cc70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8001cc70:	c0 08       	rjmp	8001cc70 <_handle_DTLB_Miss_Write>
	...

8001cd00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
8001cd00:	c0 08       	rjmp	8001cd00 <_handle_Supervisor_Call>
8001cd02:	d7 03       	nop

8001cd04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001cd04:	30 0c       	mov	r12,0
8001cd06:	fe b0 5d a7 	rcall	80008854 <_get_interrupt_handler>
8001cd0a:	58 0c       	cp.w	r12,0
8001cd0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001cd10:	d6 03       	rete

8001cd12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001cd12:	30 1c       	mov	r12,1
8001cd14:	fe b0 5d a0 	rcall	80008854 <_get_interrupt_handler>
8001cd18:	58 0c       	cp.w	r12,0
8001cd1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001cd1e:	d6 03       	rete

8001cd20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001cd20:	30 2c       	mov	r12,2
8001cd22:	fe b0 5d 99 	rcall	80008854 <_get_interrupt_handler>
8001cd26:	58 0c       	cp.w	r12,0
8001cd28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001cd2c:	d6 03       	rete

8001cd2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001cd2e:	30 3c       	mov	r12,3
8001cd30:	fe b0 5d 92 	rcall	80008854 <_get_interrupt_handler>
8001cd34:	58 0c       	cp.w	r12,0
8001cd36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001cd3a:	d6 03       	rete
8001cd3c:	d7 03       	nop
8001cd3e:	d7 03       	nop
8001cd40:	d7 03       	nop
8001cd42:	d7 03       	nop
8001cd44:	d7 03       	nop
8001cd46:	d7 03       	nop
8001cd48:	d7 03       	nop
8001cd4a:	d7 03       	nop
8001cd4c:	d7 03       	nop
8001cd4e:	d7 03       	nop
8001cd50:	d7 03       	nop
8001cd52:	d7 03       	nop
8001cd54:	d7 03       	nop
8001cd56:	d7 03       	nop
8001cd58:	d7 03       	nop
8001cd5a:	d7 03       	nop
8001cd5c:	d7 03       	nop
8001cd5e:	d7 03       	nop
8001cd60:	d7 03       	nop
8001cd62:	d7 03       	nop
8001cd64:	d7 03       	nop
8001cd66:	d7 03       	nop
8001cd68:	d7 03       	nop
8001cd6a:	d7 03       	nop
8001cd6c:	d7 03       	nop
8001cd6e:	d7 03       	nop
8001cd70:	d7 03       	nop
8001cd72:	d7 03       	nop
8001cd74:	d7 03       	nop
8001cd76:	d7 03       	nop
8001cd78:	d7 03       	nop
8001cd7a:	d7 03       	nop
8001cd7c:	d7 03       	nop
8001cd7e:	d7 03       	nop
8001cd80:	d7 03       	nop
8001cd82:	d7 03       	nop
8001cd84:	d7 03       	nop
8001cd86:	d7 03       	nop
8001cd88:	d7 03       	nop
8001cd8a:	d7 03       	nop
8001cd8c:	d7 03       	nop
8001cd8e:	d7 03       	nop
8001cd90:	d7 03       	nop
8001cd92:	d7 03       	nop
8001cd94:	d7 03       	nop
8001cd96:	d7 03       	nop
8001cd98:	d7 03       	nop
8001cd9a:	d7 03       	nop
8001cd9c:	d7 03       	nop
8001cd9e:	d7 03       	nop
8001cda0:	d7 03       	nop
8001cda2:	d7 03       	nop
8001cda4:	d7 03       	nop
8001cda6:	d7 03       	nop
8001cda8:	d7 03       	nop
8001cdaa:	d7 03       	nop
8001cdac:	d7 03       	nop
8001cdae:	d7 03       	nop
8001cdb0:	d7 03       	nop
8001cdb2:	d7 03       	nop
8001cdb4:	d7 03       	nop
8001cdb6:	d7 03       	nop
8001cdb8:	d7 03       	nop
8001cdba:	d7 03       	nop
8001cdbc:	d7 03       	nop
8001cdbe:	d7 03       	nop
8001cdc0:	d7 03       	nop
8001cdc2:	d7 03       	nop
8001cdc4:	d7 03       	nop
8001cdc6:	d7 03       	nop
8001cdc8:	d7 03       	nop
8001cdca:	d7 03       	nop
8001cdcc:	d7 03       	nop
8001cdce:	d7 03       	nop
8001cdd0:	d7 03       	nop
8001cdd2:	d7 03       	nop
8001cdd4:	d7 03       	nop
8001cdd6:	d7 03       	nop
8001cdd8:	d7 03       	nop
8001cdda:	d7 03       	nop
8001cddc:	d7 03       	nop
8001cdde:	d7 03       	nop
8001cde0:	d7 03       	nop
8001cde2:	d7 03       	nop
8001cde4:	d7 03       	nop
8001cde6:	d7 03       	nop
8001cde8:	d7 03       	nop
8001cdea:	d7 03       	nop
8001cdec:	d7 03       	nop
8001cdee:	d7 03       	nop
8001cdf0:	d7 03       	nop
8001cdf2:	d7 03       	nop
8001cdf4:	d7 03       	nop
8001cdf6:	d7 03       	nop
8001cdf8:	d7 03       	nop
8001cdfa:	d7 03       	nop
8001cdfc:	d7 03       	nop
8001cdfe:	d7 03       	nop
